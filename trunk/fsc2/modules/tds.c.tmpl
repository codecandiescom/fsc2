/* -*-C-*-
  $Id$

  Copyright (C) 1999-2002 Jens Thoms Toerring

  This file is part of fsc2.

  Fsc2 is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2, or (at your option)
  any later version.

  Fsc2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with fsc2; see the file COPYING.  If not, write to
  the Free Software Foundation, 59 Temple Place - Suite 330,
  Boston, MA 02111-1307, USA.
*/



#define TDS_TMPL_MAIN

#include "tds_tmpl.h"


const char device_name[ ]  = DEVICE_NAME;
const char generic_type[ ] = DEVICE_TYPE;


static Var *get_area( Var *v, bool use_cursor );
static Var *get_curve( Var *v, bool use_cursor );
static Var *get_amplitude( Var *v, bool use_cursor );


static TDS_TMPL tds_tmpl_stored;



/*******************************************/
/*   We start with the hook functions...   */
/*******************************************/

/*------------------------------------*/
/* Init hook function for the module. */
/*------------------------------------*/

int tds_tmpl_init_hook( void )
{
	int i;


	/* Set global variable to indicate that GPIB bus is needed */

	need_GPIB = SET;

	/* Initialize some variables in the digitizers structure */

	tds_tmpl.is_reacting = UNSET;
	tds_tmpl.w           = NULL;
	tds_tmpl.is_timebase = UNSET;
	tds_tmpl.is_num_avg  = UNSET;
	tds_tmpl.is_rec_len  = UNSET;
	tds_tmpl.is_trig_pos = UNSET;
	tds_tmpl.data_source = TDS_TMPL_UNDEF;
#ifndef NO_GATED_MEASUREMENTS
	tds_tmpl.meas_source = TDS_TMPL_UNDEF;
#endif
	tds_tmpl.lock_state  = SET;

	for ( i = TDS_TMPL_CH1; i < NUM_NORMAL_CHANNELS; i++ )
		tds_tmpl.is_sens[ i ] = UNSET;

	for ( i = 0; i < NUM_DISPLAYABLE_CHANNELS; i++ )
		tds_tmpl.channels_in_use[ i ] = UNSET;

	tds_tmpl_stored.w = NULL;

	return 1;
}


/*-----------------------------------*/
/* Test hook function for the module */
/*-----------------------------------*/

int tds_tmpl_test_hook( void )
{
	/* Store the state of the digitizer structure it was set to in the
	   PREPARATIONS section */

	tds_tmpl_store_state( &tds_tmpl_stored, &tds_tmpl );
	return 1;
}


/*------------------------------------------*/
/* End of test hook function for the module */
/*------------------------------------------*/

int tds_tmpl_end_of_test_hook( void )
{
	int ch;
	int count;


	/* Make sure we don't forget which channels have been marked as used
	   during the test run, they got to be switched on at the start of the
	   experiment. */

	for ( count = 0, ch = 0; ch < NUM_DISPLAYABLE_CHANNELS; ch++ )
	{
		tds_tmpl_stored.channels_in_use[ ch ] = tds_tmpl.channels_in_use[ ch ];
		if ( tds_tmpl.channels_in_use[ ch ] &&
			 ch >= TDS_TMPL_CH1 && ch < NUM_NORMAL_CHANNELS )
			count++;
	}

	/* If more than MAX_SIMULTANEOUS_CHANNELS are needed we're in trouble */

	if ( count > MAX_SIMULTANEOUS_CHANNELS )
	{
		print( FATAL, "%d live channels are needed for the experiment but "
			   "only %d can be displayed simulataneously.\n", count,
			   MAX_SIMULTANEOUS_CHANNELS );
		THROW( EXCEPTION );
	}

	return 1;
}


/*--------------------------------------------------*/
/* Start of experiment hook function for the module */
/*--------------------------------------------------*/

int tds_tmpl_exp_hook( void )
{
	/* Reset the digitizer structure to the state it was set to in the
	   preparations section - changes done to it in the test run are to
	   be undone... */

	tds_tmpl_store_state( &tds_tmpl, &tds_tmpl_stored );

	if ( ! tds_tmpl_init( DEVICE_NAME ) )
	{
		print( FATAL, "Initialization of device failed: %s\n",
			   gpib_error_msg );
		THROW( EXCEPTION );
	}

	tds_tmpl_do_pre_exp_checks( );

	return 1;
}


/*------------------------------------------------*/
/* End of experiment hook function for the module */
/*------------------------------------------------*/

int tds_tmpl_end_of_exp_hook( void )
{
	tds_tmpl_finished( );
	return 1;
}


/*------------------------------------------*/
/* For final work before module is unloaded */
/*------------------------------------------*/


void tds_tmpl_exit_hook( void )
{
	tds_tmpl_delete_windows( &tds_tmpl );
	tds_tmpl_delete_windows( &tds_tmpl_stored );
}


/*----------------------------------------------------*/
/*----------------------------------------------------*/

Var *digitizer_name( Var *v )
{
	v = v;
	return vars_push( STR_VAR, DEVICE_NAME );
}


/*------------------------------------------*/
/*------------------------------------------*/

Var *digitizer_define_window( Var *v )
{
	double win_start = 0,
		   win_width = 0;
	bool is_win_start = UNSET;
	bool is_win_width = UNSET;
	long num_windows = 1;
	double w1, w2;
	WINDOW *w;


	/* During the experiment if the digitizer's keyboard isn't locked we
	   need to reread the timebase, record length and trigger position and
	   update and recheck the windows */

	if ( FSC2_MODE == EXPERIMENT && ! tds_tmpl.lock_state )
		tds_tmpl_state_check( 0.0, 0.0, 0.0 );

	if ( v != NULL )
	{
		/* Get the start point of the window */

		win_start = get_double( v, "window position" );
		is_win_start = SET;

		/* If there's a second parameter take it to be the window width */

		if ( ( v = vars_pop( v ) ) != NULL )
		{
			win_width = get_double( v, "window width" );

			/* Allow window width to be zero in test run... */

			if ( ( FSC2_MODE == TEST && win_width < 0.0 ) ||
				 ( FSC2_MODE != TEST && win_width <= 0.0 ) )
			{
				print( FATAL, "Zero or negative window width.\n" );
				THROW( EXCEPTION );
			}
			is_win_width = SET;

			too_many_arguments( v );
		}
	}

	/* During the experiment take the current cursor positions as the
	   windows borders if they haven't been specified - but we have to
	   be careful: if the cursors ae exacty on top of each other we take
	   the smallest possible non-zero cursor distance as the width. */

	if ( FSC2_MODE == EXPERIMENT )
	{
		if ( ! is_win_start )
		{
			w1 = tds_tmpl_get_cursor_position( 1 );
			w2 = tds_tmpl_get_cursor_position( 2 );
			win_start = d_min( w1, w2 );
			is_win_start = SET;
		}

		if ( ! is_win_width )
		{
			win_width = fabs( tds_tmpl_get_cursor_distance( ) );
			if ( 1 > lrnd( win_width / tds_tmpl.timebase
						   * TDS_TMPL_POINTS_PER_DIV ) )
				win_width = tds_tmpl.timebase / TDS_TMPL_POINTS_PER_DIV;
			is_win_width = SET;
		}
	}

	/* Create a new window structure and append it to the list of windows */

	if ( tds_tmpl.w == NULL )
	{
		tds_tmpl.w = w = T_malloc( sizeof( WINDOW ) );
		w->prev = NULL;
	}
	else
	{
		w = tds_tmpl.w;
		while ( w->next != NULL )
		{
			num_windows++;
			w = w->next;
		}
		w->next = T_malloc( sizeof( WINDOW ) );
		w->next->prev = w;
		w = w->next;
		w->is_start = UNSET;
		w->is_width = UNSET;
		num_windows++;
	}

	w->next = NULL;
	w->num = num_windows + WINDOW_START_NUMBER;

	if ( is_win_start )
		w->start = win_start;
	w->is_start = is_win_start;

	if ( is_win_width )
		w->width = win_width;
	w->is_width = is_win_width;

	/* Do all possible checks and, if necessary, readjust window position and
	   width */

	tds_tmpl_window_checks( w );


#ifndef NO_GATED_MEASUREMENTS
	/* If we're already running the experiment and only just now the very
	   first window gets defined we have to switch on gated measurements
	   (unless the device can't do gated measurements). */

	if ( FSC2_MODE == EXPERIMENT && w == tds_tmpl.w )
	{
		tds_tmpl_set_gated_meas( SET );
		tds_tmpl.gated_state = SET;
	}

	tds_tmpl_set_tracking( w );
#endif

	return vars_push( INT_VAR, w->num );
}


/*------------------------------------------------*/
/*------------------------------------------------*/

Var *digitizer_change_window( Var *v )
{
	WINDOW *w;
	long win_num;
	double w1, w2;


	if ( tds_tmpl.w == NULL )
	{
		print( FATAL, "No windows have been defined.\n" );
		THROW( EXCEPTION );
	}

	if ( v == NULL )
	{
		print( FATAL, "Missing window ID.\n" );
		THROW( EXCEPTION );
	}

	/* During the experiment if the digitizer's keyboard isn't locked we
	   need to reread the timebase, record length and trigger position and
	   update and recheck the windws */

	if ( FSC2_MODE == EXPERIMENT && ! tds_tmpl.lock_state )
		tds_tmpl_state_check( 0.0, 0.0, 0.0 );

	/* Figure out the window number and test if a window with this number
	   exists at all */

	win_num = get_strict_long( v, "window ID" );
	v = vars_pop( v );

	for ( w = tds_tmpl.w; w->num != win_num && w != NULL; w = w->next )
		/* empty */ ;

	if ( w == NULL )
	{
		print( FATAL, "First argument is not a valid window ID.\n" );
		THROW( EXCEPTION );
	}

	/* During the experiment we also accept that there are no arguments for
	   the position or the width and use the cursor positions instead */

	if ( FSC2_MODE != PREPARATION && v == NULL )
	{
		if ( FSC2_MODE == EXPERIMENT )
		{
			w1 = tds_tmpl_get_cursor_position( 1 );
			w2 = tds_tmpl_get_cursor_position( 2 );
			w->start = d_min( w1, w2 );
		}
	}
	else
	{
		if ( v == NULL )
		{
			print( FATAL, "Missing window start position argument.\n" );
			THROW( EXCEPTION );
		}
		w->start = get_double( v, "window start position" );
		v = vars_pop( v );
	}

	if ( FSC2_MODE != PREPARATION && v == NULL )
	{
		if ( FSC2_MODE == EXPERIMENT )
		{
			w->width = fabs( tds_tmpl_get_cursor_distance( ) );
			if ( 1 > lrnd( w->width / tds_tmpl.timebase
						   * TDS_TMPL_POINTS_PER_DIV ) )
				w->width = tds_tmpl.timebase / TDS_TMPL_POINTS_PER_DIV;
		}
	}
	else
	{
		if ( v == NULL )
		{
			print( FATAL, "Missing window width argument.\n" );
			THROW( EXCEPTION );
		}
		w->width = get_double(  v, "window with" );
	}

	too_many_arguments( v );

	/* Do all possible checks and, if necessary, readjust window position and
	   width */

	tds_tmpl_window_checks( w );
#ifndef NO_GATED_MEASUREMENTS
	tds_tmpl_set_tracking( w );
#endif

	return vars_push( INT_VAR, win_num );
}

/*-----------------------------------------------------------------*/
/*-----------------------------------------------------------------*/

Var *digitizer_window_position( Var *v )
{
	WINDOW *w;
	long win_num;


	if ( tds_tmpl.w == NULL )
	{
		print( FATAL, "No windows have been defined.\n" );
		THROW( EXCEPTION );
	}

	if ( v == NULL )
	{
		print( FATAL, "Missing window ID.\n" );
		THROW( EXCEPTION );
	}

	/* During the experiment if the digitizer's keyboard isn't locked we
	   need to reread the timebase, record length and trigger position and
	   update and recheck the windows */

	if ( FSC2_MODE == EXPERIMENT && ! tds_tmpl.lock_state )
		tds_tmpl_state_check( 0.0, 0.0, 0.0 );

	/* Figure out the window number and test if a window with this number
	   exists at all */

	win_num = get_strict_long( v, "window ID" );

	for ( w = tds_tmpl.w; w->num != win_num && w != NULL; w = w->next )
		/* empty */ ;

	if ( w == NULL )
	{
		print( FATAL, "First argument is not a valid window ID.\n" );
		THROW( EXCEPTION );
	}

	if ( ( v = vars_pop( v ) ) == NULL )
		return vars_push( FLOAT_VAR, w->start );

	w->start = get_double( v, "window start position" );

	too_many_arguments( v );

	/* Do all possible checks and, if necessary, readjust window position and
	   width */

	tds_tmpl_window_checks( w );
#ifndef NO_GATED_MEASUREMENTS
	tds_tmpl_set_tracking( w );
#endif

	return vars_push( FLOAT_VAR, w->start );
}


/*-----------------------------------------------------------------*/
/*-----------------------------------------------------------------*/

Var *digitizer_window_width( Var *v )
{
	WINDOW *w;
	long win_num;


	if ( tds_tmpl.w == NULL )
	{
		print( FATAL, "No windows have been defined.\n" );
		THROW( EXCEPTION );
	}

	if ( v == NULL )
	{
		print( FATAL, "Missing argument.\n" );
		THROW( EXCEPTION );
	}

	/* During the experiment if the digitizer's keyboard isn't locked we
	   need to reread the timebase, record length and trigger position and
	   update and recheck the windows */

	if ( FSC2_MODE == EXPERIMENT && ! tds_tmpl.lock_state )
		tds_tmpl_state_check( 0.0, 0.0, 0.0 );

	/* Figure out the window number and test if a window with this number
	   exists at all */

	win_num = get_strict_long( v, "window ID" );

	for ( w = tds_tmpl.w; w->num != win_num && w != NULL; w = w->next )
		/* empty */ ;

	if ( w == NULL )
	{
		print( FATAL, "First argument is not a valid window ID.\n" );
		THROW( EXCEPTION );
	}

	if ( ( v = vars_pop( v ) ) == NULL )
		return vars_push( FLOAT_VAR, w->width );

	w->width = get_double( v, "window width" );

	too_many_arguments( v );

	/* Do all possible checks and, if necessary, readjust window position and
	   width */

	tds_tmpl_window_checks( w );
#ifndef NO_GATED_MEASUREMENTS
	tds_tmpl_set_tracking( w );
#endif

	return vars_push( FLOAT_VAR, w->width );
}


/*-------------------------------------------------------------------*/
/* This function can be called during the preparation phase to tell  */
/* the driver to switch on a certain channel and never switch it off */
/* (even if it does not seem to be used in the experiment).          */
/*-------------------------------------------------------------------*/

Var *digitizer_display_channel( Var *v )
{
	long channel;


	if ( v == NULL )
	{
		print( FATAL, "Missing arguments.\n" );
		THROW( EXCEPTION );
	}

	do
	{
		channel = tds_tmpl_translate_channel( GENERAL_TO_TDS_TMPL,
									  get_strict_long( v, "channel number" ) );

		if ( channel >= MAX_CHANNELS )
		{
			print( FATAL, "Invalid channel number: %ld.\n",
				   tds_tmpl_translate_channel( TDS_TMPL_TO_GENERAL,
											   channel ) );
			THROW( EXCEPTION );
		}

		if( channel >= NUM_DISPLAYABLE_CHANNELS )
		{
			print( FATAL, "Channel \"%s\" can't be displayed.\n",
				   Channel_Names[ channel ] );
			THROW( EXCEPTION );
		}

		tds_tmpl.channels_in_use[ channel ] = SET;
	} while ( ( v = vars_pop( v ) ) != NULL );

	return vars_push( INT_VAR, 1 );
}


/*-----------------------------------------------------------------*/
/*-----------------------------------------------------------------*/

Var *digitizer_timebase( Var *v )
{
	double timebase;
	int TB = -1;
	unsigned int i;
	char *t;


	/* During the experiment if the digitizer's keyboard isn't locked we
	   need to reread the timebase, record length and trigger position and
	   update and recheck the windows */

	if ( FSC2_MODE == EXPERIMENT && ! tds_tmpl.lock_state )
		tds_tmpl_state_check( 0.0, 0.0, 0.0 );

	if ( v == NULL )
		switch ( FSC2_MODE )
		{
			case PREPARATION :
				if ( ! tds_tmpl.is_timebase )
					no_query_possible( );
				return vars_push( FLOAT_VAR, tds_tmpl.timebase );

			case TEST :
				return vars_push( FLOAT_VAR, tds_tmpl.is_timebase ?
								 tds_tmpl.timebase : TDS_TMPL_TEST_TIME_BASE );

			case EXPERIMENT :
				return vars_push( FLOAT_VAR, tds_tmpl.timebase );
		}

	timebase = get_double( v, "time base" );

	if ( timebase <= 0 )
	{
		print( FATAL, "Invalid zero or negative time base: %s.\n",
			   tds_tmpl_ptime( timebase ) );
		THROW( EXCEPTION );
	}

	/* Pick the allowed timebase nearest to the user supplied value */

	for ( i = 0; i < TB_ENTRIES - 1; i++ )
		if ( timebase >= tb[ i ] && timebase <= tb[ i + 1 ] )
		{
			TB = i +
				   ( ( tb[ i ] / timebase > timebase / tb[ i + 1 ] ) ? 0 : 1 );
			break;
		}

	if ( TB >= 0 &&                                         /* value found ? */
		 fabs( timebase - tb[ TB ] ) > timebase * 1.0e-2 )  /* error > 1% ?  */
	{
		t = T_strdup( tds_tmpl_ptime( timebase ) );
		print( WARN, "Can't set timebase to %s, using %s instead.\n",
			   t, tds_tmpl_ptime( tb[ TB ] ) );
		T_free( t );
	}

	if ( TB < 0 )                                   /* not found yet ? */
	{
		t = T_strdup( tds_tmpl_ptime( timebase ) );

		if ( timebase < tb[ 0 ] )
		{
			TB = 0;
			print( WARN, "Timebase of %s is too low, using %s instead.\n",
				   t, tds_tmpl_ptime( tb[ TB ] ) );
		}
		else
		{
		    TB = TB_ENTRIES - 1;
			print( WARN, "Timebase of %s is too large, using %s instead.\n",
				   t, tds_tmpl_ptime( tb[ TB ] ) );
		}

		T_free( t );
	}

	too_many_arguments( v );

	tds_tmpl.is_timebase = SET;

	if ( FSC2_MODE == EXPERIMENT )
		tds_tmpl_set_timebase( tb[ TB ] );

	tds_tmpl_state_check( tb[ TB ], tds_tmpl.rec_len, tds_tmpl.trig_pos );

	return vars_push( FLOAT_VAR, tds_tmpl.timebase );
}


/*-----------------------------------------------------------------*/
/*-----------------------------------------------------------------*/

Var *digitizer_time_per_point( Var *v )
{
	v = v;

	/* During the experiment if the digitizer's keyboard isn't locked we
	   need to reread the timebase, record length and trigger position and
	   update and recheck the windows */

	if ( FSC2_MODE == EXPERIMENT && ! tds_tmpl.lock_state )
		tds_tmpl_state_check( 0.0, 0.0, 0.0 );

	return vars_push( FLOAT_VAR, tds_tmpl.timebase / TDS_TMPL_POINTS_PER_DIV );
}


/*-----------------------------------------------------------------*/
/*-----------------------------------------------------------------*/

Var *digitizer_sensitivity( Var *v )
{
	long channel;
	double sens;


	if ( v == NULL )
	{
		print( FATAL, "Missing arguments.\n" );
		THROW( EXCEPTION );
	}

	channel = tds_tmpl_translate_channel( GENERAL_TO_TDS_TMPL,
									  get_strict_long( v, "channel number" ) );

	if ( channel >= NUM_NORMAL_CHANNELS )
	{
		print( FATAL, "Can't set or obtain sensitivity for channel %s.\n",
			   Channel_Names[ channel ] );
		THROW( EXCEPTION );
	}

	if ( ( v = vars_pop( v ) ) == NULL )
		switch ( FSC2_MODE )
		{
			case PREPARATION :
				if ( ! tds_tmpl.is_sens[ channel ] )
					no_query_possible( );
				return vars_push( FLOAT_VAR, tds_tmpl.sens[ channel ] );

			case TEST :
				return vars_push( FLOAT_VAR, tds_tmpl.is_sens[ channel ] ?
								  tds_tmpl.sens[ channel ] :
								  TDS_TMPL_TEST_SENSITIVITY );

			case EXPERIMENT :
				tds_tmpl.sens[ channel ] = tds_tmpl_get_sens( channel );
				tds_tmpl.is_sens[ channel ] = SET;
				return vars_push( FLOAT_VAR, tds_tmpl.sens[ channel ] );
		}

	sens = get_double( v, "sensitivity" );

	if ( sens < max_sens || sens > min_sens )
	{
		print( FATAL, "Sensitivity setting is out of range.\n" );
		THROW( EXCEPTION );
	}

	too_many_arguments( v );

	if ( FSC2_MODE == EXPERIMENT )
		tds_tmpl_set_sens( channel, sens );

	tds_tmpl.sens[ channel ] = sens;
	tds_tmpl.is_sens[ channel ] = SET;

	return vars_push( FLOAT_VAR, tds_tmpl.sens[ channel ] );
}


/*-----------------------------------------------------------------*/
/*-----------------------------------------------------------------*/

Var *digitizer_num_averages( Var *v )
{
	long num_avg;


	/* During the experiment if the digitizer's keyboard isn't locked we
	   need to reread the timebase, record length and trigger position and
	   update and recheck the windows */

	if ( FSC2_MODE == EXPERIMENT && ! tds_tmpl.lock_state )
		tds_tmpl_state_check( 0.0, 0.0, 0.0 );

	if ( v == NULL )
		switch ( FSC2_MODE )
		{
			case PREPARATION :
				if ( ! tds_tmpl.is_num_avg )
					no_query_possible( );
				return vars_push( INT_VAR, tds_tmpl.num_avg );

			case TEST :
				return vars_push( INT_VAR, tds_tmpl.is_num_avg ?
								  tds_tmpl.num_avg : TDS_TMPL_TEST_NUM_AVG );

			case EXPERIMENT :
				tds_tmpl.num_avg = tds_tmpl_get_num_avg( );
				return vars_push( INT_VAR, tds_tmpl.num_avg );
		}

	num_avg = get_long( v, "number of averages" );

	if ( num_avg == 0 )
	{
		if ( FSC2_MODE != EXPERIMENT )
		{
			print( FATAL, "Can't do zero averages. If you want to set sample "
				   "mode specify 1 as number of averages.\n" );
			THROW( EXCEPTION );
		}

		print( SEVERE, "Can't do zero averages. Switching off averaging.\n" );
		num_avg = 1;

	}
	else if ( num_avg < 0 )
	{
		if ( FSC2_MODE != EXPERIMENT )
		{
			print( FATAL, "Invalid negative number of averages: %ld.\n",
				   num_avg );
			THROW( EXCEPTION );
		}

		print( SEVERE, "Invalid negative number of averages: %ld.\n",
			   num_avg );
		tds_tmpl.num_avg = tds_tmpl_get_num_avg( );
		return vars_push( INT_VAR, tds_tmpl.num_avg );
	}

	too_many_arguments( v );

	if ( FSC2_MODE == EXPERIMENT )
		tds_tmpl_set_num_avg( num_avg );

	tds_tmpl.num_avg = num_avg;
	tds_tmpl.is_num_avg = SET;

	return vars_push( INT_VAR, tds_tmpl.num_avg );
}


/*------------------------------------------------------------------*/
/* Function either sets or returns the current record length of the */
/* digitizer. When trying to set a record length that does not fit  */
/* the possible settings the next larger is used instead.           */
/*------------------------------------------------------------------*/

Var *digitizer_record_length( Var *v )
{
	long rec_len;
	int i;


	/* During the experiment if the digitizer's keyboard isn't locked we
	   need to reread the timebase, record length and trigger position and
	   update and recheck the windows */

	if ( FSC2_MODE == EXPERIMENT && ! tds_tmpl.lock_state )
		tds_tmpl_state_check( 0.0, 0.0, 0.0 );

	if ( v == NULL )
	{

		switch ( FSC2_MODE )
		{
			case PREPARATION :
				if ( ! tds_tmpl.is_rec_len )
					no_query_possible( );
				return vars_push( INT_VAR, tds_tmpl.rec_len );

			case TEST :
				return vars_push( INT_VAR, tds_tmpl.is_rec_len ?
								  tds_tmpl.rec_len : TDS_TMPL_TEST_REC_LEN );

			case EXPERIMENT :
				return vars_push( INT_VAR, tds_tmpl.rec_len );
		}
	}

	rec_len = get_long( v, "record length" );

	i = 0;
	while ( 1 )
	{
		if ( record_lengths[ i ] == 0 )
		{
			if ( FSC2_MODE == EXPERIMENT )
			{
				print( FATAL, "Record length %ld too long.\n", rec_len );
				THROW( EXCEPTION );
			}

			print( SEVERE, "Record length %ld too long, using %ld instead.\n",
				   rec_len, record_lengths[ i  - 1] );
			rec_len = record_lengths[ i  - 1];
		}

		if ( rec_len == record_lengths[ i ] )
			break;

		if ( rec_len < record_lengths[ i ] )
		{
			print( SEVERE, "Can't set record length to %ld, using next larger "
				   "allowed value of %ld instead.\n",
				   rec_len, record_lengths[ i ] );
			break;
		}

		i++;
	}

	tds_tmpl.is_rec_len = SET;

	if ( FSC2_MODE == EXPERIMENT )
		tds_tmpl_set_record_length( record_lengths[ i ] );

	tds_tmpl_state_check( tds_tmpl.timebase, record_lengths[ i ],
						 tds_tmpl.trig_pos );

	return vars_push( INT_VAR, tds_tmpl.rec_len );
}


/*---------------------------------------------------------------------*/
/* Function either sets or returns the amount of pretrigger as a value */
/* between 0 and 1, which, when multiplied by the record length gives  */
/* the number of points recorded before the trigger.                   */
/*---------------------------------------------------------------------*/

Var *digitizer_trigger_position( Var *v )
{
	double trig_pos;


	/* During the experiment if the digitizer's keyboard isn't locked we
	   need to reread the timebase, record length and trigger position and
	   update and recheck the windows */

	if ( FSC2_MODE == EXPERIMENT && ! tds_tmpl.lock_state )
		tds_tmpl_state_check( 0.0, 0.0, 0.0 );

	if ( v == NULL )
		switch ( FSC2_MODE )
		{
			case PREPARATION :
				if ( ! tds_tmpl.is_trig_pos )
					no_query_possible( );
				return vars_push( FLOAT_VAR, tds_tmpl.trig_pos );

			case TEST :
				return vars_push( FLOAT_VAR, tds_tmpl.is_trig_pos ?
								  tds_tmpl.trig_pos : TDS_TMPL_TEST_TRIG_POS );

			case EXPERIMENT :
				return vars_push( FLOAT_VAR, tds_tmpl.trig_pos );
		}

	trig_pos = get_double( v, "trigger position" );

	if ( trig_pos < 0.0 || trig_pos > 1.0 )
	{
		if ( FSC2_MODE == EXPERIMENT )
		{
			print( FATAL, "Invalid trigger position %f, must be in interval "
				   "[0,1].\n", trig_pos );
			THROW( EXCEPTION );
		}

		print( SEVERE, "Invalid trigger position %f, using %f instead.\n",
			   trig_pos, trig_pos < 0 ? 0.0 : 1.0 );
		trig_pos = trig_pos < 0 ? 0.0 : 1.0;
	}

	too_many_arguments( v );

	tds_tmpl.is_trig_pos = SET;

	if ( FSC2_MODE  == EXPERIMENT )
		tds_tmpl_set_trigger_pos( trig_pos );

	tds_tmpl_state_check( tds_tmpl.timebase, tds_tmpl.rec_len, trig_pos );

	return vars_push( FLOAT_VAR, tds_tmpl.trig_pos );
}


/*----------------------------------------------------------------------*/
/* This is not a function that users should usually call but a function */
/* that allows other functions to check if a certain number stands for  */
/* channel that can be used in measurements.                            */
/*----------------------------------------------------------------------*/

Var *digitizer_meas_channel_ok( Var *v )
{
	long channel;


	channel = tds_tmpl_translate_channel( GENERAL_TO_TDS_TMPL,
									  get_strict_long( v, "channel number" ) );

	if ( channel >= NUM_DISPLAYABLE_CHANNELS )
		return vars_push( INT_VAR, 0 );
	else
		return vars_push( INT_VAR, 1 );
}


/*-------------------------------------------------------------------*/
/* digitizer_set_trigger_channel() sets the channel that is used for */
/* triggering.                                                       */
/*-------------------------------------------------------------------*/

Var *digitizer_trigger_channel( Var *v )
{
	long in_channel;
	long channel;


	if ( v == NULL )
		switch ( FSC2_MODE )
		{
			case PREPARATION :
				if ( ! tds_tmpl.is_trigger_channel )
					no_query_possible( );
				return vars_push( INT_VAR, tds_tmpl_translate_channel(
							   TDS_TMPL_TO_GENERAL, tds_tmpl.trigger_channel ) );

			case TEST :
				return vars_push( INT_VAR, tds_tmpl_translate_channel(
							   TDS_TMPL_TO_GENERAL, tds_tmpl.is_trigger_channel ?
							   tds_tmpl.trigger_channel :
							   TDS_TMPL_TEST_TRIG_CHANNEL ) );

			case EXPERIMENT :
				return vars_push( INT_VAR, tds_tmpl_translate_channel(
						TDS_TMPL_TO_GENERAL, tds_tmpl_get_trigger_channel( ) ) );
		}

	in_channel = get_strict_long( v, "channel number" );
	channel = tds_tmpl_translate_channel( GENERAL_TO_TDS_TMPL, in_channel );

    switch ( channel )
    {
        case TDS_TMPL_CH1 :
		case TDS_TMPL_CH2 :
#if defined TDS_TMPL_CH3
		case TDS_TMPL_CH3 :
#endif
#if defined TDS_TMPL_CH4
		case TDS_TMPL_CH4 :
#endif
#if defined TDS_TMPL_AUX
		case TDS_TMPL_AUX :
#endif
#if defined TDS_TMPL_AUX1
		case TDS_TMPL_AUX1 :
#endif
#if defined TDS_TMPL_AUX2
		case TDS_TMPL_AUX2 :
#endif
		case TDS_TMPL_LIN :
			if ( FSC2_MODE == EXPERIMENT )
				tds_tmpl_set_trigger_channel( channel );
			tds_tmpl.trigger_channel = channel;
			tds_tmpl.is_trigger_channel = SET;
            break;

		default :
			if ( channel >= 0 && channel < MAX_CHANNELS )
				print( FATAL, "Channel \"%s\" can't be used as trigger "
					   "channel.\n", Channel_Names[ channel ] );
			else
				print( FATAL, "Invalid channel number %ld.\n", in_channel );
			THROW( EXCEPTION );
    }

	too_many_arguments( v );

	return vars_push( INT_VAR, 1 );
}


/*-------------------------------------------------------------------*/
/*-------------------------------------------------------------------*/

Var *digitizer_start_acquisition( Var *v )
{
	v = v;


	if ( FSC2_MODE == EXPERIMENT )
		tds_tmpl_start_acquisition( );

	return vars_push( INT_VAR, 1 );
}


/*-------------------------------------------------------------------*/
/*-------------------------------------------------------------------*/

Var *digitizer_get_area( Var *v )
{
	return get_area( v, tds_tmpl.w != NULL ? SET : UNSET );
}


/*----------------------------------------------------*/
/*----------------------------------------------------*/

Var *digitizer_get_area_fast( Var *v )
{
	return get_area( v, UNSET );
}


/*----------------------------------------------------*/
/*----------------------------------------------------*/

static Var *get_area( Var *v, bool use_cursor )
{
	WINDOW *w;
	int ch;


	/* The first variable got to be a channel number */

	if ( v == NULL )
	{
		print( FATAL, "Missing arguments.\n" );
		THROW( EXCEPTION );
	}

	ch = ( int ) tds_tmpl_translate_channel( GENERAL_TO_TDS_TMPL,
									  get_strict_long( v, "channel number" ) );

	if ( ch >= NUM_DISPLAYABLE_CHANNELS )
	{
		print( FATAL, "Invalid channel %s.\n", Channel_Names[ ch ] );
		THROW( EXCEPTION );
	}

	tds_tmpl.channels_in_use[ ch ] = SET;

	/* Now check if there's a variable with a window number and check it */

	if ( ( v = vars_pop( v ) ) != NULL )
	{
		long win_num;

		if ( tds_tmpl.w == NULL )
		{
			print( FATAL, "No measurement windows have been defined.\n" );
			THROW( EXCEPTION );
		}

		win_num = get_strict_long( v, "window number" );

		for ( w = tds_tmpl.w; w != NULL && w->num != win_num; w = w->next )
			/* empty */ ;

		if ( w == NULL )
		{
			print( FATAL, "Second argument is not a valid window ID.\n" );
			THROW( EXCEPTION );
		}
	}
	else
		w = NULL;

	too_many_arguments( v );

	/* During the experiment if the digitizer's keyboard isn't locked we
	   need to reread the timebase, record length and trigger position and
	   update and recheck the windows */

	if ( FSC2_MODE == EXPERIMENT && ! tds_tmpl.lock_state )
		tds_tmpl_state_check( 0.0, 0.0, 0.0 );

	/* Talk to digitizer only during the experiment, otherwise return a dummy
	   value */

	if ( FSC2_MODE != EXPERIMENT )
		return vars_push( FLOAT_VAR, 1.234e-8 );

	return vars_push( FLOAT_VAR, tds_tmpl_get_area( ch, w, use_cursor ) );
}


/*-------------------------------------------------------------------*/
/*-------------------------------------------------------------------*/

Var *digitizer_get_curve( Var *v )
{
	return get_curve( v, tds_tmpl.w != NULL ? SET : UNSET );
}


/*----------------------------------------------------*/
/*----------------------------------------------------*/

Var *digitizer_get_curve_fast( Var *v )
{
	return get_curve( v, UNSET );
}


/*----------------------------------------------------*/
/*----------------------------------------------------*/

static Var *get_curve( Var *v, bool use_cursor )
{
	WINDOW *w;
	int ch, i;
	double *array;
	long length;
	Var *nv;


	/* The first variable got to be a channel number */

	if ( v == NULL )
	{
		print( FATAL, "Missing arguments.\n" );
		THROW( EXCEPTION );
	}

	ch = ( int ) tds_tmpl_translate_channel( GENERAL_TO_TDS_TMPL,
									  get_strict_long( v, "channel number" ) );

	if ( ch >= NUM_DISPLAYABLE_CHANNELS )
	{
		print( FATAL, "Invalid channel %s.\n", Channel_Names[ ch ] );
		THROW( EXCEPTION );
	}

	tds_tmpl.channels_in_use[ ch ] = SET;

	/* Now check if there's a variable with a window number and check it */

	if ( ( v = vars_pop( v ) ) != NULL )
	{
		long win_num;

		if ( tds_tmpl.w == NULL )
		{
			print( FATAL, "No measurement windows have been defined.\n" );
			THROW( EXCEPTION );
		}

		win_num = get_strict_long( v, "window number" );

		for ( w = tds_tmpl.w; w != NULL && w->num != win_num; w = w->next )
			/* empty */ ;

		if ( w == NULL )
		{
			print( FATAL, "Second argument is not a valid window ID.\n" );
			THROW( EXCEPTION );
		}
	}
	else
		w = NULL;

	too_many_arguments( v );

	/* During the experiment if the digitizer's keyboard isn't locked we
	   need to reread the timebase, record length and trigger position and
	   update and recheck the windows */

	if ( FSC2_MODE == EXPERIMENT && ! tds_tmpl.lock_state )
		tds_tmpl_state_check( 0.0, 0.0, 0.0 );

	/* Talk to digitizer only in the real experiment, otherwise return a dummy
	   array */

	if ( FSC2_MODE == EXPERIMENT )
	{
		tds_tmpl_get_curve( ch, w, &array, &length, use_cursor );
		nv = vars_push( FLOAT_ARR, array, length );
	}
	else
	{
		if ( tds_tmpl.is_rec_len  )
			length = tds_tmpl.rec_len;
		else
			length = TDS_TMPL_TEST_REC_LEN;
		array = T_malloc( length * sizeof( double ) );
		for ( i = 0; i < length; i++ )
			array[ i ] = 1.0e-7 * sin( M_PI * i / 122.0 );
		nv = vars_push( FLOAT_ARR, array, length );
		nv->flags |= IS_DYNAMIC;
	}

	T_free( array );
	return nv;
}


/*-------------------------------------------------------------------*/
/*-------------------------------------------------------------------*/

Var *digitizer_get_amplitude( Var *v )
{
	return get_amplitude( v, SET );
}


/*----------------------------------------------------*/
/*----------------------------------------------------*/

Var *digitizer_get_amplitude_fast( Var *v )
{
	return get_amplitude( v, UNSET );
}


/*----------------------------------------------------*/
/*----------------------------------------------------*/

static Var *get_amplitude( Var *v, bool use_cursor )
{
	WINDOW *w;
	int ch;


	/* The first variable got to be a channel number */

	if ( v == NULL )
	{
		print( FATAL, "Missing argumnts.\n" );
		THROW( EXCEPTION );
	}

	ch = ( int ) tds_tmpl_translate_channel( GENERAL_TO_TDS_TMPL,
									  get_strict_long( v, "channel number" ) );

	if ( ch >= NUM_DISPLAYABLE_CHANNELS )
	{
		print( FATAL, "Invalid channel %s.\n", Channel_Names[ ch ] );
		THROW( EXCEPTION );
	}

	tds_tmpl.channels_in_use[ ch ] = SET;

	/* Now check if there's a variable with a window number and check it */

	if ( ( v = vars_pop( v ) ) != NULL )
	{
		long win_num;

		if ( tds_tmpl.w == NULL )
		{
			print( FATAL, "No measurement windows have been defined.\n" );
			THROW( EXCEPTION );
		}

		win_num = get_strict_long( v, "window number" );

		for ( w = tds_tmpl.w; w != NULL && w->num != win_num; w = w->next )
			/* empty */ ;

		if ( w == NULL )
		{
			print( FATAL, "Second argument is not a valid window ID.\n" );
			THROW( EXCEPTION );
		}
	}
	else
		w = NULL;

	too_many_arguments( v );

	/* During the experiment if the digitizer's keyboard isn't locked we
	   need to reread the timebase, record length and trigger position and
	   update and recheck the windows */

	if ( FSC2_MODE == EXPERIMENT && ! tds_tmpl.lock_state )
		tds_tmpl_state_check( 0.0, 0.0, 0.0 );

	/* Talk to digitizer only in the real experiment, otherwise return a dummy
	   value */

	if ( FSC2_MODE != EXPERIMENT )
		return vars_push( FLOAT_VAR, 1.23e-7 );

	return vars_push( FLOAT_VAR, tds_tmpl_get_amplitude( ch, w, use_cursor ) );
}


/*----------------------------------------------------*/
/*----------------------------------------------------*/

Var *digitizer_run( Var *v )
{
	v = v;

	if ( FSC2_MODE == EXPERIMENT )
		tds_tmpl_free_running( );

	return vars_push( INT_VAR,1 );
}


/*----------------------------------------------------*/
/*----------------------------------------------------*/

Var *digitizer_lock_keyboard( Var *v )
{
	bool lock;


	if ( v == NULL )
		lock = SET;
	else
	{
		lock = get_boolean( v );
		too_many_arguments( v );
	}

	if ( FSC2_MODE == EXPERIMENT )
		tds_tmpl_lock_state( lock );

	tds_tmpl.lock_state = lock;
	return vars_push( INT_VAR, lock ? 1 : 0 );
}


/*
 * Local variables:
 * tags-file-name: "../TAGS"
 * End:
 */
