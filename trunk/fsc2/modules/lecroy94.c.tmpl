/* -*-C-*-
 *
 *  $Id$
 *
 *  Copyright (C) 1999-2007 Jens Thoms Toerring
 *
 *  This file is part of fsc2.
 *
 *  Fsc2 is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2, or (at your option)
 *  any later version.
 *
 *  Fsc2 is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with fsc2; see the file COPYING.  If not, write to
 *  the Free Software Foundation, 59 Temple Place - Suite 330,
 *  Boston, MA 02111-1307, USA.
 */


#define LECROY94_TMPL_MAIN_
#include "lecroy94_tmpl.h"


/*--------------------------------*/
/* global variables of the module */
/*--------------------------------*/

const char device_name[ ]  = DEVICE_NAME;
const char generic_type[ ] = DEVICE_TYPE;

LECROY94_TMPL_T lecroy94_tmpl;

const char *LECROY94_TMPL_Channel_Names[ 13 ] = { "CH1",    "CH2",
                                                  "CH3",    "CH4",
                                                  "EXP_A",  "EXP_B",
                                                  "MEM_C",  "MEM_D",
                                                  "FUNC_E", "FUNC_F",
                                                  "LINE",   "EXT",
                                                  "EXT10" };

/* Possible numbers of points to be averaged */

long rl[ 10 ] = { 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000 };

static LECROY94_TMPL_T lecroy94_tmpl_stored;



/*******************************************/
/*   We start with the hook functions...   */
/*******************************************/

/*------------------------------------*
 * Init hook function for the module.
 *------------------------------------*/

int lecroy94_tmpl_init_hook( void )
{
    size_t i;


    /* Set global variable to indicate that GPIB bus is needed */

    Need_GPIB = SET;

    /* Initialize some variables in the digitizers structure */

    lecroy94_tmpl.num_used_channels = 0;

    lecroy94_tmpl.w                = NULL;
    lecroy94_tmpl.is_timebase      = UNSET;
    lecroy94_tmpl.is_trigger_mode  = UNSET;
    lecroy94_tmpl.is_trigger_delay = UNSET;
    lecroy94_tmpl.num_windows      = 0;
    lecroy94_tmpl.interleaved      = LECROY94_TMPL_TEST_ILVD_MODE;
    lecroy94_tmpl.tb_index         = LECROY94_TMPL_TEST_TB_INDEX;
    lecroy94_tmpl.timebase         = LECROY94_TMPL_TEST_TIMEBASE;
    lecroy94_tmpl.trigger_delay    = LECROY94_TMPL_TEST_TRIG_DELAY;

    for ( i = LECROY94_TMPL_CH1; i <= LECROY94_TMPL_FUNC_F; i++ )
    {
        lecroy94_tmpl.is_displayed[ i ]        = UNSET;
        lecroy94_tmpl.is_sens[ i ]             = UNSET;
        lecroy94_tmpl.is_offset[ i ]           = UNSET;
        lecroy94_tmpl.is_coupling[ i ]         = UNSET;
        lecroy94_tmpl.is_trigger_slope[ i ]    = UNSET;
        lecroy94_tmpl.is_trigger_coupling[ i ] = UNSET;
        lecroy94_tmpl.is_trigger_level[ i ]    = UNSET;
        lecroy94_tmpl.rec_len[ i ]             = LECROY94_TMPL_UNDEF_REC_LEN;
    }

    for ( i = LECROY94_TMPL_FUNC_E; i <= LECROY94_TMPL_FUNC_F; i++ )
    {
        lecroy94_tmpl.source_ch[ i ]    =
                                 LECROY94_TMPL_CH1 + i - LECROY94_TMPL_FUNC_E;
        lecroy94_tmpl.is_avg_setup[ i ] = UNSET;
        lecroy94_tmpl.rec_len[ i ]      = LECROY94_TMPL_UNDEF_REC_LEN;
    }

    lecroy94_tmpl_stored.w = NULL;

    return 1;
}


/*-----------------------------------*
 * Test hook function for the module
 *-----------------------------------*/

int lecroy94_tmpl_test_hook( void )
{
    lecroy94_tmpl_store_state( &lecroy94_tmpl_stored, &lecroy94_tmpl );
    return 1;
}


/*--------------------------------------------------*
 * Start of experiment hook function for the module
 *--------------------------------------------------*/

int lecroy94_tmpl_exp_hook( void )
{
    /* Reset structure describing the state of the digitizer to the one
       it had before the test run was started */

    lecroy94_tmpl_store_state( &lecroy94_tmpl, &lecroy94_tmpl_stored );

    if ( ! lecroy94_tmpl_init( DEVICE_NAME ) )
    {
        print( FATAL, "Initialization of device failed: %s\n",
               gpib_error_msg );
        THROW( EXCEPTION );
    }

    return 1;
}


/*------------------------------------------------*
 * End of experiment hook function for the module
 *------------------------------------------------*/

int lecroy94_tmpl_end_of_exp_hook( void )
{
    lecroy94_tmpl_finished( );
    return 1;
}


/*------------------------------------------*
 * For final work before module is unloaded
 *------------------------------------------*/


void lecroy94_tmpl_exit_hook( void )
{
    lecroy94_tmpl_exit_cleanup( );
    lecroy94_tmpl_delete_windows( &lecroy94_tmpl );
    lecroy94_tmpl_delete_windows( &lecroy94_tmpl_stored );
}


/*----------------------------------------------------*
 *----------------------------------------------------*/

Var_T *digitizer_name( Var_T * v  UNUSED_ARG )
{
    return vars_push( STR_VAR, DEVICE_NAME );
}


/*------------------------------------------*
 *------------------------------------------*/

Var_T *digitizer_define_window( Var_T * v )
{
    double win_start = 0,
           win_width = 0;
    Window_T *w;


    if ( v == NULL || v->next == NULL )
    {
        print( FATAL, "Missing argument(s), absolute window position "
               "(relative to trigger) and window width must be specified.\n" );
        THROW( EXCEPTION );
    }

    /* Get start point and width of window */

    win_start = get_double( v, "window start position" );
    v = vars_pop( v );
    win_width = get_double( v, "window width" );

    /* Allow window width to be zero in test run... */
    
    if (    ( FSC2_MODE == TEST && win_width < 0.0 )
         || ( FSC2_MODE != TEST && win_width <= 0.0 ) )
    {
        print( FATAL, "Zero or negative window width.\n" );
        THROW( EXCEPTION );
    }

    too_many_arguments( v );

    /* Create a new window structure and append it to the list of windows */

    if ( lecroy94_tmpl.w == NULL )
    {
        lecroy94_tmpl.w = w = WINDOW_P T_malloc( sizeof *w );
        w->prev = NULL;
    }
    else
    {
        w = lecroy94_tmpl.w;
        while ( w->next != NULL )
            w = w->next;
        w->next = WINDOW_P T_malloc( sizeof *w->next );
        w->next->prev = w;
        w = w->next;
    }

    w->next = NULL;
    w->num = lecroy94_tmpl.num_windows++ + WINDOW_START_NUMBER;

    w->start = win_start;
    w->width = win_width;

    lecroy94_tmpl_window_check( w, UNSET );

    return vars_push( INT_VAR, w->num );
}


/*------------------------------------------------*
 *------------------------------------------------*/

Var_T *digitizer_change_window( Var_T * v )
{
    Window_T *w;


    if ( lecroy94_tmpl.w == NULL )
    {
        print( FATAL, "No windows have been defined.\n" );
        THROW( EXCEPTION );
    }

    if ( v == NULL )
    {
        print( FATAL, "Missing window ID.\n" );
        THROW( EXCEPTION );
    }

    /* Figure out the window number and test if a window with this number
       exists at all */

    w = lecroy94_tmpl_get_window_by_number(
                                           get_strict_long( v, "window ID" ) );
    v = vars_pop( v );

    if ( v == NULL )
    {
        print( FATAL, "Missing window start position argument.\n" );
        THROW( EXCEPTION );
    }

    w->start = get_double( v, "window start position" );
    v = vars_pop( v );

    if ( v == NULL )
    {
        print( FATAL, "Missing window width argument.\n" );
        THROW( EXCEPTION );
    }

    w->width = get_double(  v, "window width" );

    if ( w->width < 0.0 ) {
        print( FATAL, "Negative window width.\n" );
        THROW( EXCEPTION );
    }

    too_many_arguments( v );

    lecroy94_tmpl_window_check( w, UNSET );

    return vars_push( INT_VAR, w->num );
}


/*-----------------------------------------------------------------*
 *-----------------------------------------------------------------*/

Var_T *digitizer_window_position( Var_T * v )
{
    Window_T *w;


    if ( lecroy94_tmpl.w == NULL )
    {
        print( FATAL, "No windows have been defined.\n" );
        THROW( EXCEPTION );
    }

    if ( v == NULL )
    {
        print( FATAL, "Missing window ID.\n" );
        THROW( EXCEPTION );
    }

    /* Figure out the window number and test if a window with this number
       exists at all */

    w = lecroy94_tmpl_get_window_by_number( get_strict_long( v,
                                                             "window ID" ) );

    if ( ( v = vars_pop( v ) ) == NULL )
        return vars_push( FLOAT_VAR, w->start );

    w->start = get_double( v, "window start position" );

    too_many_arguments( v );

    lecroy94_tmpl_window_check( w, UNSET );

    return vars_push( FLOAT_VAR, w->start );
}


/*-----------------------------------------------------------------*
 *-----------------------------------------------------------------*/

Var_T *digitizer_window_width( Var_T * v )
{
    Window_T *w;


    if ( lecroy94_tmpl.w == NULL )
    {
        print( FATAL, "No windows have been defined.\n" );
        THROW( EXCEPTION );
    }

    if ( v == NULL )
    {
        print( FATAL, "Missing argument.\n" );
        THROW( EXCEPTION );
    }

    /* Figure out the window number and test if a window with this number
       exists at all */

    w = lecroy94_tmpl_get_window_by_number( get_strict_long( v,
                                                             "window ID" ) );

    if ( ( v = vars_pop( v ) ) == NULL )
        return vars_push( FLOAT_VAR, w->width );

    w->width = get_double( v, "window width" );

    too_many_arguments( v );

    lecroy94_tmpl_window_check( w, UNSET );

    return vars_push( FLOAT_VAR, w->width );
}


/*-------------------------------------------------------------*
 * Function for determining or setting the timebase (in s/div)
 *-------------------------------------------------------------*/

Var_T *digitizer_timebase( Var_T * v )
{
    double timebase;
    int tb_index = -1;
    size_t i;


    if ( v == NULL )
        switch ( FSC2_MODE )
        {
            case PREPARATION :
                if ( ! lecroy94_tmpl.is_timebase )
                    no_query_possible( );
                return vars_push( FLOAT_VAR, lecroy94_tmpl.timebase );

            case TEST :
                return vars_push( FLOAT_VAR, lecroy94_tmpl.timebase );

            case EXPERIMENT :
                lecroy94_tmpl.timebase = lecroy94_tmpl_get_timebase( );
                lecroy94_tmpl.is_timebase = SET;
                return vars_push( FLOAT_VAR, lecroy94_tmpl.timebase );
        }

    timebase = get_double( v, "timebase" );

    if ( timebase <= 0 )
    {
        print( FATAL, "Invalid zero or negative timebase: %s.\n",
               lecroy94_tmpl_ptime( timebase ) );
        THROW( EXCEPTION );
    }

    /* Pick the allowed timebase nearest to the user supplied value, tell
       the user about problems if there's a deviation of more than 1% */

    for ( i = 0; i < NUM_ELEMS( hres ) - 1; i++ )
        if ( timebase >= hres[ i ].tdiv && timebase <= hres[ i + 1 ].tdiv )
        {
            tb_index = i + ( ( hres[ i ].tdiv / timebase >
                         timebase / hres[ i + 1 ].tdiv ) ? 0 : 1 );
            break;
        }

    if (    tb_index >= 0                                 /* value found ? */
         && fabs( timebase - hres[ tb_index ].tdiv ) > timebase * 1.0e-2 )
        print( WARN, "Can't set timebase to %s, using %s instead.\n",
               lecroy94_tmpl_ptime( timebase ),
               lecroy94_tmpl_ptime( hres[ tb_index ].tdiv ) );

    if ( tb_index < 0 )                                   /* not found yet ? */
    {
        if ( timebase < hres[ 0 ].tdiv )
        {
            tb_index = 0;
            print( WARN, "Timebase of %s is too short, using %s instead.\n",
                   lecroy94_tmpl_ptime( timebase ),
                   lecroy94_tmpl_ptime( hres[ tb_index ].tdiv ) );
        }
        else
        {
            tb_index = NUM_ELEMS( hres ) - 1;
            print( WARN, "Timebase of %s is too long, using %s instead.\n",
                   lecroy94_tmpl_ptime( timebase ),
                   lecroy94_tmpl_ptime( hres[ tb_index ].tdiv ) );
        }
    }

    lecroy94_tmpl.timebase = hres[ tb_index ].tdiv;
    lecroy94_tmpl.tb_index = tb_index;
    lecroy94_tmpl.is_timebase = SET;

    /* Now check if the trigger delay (in case it's set) fits with the new
       timebase setting, and, based on this, the window positions and widths */

    lecroy94_tmpl.trigger_delay = lecroy94_tmpl_trigger_delay_check( );
    lecroy94_tmpl_all_windows_check( );

    /* In the experiment set the timebase and also the trigger delay, at least
       if it was already set */

    if ( FSC2_MODE == EXPERIMENT )
    {
        lecroy94_tmpl_set_timebase( hres[ tb_index ].tdiv );

        if ( lecroy94_tmpl.is_trigger_delay )
            lecroy94_tmpl_set_trigger_delay( lecroy94_tmpl.trigger_delay );
    }

    return vars_push( FLOAT_VAR, lecroy94_tmpl.timebase );
}


/*--------------------------------------------------------------------*
 * Function to determine or set the measurement mode (i.e. RIS or SS)
 *-------------------------------------------------------------------*/

Var_T *digitizer_interleave_mode( Var_T * v )
{
    bool ilvd;


    if ( v == NULL )
        switch ( FSC2_MODE )
        {
            case PREPARATION :
                if ( ! lecroy94_tmpl.is_interleaved )
                    no_query_possible( );
                return vars_push( INT_VAR,
                                  ( long ) lecroy94_tmpl.interleaved );

            case TEST :
                return vars_push( INT_VAR,
                                  ( long ) lecroy94_tmpl.interleaved );

            case EXPERIMENT :
                lecroy94_tmpl.interleaved = lecroy94_tmpl_get_interleaved( );
                lecroy94_tmpl.is_interleaved = SET;
                return vars_push( INT_VAR,
                                  ( long ) lecroy94_tmpl.interleaved );
        }

    ilvd = get_boolean( v );

    too_many_arguments( v );

    if ( ilvd && hres[ lecroy94_tmpl.tb_index ].ris_rl < 0 )
    {
        print( FATAL, "Can't switch to RIS mode for timebase of %s.\n",
               lecroy94_tmpl_ptime( hres[ lecroy94_tmpl.tb_index ].tdiv ) );
        THROW( EXCEPTION );
    }

    if ( ! ilvd && hres[ lecroy94_tmpl.tb_index ].ss_rl < 0 )
    {
        print( FATAL, "Can't switch to Single Shot mode for timebase "
               "of %s.\n",
               lecroy94_tmpl_ptime( hres[ lecroy94_tmpl.tb_index ].tdiv ) );
        THROW( EXCEPTION );
    }

    lecroy94_tmpl.interleaved = ilvd;
    lecroy94_tmpl.is_interleaved = SET;
    lecroy94_tmpl.is_timebase = SET;              /* must be set to be able 
                                                     to set interleaved mode */

    lecroy94_tmpl.trigger_delay = lecroy94_tmpl_trigger_delay_check( );
    lecroy94_tmpl_all_windows_check( );

    if ( FSC2_MODE == EXPERIMENT )
    {
        lecroy94_tmpl_set_interleaved( ilvd );

        if ( lecroy94_tmpl.is_trigger_delay )
            lecroy94_tmpl_set_trigger_delay( lecroy94_tmpl.trigger_delay );
    }

    return vars_push( INT_VAR, ( long ) ilvd );
}


/*----------------------------------------------------------------*
 * Returns the time difference between two points for the current
 * timebase and mode (i.e. RIS or SS)
 *----------------------------------------------------------------*/

Var_T *digitizer_time_per_point( Var_T * v  UNUSED_ARG )
{
    if (    FSC2_MODE == PREPARATION
         && ( ! lecroy94_tmpl.is_timebase || ! lecroy94_tmpl.is_interleaved ) )
        no_query_possible( );

    return vars_push( FLOAT_VAR, lecroy94_tmpl_time_per_point( ) );
}


/*----------------------------------------------------------------*
 * Function for setting or determining the sensitivity (in V/div)
 *----------------------------------------------------------------*/

Var_T *digitizer_sensitivity( Var_T * v )
{
    long channel;
    double sens;
    size_t i;
    size_t fs_index = 0;
    double offset;


    if ( v == NULL )
    {
        print( FATAL, "No channel specified.\n" );
        THROW( EXCEPTION );
    }

    channel = lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                               get_strict_long( v, "channel number" ), UNSET );

    if ( channel < LECROY94_TMPL_CH1 || channel > LECROY94_TMPL_CH_MAX )
    {
        print( FATAL, "Can't set or obtain sensitivity for channel %s.\n",
               LECROY94_TMPL_Channel_Names[ channel ] );
        THROW( EXCEPTION );
    }

    if ( ( v = vars_pop( v ) ) == NULL )
        switch ( FSC2_MODE )
        {
            case PREPARATION :
                if ( ! lecroy94_tmpl.is_sens[ channel ] )
                    no_query_possible( );
                return vars_push( FLOAT_VAR, lecroy94_tmpl.sens[ channel ] );

            case TEST :
                return vars_push( FLOAT_VAR, lecroy94_tmpl.is_sens[ channel ] ?
                                             lecroy94_tmpl.sens[ channel ] :
                                             LECROY94_TMPL_TEST_SENSITIVITY );

            case EXPERIMENT :
                lecroy94_tmpl.sens[ channel ] =
                                            lecroy94_tmpl_get_sens( channel );
                return vars_push( FLOAT_VAR, lecroy94_tmpl.sens[ channel ] );
        }

    sens = get_double( v, "sensitivity" );

    too_many_arguments( v );

    if ( sens < 0.0 )
    {
        print( FATAL, "Invalid negative or zero sensitivity.\n" );
        THROW( EXCEPTION );
    }

    /* Check that the sensitivity setting isn't out of range (taking care
       of rounding errors) */

    if (    sens < 0.9999 * LECROY94_TMPL_MAX_SENS
         || sens > 1.0001 * LECROY94_TMPL_MIN_SENS )
    {
        print( FATAL, "Requested sensitivity setting is out of range.\n" );
        THROW( EXCEPTION );
    }

    if ( sens < LECROY94_TMPL_MAX_SENS )
        sens = LECROY94_TMPL_MAX_SENS;
    if ( sens > LECROY94_TMPL_MIN_SENS )
        sens = LECROY94_TMPL_MIN_SENS;

    /* Check that the currently set offset isn't too large for the requested
       sensitivity (if we're in the preparations phase we can only do the
       check if an offset has already been set) */

    if ( FSC2_MODE != PREPARATION || lecroy94_tmpl.is_offset[ channel ] ) 
    {
        for ( i = 1; i < NUM_ELEMS( fixed_sens ); i++ )
            if ( sens < 0.9999 * fixed_sens[ i ] )
            {
                fs_index = i - 1;
                break;
            }

        if ( i ==  NUM_ELEMS( fixed_sens ) )
            fs_index = i - 1;

        if ( FSC2_MODE == TEST && ! lecroy94_tmpl.is_offset[ channel ] )
            offset = LECROY94_TMPL_TEST_OFFSET;
        else
            offset = lecroy94_tmpl.sens[ channel ];

        if ( fabs( offset ) >=
                  1.0001 * offset_factor[ fs_index ] * fixed_sens[ fs_index ] )
        {
            print( FATAL, "Currently set offset too large for the requested "
                   "sensitivity.\n" );
            THROW( EXCEPTION );
        }
    }

    if ( FSC2_MODE == EXPERIMENT )
        lecroy94_tmpl_set_sens( channel, sens );

    lecroy94_tmpl.sens[ channel ] = sens;
    lecroy94_tmpl.is_sens[ channel ] = SET;

    return vars_push( FLOAT_VAR, lecroy94_tmpl.sens[ channel ] );
}


/*--------------------------------------------------------------*
 * Function for setting or query of input coupling of a channel 
 *--------------------------------------------------------------*/

Var_T *digitizer_coupling( Var_T * v )
{
    long channel;
    long cpl = LECROY94_TMPL_INVALID_COUPL;
    const char *cpl_str[ ] = { "A1M", "D1M", "D50", "GND" };
    size_t i;


    if ( v == NULL )
    {
        print( FATAL, "Missing argument(s).\n" );
        THROW( EXCEPTION );
    }

    channel = lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                               get_strict_long( v, "channel number" ), UNSET );

    if ( channel < LECROY94_TMPL_CH1 || channel > LECROY94_TMPL_CH_MAX )
    {
        print( FATAL, "Can't set or obtain coupling for channel %s.\n",
               LECROY94_TMPL_Channel_Names[ channel ] );
        THROW( EXCEPTION );
    }

    v = vars_pop( v );

    if ( v == NULL )
        switch( FSC2_MODE )
        {
            case PREPARATION :
                if ( ! lecroy94_tmpl.is_coupling[ channel ] )
                    no_query_possible( );
                /* Fall through */
        
            case TEST:
                return vars_push( INT_VAR,
                                  ( long ) lecroy94_tmpl.coupling[ channel ] );

            case EXPERIMENT :
                lecroy94_tmpl.coupling[ channel ] =
                                         lecroy94_tmpl_get_coupling( channel );
                return vars_push( INT_VAR,
                                  ( long ) lecroy94_tmpl.coupling[ channel ] );
        }

    vars_check( v, INT_VAR | FLOAT_VAR | STR_VAR );

    if ( v->type == STR_VAR )
    {
        for ( i = 0; i < NUM_ELEMS( cpl_str ); i++ )
            if ( ! strcasecmp( v->val.sptr, cpl_str[ i ] ) )
            {
                cpl = i;
                break;
            }
    }
    else
        cpl = get_long( v, "coupling type" );

    if ( cpl < LECROY94_TMPL_AC_1_MOHM || cpl > LECROY94_TMPL_GND )
    {
        print( FATAL, "Invalid coupling type.\n" );
        THROW( EXCEPTION );
    }

    too_many_arguments( v );

    if ( FSC2_MODE == EXPERIMENT )
        lecroy94_tmpl_set_coupling( channel, cpl );

    lecroy94_tmpl.is_coupling[ channel ] = SET;
    lecroy94_tmpl.coupling[ channel ] = cpl;

    return vars_push( INT_VAR, cpl );
}


/*----------------------------------------------------------------*
 * Function for setting or determining the vertical offset (in V)
 *----------------------------------------------------------------*/

Var_T *digitizer_offset( Var_T * v )
{
    long channel;
    double offset;
    size_t i;
    size_t fs_index = 0;


    if ( v == NULL )
    {
        print( FATAL, "No channel specified.\n" );
        THROW( EXCEPTION );
    }

    channel = lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                               get_strict_long( v, "channel number" ), UNSET );

    if ( channel < LECROY94_TMPL_CH1 || channel > LECROY94_TMPL_CH_MAX )
    {
        print( FATAL, "Can't set or obtain offset for channel %s.\n",
               LECROY94_TMPL_Channel_Names[ channel ] );
        THROW( EXCEPTION );
    }

    if ( ( v = vars_pop( v ) ) == NULL )
        switch ( FSC2_MODE )
        {
            case PREPARATION :
                if ( ! lecroy94_tmpl.is_offset[ channel ] )
                    no_query_possible( );
                return vars_push( FLOAT_VAR, lecroy94_tmpl.offset[ channel ] );

            case TEST :
                return vars_push( FLOAT_VAR,
                                  lecroy94_tmpl.is_offset[ channel ] ?
                                  lecroy94_tmpl.offset[ channel ] :
                                  LECROY94_TMPL_TEST_OFFSET );

            case EXPERIMENT :
                lecroy94_tmpl.offset[ channel ] =
                                           lecroy94_tmpl_get_offset( channel );
                return vars_push( FLOAT_VAR, lecroy94_tmpl.offset[ channel ] );
        }

    offset = get_double( v, "offset" );

    too_many_arguments( v );

    /* Check that the requested offset is possible with the current sensitivity
       setting ((if we're in the preparations phase we can only do the check
       if the sensitivity has already been set) */

    if ( FSC2_MODE != PREPARATION || lecroy94_tmpl.is_sens[ channel ] )
    {
        if ( FSC2_MODE == TEST && ! lecroy94_tmpl.is_sens[ channel ] )
            lecroy94_tmpl.sens[ channel ] = LECROY94_TMPL_TEST_SENSITIVITY;

        for ( i = 1; i < ( ssize_t ) NUM_ELEMS( fixed_sens ); i++ )
            if ( lecroy94_tmpl.sens[ channel ] < 0.9999 * fixed_sens[ i ] )
            {
                fs_index = i - 1;
                break;
            }

        if ( i == NUM_ELEMS( fixed_sens ) )
            fs_index = i - 1;

        if ( fabs( offset ) >=
                 1.0001 * offset_factor[ fs_index ] * fixed_sens[ fs_index ] )
        {
            print( FATAL, "Offset too large for the currently set channel "
                   "sensitivity.\n" );
            THROW( EXCEPTION );
        }
    }

    if ( FSC2_MODE == EXPERIMENT )
        lecroy94_tmpl_set_offset( channel, offset );

    lecroy94_tmpl.offset[ channel ] = offset;
    lecroy94_tmpl.is_offset[ channel ] = SET;

    return vars_push( FLOAT_VAR, lecroy94_tmpl.offset[ channel ] );
}


/*--------------------------------------------------------------------------*
 * Function sets or determines if the bandwidth limiter is switch on or off
 *--------------------------------------------------------------------------*/

Var_T *digitizer_bandwidth_limiter( Var_T * v )
{
    bool bwl;


    if ( v == NULL )
        switch ( FSC2_MODE )
        {
            case PREPARATION :
                if ( ! lecroy94_tmpl.is_bandwidth_limiter )
                    no_query_possible( );
                return vars_push( INT_VAR, 
                                  ( long ) lecroy94_tmpl.bandwidth_limiter );

            case TEST:
                return vars_push( INT_VAR, lecroy94_tmpl.is_bandwidth_limiter ?
                                  ( long ) lecroy94_tmpl.bandwidth_limiter :
                                  ( long ) LECROY94_TMPL_TEST_BWL );

            case EXPERIMENT :
                return vars_push( INT_VAR, ( long )
                                  lecroy94_tmpl_get_bandwidth_limiter( ) );
        }

    bwl = get_boolean( v );

    too_many_arguments( v );

    if ( FSC2_MODE == EXPERIMENT )
        lecroy94_tmpl_set_bandwidth_limiter( bwl );

    lecroy94_tmpl.is_bandwidth_limiter = SET;
    lecroy94_tmpl.bandwidth_limiter = bwl;

    return vars_push( INT_VAR, ( long ) bwl );
}


/*-------------------------------------------------------------------*
 * digitizer_trigger_channel() sets or determines the channel that is
 * used for triggering.
 *-------------------------------------------------------------------*/

Var_T *digitizer_trigger_channel( Var_T * v )
{
    long channel;


    if ( v == NULL )
        switch ( FSC2_MODE )
        {
            case PREPARATION :
                no_query_possible( );

            case TEST :
                if ( lecroy94_tmpl.is_trigger_channel )
                    return vars_push( INT_VAR,
                                      lecroy94_tmpl_translate_channel(
                                          LECROY94_TMPL_TO_GENERAL,
                                          lecroy94_tmpl.trigger_channel,
                                          UNSET ) );
                else
                    return vars_push( INT_VAR, lecroy94_tmpl_translate_channel(
                                          LECROY94_TMPL_TO_GENERAL,
                                          LECROY94_TMPL_TEST_TRIG_CHANNEL,
                                          UNSET ) );
                break;

            case EXPERIMENT :
                lecroy94_tmpl.trigger_channel =
                                           lecroy94_tmpl_get_trigger_source( );
                return vars_push( INT_VAR, lecroy94_tmpl_translate_channel(
                                      LECROY94_TMPL_TO_GENERAL,
                                      lecroy94_tmpl.trigger_channel,
                                      UNSET ) );
        }

    channel = lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                               get_strict_long( v, "channel number" ), UNSET );

    switch ( channel )
    {
        case LECROY94_TMPL_CH1 : case LECROY94_TMPL_CH2 :
#if defined LECROY94_TMPL_CH4_AS_TRG
        case LECROY94_TMPL_CH4 :
#endif
        case LECROY94_TMPL_LIN :
#if defined LECROY94_TMPL_EXT
        case LECROY94_TMPL_EXT :
#endif
#if defined LECROY94_TMPL_EXT10
        case LECROY94_TMPL_EXT10 :
#endif
            lecroy94_tmpl.trigger_channel = channel;
            lecroy94_tmpl.is_trigger_channel = SET;
            if ( FSC2_MODE == EXPERIMENT )
                lecroy94_tmpl_set_trigger_source( channel );
            break;

        default :
            print( FATAL, "Channel %s can't be used as trigger channel.\n",
                   LECROY94_TMPL_Channel_Names[ channel ] );
            THROW( EXCEPTION );
    }

    too_many_arguments( v );

    return vars_push( INT_VAR, 1L );
}


/*-------------------------------------------------------------------*
 * digitizer_trigger_level() sets or determines the trigger level for
 * one of the possible trigger channels
 *-------------------------------------------------------------------*/

Var_T *digitizer_trigger_level( Var_T * v )
{
    int channel;
    double level;
    double sens = 0.0;


    if ( v == NULL )
    {
        print( FATAL, "Missing argiment.\n" );
        THROW( EXCEPTION );
    }

    channel = lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                               get_strict_long( v, "channel number" ), UNSET );
    v = vars_pop( v );

    if ( channel != LECROY94_TMPL_CH1 && channel != LECROY94_TMPL_CH2
#if defined LECROY94_TMP_CH4_AS_TRG
         && channel != LECROY94_TMPL_CH4
#endif
         && channel != LECROY94_TMPL_LIN
#if defined LECROY94_TMPL_EXT
         && channel != LECROY94_TMPL_EXT
#endif
#if defined LECROY94_TMPL_EXT10
         && channel != LECROY94_TMPL_EXT10
#endif
       )
    {
        print( FATAL, "Invalid trigger channel.\n" );
        THROW( EXCEPTION );
    }

    if ( channel == LECROY94_TMPL_LIN ) {
        print( SEVERE, "Trigger level for LINE can't be determined or "
               "changed.\n" );
        return vars_push( FLOAT_VAR, 0.0 );
    }

    if ( v == NULL )
    {
        switch ( FSC2_MODE )
        {
            case PREPARATION :
                if ( ! lecroy94_tmpl.is_trigger_level[ channel ] )
                    no_query_possible( );
                return vars_push( FLOAT_VAR,
                                  lecroy94_tmpl.trigger_level[ channel ] );

            case TEST :
                if ( lecroy94_tmpl.is_trigger_level[ channel ] )
                    return vars_push( FLOAT_VAR, 
                                      lecroy94_tmpl.trigger_level[ channel ] );
                else
                    return vars_push( FLOAT_VAR,
                                      LECROY94_TMPL_TEST_TRIG_LEVEL );

            case EXPERIMENT :
                lecroy94_tmpl.trigger_level[ channel ] =
                                   lecroy94_tmpl_get_trigger_level( channel );
                return vars_push( FLOAT_VAR,
                                  lecroy94_tmpl.trigger_level[ channel ] );
        }
    }

    level = get_double( v, "trigger level" );

    too_many_arguments( v );

    switch ( channel )
    {
        case LECROY94_TMPL_CH1 : case LECROY94_TMPL_CH2 :
#if defined LECROY94_TMPL_CH4_AS_TRG
        case LECROY94_TMPL_CH4 :
#endif

            switch ( FSC2_MODE )
            {
                case PREPARATION :
                    if ( ! lecroy94_tmpl.is_sens[ channel ] )
                    {
                        print( FATAL, "Can't set trigger level in PREPARATION "
                               "section while sensitivity for the channel "
                               "hasn't been set.\n" );
                        THROW( EXCEPTION );
                    }
                    sens = lecroy94_tmpl.sens[ channel ];
                    break;

                case TEST :
                    if ( lecroy94_tmpl.is_sens[ channel ] )
                        sens = lecroy94_tmpl.sens[ channel ];
                    else
                        sens = LECROY94_TMPL_TEST_SENSITIVITY;
                    break;

                case EXPERIMENT :
                    sens = lecroy94_tmpl_get_sens( channel );
                    break;
            }

            if ( lrnd( fabs( 1.0e6 * level ) ) >
                    lrnd( 1.0e6 * LECROY94_TMPL_TRG_MAX_LEVEL_CH_FAC * sens ) )
            {
                print( FATAL, "Trigger level is too large, maximum is %f "
                       "times the current channel sensitivity.\n",
                       LECROY94_TMPL_TRG_MAX_LEVEL_CH_FAC );
                THROW( EXCEPTION );
            }
            break;

#if defined LECROY94_TMPL_EXT
        case LECROY94_TMPL_EXT :
            if ( lrnd( fabs( 1.0e6 * level ) ) >
                 lrnd( 1.0e6 * LECROY94_TMPL_TRG_MAX_LEVEL_EXT ) )
            {
                print( FATAL, "Trigger level too large, maximum is %f V.\n",
                       LECROY94_TMPL_TRG_MAX_LEVEL_EXT );
                THROW( EXCEPTION );
            }
            break;
#endif

#if defined LECROY94_TMPL_EXT10
        case LECROY94_TMPL_EXT10 :
            if ( lrnd( fabs( 1.0e6 * level ) ) >
                 lrnd( 1.0e6 * LECROY94_TMPL_TRG_MAX_LEVEL_EXT10 ) )
            {
                print( FATAL, "Trigger level too large, maximum is %f V.\n",
                       LECROY94_TMPL_TRG_MAX_LEVEL_EXT10 );
                THROW( EXCEPTION );
            }
            break;
#endif
    }

    if ( FSC2_MODE == EXPERIMENT )
        lecroy94_tmpl_set_trigger_level( channel, level );

    lecroy94_tmpl.is_trigger_level[ channel ] = SET;
    lecroy94_tmpl.trigger_level[ channel ] = level;
    return vars_push( FLOAT_VAR, level );
}


/*----------------------------------------------------------*
 * digitizer_trigger_slope() sets or determines the trigger
 * slope for one of the possible trigger channels
 *----------------------------------------------------------*/

Var_T *digitizer_trigger_slope( Var_T * v )
{
    int channel;
    int slope;


    if ( v == NULL )
    {
        print( FATAL, "Missing argiment.\n" );
        THROW( EXCEPTION );
    }

    channel = lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                               get_strict_long( v, "channel number" ), UNSET );
    v = vars_pop( v );

    if ( channel != LECROY94_TMPL_CH1 && channel != LECROY94_TMPL_CH2
#if defined LECROY94_TMP_CH4_AS_TRG
         && channel != LECROY94_TMPL_CH4
#endif
         && channel != LECROY94_TMPL_LIN
#if defined LECROY94_TMPL_EXT
         && channel != LECROY94_TMPL_EXT
#endif
#if defined LECROY94_TMPL_EXT10
         && channel != LECROY94_TMPL_EXT10
#endif
       )
    {
        print( FATAL, "Invalid trigger channel.\n" );
        THROW( EXCEPTION );
    }

    if ( channel == LECROY94_TMPL_LIN ) {
        print( SEVERE, "Trigger slope for LINE can't be determined or "
               "changed.\n" );
        return vars_push( INT_VAR, 0 );
    }

    if ( v == NULL )
    {
        switch ( FSC2_MODE )
        {
            case PREPARATION :
                if ( ! lecroy94_tmpl.is_trigger_slope[ channel ] )
                    no_query_possible( );
                return vars_push( INT_VAR, ( long )
                                  lecroy94_tmpl.trigger_slope[ channel ] );

            case TEST :
                if ( lecroy94_tmpl.is_trigger_slope[ channel ] )
                    return vars_push( INT_VAR, ( long )
                                      lecroy94_tmpl.trigger_slope[ channel ] );
                else
                    return vars_push( INT_VAR,
                                      LECROY94_TMPL_TEST_TRIG_SLOPE );

            case EXPERIMENT :
                lecroy94_tmpl.trigger_slope[ channel ] =
                                   lecroy94_tmpl_get_trigger_slope( channel );
                return vars_push( INT_VAR, ( long )
                                  lecroy94_tmpl.trigger_slope[ channel ] );
        }
    }

    if ( v->type == STR_VAR )
    {
        if (    ! strcasecmp( v->val.sptr, "POSITIVE" )
             || ! strcasecmp( v->val.sptr, "POS" ) )
            slope = 1;
        else if (    ! strcasecmp( v->val.sptr, "NEGATIVE" )
                  || ! strcasecmp( v->val.sptr, "NEG" ) ) 
            slope = 0;
        else
        {
            print( FATAL, "Invalid slope: \"%s\".\n", v->val.sptr );
            THROW( EXCEPTION );
        }
    }
    else
        slope = get_long( v, "trigger slope" );

    too_many_arguments( v );

    if ( FSC2_MODE == EXPERIMENT )
        lecroy94_tmpl_set_trigger_slope( channel,
                                         slope ? POSITIVE : NEGATIVE );

    lecroy94_tmpl.is_trigger_slope[ channel ] = SET;
    lecroy94_tmpl.trigger_slope[ channel ] = slope ? POSITIVE : NEGATIVE;
    return vars_push( INT_VAR, lecroy94_tmpl.trigger_slope[ channel ] );
}


/*-----------------------------------------------------------------*
 *-----------------------------------------------------------------*/

Var_T *digitizer_trigger_coupling( Var_T * v )
{
    long channel;
    long cpl = -1;
    size_t i;
    const char *cpl_str[ ] = { "AC", "DC", "LF REJ", "HF REJ"
#if defined LECROY94_TMPL_TRG_CPL_HF
                               , "HF" };
#else
                               };
#endif


    if ( v == NULL )
    {
        print( FATAL, "Missing argiment.\n" );
        THROW( EXCEPTION );
    }

    channel = lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                               get_strict_long( v, "channel number" ), UNSET );
    v = vars_pop( v );

    if ( channel != LECROY94_TMPL_CH1 && channel != LECROY94_TMPL_CH2
#if defined LECROY94_TMP_CH4_AS_TRG
         && channel != LECROY94_TMPL_CH4
#endif
         && channel != LECROY94_TMPL_LIN
#if defined LECROY94_TMPL_EXT
         && channel != LECROY94_TMPL_EXT
#endif
#if defined LECROY94_TMPL_EXT10
         && channel != LECROY94_TMPL_EXT10
#endif
       )
    {
        print( FATAL, "Invalid trigger channel.\n" );
        THROW( EXCEPTION );
    }

    if ( channel == LECROY94_TMPL_LIN ) {
        print( SEVERE, "Trigger coupling for LINE can't be determined or "
               "changed.\n" );
        return vars_push( FLOAT_VAR, 0.0 );
    }

    if ( v == NULL )
        switch ( FSC2_MODE )
        {
            case PREPARATION :
                if ( ! lecroy94_tmpl.is_trigger_coupling[ channel ] )
                    no_query_possible( );
                return vars_push( INT_VAR,
                                  lecroy94_tmpl.trigger_coupling[ channel ] );

            case TEST :
                return vars_push( INT_VAR,
                                 lecroy94_tmpl.is_trigger_coupling[ channel ] ?
                                  lecroy94_tmpl.trigger_coupling[ channel ] :
                                  LECROY94_TMPL_TEST_TRIG_COUP );

            case EXPERIMENT :
                lecroy94_tmpl.trigger_coupling[ channel ] =
                                 lecroy94_tmpl_get_trigger_coupling( channel );
                return vars_push( INT_VAR,
                                  lecroy94_tmpl.trigger_coupling[ channel ] );
        }

    if ( v->type == STR_VAR )
    {
        for ( i = 0; i < NUM_ELEMS( cpl_str ); i++ )
            if ( ! strcasecmp( v->val.sptr, cpl_str[ i ] ) )
            {
                cpl = i;
                break;
            }
    }
    else
        cpl = get_long( v, "trigger coupling type" );

    if (    cpl < LECROY94_TMPL_TRG_CPL_AC 
#if defined LECROY94_TMPL_TRG_CPL_HF
         || cpl > LECROY94_TMPL_TRG_CPL_HF )
#else
         || cpl > LECROY94_TMPL_TRG_CPL_HF_REJ )
#endif
    {
        print( FATAL, "Invalid trigger coupling type.\n" );
        THROW( EXCEPTION );
    }

    too_many_arguments( v );

    if ( FSC2_MODE == EXPERIMENT )
        lecroy94_tmpl_set_trigger_coupling( channel, cpl );

    lecroy94_tmpl.is_trigger_coupling[ channel ] = SET;
    lecroy94_tmpl.trigger_coupling[ channel ] = cpl;

#if defined LECROY94_TMPL_TRG_CPL_HF
    /* Settting the HF trigger coupling automatically switches to positive
       trigger slope */

    if ( cpl == LECROY94_TMPL_TRG_CPL_HF )
    {
        lecroy94_tmpl.is_trigger_slope[ channel ] = SET;
        lecroy94_tmpl.trigger_slope[ channel ] = POSITIVE;
    }
#endif

    return vars_push( INT_VAR, cpl );
}


/*---------------------------------------------------------------*
 * Function to set or determine the current trigger mode (please
 * note: SEQUENCE and WRAP mode are currrently not supported)
 *---------------------------------------------------------------*/

Var_T *digitizer_trigger_mode( Var_T * v )
{
    long mode = -1;
    const char *mode_str[ ] = { "AUTO", "NORMAL", "SINGLE",
                                "SEQUENCE", "WRAP" };
    size_t i;

    if ( v == 0 )
        switch ( FSC2_MODE )
        {
            case PREPARATION :
                if ( ! lecroy94_tmpl.is_trigger_mode )
                    no_query_possible( );
                return vars_push( INT_VAR,
                                  ( long ) lecroy94_tmpl.trigger_mode );

            case TEST :
                return vars_push( INT_VAR, lecroy94_tmpl.is_trigger_mode ?
                                  ( long ) lecroy94_tmpl.trigger_mode :
                                  LECROY94_TMPL_TEST_TRIG_MODE );

            case EXPERIMENT :
                return vars_push( INT_VAR,
                                  ( long ) lecroy94_tmpl_get_trigger_mode( ) );
        }

    if ( v->type == STR_VAR )
    {
        for ( i = 0; i < NUM_ELEMS( mode_str ); i++ )
            if ( ! strcasecmp( v->val.sptr, mode_str[ i ] ) )
            {
                mode = i;
                break;
            }
    }
    else
        mode = get_long( v, "trigger mode" );

    if ( mode < 0 || mode > ( long ) NUM_ELEMS( mode_str ) )
    {
        print( FATAL, "Invalid trigger mode.\n" );
        THROW( EXCEPTION );
    }

    if (    mode == LECROY94_TMPL_TRG_MODE_SEQUENCE
         || mode == LECROY94_TMPL_TRG_MODE_WRAP )
    {
        print( FATAL, "SEQUENCE and WRAP trigger mode currently not supported "
               "by the driver.\n" );
        THROW( EXCEPTION );
    }

    if ( FSC2_MODE == EXPERIMENT )
        lecroy94_tmpl_set_trigger_mode( mode );

    lecroy94_tmpl.trigger_mode = ( int ) mode;
    lecroy94_tmpl.is_trigger_mode = SET;

    return vars_push( INT_VAR, mode );
}


/*-----------------------------------------------------------------*
 * digitizer_trigger_delay() sets or determines the trigger delay,
 * positive values (up to the full horizontal width of the screen,
 * i.e. 10 times the timebase) are for pre-trigger while negative
 * values (up to 10,000 times the timebase) are for starting the
 * acquisition after the trigger (post-trigger). Time resolution
 * of the trigger delay is 1/50 of the timebase.
 *-----------------------------------------------------------------*/

Var_T *digitizer_trigger_delay( Var_T * v )
{
    double delay;
    double real_delay;


    if ( v == 0 )
        switch ( FSC2_MODE )
        {
            case PREPARATION :
                if ( ! lecroy94_tmpl.is_trigger_delay )
                    no_query_possible( );
                return vars_push( FLOAT_VAR, lecroy94_tmpl.trigger_delay );

            case TEST :
                return vars_push( FLOAT_VAR, lecroy94_tmpl.is_trigger_delay ?
                                  lecroy94_tmpl.trigger_delay :
                                  LECROY94_TMPL_TEST_TRIG_DELAY );

            case EXPERIMENT :
                lecroy94_tmpl.trigger_delay =
                                            lecroy94_tmpl_get_trigger_delay( );
                return vars_push( FLOAT_VAR, lecroy94_tmpl.trigger_delay );
        }

    delay = get_double( v, "trigger delay" );

    too_many_arguments( v );

    if ( FSC2_MODE == PREPARATION && ! lecroy94_tmpl.is_timebase )
    {
        print( FATAL, "Can't set trigger delay in PREPARATION "
               "section while timebase hasn't been set.\n" );
        THROW( EXCEPTION );
    }

    /* The delay can only be set in units of 1/50 of the timebase */

    real_delay = 0.02 * lrnd( 50.0 * delay / lecroy94_tmpl.timebase )
                 * lecroy94_tmpl.timebase;

    /* Check that the trigger delay is within the limits (taking rounding
       errors of the order of the current time resolution into account) */

    if (    real_delay > 0.0
         && real_delay >   10.0 * lecroy94_tmpl.timebase
                         +  0.5 * lecroy94_tmpl_time_per_point( ) )
    {
        print( FATAL, "Pre-trigger delay of %s is too long, can't be longer "
               "than 10 times the timebase.\n",
               lecroy94_tmpl_ptime( real_delay ) );
        THROW( EXCEPTION );
    }

    if (    real_delay < 0.0
         && real_delay <   -1.0e4 * lecroy94_tmpl.timebase
                         -  0.5 * lecroy94_tmpl_time_per_point( ) )
    {
        print( FATAL, "Post-trigger delay of %s is too long, can't be longer "
               "than 10,000 times the timebase.\n",
               lecroy94_tmpl_ptime( real_delay ) );
        THROW( EXCEPTION );
    }

    /* If the difference between the requested trigger delay and the one
       that can be set is larger than the time resolution warn the user */

    if ( fabs( real_delay - delay ) > lecroy94_tmpl_time_per_point( ) )
        print( WARN, "Trigger delay had to be adjusted from %s to %s.\n",
               lecroy94_tmpl_ptime( delay ),
               lecroy94_tmpl_ptime( real_delay ) );

    /* Finally set the delay */

    if ( FSC2_MODE == EXPERIMENT )
        lecroy94_tmpl_set_trigger_delay( real_delay );

    lecroy94_tmpl.trigger_delay    = real_delay;
    lecroy94_tmpl.is_trigger_delay = SET;

    return vars_push( FLOAT_VAR, real_delay );
}


/*------------------------------------------------------------------------*
 * Function for setting up averaging:
 *  1st argument is one of the function channel doing the averaging,
 *  2nd argument is the source channel
 *  3rd argument is the number of averages to be done
 *------------------------------------------------------------------------*/

Var_T *digitizer_averaging( Var_T * v )
{
    long channel;
    long source_ch;
    long num_avg;


    if ( v == NULL )
    {
        print( FATAL, "Missing arguments.\n" );
        THROW( EXCEPTION );
    }

    /* Get the channel to use for averaging */

    channel = lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                               get_strict_long( v, "channel number" ), UNSET );

    if ( channel != LECROY94_TMPL_FUNC_E && channel != LECROY94_TMPL_FUNC_F )
    {
        print( FATAL, "Averaging can only be done with channels %s and %s.\n",
               LECROY94_TMPL_Channel_Names[ LECROY94_TMPL_FUNC_E ],
               LECROY94_TMPL_Channel_Names[ LECROY94_TMPL_FUNC_F ] );
        THROW( EXCEPTION );
    }

    /* Get the source channel */

    if ( ( v = vars_pop( v ) ) == NULL )
    {
        print( FATAL, "Missing source channel argument.\n" );
        THROW( EXCEPTION );
    }

    /* If we get the string "OFF" it means we're supposed to switch off
       averaging (at least for this channel) */

    if ( v->type == STR_VAR && ! strcasecmp( v->val.sptr, "OFF" ) )
    {
        too_many_arguments( v );
        lecroy94_tmpl.is_avg_setup[ channel ] = UNSET;
        return vars_push( INT_VAR, 0L );
    }

    source_ch = lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                               get_strict_long( v, "channel number" ), UNSET );

    if ( source_ch < LECROY94_TMPL_CH1 || source_ch > LECROY94_TMPL_CH_MAX )
    {
        print( FATAL, "Averaging can only be done on channels %s to %s as "
               "source channels.\n",
               LECROY94_TMPL_Channel_Names[ LECROY94_TMPL_CH1 ],
               LECROY94_TMPL_Channel_Names[ LECROY94_TMPL_CH_MAX ] );
        THROW( EXCEPTION );
    }

    /* Get the number of averages to use - adjust value if necessary to one
       of the possible numbers of averages as given by the array 'na' */

    if ( ( v = vars_pop( v ) ) == NULL )
    {
        print( FATAL, "Missing number of averages.\n" );
        THROW( EXCEPTION );
    }

    num_avg = get_long( v, "number of averages" );

    if ( num_avg <= 0 )
    {
        print( FATAL, "Zero or negative number of averages (%ld).\n",
               num_avg );
        THROW( EXCEPTION );
    }

    if ( num_avg > LECROY94_TMPL_MAX_AVERAGES )
    {
        print( FATAL, "Requested number of averages too large, maximum is "
               "%ld.\n", LECROY94_TMPL_MAX_AVERAGES );
        THROW( EXCEPTION );
    }

    too_many_arguments( v );

    lecroy94_tmpl.is_avg_setup[ channel ] = SET;
    lecroy94_tmpl.source_ch[ channel ]    = source_ch;
    lecroy94_tmpl.num_avg[ channel ]      = num_avg;
    lecroy94_tmpl.rec_len[ channel ]      = lecroy94_tmpl_find_length( );

    return vars_push( INT_VAR, 1L );
}


/*-----------------------------------------------------------------*
 * Function returns the number of averages for a channel (but only
 * if this number has been already set previously)
 *-----------------------------------------------------------------*/

Var_T *digitizer_num_averages( Var_T * v )
{
    long channel;


    if ( v == NULL )
    {
        print( FATAL, "Missing argument.\n" );
        THROW( EXCEPTION );
    }

    if ( v->next != NULL )
    {
        print( FATAL, "Function can only be used for queries.\n" );
        THROW( EXCEPTION );
    }

    channel = lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                               get_strict_long( v, "channel number" ), UNSET );

    if ( channel != LECROY94_TMPL_FUNC_E && channel != LECROY94_TMPL_FUNC_F )
    {
        print( FATAL, "Averaging can only be done using channels %s and %s.\n",
               LECROY94_TMPL_Channel_Names[ LECROY94_TMPL_FUNC_E ],
               LECROY94_TMPL_Channel_Names[ LECROY94_TMPL_FUNC_F ] );
        THROW( EXCEPTION );
    }

    if ( ! lecroy94_tmpl.is_avg_setup[ channel ] )
    {
        print( FATAL, "Number of averages can't be determined "
               "without a previous acqusition setup.\n" );
        THROW( EXCEPTION );
    }
            
    return vars_push( INT_VAR, lecroy94_tmpl.num_avg[ channel ] );
}


/*--------------------------------------------------------------*
 * Function returns the current record length of the digitizer.
 *--------------------------------------------------------------*/

Var_T *digitizer_record_length( Var_T * v )
{

    if ( v != NULL )
    {
        print( FATAL, "Record length can only be queried\n" );
        THROW( EXCEPTION );
    }

    if ( FSC2_MODE == PREPARATION && ! lecroy94_tmpl.is_timebase )
        no_query_possible( );

    return vars_push( INT_VAR, lecroy94_tmpl_curve_length( ) );
}


/*----------------------------------------------------------------------*
 * This is not a function that users should usually call but a function
 * that allows other functions to check if a certain number stands for
 * channel that can be used in measurements. Normally, an exception
 * gets thrown (and an error message gets printed) when the channel
 * number isn't ok. Only when the function gets called with a second
 * argument it returns with either 0 or 1, indicating false or true.
 *----------------------------------------------------------------------*/

Var_T *digitizer_meas_channel_ok( Var_T * v )
{
    long channel;
    bool flag;


    flag = v->next != NULL;

    channel = lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                                get_strict_long( v, "channel number" ), flag );

    if ( channel >= LECROY94_TMPL_CH1 && channel <= LECROY94_TMPL_CH_MAX )
        return vars_push( INT_VAR, 1L );
    else
        return vars_push( INT_VAR, 0L );
}


/*-------------------------------------------------------------------*
 *-------------------------------------------------------------------*/

Var_T *digitizer_copy_curve( Var_T * v )
{
    long src, dest;


    src = lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                        get_strict_long( v, "source channel number" ), UNSET );

    if (    ! ( src >= LECROY94_TMPL_CH1 && src <= LECROY94_TMPL_CH_MAX )
         && src != LECROY94_TMPL_EXP_A  && src != LECROY94_TMPL_EXP_B
         && src != LECROY94_TMPL_MEM_C  && src != LECROY94_TMPL_MEM_D
         && src != LECROY94_TMPL_FUNC_E && src != LECROY94_TMPL_FUNC_E )
    {
        print( FATAL, "Invalid source channel %s.\n",
               LECROY94_TMPL_Channel_Names[ src ] );
        THROW( EXCEPTION );
    }

    v = vars_pop( v );

    dest = lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                   get_strict_long( v, "destination channel number" ), UNSET );

    if ( dest != LECROY94_TMPL_MEM_C && dest != LECROY94_TMPL_MEM_D )
    {
        print( FATAL, "Invalid destination channel %s, must be one of the "
               "memory channels\n", LECROY94_TMPL_Channel_Names[ dest ] );
        THROW( EXCEPTION );
    }

    if ( FSC2_MODE == EXPERIMENT && src != dest )
        lecroy94_tmpl_copy_curve( src, dest );

    return vars_push( INT_VAR, 1L );
}


/*-------------------------------------------------------------------*
 *-------------------------------------------------------------------*/

Var_T *digitizer_start_acquisition( Var_T * v  UNUSED_ARG )
{
    int ch;
    int cnt = 0;


    if ( FSC2_MODE == EXPERIMENT )
    {
        for ( ch = LECROY94_TMPL_CH1; ch <= LECROY94_TMPL_CH_MAX; ch++ )
            if ( lecroy94_tmpl.is_displayed[ ch ] )
                cnt++;

        for ( ch = LECROY94_TMPL_FUNC_E; ch <= LECROY94_TMPL_FUNC_F; ch++ )
            if ( lecroy94_tmpl.is_avg_setup[ ch ] )
                cnt++;

        if ( cnt == 0 )
        {
            print( FATAL, "Can't start acquisition if with neither a "
                   "measurement channnel being switched on nor an "
                   "acquisition being setup.\n" );
            THROW( EXCEPTION );
        }

        lecroy94_tmpl_start_acquisition( );
    }

    return vars_push( INT_VAR, 1L );
}


/*----------------------------------------------------*
 *----------------------------------------------------*/

Var_T *digitizer_get_curve_fast( Var_T * v )
{
    return digitizer_get_curve( v );
}


/*----------------------------------------------------*
 *----------------------------------------------------*/

Var_T *digitizer_get_curve( Var_T * v )
{
    Window_T *w;
    int ch, i;
    double *array = NULL;
    long length;
    Var_T *nv;


    /* The first variable got to be a channel number */

    if ( v == NULL )
    {
        print( FATAL, "Missing arguments.\n" );
        THROW( EXCEPTION );
    }

    ch = ( int ) lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                               get_strict_long( v, "channel number" ), UNSET );

    if (    ! ( ch >= LECROY94_TMPL_CH1 && ch <= LECROY94_TMPL_CH_MAX )
         && ch != LECROY94_TMPL_MEM_C  && ch != LECROY94_TMPL_MEM_C
         && ch != LECROY94_TMPL_FUNC_E && ch != LECROY94_TMPL_FUNC_F )
    {
        print( FATAL, "Can't get a curve from channel %s.\n",
               LECROY94_TMPL_Channel_Names[ ch ] );
        THROW( EXCEPTION );
    }

    if (    ( ch == LECROY94_TMPL_FUNC_E || ch == LECROY94_TMPL_FUNC_F )
         && ! lecroy94_tmpl.is_avg_setup[ ch ] )
    {
        print( FATAL, "Averaging has not been initialized for "
               "channel '%s'.\n", LECROY94_TMPL_Channel_Names[ ch ] );
        THROW( EXCEPTION );
    }

    /* Now check if there's a variable with a window number and check it */

    if ( ( v = vars_pop( v ) ) != NULL )
    {
        long win_num;

        if ( lecroy94_tmpl.w == NULL )
        {
            print( FATAL, "No measurement windows have been defined.\n" );
            THROW( EXCEPTION );
        }

        win_num = get_strict_long( v, "window number" );

        for ( w = lecroy94_tmpl.w; w != NULL && w->num != win_num;
              w = w->next )
            /* empty */ ;

        if ( w == NULL )
        {
            print( FATAL, "Invalid measurement window number.\n" );
            THROW( EXCEPTION );
        }
    }
    else
        w = NULL;

    too_many_arguments( v );

    /* Talk to digitizer only in the real experiment, otherwise return a dummy
       array */

    if ( FSC2_MODE == EXPERIMENT )
    {
        lecroy94_tmpl_get_curve( ch, w, &array, &length );
        nv = vars_push( FLOAT_ARR, array, length );
    }
    else
    {
        if ( w != NULL )
            length = w->num_points;
        else if ( lecroy94_tmpl.rec_len[ ch ] == LECROY94_TMPL_UNDEF_REC_LEN )
            length = LECROY94_TMPL_TEST_REC_LEN;
        else
            length = lecroy94_tmpl.rec_len[ ch ];
        array = DOUBLE_P T_malloc( length * sizeof *array );
        for ( i = 0; i < length; i++ )
            array[ i ] = 1.0e-7 * sin( M_PI * i / 122.0 );
        nv = vars_push( FLOAT_ARR, array, length );
        nv->flags |= IS_DYNAMIC;
    }

    T_free( array );
    return nv;
}


/*----------------------------------------------------*
 *----------------------------------------------------*/

Var_T *digitizer_get_area_fast( Var_T * v )
{
    return digitizer_get_area( v );
}


/*----------------------------------------------------*
 *----------------------------------------------------*/

Var_T *digitizer_get_area( Var_T * v )
{
    Window_T *w;
    int ch, i, j;
    Var_T *cv;
    Var_T *ret = NULL;
    int win_count = 0;


    /* The first variable got to be a channel number */

    if ( v == NULL )
    {
        print( FATAL, "Missing arguments.\n" );
        THROW( EXCEPTION );
    }

    ch = ( int ) lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                               get_strict_long( v, "channel number" ), UNSET );

    if (    ! ( ch >= LECROY94_TMPL_CH1 && ch <= LECROY94_TMPL_CH_MAX )
         && ch != LECROY94_TMPL_MEM_C  && ch != LECROY94_TMPL_MEM_C
         && ch != LECROY94_TMPL_FUNC_E && ch != LECROY94_TMPL_FUNC_F )
    {
        print( FATAL, "Can't get a curve from channel %s.\n",
               LECROY94_TMPL_Channel_Names[ ch ] );
        THROW( EXCEPTION );
    }

    if (    ( ch == LECROY94_TMPL_FUNC_E || ch == LECROY94_TMPL_FUNC_F )
         && ! lecroy94_tmpl.is_avg_setup[ ch ] )
    {
        print( FATAL, "Averaging has not been initialized for "
               "channel '%s'.\n", LECROY94_TMPL_Channel_Names[ ch ] );
        THROW( EXCEPTION );
    }

    /* Now check the variables and count how many window handles we got */

    for ( cv = v = vars_pop( v ); cv != NULL; cv = cv->next )
    {
        vars_check( cv, INT_VAR | INT_ARR );

        if ( cv->type == INT_VAR )
            win_count++;
        else
        {
            if ( cv->len == 0 )
            {
                print( FATAL, "Length of array passed as argument #%d is "
                       "not known.\n", win_count + 1 );
                THROW( EXCEPTION );
            }
            win_count += cv->len;
        }
    }

    /* Complain when we got something that could be a window handle but no
       windows have been defined */

    if ( win_count > 0 && lecroy94_tmpl.w == NULL )
    {
        print( FATAL, "No measurement windows have been defined.\n" );
        THROW( EXCEPTION );
    }

    /* If there's more than one window handle we must return an array */

    if ( win_count > 1 )
        ret = vars_push( FLOAT_ARR, NULL, ( long ) win_count );


    /* When we're still in the test phase we got to return a dummy value */

    if ( FSC2_MODE != EXPERIMENT )
    {
        if ( win_count == 0 )
            return vars_push( FLOAT_VAR, 1.234e-8 );

        for ( i = 0; i < win_count; v = vars_pop( v ) )
        {
            if ( v->type == INT_VAR )
            {
                w = lecroy94_tmpl_get_window_by_number(
                                       get_strict_long( v, "window number" ) );

                if ( win_count == 1 )
                    return vars_push( FLOAT_VAR, 1.234e-8 );

                ret->val.dpnt[ i++ ] = 1.234e-8;
                continue;
            }

            for ( j = 0; j < v->len; j++ )
            {
                w = lecroy94_tmpl_get_window_by_number( v->val.lpnt[ j ] );

                /* Take care of the hopefully rather unlikely situation that
                   we've got an array of length 1 */

                if ( win_count == 1 )
                    return vars_push( FLOAT_VAR, 1.234e-8 );

                ret->val.dpnt[ i++ ] = 1.234e-8;
            }
        }

        return ret;
    }

    /* Now comes the part that gets run in a real experiment. */

    if ( win_count == 0 )
        return vars_push( FLOAT_VAR, lecroy94_tmpl_get_area( ch, NULL ) );

    /* Otherwise loop over the window numbers and fill the array with areas
       for the different windows. */

    for ( i = 0; i < win_count; v = vars_pop( v ) )
    {
        if ( v->type == INT_VAR )
        {
            w = lecroy94_tmpl_get_window_by_number(
                                       get_strict_long( v, "window number" ) );

            if ( win_count == 1 )
                return vars_push( FLOAT_VAR, lecroy94_tmpl_get_area( ch, w ) );

            ret->val.dpnt[ i++ ] = lecroy94_tmpl_get_area( ch, w );

            continue;
        }

        for ( j = 0; j < v->len; j++ )
        {
            w = lecroy94_tmpl_get_window_by_number( v->val.lpnt[ j ] );

            if ( win_count == 1 )
                return vars_push( FLOAT_VAR, lecroy94_tmpl_get_area( ch, w ) );

            ret->val.dpnt[ i++ ] = lecroy94_tmpl_get_area( ch, w );

        }
    }

    return ret;
}


/*----------------------------------------------------*
 *----------------------------------------------------*/

Var_T *digitizer_get_amplitude_fast( Var_T * v )
{
    return digitizer_get_amplitude( v );
}


/*----------------------------------------------------*
 *----------------------------------------------------*/

Var_T *digitizer_get_amplitude( Var_T * v )
{
    Window_T *w;
    int ch, i, j;
    Var_T *cv;
    Var_T *ret = NULL;
    int win_count = 0;


    /* The first variable got to be a channel number */

    if ( v == NULL )
    {
        print( FATAL, "Missing arguments.\n" );
        THROW( EXCEPTION );
    }

    ch = ( int ) lecroy94_tmpl_translate_channel( GENERAL_TO_LECROY94_TMPL,
                               get_strict_long( v, "channel number" ), UNSET );

    if (    ! ( ch >= LECROY94_TMPL_CH1 && ch <= LECROY94_TMPL_CH_MAX )
         && ch != LECROY94_TMPL_MEM_C  && ch != LECROY94_TMPL_MEM_C
         && ch != LECROY94_TMPL_FUNC_E && ch != LECROY94_TMPL_FUNC_F )
    {
        print( FATAL, "Can't get a curve from channel %s.\n",
               LECROY94_TMPL_Channel_Names[ ch ] );
        THROW( EXCEPTION );
    }

    if (    ( ch == LECROY94_TMPL_FUNC_E || ch == LECROY94_TMPL_FUNC_F )
         && ! lecroy94_tmpl.is_avg_setup[ ch ] )
    {
        print( FATAL, "Averaging has not been initialized for "
               "channel '%s'.\n", LECROY94_TMPL_Channel_Names[ ch ] );
        THROW( EXCEPTION );
    }

    /* Now check the variables and count how many window handles we got */

    for ( cv = v = vars_pop( v ); cv != NULL; cv = cv->next )
    {
        vars_check( cv, INT_VAR | INT_ARR );

        if ( cv->type == INT_VAR )
            win_count++;
        else
        {
            if ( cv->len == 0 )
            {
                print( FATAL, "Length of array passed as argument #%d is "
                       "not known.\n", win_count + 1 );
                THROW( EXCEPTION );
            }
            win_count += cv->len;
        }
    }

    /* Complain when we got something that could be a window handle but no
       windows have been defined */

    if ( win_count > 0 && lecroy94_tmpl.w == NULL )
    {
        print( FATAL, "No measurement windows have been defined.\n" );
        THROW( EXCEPTION );
    }

    /* If there's more than one window handle we must return an array */

    if ( win_count > 1 )
        ret = vars_push( FLOAT_ARR, NULL, ( long ) win_count );


    /* When we're still in the test phase we got to return a dummy value */

    if ( FSC2_MODE != EXPERIMENT )
    {
        if ( win_count == 0 )
            return vars_push( FLOAT_VAR, 1.234e-7 );

        for ( i = 0; i < win_count; v = vars_pop( v ) )
        {
            if ( v->type == INT_VAR )
            {
                w = lecroy94_tmpl_get_window_by_number(
                                       get_strict_long( v, "window number" ) );

                if ( win_count == 1 )
                    return vars_push( FLOAT_VAR, 1.234e-7 );

                ret->val.dpnt[ i++ ] = 1.234e-7;
                continue;
            }

            for ( j = 0; j < v->len; j++ )
            {
                w = lecroy94_tmpl_get_window_by_number( v->val.lpnt[ j ] );

                /* Take care of the hopefully rather unlikely situation that
                   we've got an array of length 1 */

                if ( win_count == 1 )
                    return vars_push( FLOAT_VAR, 1.234e-7 );

                ret->val.dpnt[ i++ ] = 1.234e-7;
            }
        }

        return ret;
    }

    /* Now comes the part that gets run in a real experiment. */

    if ( win_count == 0 )
        return vars_push( FLOAT_VAR, lecroy94_tmpl_get_amplitude( ch, NULL ) );

    /* Otherwise loop over the window numbers and fill the array with areas
       for the different windows. */

    for ( i = 0; i < win_count; v = vars_pop( v ) )
    {
        if ( v->type == INT_VAR )
        {
            w = lecroy94_tmpl_get_window_by_number(
                                       get_strict_long( v, "window number" ) );

            if ( win_count == 1 )
                return vars_push( FLOAT_VAR,
                                  lecroy94_tmpl_get_amplitude( ch, w ) );

            ret->val.dpnt[ i++ ] = lecroy94_tmpl_get_amplitude( ch, w );

            continue;
        }

        for ( j = 0; j < v->len; j++ )
        {
            w = lecroy94_tmpl_get_window_by_number( v->val.lpnt[ j ] );

            if ( win_count == 1 )
                return vars_push( FLOAT_VAR,
                                  lecroy94_tmpl_get_amplitude( ch, w ) );

            ret->val.dpnt[ i++ ] = lecroy94_tmpl_get_amplitude( ch, w );

        }
    }

    return ret;
}


/*----------------------------------------------------*
 *----------------------------------------------------*/

Var_T *digitizer_command( Var_T * v )
{
    char *cmd = NULL;


    CLOBBER_PROTECT( cmd );

    vars_check( v, STR_VAR );
    
    if ( FSC2_MODE == EXPERIMENT )
    {
        TRY
        {
            cmd = translate_escape_sequences( T_strdup( v->val.sptr ) );
            lecroy94_tmpl_command( cmd );
            T_free( cmd );
            TRY_SUCCESS;
        }
        OTHERWISE
        {
            T_free( cmd );
            RETHROW( );
        }
    }

    return vars_push( INT_VAR, 1L );
}


/*
 * Local variables:
 * tags-file-name: "../TAGS"
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
