/* -*-C-*-
  $Id$

  Copyright (C) 1999-2002 Jens Thoms Toerring

  This file is part of fsc2.

  Fsc2 is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2, or (at your option)
  any later version.

  Fsc2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with fsc2; see the file COPYING.  If not, write to
  the Free Software Foundation, 59 Temple Place - Suite 330,
  Boston, MA 02111-1307, USA.
*/


#include "fsc2_module.h"


/* Include configuration information for the device */

#include "s_band_magnet_tmpl.conf"

const char device_name[ ]  = DEVICE_NAME;
const char generic_type[ ] = DEVICE_TYPE;


/* Exported functions */

int s_band_magnet_tmpl_init_hook( void );
int s_band_magnet_tmpl_test_hook( void );
int s_band_magnet_tmpl_exp_hook( void );
int s_band_magnet_tmpl_end_of_exp_hook( void );
void s_band_magnet_tmpl_exit_hook( void );

Var *magnet_name( Var *v );
Var *magnet_setup( Var *v );
Var *magnet_fast_init( Var *v );
Var *set_field( Var *v );
Var *get_field( Var *v );
Var *sweep_up( Var *v );
Var *sweep_down( Var *v );
Var *reset_field( Var *v );


/* Locally used functions */

static double s_band_magnet_tmpl_field_check( double field, bool *err_flag );
static int magnet_field_to_DAC( double field );
static double magnet_DAC_to_field( int DAC_value );
static bool magnet_goto_field( double field );
static bool magnet_do( int command );


static struct
{
	double start_field;     /* the start field given by the user */
	double field_step;      /* the field steps to be used */

	double resolution;

	bool is_start_field;    /* flag, set if start field is defined */
	bool is_field_step;     /* flag, set if field step size is defined */

	double field;           /* used internally */
	int DAC_value;
	int DAC_step;

	bool is_opened;
    struct termios *tio;    /* serial port terminal interface structures */
} magnet;

enum {
	   SERIAL_INIT,
	   SERIAL_VOLTAGE,
	   SERIAL_EXIT
};


/*****************************************************************************/
/*                                                                           */
/*                  hook functions                                           */
/*                                                                           */
/*****************************************************************************/


/*----------------------------------------------------------------*/
/* Here we check if also a driver for a field meter is loaded and */
/* test if this driver will be loaded before the magnet driver.   */
/*----------------------------------------------------------------*/

int s_band_magnet_tmpl_init_hook( void )
{
	/* Claim the serial port (throws an exception on errors) */

	fsc2_request_serial_port( SERIAL_PORT, DEVICE_NAME );

	/* Finally initialize some variables */

	magnet.is_start_field = UNSET;
	magnet.is_field_step  = UNSET;
	magnet.is_opened      = UNSET;

	magnet.DAC_value      = 0;
	magnet.DAC_step       = 0;

	magnet.resolution     = (   S_BAND_MAGNET_TMPL_MAX_FIELD
							  - S_BAND_MAGNET_TMPL_MIN_FIELD ) / 4095;

	return 1;
}


/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/

int s_band_magnet_tmpl_test_hook( void )
{
	if ( magnet.is_start_field )
	{
		magnet.field = magnet.start_field;
		magnet.DAC_value = magnet_field_to_DAC( magnet.start_field );
	}

	return 1;
}


/*---------------------------------------------------------------------*/
/* Opens connection to the power supply and calibrates the field sweep */
/*---------------------------------------------------------------------*/

int s_band_magnet_tmpl_exp_hook( void )
{
	/* Try to initialize the magnet power supply controller */

	if ( ! magnet_do( SERIAL_INIT ) )
	{
		print( FATAL, "Can't access the magnet power supply.\n" );
		THROW( EXCEPTION );
	}

	if ( magnet.is_start_field )
		magnet_goto_field( magnet.start_field );
	else
		magnet_goto_field( S_BAND_MAGNET_TMPL_MIN_FIELD );

	magnet.is_opened = SET;

	return 1;
}


/*---------------------------------------------------------------*/
/* Closes the connection to the power supply after an experiment */
/*---------------------------------------------------------------*/

int s_band_magnet_tmpl_end_of_exp_hook( void )
{
	if ( magnet.is_opened )
	{
		magnet_goto_field( S_BAND_MAGNET_TMPL_MIN_FIELD );
		magnet_do( SERIAL_EXIT );
	}

	magnet.is_opened = UNSET;

	return 1;
}


/*--------------------------------------------------------------------*/
/* Just make sure the connection to the power supply is really closed */
/*--------------------------------------------------------------------*/

void s_band_magnet_tmpl_exit_hook( void )
{
	s_band_magnet_tmpl_end_of_exp_hook( );
}


/******************************************************/
/*                                                    */
/*      exported functions, i.e. EDL functions        */
/*                                                    */
/******************************************************/


/*-------------------------------------------------------------------*/
/*-------------------------------------------------------------------*/

Var *magnet_name( Var *v )
{
	v = v;
	return vars_push( STR_VAR, DEVICE_NAME );
}


/*-------------------------------------------------------------------*/
/* Function for registering the start field and the field step size. */
/*-------------------------------------------------------------------*/

Var *magnet_setup( Var *v )
{
	bool err_flag = UNSET;
	double start_field;
	double field_step;
	int step;


	/* Check that both variables are reasonable */

	if ( v == NULL )
	{
		print( FATAL, "Missing arguments.\n" );
		THROW( EXCEPTION );
	}

	start_field = get_double( v, "magnetic field" );

	/* Check the start field value (this will throw an exception if the
	   field isn't in the allowed range) */

	start_field = s_band_magnet_tmpl_field_check( start_field, &err_flag );

	if ( ( v = vars_pop( v ) ) == NULL )
	{
		print( FATAL, "Missing field step size.\n" );
		THROW( EXCEPTION );
	}

	field_step = get_double( v, "field step width" );

	if ( fabs( field_step ) < magnet.resolution )
	{
		print( FATAL, "Field sweep step size (%lf G) too small, minimum is "
			   "%f G.\n", field_step, magnet.resolution );
		THROW( EXCEPTION );
	}

	step = irnd( field_step / magnet.resolution );
	if ( fabs( step * magnet.resolution - field_step ) >
		 0.01 * magnet.resolution )
		print( SEVERE, "Can't use field step of %f G, using %f G instead.\n",
			   field_step, step * magnet.resolution );

	too_many_arguments( v );

	magnet.start_field = start_field;
	magnet.field_step = field_step;
	magnet.DAC_step = step;
	magnet.is_start_field = magnet.is_field_step = SET;

	return vars_push( INT_VAR, 1 );
}


/*-----------------------------------------------------*/
/*-----------------------------------------------------*/

Var *set_field( Var *v )
{
	double field;
	bool err_flag = UNSET;


	if ( v == NULL )
	{
		print( FATAL, "Missing arguments.\n" );
		THROW( EXCEPTION );
	}

	field = get_double( v, "magnetic field" );

	/* Check the new field value and reduce value if necessary */

	field = s_band_magnet_tmpl_field_check( field, &err_flag );

	too_many_arguments( v );

	if ( FSC2_MODE == TEST )
	{
		magnet.DAC_value = magnet_field_to_DAC( field );
		return vars_push( FLOAT_VAR, magnet.field = field );
	}

	if ( ! magnet_goto_field( field ) )
	{
		print( FATAL, "Can't reach requested field of %f G.\n", field );
		THROW( EXCEPTION );
	}

	return vars_push( FLOAT_VAR, magnet.field );
}


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

Var *get_field( Var *v )
{
	v = v;
	return vars_push( FLOAT_VAR, magnet.field );
}


/*-----------------------------------------------------*/
/*-----------------------------------------------------*/

Var *sweep_up( Var *v )
{
	bool err_flag = UNSET;


	v = v;

	if ( ! magnet.is_field_step )
	{
		print( FATAL, "Sweep step size has not been defined.\n" );
		THROW( EXCEPTION );
	}

	/* Check that new field value is still within bounds */

	s_band_magnet_tmpl_field_check( magnet.field + magnet.field_step,
									&err_flag );
	if ( err_flag )
		return vars_push( FLOAT_VAR, magnet.field );

	if ( FSC2_MODE == EXPERIMENT )
		return vars_push( FLOAT_VAR,
					   magnet_goto_field( magnet.field + magnet.field_step ) );

	magnet.field += magnet.field_step;
	magnet.DAC_value = magnet_field_to_DAC( magnet.field );
	return vars_push( FLOAT_VAR, magnet.field );
}


/*-----------------------------------------------------*/
/*-----------------------------------------------------*/

Var *sweep_down( Var *v )
{
	bool err_flag = UNSET;


	v = v;

	if ( ! magnet.is_field_step )
	{
		print( FATAL, "Sweep step size has not been defined.\n" );
		THROW( EXCEPTION );
	}

	/* Check that new field value is still within bounds */

	s_band_magnet_tmpl_field_check( magnet.field - magnet.field_step,
									&err_flag );
	if ( err_flag )
		return vars_push( FLOAT_VAR, magnet.field );

	if ( FSC2_MODE == EXPERIMENT )
		return vars_push( FLOAT_VAR,
					   magnet_goto_field( magnet.field - magnet.field_step ) );

	magnet.field -= magnet.field_step;
	magnet.DAC_value = magnet_field_to_DAC( magnet.field );
	return vars_push( FLOAT_VAR, magnet.field );
}


/*-----------------------------------------------------*/
/*-----------------------------------------------------*/

Var *reset_field( Var *v )
{
	v = v;

	if ( ! magnet.is_start_field )
	{
		print( FATAL, "Start field has not been defined.\n" );
		THROW( EXCEPTION );
	}

	if ( FSC2_MODE != EXPERIMENT )
	{
		magnet.field = magnet.start_field;
		magnet.DAC_value = magnet_field_to_DAC( magnet.field );
		return vars_push( FLOAT_VAR, magnet.field );
	}

	magnet_goto_field( magnet.start_field );
	return vars_push( FLOAT_VAR, magnet.field );
}


/*****************************************************************************/
/*                                                                           */
/*            Internally used functions                                      */
/*                                                                           */
/*****************************************************************************/


static double s_band_magnet_tmpl_field_check( double field, bool *err_flag )
{
	double new_field;
	int DAC_value;


	if ( field < S_BAND_MAGNET_TMPL_MIN_FIELD )
	{
		print( FATAL, "Field (%f G) too low, minimum is %f G.\n",
			   field, S_BAND_MAGNET_TMPL_MIN_FIELD );
		if ( FSC2_MODE == EXPERIMENT )
		{
			*err_flag = SET;
			return S_BAND_MAGNET_TMPL_MIN_FIELD;
		}
		else
			THROW( EXCEPTION );
	}

	if ( field > S_BAND_MAGNET_TMPL_MAX_FIELD )
	{
		print( FATAL, "Field (%f G) too high, maximum is %f G.\n", field,
			   S_BAND_MAGNET_TMPL_MAX_FIELD );
		if ( FSC2_MODE == EXPERIMENT )
		{
			*err_flag = SET;
			return S_BAND_MAGNET_TMPL_MAX_FIELD;
		}
		else
			THROW( EXCEPTION );
	}

	DAC_value = lrnd( ( field - S_BAND_MAGNET_TMPL_MIN_FIELD ) /
					  magnet.resolution );
	if ( fabs( DAC_value * magnet.resolution + S_BAND_MAGNET_TMPL_MIN_FIELD )
		 > 0.01 * magnet.resolution )
	{
		new_field = DAC_value * magnet.resolution +
					S_BAND_MAGNET_TMPL_MIN_FIELD;
		print( SEVERE, "Field of exactly %f G can't be reached, using %f G "
			   "instead.\n", field, new_field );
		field = new_field;
	}

	return field;
}


/*-----------------------------------------------------*/
/*-----------------------------------------------------*/

static int magnet_field_to_DAC( double field )
{
	int DAC_value;

	DAC_value = irnd( ( field - S_BAND_MAGNET_TMPL_MIN_FIELD ) /
					  magnet.resolution );

	if ( DAC_value < 0 || DAC_value > 4095 )
	{
		print( FATAL, "Internal error detected at %s:%d.\n",
			   __FILE__, __LINE__ );
		THROW( EXCEPTION );
	}

	return DAC_value;
}


/*-----------------------------------------------------*/
/*-----------------------------------------------------*/

static double magnet_DAC_to_field( int DAC_value )
{
	if ( DAC_value < 0 || DAC_value > 4095 )
	{
		print( FATAL, "Internal error detected at %s:%d.\n",
			   __FILE__, __LINE__ );
		THROW( EXCEPTION );
	}

	return DAC_value * magnet.resolution + S_BAND_MAGNET_TMPL_MIN_FIELD;
}


/*-----------------------------------------------------*/
/*-----------------------------------------------------*/

static bool magnet_goto_field( double field )
{
	magnet.DAC_value = magnet_field_to_DAC( field );
	magnet_do( SERIAL_VOLTAGE );
	return magnet.field = magnet_DAC_to_field( magnet.DAC_value );
}


#define sign( x ) ( ( ( x ) >= 0.0 ) ? 1.0 : -1.0 )


/* The magnet power supply is controlled by an external voltage (between 0 V
   and 5 V for a field values between 0 G and 6600 G). This voltage is
   created by a 12 bit DAC but, depending on the settings it won't always
   produce the full range but only parts of it, thereby reducing the allowed
   field range but increasing the field resolution.

   Sinve the DAC is a 12-bit converter, thus two bytes have to be sent to the
   interface card. The first byte must have bit 6 set to tell the inter-
   face card that this is the first byte. In bit 0 to 3 of the first byte
   sent the upper 4 bits of the 12-bit data are encoded, while bit 4
   contains the next lower bit (bit 7) of the 12-data word to be sent.
   In the second byte sent to the interface card bit 7 has to be set to
   tell the card that this is the second byte, followed by the remaining
   lower 7 bits of the data. Thus in order to send the 12-bit data

                       xxxx yzzz zzzz

   The 2-byte sequence to be sent to the interface card is (binary)

                  1.   010y xxxx
				  2.   1zzz zzzz
*/



/*---------------------------------------------------------------------------*/
/* This is the most basic routine for controlling the field - there are four */
/* basic commands, i.e. initializing the serial interface, setting a sweep   */
/* voltage, triggering a field sweep and finally resetting the serial inter- */
/* face.                                                                     */
/*---------------------------------------------------------------------------*/

static bool magnet_do( int command )
{
	unsigned char data[ 2 ];


	switch ( command )
	{
		case SERIAL_INIT :               /* open and initialize serial port */
			/* We need exclussive access to the serial port and we also need
			   non-blocking mode to avoid hanging indefinitely if the other
			   side does not react. O_NOCTTY is set because the serial port
			   should not become the controlling terminal, otherwise line
			   noise read as a CTRL-C might kill the program. */

			if ( ( magnet.tio = fsc2_serial_open( SERIAL_PORT, DEVICE_NAME,
						O_WRONLY | O_EXCL | O_NOCTTY | O_NONBLOCK ) ) == NULL )
				return FAIL;

			/* Switch off parity checking (8N1) and use of 2 stop bits and
			   clear character size mask, then set character size mask to CS8,
			   allow flow control and finally set the baud rate */

			magnet.tio->c_cflag &= ~ ( PARENB | CSTOPB | CSIZE );
			magnet.tio->c_cflag |= CS8 | CRTSCTS;
			cfsetispeed( magnet.tio, SERIAL_BAUDRATE );
			cfsetospeed( magnet.tio, SERIAL_BAUDRATE );

			fsc2_tcflush( SERIAL_PORT, TCIFLUSH );
			fsc2_tcsetattr( SERIAL_PORT, TCSANOW, magnet.tio );
			break;

		case SERIAL_VOLTAGE :                 /* send voltage data pattern */
		    data[ 0 ] = ( unsigned char )
				( 0x40 | ( ( magnet.DAC_value >> 8 ) & 0xF ) |
				  ( ( magnet.DAC_value >> 3 ) & 0x10 ) );
			data[ 1 ] = ( unsigned char ) ( 0x80 |
											( magnet.DAC_value & 0x07F ) );
			fsc2_serial_write( SERIAL_PORT, data, 2 );
			break;

		case SERIAL_EXIT :                    /* reset and close serial port */
			fsc2_serial_close( SERIAL_PORT );
			break;

		default :
			print( FATAL, "INTERNAL ERROR detected at %s:%d.\n",
				   __FILE__, __LINE__ );
			THROW( EXCEPTION );
	}

	return OK;
}


/*
 * Local variables:
 * tags-file-name: "../TAGS"
 * End:
 */
