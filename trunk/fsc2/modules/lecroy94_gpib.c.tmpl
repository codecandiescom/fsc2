/* -*-C-*-
 *
 *  $Id$
 * 
 *  Copyright (C) 1999-2006 Jens Thoms Toerring
 * 
 *  This file is part of fsc2.
 * 
 *  Fsc2 is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2, or (at your option)
 *  any later version.
 * 
 *  Fsc2 is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 * 
 *  You should have received a copy of the GNU General Public License
 *  along with fsc2; see the file COPYING.  If not, write to
 *  the Free Software Foundation, 59 Temple Place - Suite 330,
 *  Boston, MA 02111-1307, USA.
 */


#include "lecroy94_tmpl.h"


static unsigned char *lecroy94_tmpl_get_data( long * len );
static unsigned int lecroy94_tmpl_get_inr( void );
static void lecroy94_tmpl_get_prep( int              ch,
									Window_T *       w,
									unsigned char ** data,
									long *           length,
									double *         gain,
									double *         offset,
									const char *     what );
/*
static int lecroy94_tmpl_get_int_value( int          ch,
										const char * name );
*/
static double lecroy94_tmpl_get_float_value( int          ch,
											 const char * name );
static unsigned char *lecroy94_tmpl_get_data( long * len );
static bool lecroy94_tmpl_talk( const char * cmd,
								char *       reply,
								long *       length );
static void lecroy94_tmpl_gpib_failure( void );


static unsigned int can_fetch = 0;
static int trg_channels[ ] = {
#if defined LECROY94_TMPL_CH4_AS_TRG
								LECROY94_TMPL_CH4,
#endif
								LECROY94_TMPL_LIN,
#if defined LECROY94_TMPL_EXT
								LECROY94_TMPL_EXT,
#endif
#if defined LECROY94_TMPL_EXT10
								LECROY94_TMPL_EXT10

#endif
							  };


/*---------------------------------------------------------------*
 * Function called for initialization of device and to determine
 * its state
 *---------------------------------------------------------------*/

bool lecroy94_tmpl_init( const char * name )
{
	char buffer[ 100 ];
	long len = 100;
	int i;


	if ( gpib_init_device( name, &lecroy94_tmpl.device ) == FAILURE )
        return FAIL;

    /* Disable the local button, set digitizer to short form of replies,
	   switch off debugging, transmit data in one block of binary words
	   (2 byte) format with LSB first. Then ask it for the status byte
	   to make sure the device reacts. */

    if ( // gpib_local_lockout( lecroy94_tmpl.device ) == FAILURE  ||
		gpib_write( lecroy94_tmpl.device,
					"CHDR OFF;CHLP OFF;CFMT DEF9,WORD,BIN;CORD LO", 44 )
					                                    == FAILURE ||
		 gpib_write( lecroy94_tmpl.device, "*STB?", 5 ) == FAILURE ||
		 gpib_read( lecroy94_tmpl.device, buffer, &len ) == FAILURE )
	{
		gpib_local( lecroy94_tmpl.device );
        return FAIL;
	}

	TRY
	{
		/* Figure out which traces are displayed (only 4 can be displayed
		   at the same time and we must be able to check for this when
		   th user asks for one more to be displayed) */

		lecroy94_tmpl.num_used_channels = 0;

		for ( i = LECROY94_TMPL_CH1; i < LECROY94_TMPL_CH_MAX; i++ )
		{
			lecroy94_tmpl.is_displayed[ i ] = UNSET;
			if ( lecroy94_tmpl_is_displayed( i ) )
			{
				lecroy94_tmpl.is_displayed[ i ] = SET;
				lecroy94_tmpl.num_used_channels++;
			}
		}

		for ( i = LECROY94_TMPL_EXP_A; i < LECROY94_TMPL_EXP_B; i++ )
		{
			lecroy94_tmpl.is_displayed[ i ] = UNSET;
			if ( lecroy94_tmpl_is_displayed( i ) )
			{
				lecroy94_tmpl.is_displayed[ i ] = SET;
				lecroy94_tmpl.num_used_channels++;
			}
		}

		for ( i = LECROY94_TMPL_MEM_C; i < LECROY94_TMPL_MEM_D; i++ )
		{
			lecroy94_tmpl.is_displayed[ i ] = UNSET;
			if ( lecroy94_tmpl_is_displayed( i ) )
			{
				lecroy94_tmpl.is_displayed[ i ] = SET;
				lecroy94_tmpl.num_used_channels++;
			}
		}

		for ( i = LECROY94_TMPL_FUNC_E; i < LECROY94_TMPL_FUNC_F; i++ )
		{
			lecroy94_tmpl.is_displayed[ i ] = UNSET;
			if ( lecroy94_tmpl_is_displayed( i ) )
			{
				lecroy94_tmpl.is_displayed[ i ] = SET;
				lecroy94_tmpl.num_used_channels++;
			}
		}

		/* Make sure the internal timebase is used */

		if ( gpib_write( lecroy94_tmpl.device, "SCLK INT", 8 ) == FAILURE )
			lecroy94_tmpl_gpib_failure( );

		/* Set or get the time base (including the index in the table of
		   possible time bases) while also taking care of the mode, i.e.
		   RIS or SS */

		if ( lecroy94_tmpl.is_timebase )
			lecroy94_tmpl_set_timebase( lecroy94_tmpl.timebase );
		else
		{
			lecroy94_tmpl.tb_index = -1;

			lecroy94_tmpl.timebase = lecroy94_tmpl_get_timebase( );

			for ( i = 0; i < ( int ) NUM_ELEMS( hres ); i++ )
				if ( fabs( hres[ i ].tdiv - lecroy94_tmpl.timebase ) /
					 lecroy94_tmpl.timebase < 0.1 )
				{
					lecroy94_tmpl.tb_index = i;
					break;
				}

			if ( lecroy94_tmpl.tb_index < 0 )
			{
				print( FATAL, "Can't determine time base correctly.\n" );
				THROW( EXCEPTION );
			}
		}

		/* Switch interleaved mode on if the user asked for it and it can
		   be done, otherwise switch it off */

		if ( lecroy94_tmpl.is_interleaved && lecroy94_tmpl.interleaved &&
			 hres[ lecroy94_tmpl.tb_index ].ris_rl > 0 )
			lecroy94_tmpl_set_interleaved( SET );

		if ( ( lecroy94_tmpl.is_interleaved && ! lecroy94_tmpl.interleaved ) ||
			 hres[ lecroy94_tmpl.tb_index ].ss_rl > 0 )
			lecroy94_tmpl_set_interleaved( UNSET );

		/* Set (if required) the sensitivies, offsets coupling types of
		   all measurement channels */

		for ( i = LECROY94_TMPL_CH1; i < LECROY94_TMPL_CH_MAX; i++ )
		{
			if ( ! lecroy94_tmpl.is_sens[ i ] )
				lecroy94_tmpl.sens[ i ] = lecroy94_tmpl_get_sens( i );

			if ( ! lecroy94_tmpl.is_offset[ i ] )
				lecroy94_tmpl.offset[ i ] = lecroy94_tmpl_get_offset( i );

			/* If only a sensitivity or an offset setting was requested check
			   that it's possible to set it with the offset or sensitivity
			   already set at the device */

			if ( ( ! lecroy94_tmpl.is_sens[ i ] &&
				   lecroy94_tmpl.is_offset[ i ]    ) ||
				 ( lecroy94_tmpl.is_sens[ i ]   &&
				   ! lecroy94_tmpl.is_offset[ i ]  ) )
			{
				size_t j;
				size_t fs_index = 0;

				for ( j = 1; j < NUM_ELEMS( fixed_sens ); j++ )
					if ( lecroy94_tmpl.sens[ i ] < 0.9999 * fixed_sens[ j ] )
					{
						fs_index = j - 1;
						break;
					}

				if ( j == NUM_ELEMS( fixed_sens ) )
					fs_index = j - 1;

				if ( fabs( lecroy94_tmpl.offset[ i ] ) >=
					                         1.0001 * offset_factor[ fs_index ]
					                         * fixed_sens[ fs_index ] )
				{
					if ( ! lecroy94_tmpl.is_sens[ i ] )
						print( FATAL, "Currently set offset too large for the "
							   "requested sensitivity.\n" );
					else
						print( FATAL, "Requested iffset tiio large for the "
							   "currently set sensitivity.\n" );
					THROW( EXCEPTION );
				}
			}

			if ( lecroy94_tmpl.is_sens[ i ] )
				lecroy94_tmpl_set_sens( i, lecroy94_tmpl.sens[ i ] );

			if ( lecroy94_tmpl.is_offset[ i ] )
				lecroy94_tmpl_set_offset( i, lecroy94_tmpl.offset[ i ] );

			if ( lecroy94_tmpl.is_coupling[ i ] )
				lecroy94_tmpl_set_coupling( i, lecroy94_tmpl.coupling[ i ] );
			else
				lecroy94_tmpl.coupling[ i ] = lecroy94_tmpl_get_coupling( i );
		}

		/* Set (if required) the state of the bandwidth limiter */

		if ( lecroy94_tmpl.is_bandwidth_limiter )
			lecroy94_tmpl_set_bandwidth_limiter(
				                             lecroy94_tmpl.bandwidth_limiter );
		else 
			lecroy94_tmpl.bandwidth_limiter =
				                        lecroy94_tmpl_get_bandwidth_limiter( );

		/* Set (if required) the trigger source */

		if ( lecroy94_tmpl.is_trigger_channel )
			lecroy94_tmpl_set_trigger_source( lecroy94_tmpl.trigger_channel );
		else
			lecroy94_tmpl.trigger_channel =
				                           lecroy94_tmpl_get_trigger_source( );

		/* Set (if required) the trigger level, slope and coupling of the
		   trigger channels */

		for ( i = 0; i < ( int ) NUM_ELEMS( trg_channels ); i++ )
		{
			if ( trg_channels[ i ] == LECROY94_TMPL_LIN )
				continue;

			if ( lecroy94_tmpl.is_trigger_level[ trg_channels[ i ] ] )
				lecroy94_tmpl_set_trigger_level( trg_channels[ i ],
							lecroy94_tmpl.trigger_level[ trg_channels[ i ] ] );
			else
				lecroy94_tmpl.trigger_level[ trg_channels[ i ] ] =
					      lecroy94_tmpl_get_trigger_level( trg_channels[ i ] );

			if ( lecroy94_tmpl.is_trigger_slope[ trg_channels[ i ] ] )
				lecroy94_tmpl_set_trigger_slope( trg_channels[ i ],
							lecroy94_tmpl.trigger_slope[ trg_channels[ i ] ] );
			else
				lecroy94_tmpl.trigger_slope[ trg_channels[ i ] ] =
					      lecroy94_tmpl_get_trigger_slope( trg_channels[ i ] );

			if ( lecroy94_tmpl.is_trigger_coupling[ trg_channels[ i ] ] )
				lecroy94_tmpl_set_trigger_coupling( trg_channels[ i ],
						 lecroy94_tmpl.trigger_coupling[ trg_channels[ i ] ] );
			else
				lecroy94_tmpl.trigger_coupling[ trg_channels[ i ] ] =
					   lecroy94_tmpl_get_trigger_coupling( trg_channels[ i ] );
		}

		/* Set (if required) the trigger delay */

		if ( lecroy94_tmpl.is_trigger_delay )
			lecroy94_tmpl_set_trigger_delay( lecroy94_tmpl.trigger_delay );
		else
			lecroy94_tmpl.trigger_delay = lecroy94_tmpl_get_trigger_delay( );

		/* Set the trigger mode - if the user didn't request one and we're
		   in SEQUENCE or WRAP mode switch to normal mode */

		if ( lecroy94_tmpl.is_trigger_mode )
			lecroy94_tmpl_set_trigger_mode( lecroy94_tmpl.trigger_mode );
		else
		{
			int mode = lecroy94_tmpl_get_trigger_mode( );

			if ( mode == LECROY94_TMPL_TRG_MODE_SEQUENCE ||
				 mode == LECROY94_TMPL_TRG_MODE_WRAP )
			{
				lecroy94_tmpl_set_trigger_mode(
					                           LECROY94_TMPL_TRG_MODE_NORMAL );
				lecroy94_tmpl.trigger_mode = LECROY94_TMPL_TRG_MODE_NORMAL;
			}
			else
				lecroy94_tmpl.trigger_mode = mode;
		}

		can_fetch = lecroy94_tmpl_get_inr( );
	}
	OTHERWISE
	{
		gpib_local( lecroy94_tmpl.device );
        return FAIL;
	}
		
	return OK;
}


/*-------------------------------------------------*
 * Function for determing the digitizers time base 
 *-------------------------------------------------*/

double lecroy94_tmpl_get_timebase( void )
{
	char reply[ 30 ];
	long length = 30;


	lecroy94_tmpl_talk( "TDIV?", reply, &length );
	reply[ length - 1 ] = '\0';
	return T_atod( reply );
}


/*-----------------------------------------------*
 * Function for setting the digitizers time base 
 *-----------------------------------------------*/

void lecroy94_tmpl_set_timebase( double timebase )
{
	char cmd[ 40 ] = "TDIV ";


	gcvt( timebase, 8, cmd + strlen( cmd ) );
	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
}


/*------------------------------------------------------------*
 * Function for determining if digitizer is in RIS or SS mode
 *------------------------------------------------------------*/

bool lecroy94_tmpl_get_interleaved( void )
{
	char reply[ 30 ];
	long length = 30;


	lecroy94_tmpl_talk( "ILVD?", reply, &length );
	return reply[ 1 ] == 'N';
}


/*------------------------------------------------*
 * Function for switching between RIS and SS mode
 *------------------------------------------------*/

void lecroy94_tmpl_set_interleaved( bool state )
{
	char cmd[ 30 ] = "ILVD ";

	strcat( cmd, state ? "ON" : "OFF" );
	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
}



/*------------------------------------------------------------------*
 * Function for determining the sensitivity (in V/div) of a channel
 *------------------------------------------------------------------*/

double lecroy94_tmpl_get_sens( int channel )
{
    char cmd[ 20 ];
    char reply[ 30 ];
    long length = 30;


	fsc2_assert( channel >= LECROY94_TMPL_CH1 &&
				 channel <= LECROY94_TMPL_CH_MAX );

	sprintf( cmd, "C%1d:VDIV?", channel + 1 );
	lecroy94_tmpl_talk( cmd, reply, &length );
    reply[ length - 1 ] = '\0';
	return lecroy94_tmpl.sens[ channel ] = T_atod( reply );
}


/*--------------------------------------------------------------*
 * Function for setting the sensitivity (in V/div) of a channel
 *--------------------------------------------------------------*/

void lecroy94_tmpl_set_sens( int    channel,
							 double sens )
{
    char cmd[ 40 ];


	fsc2_assert( channel >= LECROY94_TMPL_CH1 &&
				 channel <= LECROY94_TMPL_CH_MAX );

	sprintf( cmd, "C%1d:VDIV ", channel + 1 );
	gcvt( sens, 8, cmd + strlen( cmd ) );
	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
}


/*-----------------------------------------------------------*
 * Function for determining the offset voltage for a channel
 *-----------------------------------------------------------*/

double lecroy94_tmpl_get_offset( int channel )
{
    char buf[ 30 ];
    long length = 30;


	fsc2_assert( channel >= LECROY94_TMPL_CH1 &&
				 channel <= LECROY94_TMPL_CH_MAX );

	sprintf( buf, "C%1d:OFST?", channel + 1 );
	lecroy94_tmpl_talk( ( const char * ) buf, buf, &length );
    buf[ length - 1 ] = '\0';
	return  T_atod( buf );
}


/*-------------------------------------------------------*
 * Function for setting the offset voltage for a channel
 *-------------------------------------------------------*/

void lecroy94_tmpl_set_offset( int    channel,
							   double offset )
{
    char cmd[ 40 ];


	fsc2_assert( channel >= LECROY94_TMPL_CH1 &&
				 channel <= LECROY94_TMPL_CH_MAX );

	sprintf( cmd, "C%1d:OFST ", channel + 1 );
	gcvt( offset, 8, cmd + strlen( cmd ) );
	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
}


/*----------------------------------------------------------*
 * Function for determining the coupling type for a channel
 *----------------------------------------------------------*/

int lecroy94_tmpl_get_coupling( int channel )
{
	int type = LECROY94_TMPL_INVALID_COUPL;
	char buf[ 100 ];
	long length = 100;


	fsc2_assert( channel >= LECROY94_TMPL_CH1 &&
				 channel <= LECROY94_TMPL_CH_MAX );

	sprintf( buf, "C%1d:CPL?", channel + 1 );
	lecroy94_tmpl_talk( ( const char * ) buf, buf, &length );
    buf[ length - 1 ] = '\0';

	if ( buf[ 0 ] == 'A' )
		type = LECROY94_TMPL_AC_1_MOHM;
	else if ( buf[ 0 ] == 'G' )
		type = LECROY94_TMPL_GND;
	else if ( buf[ 1 ] == '1' )
		type = LECROY94_TMPL_DC_1_MOHM;
	else if ( buf[ 1 ] == '5' )
		type = LECROY94_TMPL_DC_50_OHM;

	fsc2_assert( type != LECROY94_TMPL_INVALID_COUPL );  /* call me paranoid */

	return type;
}


/*------------------------------------------------------*
 * Function for setting the coupling type for a channel
 *------------------------------------------------------*/

void lecroy94_tmpl_set_coupling( int channel,
								 int type )
{
    char cmd[ 30 ];
	char const *cpl[ ] = { "A1M", "D1M", "D50", "GND" };


	fsc2_assert( channel >= LECROY94_TMPL_CH1 &&
				 channel <= LECROY94_TMPL_CH_MAX );
	fsc2_assert( type >= LECROY94_TMPL_AC_1_MOHM &&
				 type <= LECROY94_TMPL_DC_50_OHM );


	sprintf( cmd, "C%1d:CPL %s", channel + 1, cpl[ type ] );
	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
}


/*-------------------------------------------------------------*
 * Function to determine if the bandwidth limiter is on or off
 *-------------------------------------------------------------*/

int lecroy94_tmpl_get_bandwidth_limiter( void )
{
	char buf[ 30 ] = "BWL?";
	long length = 30;

	lecroy94_tmpl_talk( ( const char * ) buf, buf, &length );
	return buf[ 1 ] == 'N';
}


/*----------------------------------------------------*
 * Function to switch the bandwidth limiter on or off
 *----------------------------------------------------*/

void lecroy94_tmpl_set_bandwidth_limiter( bool state )
{
	char cmd[ 30 ] = "BWL ";

	strcat( cmd, state ? "ON" : "OFF" );
	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
}


/*----------------------------------------------------------*
 * Function to dtermine which channel is the trigger source
 *----------------------------------------------------------*/

int lecroy94_tmpl_get_trigger_source( void )
{
	char reply[ 100 ];
	long length = 100;
	int src = LECROY94_TMPL_UNDEF;


	lecroy94_tmpl_talk( "TRSE?", reply, &length );
	reply[ length - 1 ] = '\0';

	if ( strncmp( reply, "STD,SR,", 7 ) ) {
		print( SEVERE, "Non-standard mode trigger, switched to LIN trigger "
			   "mode.\n" );
		lecroy94_tmpl_set_trigger_source( LECROY94_TMPL_LIN );
		return LECROY94_TMPL_LIN;
	}

	if ( reply[ 7 ] == 'C' )
		sscanf( reply + 8, "%d", &src );
	else if ( reply[ 7 ] == 'L' )
		src = LECROY94_TMPL_LIN;
#if defined LECROY94_TMPL_EXT
	else if ( reply[ 7 ] == 'E' )
		src = LECROY94_TMPL_EXT;
#endif

	fsc2_assert( src != LECROY94_TMPL_UNDEF );

	return src;
}


/*-------------------------------------------------*
 * Function to set a channel as the trigger source
 *-------------------------------------------------*/

void lecroy94_tmpl_set_trigger_source( int channel )
{
	char cmd[ 40 ] = "TRSE STD,SR,";


	switch ( channel )
	{
		case LECROY94_TMPL_CH1 :
		case LECROY94_TMPL_CH2 :
#if defined LECROY94_TMPL_CH4_AS_TRG
		case LECROY94_TMPL_CH4 :
#endif
			sprintf( cmd + 11, "C%1d", channel + 1 );
			break;

		case LECROY94_TMPL_LIN :
			strcat( cmd, "LINE" );
			break;

#if defined LECROY94_TMPL_EXT
		case LECROY94_TMPL_EXT :
			strcat( cmd, "EX" );
			break;
#endif
#if defined LECROY94_TMPL_EXT10
		case LECROY94_TMPL_EXT10 :
			strcat( cmd, "EX10" );
			break;
#endif
		default :
			fsc2_assert( 1 == 0 );
	}

	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
}


/*---------------------------------------------------------------------*
 * Function to determine the trigger level of a trigger source channel
 *---------------------------------------------------------------------*/

double lecroy94_tmpl_get_trigger_level( int channel )
{
	char buf[ 30 ];
	long length = 30;


	switch ( channel )
	{
		case LECROY94_TMPL_CH1 :
		case LECROY94_TMPL_CH2 :
#if defined LECROY94_TMPL_CH4_AS_TRG
		case LECROY94_TMPL_CH4 :
#endif
			sprintf( buf, "C%1d:TRLV?", channel + 1 );
			break;

#if defined LECROY94_TMPL_EXT
		case LECROY94_TMPL_EXT :
			strcpy( buf, "EX:TRLV?" );
			break;
#endif
#if defined LECROY94_TMPL_EXT10
		case LECROY94_TMPL_EXT10 :
			strcpy( buf, "EX10:TRLV?" );
			break;
#endif
		default :
			fsc2_assert( 1 == 0 );
	}

	lecroy94_tmpl_talk( ( const char * ) buf, buf, &length );
	buf[ length - 1 ] = '\0';
	return T_atod( buf );
}


/*--------------------------------------------------------------------*
 * Function for setting the trigger level of a trigger source channel
 * (please note: changing the trigger level won't automatically also
 * change the trigger source channel in use)
 *--------------------------------------------------------------------*/

void lecroy94_tmpl_set_trigger_level( int    channel,
									  double level )
{
	char cmd[ 40 ];


	switch ( channel )
	{
		case LECROY94_TMPL_CH1 :
		case  LECROY94_TMPL_CH2 :
#if defined LECROY94_TMPL_CH4_AS_TRG
		case LECROY94_TMPL_CH4 :
#endif
		sprintf( cmd, "C%1d:TRLV ", channel + 1 );
		break;

#if defined LECROY94_TMPL_EXT
		case LECROY94_TMPL_EXT :
			strcpy( cmd, "EX:TRLV " );
			break;
#endif
#if defined LECROY94_TMPL_EXT10
		case LECROY94_TMPL_EXT10 :
			strcpy( cmd, "EX10:TRLV " );
			break;
#endif
		default :
			fsc2_assert( 1 == 0 );
	}

	gcvt( level, 6, cmd + strlen( cmd ) );
	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
}


/*---------------------------------------------------------------------*
 * Function to determine the trigger slope of a trigger source channel
 *---------------------------------------------------------------------*/

double lecroy94_tmpl_get_trigger_slope( int channel )
{
	char buf[ 30 ];
	long length = 30;


	switch ( channel )
	{
		case LECROY94_TMPL_CH1 :
		case LECROY94_TMPL_CH2 :
#if defined LECROY94_TMPL_CH4_AS_TRG
		case LECROY94_TMPL_CH4 :
#endif
		sprintf( buf, "C%1d:TRSL?", channel + 1 );
		break;

#if defined LECROY94_TMPL_EXT
		case LECROY94_TMPL_EXT :
			strcpy( buf, "EX:TRSL?" );
			break;
#endif
#if defined LECROY94_TMPL_EXT10
		case LECROY94_TMPL_EXT10 :
			strcpy( buf, "EX10:TRSL?" );
			break;
#endif
		default :
			fsc2_assert( 1 == 0 );
	}

	lecroy94_tmpl_talk( ( const char *) buf, buf, &length );
	return buf[ 0 ] == 'P';
}


/*--------------------------------------------------------------------*
 * Function for setting the trigger slope of a trigger source channel
 * (please note: changing the trigger level won't automatically also
 * change the trigger source channel in use)
 *--------------------------------------------------------------------*/

void lecroy94_tmpl_set_trigger_slope( int channel,
									  int slope )
{
	char cmd[ 40 ];


	switch ( channel )
	{
		case LECROY94_TMPL_CH1 :
		case LECROY94_TMPL_CH2 :
#if defined LECROY94_TMPL_CH4_AS_TRG
		case LECROY94_TMPL_CH4 :
#endif
			sprintf( cmd, "C%1d:TRSL ", channel + 1 );
			break;
#if defined LECROY94_TMPL_EXT
		case LECROY94_TMPL_EXT :
			strcpy( cmd, "EX:TRSL " );
			break;
#endif
#if defined LECROY94_TMPL_EXT10
		case LECROY94_TMPL_EXT10 :
			strcpy( cmd, "EX10:TRSL " );
			break;
#endif
		default :
			fsc2_assert( 1 == 0 );
	}

	strcat( cmd, slope ? "POS" : "NEG" );
	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
}


/*------------------------------------------------------------------------*
 * Function to determine the trigger coupling of a trigger source channel
 *------------------------------------------------------------------------*/

int lecroy94_tmpl_get_trigger_coupling( int channel )
{
	char buf[ 40 ];
	long length = 40;
	int cpl = -1;


	switch ( channel )
	{
		case LECROY94_TMPL_CH1 :
		case LECROY94_TMPL_CH2 :
#if defined LECROY94_TMPL_CH4_AS_TRG
		case LECROY94_TMPL_CH4 :
#endif
			sprintf( buf, "C%1d:TRCP?", channel + 1 );
			break;

#if defined LECROY94_TMPL_EXT
		case LECROY94_TMPL_EXT :
			strcpy( buf, "EX:TRCP?" );
			break;
#endif
#if defined LECROY94_TMPL_EXT10
		case LECROY94_TMPL_EXT10 :
			strcpy( buf, "EX10:TRCP?" );
			break;
#endif
		default :
			fsc2_assert( 1 == 0 );
	}

	lecroy94_tmpl_talk( ( const char *) buf, buf, &length );

	switch ( buf[ 0 ] )
	{
		case 'A' :
			cpl = LECROY94_TMPL_TRG_CPL_AC;
			break;

		case 'D' :
			cpl = LECROY94_TMPL_TRG_CPL_DC;
			break;

		case 'L' :
			cpl = LECROY94_TMPL_TRG_CPL_LF_REJ;
			break;

		case 'H' :
			cpl = buf[ 2 ] == 'R' ?
				  LECROY94_TMPL_TRG_CPL_HF_REJ : LECROY94_TMPL_TRG_CPL_HF;
			break;

		default :
			lecroy94_tmpl_gpib_failure( );
	}

	return cpl;
}


/*----------------------------------------------------------------*
 * Function for setting the trigger coupling of a trigger source
 * channel (please note: changing the trigger level won't autom-
 * atically also change the trigger source channel in use)
 *----------------------------------------------------------------*/

void lecroy94_tmpl_set_trigger_coupling( int channel,
										 int cpl )
{
	char cmd[ 40 ];
	const char *cpl_str[ ] = { "AC", "DC", "LFREJ", "HFREJ", "HFDIV" };


	switch ( channel )
	{
		case LECROY94_TMPL_CH1 :
		case LECROY94_TMPL_CH2 :
#if defined LECROY94_TMPL_CH4_AS_TRG
		case LECROY94_TMPL_CH4 :
#endif
			sprintf( cmd, "C%1d:TRCP ", channel + 1 );
			break;

#if defined LECROY94_TMPL_EXT
		case LECROY94_TMPL_EXT :
			strcpy( cmd, "EX:TRCP " );
			break;
#endif
#if defined LECROY94_TMPL_EXT10
		case LECROY94_TMPL_EXT10 :
			strcpy( cmd, "EX10:TRCP " );
			break;
#endif
		default :
			fsc2_assert( 1 == 0 );
	}

	strcat( cmd, cpl_str[ cpl ] );

	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
}


/*-----------------------------------------*
 * Function for determing the trigger mode
 *-----------------------------------------*/

int lecroy94_tmpl_get_trigger_mode( void )
{
	char buf[ 40 ];
	long length = 40;
	int mode = -1;


	lecroy94_tmpl_talk( "TRMD?", buf, &length );

	switch ( buf[ 0 ] )
	{
		case 'A' :
			mode = LECROY94_TMPL_TRG_MODE_AUTO;
			break;

		case 'N' :
			mode = LECROY94_TMPL_TRG_MODE_NORMAL;
			break;

		case 'W' :
			mode = LECROY94_TMPL_TRG_MODE_WRAP;
			break;

		case 'S' :
			mode = buf[ 1 ] == 'E' ?
				   LECROY94_TMPL_TRG_MODE_SEQUENCE :
				   LECROY94_TMPL_TRG_MODE_SINGLE;
			break;

		default :
			lecroy94_tmpl_gpib_failure( );
	}

	return mode;
}


/*---------------------------------------*
 * Function for setting the trigger mode
 *---------------------------------------*/

void lecroy94_tmpl_set_trigger_mode( int mode )
{
	char cmd[ 40 ] = "TRMD ";
	const char *mode_str[ ] = { "AUTO", "NORM", "SINGLE", "SEQNCE", "WRAP" };


	fsc2_assert( mode >= LECROY94_TMPL_TRG_MODE_AUTO &&
				 mode <= LECROY94_TMPL_TRG_MODE_WRAP );

	strcat( cmd, mode_str[ mode ] );
	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
}


/*--------------------------------------------*
 * Fucntion for determining the trigger delay
 *--------------------------------------------*/

double lecroy94_tmpl_get_trigger_delay( void )
{
	char reply[ 40 ];
	long length = 40;
	double delay;


	lecroy94_tmpl_talk( "TRDL?", reply, &length );
	reply[ length - 1 ] = '\0';
	delay = T_atod( reply );

	/* Positive delays (i.e. when pre-trigger is on) get returned as
	   a percentage of the full horizontal screen (i.e. 10 times the
	   timebase) while for negative values it's already the delay time */

	if ( delay > 0.0 )
		delay = 0.1 * lecroy94_tmpl.timebase;

	return delay;
}


/*----------------------------------------*
 * Fucntion for setting the trigger delay
 *----------------------------------------*/

void lecroy94_tmpl_set_trigger_delay( double delay )
{
	char cmd[ 40 ] = "TRDL ";


	/* For positive delay (i.e. pre-trigger) the delay must be set as a
	   percentage of the full horizontal screen width (i.e. 10 times the
	   timebase) */

	if ( delay > 0.0 )
		delay = 10.0 * delay / lecroy94_tmpl.timebase;

	gcvt( delay, 8, cmd + strlen( cmd ) );
	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
}


/*----------------------------------------------------------*
 * Function to determine the probe attenuation of a channel
 *----------------------------------------------------------*/

long lecroy94_tmpl_get_probe_attenuation( int ch )
{
	char cmd[ 30 ];
	long length = 30;


	fsc2_assert( ch >= LECROY94_TMPL_CH1 && ch <= LECROY94_TMPL_CH_MAX );

	sprintf( cmd, "C%d:ATTN?", ch );
	lecroy94_tmpl_talk( ( const char * ) cmd, cmd, &length );
	cmd[ length - 1 ] = '\0';
	return T_atol( cmd );
}


/*---------------------------------------------------------*
 * Function for setting the probe attenuation of a channel
 *---------------------------------------------------------*/

void lecroy94_tmpl_set_probe_attenuation( int ch,
										  long att )
{
	char cmd[ 30 ];

	fsc2_assert( ch >= LECROY94_TMPL_CH1 && ch <= LECROY94_TMPL_CH_MAX );
	fsc2_assert( att == 1 || att == 10 || att == 100 ||
				 att == 1000 || att == 10000 );

	sprintf( cmd, "C%d:%ld", ch, att );
	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
}


/*-----------------------------------------------------------*
 * Function to determine if a channel is currently displayed 
 *-----------------------------------------------------------*/

bool lecroy94_tmpl_is_displayed( int ch )
{
	char cmd[ 30 ];
	long length = 30;


	if ( ch >= LECROY94_TMPL_CH1 && ch <= LECROY94_TMPL_CH_MAX )
		sprintf( cmd, "C%d:TRA?", ch - LECROY94_TMPL_CH1 + 1 );
	else if ( ch == LECROY94_TMPL_EXP_A || ch == LECROY94_TMPL_EXP_B )
		sprintf( cmd, "E%c:TRA?", ch == LECROY94_TMPL_EXP_A ? 'A' : 'B' );
	else if ( ch == LECROY94_TMPL_MEM_C || ch == LECROY94_TMPL_MEM_D )
		sprintf( cmd, "M%c:TRA?", ch == LECROY94_TMPL_MEM_C ? 'C' : 'D' );
	else if ( ch == LECROY94_TMPL_FUNC_E || ch == LECROY94_TMPL_FUNC_F )
		sprintf( cmd, "F%c:TRA?", ch == LECROY94_TMPL_FUNC_E ? 'E' : 'F' );

	lecroy94_tmpl_talk( ( const char * ) cmd, cmd, &length );
	return cmd[ 1 ] == 'N';
}


/*-----------------------------------------------------------*
 * Function for switching the display of a channel on or off
 *-----------------------------------------------------------*/

void lecroy94_tmpl_display( int ch,
							int on_off )
{
	char cmd[ 30 ];
		

	if ( ch >= LECROY94_TMPL_CH1 && ch <= LECROY94_TMPL_CH_MAX )
		sprintf( cmd, "C%d:TRA ", ch - LECROY94_TMPL_CH1 + 1 );
	else if ( ch == LECROY94_TMPL_EXP_A || ch == LECROY94_TMPL_EXP_B )
		sprintf( cmd, "E%c:TRA ", ch == LECROY94_TMPL_EXP_A ? 'A' : 'B' );
	else if ( ch == LECROY94_TMPL_MEM_C || ch == LECROY94_TMPL_MEM_D )
		sprintf( cmd, "M%c:TRA ", ch == LECROY94_TMPL_MEM_C ? 'C' : 'D' );
	else if ( ch == LECROY94_TMPL_FUNC_E || ch == LECROY94_TMPL_FUNC_F )
		sprintf( cmd, "F%c:TRA ", ch == LECROY94_TMPL_FUNC_E ? 'E' : 'F' );

	strcat( cmd, on_off ? "ON" : "OFF" );

	if ( on_off &&
		 lecroy94_tmpl.num_used_channels >= LECROY94_TMPL_MAX_USED_CHANNELS )
	{
		print( FATAL, "Can't switch on another trace, there are already as "
			   "many as possible (%d) displayed.\n",
			   LECROY94_TMPL_MAX_USED_CHANNELS );
		THROW( EXCEPTION );
	}

	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );

	if ( on_off )
	{
		lecroy94_tmpl.num_used_channels++;
		lecroy94_tmpl.is_displayed[ ch ] = SET;
	}
	else
	{
		lecroy94_tmpl.num_used_channels--;
		lecroy94_tmpl.is_displayed[ ch ] = UNSET;
	}
}


/*------------------------------------------------------------*
 * Function for bringing the devicd back into the local state
 *------------------------------------------------------------*/

void lecroy94_tmpl_finished( void )
{
	gpib_local( lecroy94_tmpl.device );
}


/*-----------------------------------------------------------------*
 *-----------------------------------------------------------------*/

void lecroy94_tmpl_start_acquisition( void )
{
	int ch;
	char cmd[ 100 ];


	/* Stop the digitizer */

	if ( gpib_write( lecroy94_tmpl.device, "STOP", 4 ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );

	/* Set up the parameter to be used for averaging for the function
	   channels (as far as they have been set by the user) */

	for ( ch = LECROY94_TMPL_FUNC_E; ch <= LECROY94_TMPL_FUNC_F; ch++ )
	{
		if ( ! lecroy94_tmpl.is_avg_setup[ ch ] )
			continue;

		/* It looks as if both the source channel as well as the function
		   channel doing the averaging must be displayed in order to be
		   able to do an acquisition */

		if ( ! lecroy94_tmpl_is_displayed( lecroy94_tmpl.source_ch[ ch ] ) )
			lecroy94_tmpl_display( lecroy94_tmpl.source_ch[ ch ], SET );

		if ( ! lecroy94_tmpl_is_displayed( ch ) )
			lecroy94_tmpl_display( ch, SET );

		snprintf( cmd, 100, "F%c:DEF EQN,'AVGS(C%ld)',MAXPTS,%ld,SWEEPS,%ld",
				  ch == LECROY94_TMPL_FUNC_E ? 'E' : 'F',
				  lecroy94_tmpl.source_ch[ ch ] - LECROY94_TMPL_CH1 + 1,
				  lecroy94_tmpl.rec_len[ ch ],
				  lecroy94_tmpl.num_avg[ ch ] );

		if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) )
			 == FAILURE )
			lecroy94_tmpl_gpib_failure( );
	}

	/* Switch digitizer back on to running state by switching to normal
	   trigger mode and arm it, so that the next trigger starts the
	   acquisition */

	if ( gpib_write( lecroy94_tmpl.device, "TRMD NORM;ARM", 13 ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );

	/* Reset the bits in the word that tells us later that the data in the
	   corresponding channel are ready to be fetched */

	can_fetch &= ~ ( LECROY94_TMPL_INR_FE_DONE |
					 LECROY94_TMPL_INR_FF_DONE |
					 LECROY94_TMPL_INR_SIG_DONE );
}


/*------------------------------------------------------------*
 *------------------------------------------------------------*/

static void lecroy94_tmpl_get_prep( int              ch,
									Window_T *       w,
									unsigned char ** data,
									long *           length,
									double *         gain,
									double *         offset,
									const char *     what )
{
	unsigned int bit_to_test;
	char cmd[ 100 ];
	char ch_str[ 3 ];
	bool is_mem_ch = UNSET;


	CLOBBER_PROTECT( data );
	CLOBBER_PROTECT( bit_to_test );

	/* Figure out which channel is to be used and set a few variables
	   needed later accordingly */

	if ( ch >= LECROY94_TMPL_CH1 && ch <= LECROY94_TMPL_CH_MAX )
	{
		if ( ! lecroy94_tmpl.is_displayed[ ch ] )
		{
			print( FATAL, "Can't fetch %s for channel %s since it isn't "
				   "switched on.\n", what, LECROY94_TMPL_Channel_Names[ ch ] );
			THROW( EXCEPTION );
		}

		bit_to_test = LECROY94_TMPL_INR_SIG_DONE;
		sprintf( ch_str, "C%d", ch - LECROY94_TMPL_CH1 + 1 );
	}
	else if ( ch >= LECROY94_TMPL_MEM_C && ch <= LECROY94_TMPL_MEM_D )
	{
		is_mem_ch = SET;
		strcpy( ch_str, ch == LECROY94_TMPL_MEM_C ? "MC" : "MD" );
	}
	else if ( ch == LECROY94_TMPL_FUNC_E || ch == LECROY94_TMPL_FUNC_F )
	{
		if ( ! lecroy94_tmpl.is_avg_setup[ ch ] )
		{
			print( FATAL, "Averaging has not been initialized for "
				   "channel %s.\n", LECROY94_TMPL_Channel_Names[ ch ] );
			THROW( EXCEPTION );
		}

		bit_to_test = ch == LECROY94_TMPL_FUNC_E ?
			          LECROY94_TMPL_INR_FE_DONE : LECROY94_TMPL_INR_FF_DONE;
		strcpy( ch_str, ch == LECROY94_TMPL_FUNC_E ? "FE" : "FF" );
	}
	else
	{
		fsc2_assert( 1 == 0 );
	}

	/* Set up the number of points to be fetched */

	if ( w != NULL )
		sprintf( cmd, "WFSU SP,0,NP,%ld,FP,%ld,SN,0",
				 w->num_points, w->start_num );
	else
		sprintf( cmd, "WFSU SP,0,NP,0,FP,0,SN,0" );

	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );

	/* When a non-memory curve is to be fetched and the acquisition isn't
	   finished yet poll until the bit that tells that the acquisition for
	   the requested channel is finished has become set */

	if ( ! is_mem_ch &&
		 ! ( can_fetch & bit_to_test ) )
	{
		while ( ! ( ( can_fetch |= lecroy94_tmpl_get_inr( ) ) & bit_to_test ) )
		{
			stop_on_user_request( );
			fsc2_usleep( 20000, UNSET );
		}
	}

	TRY
	{
		/* Ask the device for the data */

		strcpy( cmd, ch_str );
		strcat( cmd, ":WF? DAT1" );
		if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) )
			 == FAILURE )
			lecroy94_tmpl_gpib_failure( );

		/* And fetch 'em and cut back on the number of data - the device
		   seems to send 4 bytes too many, at least when asked for a
		   complete curve */

		*data = NULL;
		*data = lecroy94_tmpl_get_data( length );
		*length /= 2;          /* we got word sized (16 bit) data, LSB first */

		if ( w == NULL && *length > lecroy94_tmpl_curve_length( ) )
			*length = lecroy94_tmpl_curve_length( );

		/* Get the gain factor and offset for the date we just fetched */

		*gain = lecroy94_tmpl_get_float_value( ch, "VERTICAL_GAIN" );
		*offset = lecroy94_tmpl_get_float_value( ch, "VERTICAL_OFFSET" );

		TRY_SUCCESS;
	}
	OTHERWISE
	{
		if ( *data != NULL )
			T_free( *data );
		RETHROW( );
	}
}


/*-----------------------------------------------------------------*
 *-----------------------------------------------------------------*/

void lecroy94_tmpl_get_curve( int        ch,
							  Window_T * w,
							  double **  array,
							  long *     length )
{
	double gain, offset;
	unsigned char *data;
	unsigned char *dp;
	long i;
	int val;


	/* Get the curve from the device */

	lecroy94_tmpl_get_prep( ch, w, &data, length, &gain, &offset, "curve" );

	/* Calculate the voltages from the data, data are two byte (LSB first),
	   two's complement integers, which then need to be scaled by gain and
	   offset. */

	*array = DOUBLE_P T_malloc( *length * sizeof **array );

	for ( i = 0, dp = data; i < *length; dp += 2, i++ )
	{
		val = dp[ 0 ] + 256 * dp[ 1 ];

		if ( val >= 32768 )
			val -= 65536;

		( *array )[ i ] = gain * val - offset;
	}

	T_free( data );
}


/*-----------------------------------------------------------------*
 *-----------------------------------------------------------------*/

double lecroy94_tmpl_get_area( int        ch,
							   Window_T * w )
{
	unsigned char *data;
	unsigned char *dp;
	long i;
	double gain, offset;
	double area = 0.0;
	int val;
	long length;


	/* Get the curve from the device */

	lecroy94_tmpl_get_prep( ch, w, &data, &length, &gain, &offset, "area" );

	/* Calculate the voltages from the data, data are two byte (LSB first),
	   two's complement integers, which then need to be scaled by gain and
	   offset. */

	for ( i = 0, dp = data; i < length; dp += 2, i++ )
	{
		val = dp[ 0 ] + 256 * dp[ 1 ];

		if ( val >= 32768 )
			val -= 65536;

		area += gain * val - offset;
	}

	T_free( data );

	return area;
}


/*-----------------------------------------------------------------*
 *-----------------------------------------------------------------*/

double lecroy94_tmpl_get_amplitude( int        ch,
									Window_T * w )
{
	unsigned char *data = NULL;
	unsigned char *dp;
	long i;
	double gain, offset;
	double min;
	double max;
	double val;
	long length;
	int dat;


	/* Get the curve from the device */

	lecroy94_tmpl_get_prep( ch, w, &data, &length, &gain, &offset,
							"amplitude" );

	/* Calculate the maximum and minimum voltages from the data, data are two
	   byte (LSB first), two's complement integers, which then need to be
	   scaled by gain and offset. */

	min = HUGE_VAL;
	max = - HUGE_VAL;

	for ( i = 0, dp = data; i < length; i++, dp += 2 )
	{
		dat = dp[ 0 ] + 256 * dp[ 1 ];

		if ( dat >= 32768 )
			dat -= 65536;

		val = gain * dat - offset;

		max = d_max( val, max );
		min = d_min( val, min );
	}

	T_free( data );

	/* Return difference between highest and lowest value */

	return max - min;
}


/*----------------------------------------------------------------------*
 *---------------------------------------------------------------------*/

void lecroy94_tmpl_copy_curve( long src,
							   long dest )
{
	char cmd[ 100 ];


	fsc2_assert( ( src >= LECROY94_TMPL_CH1 && src <= LECROY94_TMPL_CH_MAX ) ||
				 src == LECROY94_TMPL_EXP_A  || src == LECROY94_TMPL_EXP_B   ||
				 src == LECROY94_TMPL_MEM_C  || src == LECROY94_TMPL_MEM_D   ||
				 src == LECROY94_TMPL_FUNC_E || src == LECROY94_TMPL_FUNC_E );
	fsc2_assert( dest == LECROY94_TMPL_MEM_C || dest == LECROY94_TMPL_MEM_D );


	if ( ! lecroy94_tmpl.is_displayed[ src ] )
	{
		print( FATAL, "Can't copy channel %s since it isn't switched on.\n",
			   LECROY94_TMPL_Channel_Names[ src ] );
		THROW( EXCEPTION );
	}

	sprintf( cmd, "M%c:STO ", dest == LECROY94_TMPL_MEM_C ? 'C' : 'D' );
	if ( src >= LECROY94_TMPL_CH1 && src <= LECROY94_TMPL_CH_MAX )
		sprintf( cmd + strlen( cmd ), "C%ld", src - LECROY94_TMPL_CH1 + 1 );
	else if ( src == LECROY94_TMPL_EXP_A  || src == LECROY94_TMPL_EXP_B )
		sprintf( cmd + strlen( cmd ), "E%c", 
				 src == LECROY94_TMPL_EXP_A ? 'A' : 'B' );
	else if ( src == LECROY94_TMPL_MEM_C  || src == LECROY94_TMPL_MEM_D )
		sprintf( cmd + strlen( cmd ), "M%c", 
				 src == LECROY94_TMPL_MEM_C ? 'C' : 'D' );
	else
		sprintf( cmd + strlen( cmd ), "F%c", 
				 src == LECROY94_TMPL_FUNC_E ? 'E' : 'F' );
	
	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
}


/*----------------------------------------------------------------------*
 *---------------------------------------------------------------------*/

static unsigned char *lecroy94_tmpl_get_data( long * len )
{
	unsigned char *data;
	char len_str[ 10 ];


	/* First thing we read is "DAT1,#[0-9]" where the number following the
	   hash mark is the number of bytes to be read next */

	*len = 7;
	if ( gpib_read( lecroy94_tmpl.device, len_str, len ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );

	len_str [ *len ] = '\0';
	*len = T_atol( len_str + 6 );

	fsc2_assert( *len > 0 );

	/* Now get the number of bytes to read */

	if ( gpib_read( lecroy94_tmpl.device, len_str, len ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
	
	len_str[ *len ] = '\0';
	*len = T_atol( len_str );

	fsc2_assert( *len > 0 );

	/* Obtain enough memory and then read the real data */

	data = UCHAR_P T_malloc( *len );

	if ( gpib_read( lecroy94_tmpl.device, data, len ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );

	return data;
}


#if 0
/*----------------------------------------------------------------------*
 * Function for obtaining an integer value from the waveform descriptor
 *---------------------------------------------------------------------*/

static int lecroy94_tmpl_get_int_value( int          ch,
										const char * name )
{
	char cmd[ 100 ];
	long length = 100;
	const char *data = cmd;


	if ( ch >= LECROY94_TMPL_CH1 && ch <= LECROY94_TMPL_CH_MAX )
		sprintf( cmd, "C%d:INSP? \"%s\"", ch - LECROY94_TMPL_CH1 + 1, name );
	else if ( ch == LECROY94_TMPL_EXP_A || ch == LECROY94_TMPL_EXP_B )
		sprintf( cmd, "E%c:INSP? \"%s\"",
				 ch == LECROY94_TMPL_EXP_A ? 'A' : 'B', name );
	else if ( ch == LECROY94_TMPL_MEM_C || ch == LECROY94_TMPL_MEM_D )
		sprintf( cmd, "M%c:INSP? \"%s\"",
				 ch == LECROY94_TMPL_MEM_C ? 'C' : 'D', name );
	else if ( ch == LECROY94_TMPL_FUNC_E || ch == LECROY94_TMPL_FUNC_F )
		sprintf( cmd, "F%c:INSP? \"%s\"",
				 ch == LECROY94_TMPL_FUNC_E ? 'E' : 'F', name );

	lecroy94_tmpl_talk( cmd, cmd, &length );

	while ( length == 1 && *cmd == '\n' ) {
		length = 100;
		if ( gpib_read( lecroy94_tmpl.device, cmd, &length ) == FAILURE )
			lecroy94_tmpl_gpib_failure( );
	}		

	cmd[ length - 1 ] = '\0';

	/* The device seems to send a line with just a line feed char first
	   and only then, as a second message, the line with the information
	   we asked for. On this line the number we're interested in can be
	   found after a colon. */

	while ( *data != '\0' && *data != ':' )
		data++;
	if ( *data == '\0' || *++data == '\0' )
		lecroy94_tmpl_gpib_failure( );

	return T_atoi( data );
}
#endif


/*-------------------------------------------------------------------*
 * Function for obtaining a float value from the waveform descriptor
 *-------------------------------------------------------------------*/

static double lecroy94_tmpl_get_float_value( int          ch,
											 const char * name )
{
	char cmd[ 100 ];
	long length = 100;
	const char *data = cmd;


	if ( ch >= LECROY94_TMPL_CH1 && ch <= LECROY94_TMPL_CH_MAX )
		sprintf( cmd, "C%d:INSP? \"%s\"", ch - LECROY94_TMPL_CH1 + 1, name );
	else if ( ch == LECROY94_TMPL_EXP_A || ch == LECROY94_TMPL_EXP_B )
		sprintf( cmd, "E%c:INSP? \"%s\"",
				 ch == LECROY94_TMPL_EXP_A ? 'A' : 'B', name );
	else if ( ch == LECROY94_TMPL_MEM_C || ch == LECROY94_TMPL_MEM_D )
		sprintf( cmd, "M%c:INSP? \"%s\"",
				 ch == LECROY94_TMPL_MEM_C ? 'C' : 'D', name );
	else if ( ch == LECROY94_TMPL_FUNC_E || ch == LECROY94_TMPL_FUNC_F )
		sprintf( cmd, "F%c:INSP? \"%s\"",
				 ch == LECROY94_TMPL_FUNC_E ? 'E' : 'F', name );

	lecroy94_tmpl_talk( cmd, cmd, &length );

	/* The device seems to send a line with just a line feed char first
	   and only then, as a second message, the line with the information
	   we asked for. On this line the number we're interested in can be
	   found after some text and a colon. */

	while ( length == 1 && *cmd == '\n' ) {
		length = 100;
		if ( gpib_read( lecroy94_tmpl.device, cmd, &length ) == FAILURE )
			lecroy94_tmpl_gpib_failure( );
	}		

	cmd[ length - 1 ] = '\0';

	while ( *data != '\0' && *data != ':' )
		data++;
	if ( *data == '\0' || *++data == '\0' )
		lecroy94_tmpl_gpib_failure( );

	return T_atod( data );
}


/*----------------------------------------------*
 * Function for sending a command to the device
 *----------------------------------------------*/

void lecroy94_tmpl_command( const char * cmd )
{
	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
}


/*------------------------------------------------------------------------*
 * Function fetches (thereby reseting!) the INR register from the device.
 * It sets all bits in the INR element of the structure for the device
 * where a bit in the INR is set. Functions making use of the fact that
 * a bit is set must reset it when the action they take invalidate the
 * condition that led to the bit becoming set.
 *-----------------------------------------------------------------------*/

static unsigned int lecroy94_tmpl_get_inr( void )
{
	char reply[ 10 ] = "INR?";
	long length = 10;


	lecroy94_tmpl_talk( "INR?", reply, &length );
	reply[ length - 1 ] = '\0';
	return ( unsigned int ) T_atoi( reply );
}


/*--------------------------------------------------------------*
 *--------------------------------------------------------------*/

static bool lecroy94_tmpl_talk( const char * cmd,
								char *       reply,
								long *       length )
{
	if ( gpib_write( lecroy94_tmpl.device, cmd, strlen( cmd ) ) == FAILURE ||
		 gpib_read( lecroy94_tmpl.device, reply, length ) == FAILURE )
		lecroy94_tmpl_gpib_failure( );
	return OK;
}


/*-------------------------------------------*
 * Function called on communication failures
 *-------------------------------------------*/

static void lecroy94_tmpl_gpib_failure( void )
{
	print( FATAL, "Communication with device failed.\n" );
	THROW( EXCEPTION );
}


/*
 * Local variables:
 * tags-file-name: "../TAGS"
 * End:
 */
