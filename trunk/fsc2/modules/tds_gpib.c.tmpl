/* -*-C-*-
 *  $Id$
 * 
 *  Copyright (C) 1999-2006 Jens Thoms Toerring
 * 
 *  This file is part of fsc2.
 * 
 *  Fsc2 is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2, or (at your option)
 *  any later version.
 * 
 *  Fsc2 is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 * 
 *  You should have received a copy of the GNU General Public License
 *  along with fsc2; see the file COPYING.  If not, write to
 *  the Free Software Foundation, 59 Temple Place - Suite 330,
 *  Boston, MA 02111-1307, USA.
 */


#include "tds_tmpl.h"


static double tds_tmpl_get_area_wo_cursor( int        channel,
										   Window_T * w );
static double tds_tmpl_get_amplitude_wo_cursor( int        channel,
												Window_T * w );
static bool tds_tmpl_talk( const char * cmd,
						   char *       reply,
						   long *       length );

static bool in_init = UNSET;
static bool acquisition_is_running = UNSET;


/*-----------------------------------------------------------------*
 *-----------------------------------------------------------------*/

bool tds_tmpl_init( const char * name )
{
	int ch;
	double cp1, cp2;
	char buffer[ 100 ];
	long len = 100;
	bool lock_state;
	int on_count, needed_count, needed_on_count;


	CLOBBER_PROTECT( lock_state );

#ifndef NO_GATED_MEASUREMENTS
	tds_tmpl.meas_source = -1;
#endif
	if ( gpib_init_device( name, &tds_tmpl.device ) == FAILURE )
        return FAIL;

	in_init = SET;
	lock_state = SET;
	TRY
	{
		/* Store the lock state the user asked for and for the initialization
		   set it to locked. */

		tds_tmpl_command( "LOC ALL\n" );
		lock_state = tds_tmpl.lock_state;
		tds_tmpl.lock_state = SET;

		/* Set digitizer to short form of replies */

		tds_tmpl_command( "*CLS;:VERB OFF;:HEAD OFF\n" );
		tds_tmpl_talk( "*STB?\n", buffer, &len );

		tds_tmpl.is_reacting = SET;

		/* Check if the the time base, record length and trigger position
		   have been set during preparation, if so send them to the device,
		   otherwise fetch them */

		if ( tds_tmpl.is_timebase )
			tds_tmpl_set_timebase( tds_tmpl.timebase );
		else
			tds_tmpl.timebase = tds_tmpl_get_timebase( );

		if ( tds_tmpl.is_rec_len )
			tds_tmpl_set_record_length( tds_tmpl.rec_len );
		else
			tds_tmpl.rec_len = tds_tmpl_get_record_length( );

		if ( tds_tmpl.is_trig_pos )
			tds_tmpl_set_trigger_pos( tds_tmpl.trig_pos );
		else
			tds_tmpl.trig_pos = tds_tmpl_get_trigger_pos( );

		if ( tds_tmpl.is_trigger_channel )
			tds_tmpl_set_trigger_channel( tds_tmpl.trigger_channel );
		else
			tds_tmpl.trigger_channel = tds_tmpl_get_trigger_channel( );

		/* Set format of data transfer (binary, INTEL format) */

		tds_tmpl_command( "DAT:ENC SRI;WID 2\n" );

		/* Set unit for cursor setting commands to seconds and cursor types
		   to VBAR (vertical bars)*/

		tds_tmpl_command( "CURS:FUNC VBA;VBA:UNITS SECO\n" );

		/* Make sure cursor 1 is the left one */

		cp1 = tds_tmpl_get_cursor_position( 1 );
		cp2 = tds_tmpl_get_cursor_position( 2 );

		if ( cp1 > cp2 )
		{
			tds_tmpl_set_cursor( 1, cp2 );
			tds_tmpl_set_cursor( 2, cp1 );
			tds_tmpl.cursor_pos = cp2;
		}
		else
			tds_tmpl.cursor_pos = cp1;

		/* Switch off repetitive acquisition mode */

		tds_tmpl_command( "ACQ:REPE OFF\n" );

		/* If a sensitivity has been set in the PREPARATION section set them
           now */

		for ( ch = TDS_TMPL_CH1; ch < NUM_NORMAL_CHANNELS; ch++ )
			if ( tds_tmpl.is_sens[ ch ] )
				tds_tmpl_set_sens( ch, tds_tmpl.sens[ ch ] );
			else
				tds_tmpl.sens[ ch ] = tds_tmpl_get_sens( ch );

		/* If the number of averages has been set in the PREPARATIONS section
		   send it to the digitizer now */

		if ( tds_tmpl.is_num_avg == SET )
			tds_tmpl_set_num_avg( tds_tmpl.num_avg );
		else
			tds_tmpl.num_avg = tds_tmpl_get_num_avg( );

		/* Count how many live channels (that are the normal channels plus,
		   on devices with two AUX channels, the AUX channels) are switched
		   on, how many are needed and how many of the needed ones are on */

		for ( needed_count = needed_on_count = on_count = 0, ch = 0;
			  ch < NUM_DISPLAYABLE_CHANNELS; ch++ )
		{
			if ( ( tds_tmpl.channel_is_on[ ch ]
				   = tds_tmpl_display_channel_state( ch ) ) )
				on_count++;

			if ( tds_tmpl.channels_in_use[ ch ] )
			{
				needed_count++;

				if ( tds_tmpl.channel_is_on[ ch ] )
					needed_on_count++;
			}
		}

		fsc2_assert( needed_count <= MAX_SIMULTANEOUS_CHANNELS );

		/* If not all needed channels are on, but switching them all on
		   would take more than MAX_SIMULTANEOUS_CHANNELS first switch off
		   channels that aren't needed (beginning with the high numbered
		   channels, i.e. first REF channels, then MATH channels and finally
		   real measurement channels) until all the needed channels can
		   be switched on. */

		if ( needed_count > needed_on_count )
		{
			while ( needed_count - needed_on_count >
					MAX_SIMULTANEOUS_CHANNELS - on_count )
				for ( ch = NUM_NORMAL_CHANNELS - 1; ch >= 0; ch-- )
				{
					if ( ! tds_tmpl.channels_in_use[ ch ] &&
						 tds_tmpl.channel_is_on[ ch ] )
					{
						tds_tmpl_display_channel( ch, UNSET );
						tds_tmpl.channel_is_on[ ch ] = UNSET;
						on_count--;
						break;
					}
				}
		}

		for ( ch = 0; ch < NUM_DISPLAYABLE_CHANNELS; ch++ )
			if ( tds_tmpl.channels_in_use[ ch ] &&
				 ! tds_tmpl.channel_is_on[ ch ] )
				tds_tmpl_display_channel( ch, SET );

		/* Switch to running until run/stop button is pressed and start
           running */

		tds_tmpl_free_running( );

		/* Unlock the keyboard if the user told us so */

		tds_tmpl.lock_state = lock_state;

		if ( ! tds_tmpl.lock_state )
			tds_tmpl_command( "LOC NON\n" );

		TRY_SUCCESS;
	}
	OTHERWISE
	{
		gpib_local( tds_tmpl.device );
		tds_tmpl.lock_state = lock_state;
		in_init = UNSET;
		return FAIL;
	}

	in_init = UNSET;
	return OK;
}


/*---------------------------------*
 * Returns the digitizers timebase
 *---------------------------------*/

double tds_tmpl_get_timebase( void )
{
	char reply[ 30 ];
	long length = 30;


	tds_tmpl_talk( "HOR:MAI:SCA?\n", reply, &length );
	reply[ length - 1 ] = '\0';
	return T_atod( reply );
}


/*------------------------------------*
 * Sets the timebase of the digitizer
 *------------------------------------*/

void tds_tmpl_set_timebase( double timebase )
{
	char cmd[ 40 ];


	sprintf( cmd, "HOR:MAI:SCA %8.3E\n", timebase );
	tds_tmpl_command( cmd );

	tds_tmpl_state_check( 0.0, 0, 0.0 );
}


/*------------------------------------------------------*
 * tds_tmpl_set_record_length() sets the record length.
 *------------------------------------------------------*/

void tds_tmpl_set_record_length( long num_points )
{
    char cmd[ 100 ];


	sprintf( cmd, "HOR:RECO %ld\n", num_points );
	tds_tmpl_command( cmd );

	tds_tmpl_state_check( 0.0, 0, 0.0 );
}


/*-----------------------------------------------------------------*
 * tds_tmpl_get_record_length() returns the current record length.
 *-----------------------------------------------------------------*/

long tds_tmpl_get_record_length( void )
{
    char reply[ 30 ];
    long length = 30;
	char *r = reply;


	tds_tmpl_talk( "HOR:RECO?\n", reply, &length );
    reply[ length - 1 ] = '\0';
	while ( ! isdigit( ( unsigned char ) *r ) && *r++ )
		/* empty */ ;

    return T_atol( r );
}


/*--------------------------------------------------------------*
 * Sets the trigger position, range of paramters is [0,1] where
 * 0 means no pretrigger while 1 indicates maximum pretrigger
 *--------------------------------------------------------------*/

void tds_tmpl_set_trigger_pos( double pos )
{
    char cmd[ 50 ];


	sprintf( cmd, "HOR:TRIG:POS %f\n", 100.0 * pos );
	tds_tmpl_command( cmd );

	tds_tmpl_state_check( 0.0, 0, 0.0 );
}


/*-------------------------------------------------------------------*
 * Returns the current trigger position in the intervall [0,1] where
 * 0 means no pretrigger while 1 indicates maximum pretrigger
 *-------------------------------------------------------------------*/

double tds_tmpl_get_trigger_pos( void )
{
    char reply[ 30 ];
    long length = 30;


	tds_tmpl_talk( "HOR:TRIG:POS?\n", reply, &length );
    reply[ length - 1 ] = '\0';
    return 0.01 * T_atod( reply );
}


/*-----------------------------------------*
 * Function returns the number of averages
 *-----------------------------------------*/

long tds_tmpl_get_num_avg( void )
{
	char reply[ 30 ];
	long length = 30;


	if ( tds_tmpl_get_acq_mode( ) == AVERAGE )
	{
		tds_tmpl_talk( "ACQ:NUMAV?\n", reply, &length );
		reply[ length - 1 ] = '\0';
		return T_atol( reply );
	}
	else                            	/* digitizer is in sample mode */
		return 1;
}


/*--------------------------------------*
 * Function sets the number of averages
 *--------------------------------------*/

void tds_tmpl_set_num_avg( long num_avg )
{
	char cmd[ 30 ];


	/* With number of acquisitions set to zero simply stop the digitizer */

	if ( num_avg == 0 )
		tds_tmpl_command( "ACQ:STATE STOP\n" );

	/* With 1 as the number of acquisitions switch to sample mode, for all
	   others set the number of acquisitions and switch to average mode */

	if ( num_avg == 1 )
		tds_tmpl_command( "ACQ:MOD SAM\n" );
	else
	{
		sprintf( cmd, "ACQ:NUMAV %ld\n", num_avg );
		tds_tmpl_command( cmd );
		tds_tmpl_command( "ACQ:MOD AVE\n" );
	}

	/* Finally restart the digitizer */

	tds_tmpl_command( "ACQ:STATE RUN\n" );
}


/*-------------------------------------------------------------------------*
 * Function returns the data acquisition mode. If the digitizer is neither
 * in average nor in sample mode, it is switched to sample mode.
 *-------------------------------------------------------------------------*/

int tds_tmpl_get_acq_mode( void )
{
	char reply[ 30 ];
	long length = 30;


	tds_tmpl_talk( "ACQ:MOD?\n", reply, &length );

	if ( *reply == 'A' )		/* digitizer is in average mode */
		return AVERAGE;

	if ( *reply != 'S' )		/* if not in sample mode set it */
		tds_tmpl_command( "ACQ:MOD SAM\n" );

	return SAMPLE;
}


/*---------------------------------------------------------------*
 * Returns the position of the first or second cursor, depending
 * on the value of the argument passed to the function (1 or 2 )
 *---------------------------------------------------------------*/

double tds_tmpl_get_cursor_position( int cur_no )
{
	char cmd[ 40 ] = "CURS:VBA:POSITION";
    char reply[ 30 ];
    long length = 30;

	fsc2_assert( cur_no == 1 || cur_no == 2 );

	strcat( cmd, cur_no == 1 ? "1?\n" : "2?\n" );
	tds_tmpl_talk( cmd, reply, &length );
    reply[ length - 1 ] = '\0';
    return T_atod( reply );
}


/*----------------------------------------------*
 * Returns the distance between the two cursors
 *----------------------------------------------*/

double tds_tmpl_get_cursor_distance( void )
{
	return   tds_tmpl_get_cursor_position( 1 )
		   - tds_tmpl_get_cursor_position( 2 );
}


/*---------------------------------------------------------------------*
 * Sets the trigger channel according to the number passed as argument
 *---------------------------------------------------------------------*/

void tds_tmpl_set_trigger_channel( int ch )
{
	char cmd[ 50 ];


#ifdef TDS_TMPL_AUX
	fsc2_assert( ( ch >= TDS_TMPL_CH1 && ch < NUM_NORMAL_CHANNELS ) ||
				 ch == TDS_TMPL_AUX || ch == TDS_TMPL_LIN );
#endif
#ifndef TDS_TMPL_AUX
	fsc2_assert( ( ch >= TDS_TMPL_CH1 && ch < NUM_NORMAL_CHANNELS ) ||
				 ch == TDS_TMPL_LIN );
#endif

	sprintf( cmd, "TRIG:MAI:EDGE:SOU %s\n", TDS_TMPL_Channel_Names[ ch ] );
	tds_tmpl_command( cmd );
}


/*-----------------------------------------------*
 * Returns number of the current trigger channel
 *-----------------------------------------------*/

int tds_tmpl_get_trigger_channel( void )
{
    char reply[ 30 ];
    long length = 30;


	tds_tmpl_talk( "TRIG:MAI:EDGE:SOU?\n", reply, &length );

	/* Possible replies are "CH1", "CH2", "CH3", "CH4", "AUX", or "LIN",
	   depending on the model (some models that only have 2 normal channels
	   but 2 AUX channels return "CH3" and "CH4" for AUX1 and AUX2) */

#ifdef TDS_TMPL_AUX
    if ( ! strncmp( reply, "AUX", 3 ) )
        return TDS_TMPL_AUX;
#endif
#ifdef TDS_TMPL_AUX1
    if ( ! strncmp( reply, "CH3", 3 ) )
        return TDS_TMPL_AUX1;
#endif
#ifdef TDS_TMPL_AUX2
    if ( ! strncmp( reply, "CH4", 3 ) )
        return TDS_TMPL_AUX2;
#endif
    if ( ! strncmp( reply, "LIN", 3 ) )
        return TDS_TMPL_LIN;

	switch ( reply[ 2 ] )
	{
		case '1' :
			return TDS_TMPL_CH1;

		case '2' :
			return TDS_TMPL_CH2;
#ifdef TDS_TMPL_CH3
		case '3' :
			return TDS_TMPL_CH3;
#endif
#ifdef TDS_TMPL_CH4
		case '4' :
			return TDS_TMPL_CH4;
#endif
		default :
			print( FATAL, "Received invalid data from device.\n" );
			THROW( EXCEPTION );
	}
}


/*----------------------------------*
 * Called on communication problems
 *----------------------------------*/

void tds_tmpl_gpib_failure( void )
{
	if ( ! in_init )
		print( FATAL, "Communication with device failed.\n" );
	THROW( EXCEPTION );
}


/*--------------------------------------------------------------------*
 * tds_tmpl_clear_SESR() reads the the standard event status register
 * and thereby clears it - if this isn't done no SRQs are flagged !
 *--------------------------------------------------------------------*/

void tds_tmpl_clear_SESR( void )
{
    char reply[ 30 ];
    long length = 30;


	tds_tmpl_talk( "*ESR?\n", reply, &length );
}


/*--------------------------------------------------------------*
 * Does all the necessary work after an experiment is finished.
 *--------------------------------------------------------------*/

void tds_tmpl_finished( void )
{
	if ( ! tds_tmpl.is_reacting )
		return;

    gpib_write( tds_tmpl.device, "ACQ:STATE STOP\n", 15 );
    tds_tmpl_clear_SESR( );
    gpib_write( tds_tmpl.device,
				"*SRE 0;:ACQ:STOPA RUNST;STATE RUN;:LOC NON\n", 43 );
	gpib_local( tds_tmpl.device );
	tds_tmpl.is_reacting = UNSET;
}


/*--------------------------------------*
 * Positions the first or second cursor
 *--------------------------------------*/

void tds_tmpl_set_cursor( int    cur_num,
						  double pos )
{
    char cmd[ 60 ];


	fsc2_assert( cur_num == 1 || cur_num == 2 );

    /* set cursors to specified positions */

	sprintf( cmd, "CURS:VBA:POSITION%d %11.5E\n", cur_num, pos );
	tds_tmpl_command( cmd );
}


/*--------------------------------------------*
 * Function tests if a channel is switched on
 *--------------------------------------------*/

bool tds_tmpl_display_channel_state( int channel )
{
	char cmd[ 30 ];
    char reply[ 10 ];
    long length = 10;


	fsc2_assert( channel >= TDS_TMPL_CH1 &&
				 channel < NUM_DISPLAYABLE_CHANNELS );

	sprintf( cmd, "SEL:%s?\n", TDS_TMPL_Channel_Names[ channel ] );
	tds_tmpl_talk( cmd, reply, &length );
	return reply[ 0 ] != '0';
}


/*--------------------------------------------------------*
 * Function switches a channel of the digitizer on or off
 *--------------------------------------------------------*/

void tds_tmpl_display_channel( int  channel,
							   bool on_flag )
{
	char cmd[ 30 ];


	fsc2_assert( channel >= TDS_TMPL_CH1 &&
				 channel < NUM_DISPLAYABLE_CHANNELS );

	/* Get the channels sensitivity */

	if ( on_flag && channel >= 0 && channel < NUM_NORMAL_CHANNELS )
	{
		tds_tmpl_get_sens( channel );
		tds_tmpl.is_sens[ channel ] = SET;
	}

    /* If it's not in the state we need switch it on or off */

    if ( tds_tmpl_display_channel_state( channel ) != on_flag )
    {
        sprintf( cmd, "SEL:%s %s\n", TDS_TMPL_Channel_Names[ channel ],
				 on_flag ? "ON" : "OFF" );
		tds_tmpl_command( cmd );
    }
}


/*---------------------------------------------------------------*
 * Returns the sensitivity of the channel passed as the argument
 *---------------------------------------------------------------*/

double tds_tmpl_get_sens( int channel )
{
    char cmd[ 30 ];
    char reply[ 30 ];
    long length = 30;


	fsc2_assert( channel >= TDS_TMPL_CH1 && channel < NUM_NORMAL_CHANNELS );

	sprintf( cmd, "%s:SCA?\n", TDS_TMPL_Channel_Names[ channel ] );
	tds_tmpl_talk( cmd, reply, &length );

    reply[ length - 1 ] = '\0';
	tds_tmpl.sens[ channel ] = T_atod( reply );

	return tds_tmpl.sens[ channel ];
}


/*--------------------------------------------------------*
 * Sets the sensitivity of one of the digitizers channels
 *--------------------------------------------------------*/

void tds_tmpl_set_sens( int    channel,
						double sens )
{
    char cmd[ 40 ];
#ifdef CHECK_SENS_IMPEDANCE
	char reply[ 40 ];
	long length = 40;
#endif


	fsc2_assert( channel >= TDS_TMPL_CH1 && channel < NUM_NORMAL_CHANNELS );

#ifdef CHECK_SENS_IMPEDANCE
	/* Some digitizers allow high sensitivities only for 1 MOhm input
	   impedance, not for 50 Ohm */

	if ( sens > min_sens_50 )
	{
		sprintf( cmd, "CH%1d:IMP?\n", channel );
		tds_tmpl_talk( cmd, reply, &length );

		if ( strncmp( reply, "MEG", 3 ) )
		{
			if ( in_init )
			{
				print( FATAL, "Sensitivity of %f V for channel %s too low "
					   "with input impedance set to  50 Ohm.\n",
					   User_Channel_Names[ channel ], sens );
				THROW( EXCEPTION );
			}

			print( SEVERE, "Sensitivity of %f V for channel %s too low "
				   "with input impedance set to 50 Ohm.\n",
				   User_Channel_Names[ channel ], sens );
			return;
		}
	}
#endif

	sprintf( cmd, "%s:SCA %8.3E\n", TDS_TMPL_Channel_Names[ channel ], sens );
	tds_tmpl_command( cmd );
}


/*-----------------------------------------------------------------*
 *-----------------------------------------------------------------*/

void tds_tmpl_start_acquisition( void )
{
    /* Start an acquisition:
       1. clear the SESR register to allow SRQs
       2. set state to run
	   3. set stop after sequence */


	tds_tmpl_clear_SESR( );
	tds_tmpl_command( "ACQ:STATE RUN;STOPA SEQ\n" );
	acquisition_is_running = SET;
}


/*-----------------------------------------------------------------*
 *-----------------------------------------------------------------*/

double tds_tmpl_get_area( int        channel,
						  Window_T * w,
						  bool       use_cursor )
{
#ifdef NO_GATED_MEASUREMENTS
	/* Some older devices (TDS520) can't do gated measurements at all, so
	   we've got to get the curve 'by hand'. If the user asked to mark the
	   window position using cursors (as would be done with the newer
	   oszilloscopes and gated measurements) set the cursors to the start
	   and end position of the window. */

	if ( use_cursor )
	{
		double window = tds_tmpl.timebase * tds_tmpl.rec_len /
						TDS_TMPL_POINTS_PER_DIV;

		tds_tmpl_set_cursor( 1, w != NULL ?
							 w->start : ( - tds_tmpl.trig_pos * window ) );
		tds_tmpl_set_cursor( 2, w != NULL ?
							 w->start + w->width :
							 ( ( 1.0 - tds_tmpl.trig_pos ) * window ));
	}

	return tds_tmpl_get_area_wo_cursor( channel, w );

#else

	char cmd[ 50 ];
	char reply[ 40 ];
	long length = 40;



	if ( ! use_cursor )
		return tds_tmpl_get_area_wo_cursor( channel, w );

	/* Set measurement type to area */

	tds_tmpl_command( "MEASU:IMM:TYP ARE\n" );

	fsc2_assert( channel >= TDS_TMPL_CH1 &&
				 channel < NUM_DISPLAYABLE_CHANNELS );

	/* Set channel (if the channel is not already set) */

	if ( channel != tds_tmpl.meas_source )
	{
		sprintf( cmd, "MEASU:IMM:SOURCE %s\n",
				 TDS_TMPL_Channel_Names[ channel ] );
		tds_tmpl_command( cmd );
		tds_tmpl.meas_source = channel;
	}

	/* Set the cursors */

	tds_tmpl_set_meas_window( w );

	/* Wait for measurement to finish */

	if ( acquisition_is_running )
		do
		{
			stop_on_user_request( );

			length = 40;
			usleep( 100000 );
			tds_tmpl_talk( "BUSY?\n", reply, &length );
		} while ( reply[ 0 ] == '1' );

	acquisition_is_running = UNSET;

	/* Get the the area */

	length = 40;
	tds_tmpl_talk( "*WAI;:MEASU:IMM:VAL?\n", reply, &length );

	reply[ length - 1 ] = '\0';
	return T_atod( reply );

#endif
}


/*---------------------------------------------------------------------*
 * Measures the area without using the built-in measurement method but
 * by fetching the curve in the window and integrating it 'by hand'.
 *---------------------------------------------------------------------*/

static double tds_tmpl_get_area_wo_cursor( int        channel,
										   Window_T * w )
{
	double *data, area;
	long length, i;
	double pos = 0.0;
	char cmd[ 100 ];
	char buf[ 100 ];
	long len = 100;


	tds_tmpl_get_curve( channel, w, &data, &length, UNSET );

	for ( area = 0.0, i = 0; i < length; i++ )
		area += data[ i ];

	T_free( data );

	/* To be able to get comparable results to the built-in measurement
	   method we have to subtract the position setting */

	if ( channel >= TDS_TMPL_CH1 && channel < NUM_NORMAL_CHANNELS )
	{
		sprintf( cmd, "CH%1d:POS?\n", channel + 1 );
		tds_tmpl_talk( cmd, buf, &len );

		pos = T_atod( buf );
	}

	/* Return the integrated area, multiplied by the the time per point */

	return ( area - length * pos )
		   * tds_tmpl.timebase / TDS_TMPL_POINTS_PER_DIV;
}


/*-----------------------------------------------------------------------*
 * Function for fetching a curve from one of the channels of the device.
 * The first argument is the channel, the second a pointer to a WINDOW
 * structure holding information about which section of the whole curve
 * is to be fetched, 'data' is a pointer to a a double pointer, that on
 * return from the function will point to an allocated memory area with
 * 'length' double data (thus it is the resonsibility of the user of the
 * function to deallocate the memory when it isn't used any more) and
 * 'use_cursors' is a flag that indicates that the section of the curve
 * fetched fromt the device is to be encolsed by two vertical cursors.
 *-----------------------------------------------------------------------*/

void tds_tmpl_get_curve( int        channel,
						 Window_T * w,
						 double **  data,
						 long *     length,
						 bool       use_cursor )
{
	char cmd[ 50 ];
	char reply[ 10 ];
	long len = 10;
	char *buffer;
	char *b;
	long i;
	double sens;
	double scale;
	long len1, len2;


	fsc2_assert( channel >= TDS_TMPL_CH1 &&
				 channel < NUM_DISPLAYABLE_CHANNELS );

#ifdef NO_GATED_MEASUREMENTS
	/* Some older devices (TDS520) can't do gated measurements at all, so
	   we've got to get the curve 'by hand'. If the user asked to mark the
	   window position using cursors (as would be done with the newer
	   oszilloscopes and gated measurements) set the cursors to the start
	   and end position of the window. */

	if ( use_cursor )
	{
		double window = tds_tmpl.timebase * tds_tmpl.rec_len /
						TDS_TMPL_POINTS_PER_DIV;
		tds_tmpl_set_cursor( 1, w != NULL ?
							 w->start : ( - tds_tmpl.trig_pos * window ) );
		tds_tmpl_set_cursor( 2, w != NULL ?
							 w->start + w->width :
							 ( ( 1.0 - tds_tmpl.trig_pos ) * window ));
	}
#endif

	/* Calculate the scale factor for converting the data returned by the
	   digitizer (2-byte integers) into voltage levels */

	if ( channel >= TDS_TMPL_CH1 && channel < NUM_NORMAL_CHANNELS )
	{
		if ( ! tds_tmpl.is_sens[ channel ] || ! tds_tmpl.lock_state )
		{
			sens = tds_tmpl_get_sens( channel );
			tds_tmpl.is_sens[ channel ] = SET;
		}

		sens = tds_tmpl.sens[ channel ];
	}
	else
		sens = 1.0;

	scale = 10.24 * sens / ( double ) 0xFFFF;

	/* Set the data source channel (if it's not already set correctly) */

	if ( channel != tds_tmpl.data_source )
	{
		sprintf( cmd, "DAT:SOU %s\n", TDS_TMPL_Channel_Names[ channel ] );
		tds_tmpl_command( cmd );
		tds_tmpl.data_source = channel;
	}

	/* Set the cursors or set start and end point of interval */

#ifdef NO_GATED_MEASUREMENTS
	sprintf( cmd, "DAT:START %ld;STOP %ld\n",
			 w != NULL ? w->start_num : 1,
			 w != NULL ? w->end_num : tds_tmpl.rec_len );
	tds_tmpl_command( cmd );
#else
	if ( use_cursor )
		tds_tmpl_set_curve_window( w );
	else
	{
		sprintf( cmd, "DAT:START %ld;STOP %ld\n",
				 w != NULL ? w->start_num : 1,
				 w != NULL ? w->end_num : tds_tmpl.rec_len );
		tds_tmpl_command( cmd );
	}
#endif

	/* Wait for measurement to finish using polling (unless the channel is
	   a reference channel) */

	if ( acquisition_is_running && channel < NUM_MEAS_CHANNELS )
	{
		do
		{
			stop_on_user_request( );

			len = 10;
			usleep( 100000 );
			tds_tmpl_talk( "BUSY?\n", reply, &len );
		} while ( reply[ 0 ] == '1' );

		acquisition_is_running = UNSET;
	}

	/* Calculate how long the curve (with header) is going to be and allocate
       enough memory (data are 2-byte integers) */

	*length = w != NULL ? w->end_num - w->start_num + 1 : tds_tmpl.rec_len;
	len = 2 * *length;
	len2 = 1 + lrnd( floor( log10( len ) ) );
	len1 = 1 + lrnd( floor( log10( len2 ) ) );
	len += len1 + len2 + 2;

	*data = DOUBLE_P T_malloc( *length * sizeof **data );
	buffer = CHAR_P T_malloc( len );

	/* Now get all the data bytes... */

	TRY
	{
		tds_tmpl_talk( "CURV?\n", buffer, &len );
		TRY_SUCCESS;
	}
	OTHERWISE
	{
		T_free( buffer );
		T_free( *data );
		RETHROW( );
	}

	/* ....and copy them to the final destination (the data are INTEL format
	   2-byte integers, so the following requires sizeof( short ) == 2 and
	   only works on a machine with INTEL format - there got to be better ways
	   to do this...) Also scale data so that we get the real measured
	   voltage. */

	fsc2_assert( sizeof( short ) == 2 );

	b = buffer + len1 + len2 + 1;

	for ( i = 0; i < *length; i++ )
		*( *data + i ) = scale * ( double ) *( ( short * ) b + i );

	T_free( buffer );
}


/*-----------------------------------------------------------------*
 *-----------------------------------------------------------------*/

double tds_tmpl_get_amplitude( int        channel,
							   Window_T * w,
							   bool       use_cursor )
{
#ifdef NO_GATED_MEASUREMENTS
	/* Some older devices (TDS520) can't do gated measurements at all, so
	   we've got to calculate the area 'by hand'. If the user asked to
	   simulate using cursors (as would be done with the newer oszilloscopes
	   and gated measurements) set the cursors to the start and end position
	   of the window. */

	if ( use_cursor )
	{
		double window = tds_tmpl.timebase * tds_tmpl.rec_len /
						TDS_TMPL_POINTS_PER_DIV;

		tds_tmpl_set_cursor( 1, w != NULL ?
							 w->start : ( - tds_tmpl.trig_pos * window ) );
		tds_tmpl_set_cursor( 2, w != NULL ?
							 w->start + w->width :
							 ( ( 1.0 - tds_tmpl.trig_pos ) * window ));
	}

	return tds_tmpl_get_amplitude_wo_cursor( channel, w );

#else

	char cmd[ 50 ];
	char reply[ 40 ];
	long length = 40;


	if ( ! use_cursor )
		return tds_tmpl_get_amplitude_wo_cursor( channel, w );

	/* Set measurement type to area */

	tds_tmpl_command( "MEASU:IMM:TYP AMP\n" );

	fsc2_assert( channel >= TDS_TMPL_CH1 &&
				 channel < NUM_DISPLAYABLE_CHANNELS );

	/* Set channel (if the channel is not already set) */

	if ( channel != tds_tmpl.meas_source )
	{
		sprintf( cmd, "MEASU:IMM:SOURCE %s\n",
				 TDS_TMPL_Channel_Names[ channel ] );
		tds_tmpl_command( cmd );
		tds_tmpl.meas_source = channel;
	}

	/* Set the cursors */

	tds_tmpl_set_meas_window( w );

	/* Wait for measurement to finish (use polling) */

	if ( acquisition_is_running )
		do
		{
			stop_on_user_request( );

			length = 40;
			usleep( 100000 );
			tds_tmpl_talk( "BUSY?\n", reply, &length );
		} while ( reply[ 0 ] == '1' );

	acquisition_is_running = UNSET;

	/* Get the the amplitude */

	length = 40;
	tds_tmpl_command( "*WAI\n" );
	tds_tmpl_talk( "MEASU:IMM:VAL?\n", reply, &length );

	reply[ length - 1 ] = '\0';
	return T_atod( reply );

#endif
}


/*-------------------------------------------------------------------*
 * Gets the amplitude without the built-in measurement method but by
 * fetching the curve in the window and integrating it 'by hand'.
 *-------------------------------------------------------------------*/

static double tds_tmpl_get_amplitude_wo_cursor( int        channel,
												Window_T * w )
{
	double *data, min, max;
	long length, i;


	tds_tmpl_get_curve( channel, w, &data, &length, UNSET );

	min = HUGE_VAL;
	max = - HUGE_VAL;
	for ( i = 0; i < length; i++ )
	{
		max = d_max( data[ i ], max );
		min = d_min( data[ i ], min );
	}

	T_free( data );

	/* Return the difference between highest and lowest value */

	return max - min;
}


/*----------------------------------------*
 * Sets the digitizer to run continuously
 *----------------------------------------*/

void tds_tmpl_free_running( void )
{
	tds_tmpl_command( "ACQ:STOPA RUNST;STATE RUN\n" );
}


/*--------------------------------------------------------------*
 *--------------------------------------------------------------*/

void tds_tmpl_lock_state( bool lock )
{
	char cmd[ 100 ];
	int channel;


	/* If we switch from unlocked to locked state we need to find out the
	   current timebase, record length, trigger position and sensitivity
	   settings */

	if ( ! tds_tmpl.lock_state && lock )
	{
		tds_tmpl_state_check( 0.0, 0, 0.0 );

		for ( channel = TDS_TMPL_CH1; channel < NUM_NORMAL_CHANNELS;
			  channel++ )
		{
			tds_tmpl_get_sens( channel );
			tds_tmpl.is_sens[ channel ] = SET;
		}
	}

	sprintf( cmd, "LOC %s\n", lock ? "ALL" : "NON" );
	tds_tmpl_command( cmd );
	tds_tmpl.lock_state = lock;
}


/*----------------------------------------------------*
 *----------------------------------------------------*/

void tds_tmpl_copy_curve( int src,
						  int dest )
{
	char cmd[ 100 ] = "SAV:WAVEFORM ";
	long length;
	char reply[ 20 ];


	fsc2_assert( src < NUM_MEAS_CHANNELS );
	fsc2_assert( dest >= TDS_TMPL_REF1 && dest < TDS_TMPL_REF4 );

	/* Wait until a still running acquisition is finished */

	if ( acquisition_is_running )
		do
		{
			stop_on_user_request( );

			length = 40;
			usleep( 100000 );
			tds_tmpl_talk( "BUSY?\n", reply, &length );
		} while ( reply[ 0 ] == '1' );

	acquisition_is_running = UNSET;

	sprintf( cmd, "SAV:WAVEFORM %s,%s\n", TDS_TMPL_Channel_Names[ src ],
			 TDS_TMPL_Channel_Names[ dest ] );
	tds_tmpl_command( cmd );
}


/*-----------------------------------------------------------------*
 * This command is for sending a command to the device. On failure
 * an error message gets printed and an exception is thrown.
 *-----------------------------------------------------------------*/

bool tds_tmpl_command( const char * cmd )
{
	if ( gpib_write( tds_tmpl.device, cmd, strlen( cmd ) ) == FAILURE )
		tds_tmpl_gpib_failure( );
	return OK;
}


/*-------------------------------------------------------------------------*
 * This function is for sending a query to the device and getting back its
 * reply. When writing or reading from the device fails an exception is
 * thrown, otherwise up to *length characters are returned in 'reply'.
 *-------------------------------------------------------------------------*/

static bool tds_tmpl_talk( const char * cmd,
						   char *       reply,
						   long *       length )
{
	if ( gpib_write( tds_tmpl.device, cmd, strlen( cmd ) ) == FAILURE ||
		 gpib_read( tds_tmpl.device, reply, length ) == FAILURE )
		tds_tmpl_gpib_failure( );
	return OK;
}


/* The next functions are useless when the device (i.e. TDS520) can't do
   gated measurements or has no tracking cursors */

#ifndef NO_GATED_MEASUREMENTS
/*-----------------------------------------------------------------*
 *-----------------------------------------------------------------*/

void tds_tmpl_set_track_cursors( bool flag )
{
	char cmd[ 20 ];


	sprintf( cmd, "CURS:MODE %s\n", flag ? "TRAC" : "IND" );
	tds_tmpl_command( cmd );
}


/*----------------------------------------------------*
 *----------------------------------------------------*/

void tds_tmpl_set_gated_meas( bool flag )
{
	char cmd[ 20 ];


	sprintf( cmd, "MEASU:GAT %s\n", flag ? "ON" : "OFF" );
	tds_tmpl_command( cmd );
}


/*----------------------------------------------------*
 *----------------------------------------------------*/

void tds_tmpl_set_snap( bool flag )
{
	char cmd[ 50 ];


	if ( flag )
		tds_tmpl_command( "DAT SNA\n" );
	else
	{
		sprintf( cmd, "DAT:STAR 1;STOP %ld\n", tds_tmpl.rec_len );
		tds_tmpl_command( cmd );
	}
}

#endif


/*
 * Local variables:
 * tags-file-name: "../TAGS"
 * End:
 */
