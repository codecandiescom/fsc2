#!/usr/bin/perl -w    -*- cperl -*-
#
#  $Id$
#
#  Copyright (C) 1999-2002 Jens Thoms Toerring
#
#  This file is part of fsc2.
#
#  Fsc2 is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2, or (at your option)
#  any later version.
#
#  Fsc2 is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with fsc2; see the file COPYING.  If not, write to
#  the Free Software Foundation, 59 Temple Place - Suite 330,
#  Boston, MA 02111-1307, USA.


use strict;
use IO::Socket::INET;
use POSIX;


my $client;            # The Most Important Entity ;-)
my $max_reqs = 16;     # how many simultaneous requests get accepted
my $crlf = "\r\n";     # RFC 2616 requires this as the newline
my $has_pnmtopng;      # does the pnmtopng utility exist?


# Check if we got a port number as the first command line argument...

my $port = 8080;
$port = $ARGV[ 0 ] if defined $ARGV[ 0 ] and $ARGV[ 0 ] =~ /\d+/o and
		$ARGV[ 0 ] >= 1024 and $ARGV[ 0 ] <= 65535;


# The second argument is supposed to be the place where to look for the
# GIF or PNG files with the fsc2 logo

my $auxdir = "../aux/";
$auxdir = $ARGV[ 1 ] if defined $ARGV[ 1 ];


# Un-buffer the (write) connection to fsc2 or it may never react to what
# we're sending its way

$| = 1;


# SIGPIPE signals should only come from a spawned server while it's writing,
# thus indicating that its client died (or got too bored waiting for a reply).
# All we can do then is to close the connection and let the serving process
# die silently (which, in turn, is caught by the following signal handler...)

$SIG{ PIPE } = sub { close $client; exit 0 };


# The main process must expect lots of dead child processes, so it better
# deals with them

$SIG{ CHLD } = sub { 1 until waitpid( -1, WNOHANG ) == -1 };


# Check if the pnmtopng utility is available, otherwise we can't send
# the display and cross section windows of fsc2

my @a = `echo -n "P6 1 1 255\n000" | pnmtopng 2>/dev/null`;
$has_pnmtopng = defined $a[ 0 ];


# Ok, fire up the server - isn't OOP plus helpful modules a nice thing? ;-)

my $server = IO::Socket::INET->new( LocalPort => $port,
									Type      => SOCK_STREAM,
									Reuse     => 1,
									Listen    => $max_reqs )
	or exit 1;


# After we have the server up and running we should also make sure it gets
# shutdown correctly when fsc2 tells us to close shop

my $ppid = $$;
$SIG{ TERM } = sub { shutdown( $server, 2 ) if $$ == $ppid; exit 0; };


# Now wait for the users to hammer on our little server - at least $max_reqs
# requests can get served simultaneously. This requires the child processes
# to look out for locks on STDOUT, i.e. the write-connection to fsc2. To be
# more precise, each single server has to get an lock on STDOUT by calling
# stdout_lock() before writing to it and must release the lock only after
# reading the complete reply from fsc2.

while ( $client = $server->accept( ) ) {
	if ( my $pid = fork ) {         # parent on success
		close $client;
	} elsif ( defined $pid ) {      # child
		serve( );
	} elsif ( $! == EAGAIN ) {      # (hopefully) recoverable fork problem
		sleep 1;
		redo;
	} else {                        # fork failed badly
		exit 1;
	}
}


#########################################################
# This function handles a single new connection from the outside world. It
# must close the connection when done and must never return.

sub serve {

	my $txt;
	my ( $has_png, $has_gif ) = ( 0, 0 );


	# Make the client connection the default I/O channel

	select $client;
	$| = 1;

	# Skip leading blank lines from the client, give up if the client
	# closes the connection

	1 while defined( $txt = <$client> ) and $txt =~ /^\r*$/o;
	exit 0 unless defined $txt;

	# The "server" only handles well-formed GET requests...

	exit illegal_request( $1, $txt )
		unless $txt =~ m|^\s*([^ \t]+)\s+([^ \t]+)\s+HTTP/\d+\.\d+\s*\r*$|io;

	my ( $req, $file ) = ( $1, $2 );
	exit illegal_request( $req, $txt ) unless $req =~ /^GET$/io;

	# Check if client accepts PNG or GIF files and skip the rest of the noise,
	# we're done listening when we get an empty line

	while ( defined( $txt = <$client> ) and $txt !~ /^\r*\n$/o ) {
		$has_png = 1 if $txt =~ m|^\s*Accept:.*\s+image/png[^a-zA-Z0-9]|io;
		$has_gif = 1 if $txt =~ m|^\s*Accept:.*\s*image/gif[^a-zA-Z0-9]|io;
	}

	# Give up if the client bailed out in between...

	exit 0 unless defined $txt;

	# Ok, now it's finally our turn to send something back...

	if ( $file =~ m|^/(index.html*)*$|o ) {
		serve_main( $has_png, $has_gif );
	} elsif ( $file =~ m{^/(fsc2\.(png|gif))$}o ) {
		serve_logo( $1, $2 );
	} elsif ( $file =~ m{^/fsc2_(a|b)\.png$}o ) {
		serve_pics( $1 );
	} else {
		not_found( $file );
	}

	close $client;
	exit 0;
}


#########################################################
# Sends the client the main page, cobbled together according to what fsc2
# tells us about its state.

sub serve_main {

	my ( $has_png, $has_gif ) = @_;

	my @st1 = ( "IDLE", "RUNNING" , "WAITING", "DONE" );
	my @st2 = ( "Idle",
				"Experiment running",
				"<FONT COLOR=#FF0000>Waiting for user input</FONT>",
				"Experiment finished" );
	my $state;
	my $pic;
	my $txt;
	my $date = rfc_1123_date( );
	my @colors = ( "FF0000", "00FF00", "000000", "0000FF" );


	# Ask the parent for its current state - and don't forget to set a lock
	# on STDOUT while doing it or other processes might interfere

	stdout_lock( 1 ) or exit 1;
	print STDOUT 'S';
	1 while defined ( $state = <STDIN> ) and $state =~ /^$/o;
	stdout_lock( 0 );

	return unless defined $state;

	# First send some meta-information for the browser plus the first lines
	# of the page

	print &uq( <<'HTTP' );
:		HTTP/1.0 200 OK
:		Date: $date
:		Server: fsc2/0.1
:		Allow: GET
:		Content-Type: text/html; charset=iso-8859-1
:		Connection: close
:		Expires: $date
:
:		<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
:		<HTML><HEAD>
:		<META content="iso-8859-1" http-equiv="charset">
:		<META name="author" content="fsc2">
:		<META name="robots" content="noindex">
HTTP

	# Send the logo (per default the GIF version because some browser don't
	# seem to deal correctly with transparency in PNG files even when they
	# clain to understand png) and the status information

	if ( $state =~ /^[0-3]$/o ) {
		print "<TITLE>fsc2: $st1[ $state ]</TITLE></HEAD>$crlf";

		print "<P><CENTER><IMG SRC=\"fsc2." . ( $has_gif ? "gif" : "png" ) .
			  "\" ALT=\"fsc2\"></CENTER></P>$crlf" if $has_png or $has_gif;

		print "<P><CENTER><H1>Status:  $st2[ $state ]</H1></CENTER>$crlf" .
			  "<CENTER>(" . strftime( "%a", localtime ) . ", "  .
			  strftime( "%d %b %G %T %Z", localtime ) . ")</CENTER></P>$crlf";
	} else {
		print "<TITLE>fsc2: WEIRD</TITLE></HEAD>$crlf";

		print "<P><CENTER><IMG SRC=\"fsc2." . ( $has_gif ? "gif" : "png" ) .
			  "\"ALT=\"fsc2\"></CENTER></P>$crlf" if $has_png or $has_gif;

		print &uq( <<'HTTP' );
:			<P><CENTER><H1>Status:  Something weird is happening here...
:			</H1></CENTER>
:			<P>Ok, you seem to have found a bug. Please tell nobody ;-)
:			</P>$crlf</BODY></HTML>
HTTP
		return;
	}

	# Now tell the client where to look for the graphics fsc2 currently
	# displays - only PNG format is supported for legal reasons that I
	# am not inclined to try to even understand

	if ( $state =~ /^[1-3]$/o and $has_pnmtopng and $has_png ) {
		stdout_lock( 1 ) or exit 1;
		print STDOUT 'W';
		1 while defined ( $pic = <STDIN> ) and $state =~ /^$/o;
		stdout_lock( 0 );

		return unless defined $state;

		print &uq( <<'HTTP' ) if $pic =~ /^[1-3]$/o;
:			<H2>Display window:</H2>
:			<P><CENTER><IMG SRC="fsc2_a.png"
:			ALT="Display window"></CENTER></P>
HTTP

		print &uq( <<'HTTP' ) if $pic =~ /^3$/o;
:			<H2>Cross section window:</H2>
:			<P><CENTER><IMG SRC="fsc2_b.png"
:			ALT="Cross section window"></CENTER>
HTTP
	}

	# Finally, ask fsc2 for the contents of the error browser and, when we
	# got it (and if there's any content), pass it on to the client after
	# some changes.

	stdout_lock( 1 ) or exit 1;
	print STDOUT 'E';
	while ( <STDIN> ) {
		last if /^$/o;
		chomp;
		s/^@(C)(\d+)@(f)(.*)$/$4/o;
		if ( ! ( defined $2 and defined $colors[ $2 - 1 ] ) ) {
			$txt .= "$_$crlf";
		} else {
			$txt .= "<FONT COLOR=#" . $colors[ $2 - 1 ] .
				    ">$_</FONT>$crlf";
		}
	}
	stdout_lock( 0 );

	print "<H2>Output browser:</H2>$crlf<P><PRE>$txt</PRE></P>$crlf"
		if defined $txt;
	print "</BODY></HTML>$crlf";
}


#########################################################
# Sends the fsc2 logo file to the client if it can be found where we
# expect it (also telling the client via the expiry date that the logo
# won't change anytime in the near future, so it may happily cache it)

sub serve_logo {

	my ( $file, $type ) = @_;
	my $date = rfc_1123_date( );
	my $edate = rfc_1123_date( 'next_year' );
	my $fh;


	open( $fh, $auxdir . $file ) or return not_found( $file );

	print &uq( <<'HTTP' );
:		HTTP/1.0 200 OK
:		Date: $date .
:		Server: fsc2/0.1
:		Allow: GET
:		Accept-Ranges: none
:		Connection: close" .
:		Expires: $edate
:		Content-Type: image/$type
HTTP

	print "Content-Length: " . ( stat( $auxdir . $file ) )[ 7 ] . "$crlf$crlf";

	print <$fh>;
	close $fh;
}


#########################################################
# Sends a graphic to the client. fsc2 has to create it for us as a temporary
# file and then send us the file name. If the window to be shown does not
# exist anymore (or the file can't be created) we get send a '0' character
# instead in which case we have to send the "Not available" picture.

sub serve_pics {
	my $which = shift;
	my $state;
	my $date = rfc_1123_date( );
	my $fh;
	my $file;
	my @data;


	# We need a special SIGPIPE handler here because we must remove the
	# temporary file fsc2 created for us...

	$SIG{ PIPE } = sub {  close $fh if defined $fh;
						  unlink $file if defined $file and $file !~ /na\.png/;
						  close $client;
						  exit 0
					   };

	stdout_lock( 1 ) or exit 1;
	print STDOUT $which;
	1 while defined ( $state = <STDIN> ) and $state =~ /^$/o;
	return stdout_lock( 0 ) unless defined $state;

	# If we get a positive reply from fsc2 (it's sending us a character which
	# is not '0') the next thing it sends is the name of a file with the
	# requested graphic in ppm format, which we then have to convert to png
	# before passing it on to the browser

	if ( $state !~ /^0$/o and $has_pnmtopng ) {
		$file = <STDIN>;
		chomp $file;
		@data = `pnmtopng -compression 9 $file`;
	} elsif ( $state =~ /^0$/o ) {
		$file = $auxdir . "na.png";
		open( $fh, $file ) or return not_found( "fsc2_" . $which . ".png" );
	}
	stdout_lock( 0 );

	print &uq( <<'HTTP' );
:		HTTP/1.0 200 OK
:		Date: $date
:		Server: fsc2/0.1
:		Allow: GET
:		Accept-Ranges: none
:		Connection: close
:		Expires: $date
:		Content-Type: image/png
HTTP

	if ( $state !~ /^0$/o and $has_pnmtopng ) {
		print "Content-Length: " . len( @data ) . "$crlf$crlf";
		print @data;
		unlink $file;
	} else {
		print "Content-Length: " . ( stat( $file ) )[ 7 ] . "$crlf$crlf";
		print <$fh>;
		close $fh;
	}
}


#########################################################
# Deals with requests for pages we don't know about...

sub not_found {
	my $file = shift;
	my $date = rfc_1123_date( );

	print &uq( <<'HTTP' );
:		HTTP/1.0 404 Not Found
:		Date: $date
:		Server: fsc2/0.1
:		Connection: close
:		Content-Type: text/html; charset=iso-8859-1
:
:		<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
:		<HTML><HEAD>
:		<TITLE>404 Not Found</TITLE>
:		</HEAD><BODY>
:		<HR>
:		<H1>Not Found</H1>
:		<P>The requested URL ($file) was not found.</P>
:		<HR>
:		</BODY></HTML>
HTTP
}


#########################################################
# Deals with non-GET requests or even stranger ones...

sub illegal_request {
	my ( $type, $string ) = @_;
	my $date = rfc_1123_date( );


	print &uq( <<'HTTP' );
:		HTTP/1.0 400 Bad Request
:		Date: $date
:		Server: fsc2/0.1
:		Connection: close
:		Content-Type: text/html; charset=iso-8859-1
:
:		<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.0//EN">
:		<HTML><HEAD>
:		<TITLE>400 Bad Request</TITLE>
:		</HEAD><BODY>
:		<HR>
:		<H1>Bad Request</H1>
HTTP

	if ( $type !~ /^GET$/o ) {
		print "<P>This simple server only supports GET requests.</P>$crlf";
	} else {
		$string =~ s/\r*\n$//o;
		print "<P>Malformed request: <SAMP>$string</SAMP>.</P>$crlf";
	}

	print "<HR>$crlf</BODY></HTML>$crlf";
}


#########################################################
# If called without an argument the function returns the current (GMT) date
# in RFC 1123 format, otherwise the date in about one years time (to be used
# as the 'infinite' expiry date according to RFC 2616)

sub rfc_1123_date {
	my @gm_time = gmtime( time( ) + ( @_ == 0 ? 0 : 31557600 ) );

	return strftime( "%a", @gm_time ) . ", "  .
		   strftime( "%d %b %G %T", @gm_time ) . " GMT";
}


#########################################################
# Creates (or releases) an advisory lock on STDOUT. Uses fcntl() instead of
# flock() in a rather cryptic way (about which I am not too happy) because
# flock() does not seem to work for locking STDOUT.

sub stdout_lock {
	return defined fcntl STDOUT, F_SETLKW,
		pack( "sslll", shift( ) ? F_WRLCK : F_UNLCK, SEEK_SET, 0, 0, 0 );
}


#########################################################
# Strips leading colon and tabs from the lines of string passed to it (the
# string may contain newlines) and replaces all newlines by "\r\n" (as RFC
# 2616 requires for strings send to a browser).

sub uq {
	my $s = shift;
	$s =~ s/^:\t*(.*)\n/$1$crlf/gm;
	$s;
}


#########################################################
# Returns the total length (in bytes) of an array

sub len {
	use bytes;

	my $l = 0;
	$l += length for @_;
}
