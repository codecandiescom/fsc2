#!/usr/bin/perl -w
# -*- cperl -*-
#
#  $Id$
#
#  Copyright (C) 1999-2002 Jens Thoms Toerring
#
#  This file is part of fsc2.
#
#  Fsc2 is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2, or (at your option)
#  any later version.
#
#  Fsc2 is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with fsc2; see the file COPYING.  If not, write to
#  the Free Software Foundation, 59 Temple Place - Suite 330,
#  Boston, MA 02111-1307, USA.


use strict;
use IO::Socket::INET;
use POSIX;


my $client;            # The Most Important Entity ;-)
my $max_reqs = 16;     # how many simultaneous requests get accepted
my $crlf = "\r\n";     # RFC 2616 requires this as the newline
my $has_pnmtopng;      # does the pnmtopng utility exist?
my $has_ppmtojpeg;     # does the ppmtojpeg utility exist?
my $version = 0.3;
my $hostname = `hostname -f`;

chomp $hostname;

# Check if we got a port number as the first command line argument...

my $port = 8080;
$port = $ARGV[ 0 ] if defined $ARGV[ 0 ] and $ARGV[ 0 ] =~ /\d+/o
					  and $ARGV[ 0 ] >= 1024 and $ARGV[ 0 ] <= 65535;


# The second argument is supposed to be the place where to look for the
# GIF or PNG files with the fsc2 logo

my $auxdir = "../aux/";
$auxdir = $ARGV[ 1 ] if defined $ARGV[ 1 ];


# Un-buffer the (write) connection to fsc2 (i.e. STDOUT) or it may never
# get to react to what we're sending its way

$| = 1;


# SIGPIPE signals should only come from a spawned server while it's writing,
# thus indicating that its client died (or got too bored waiting for a reply).
# All we can do then is to close the connection and let the serving process
# die silently (which, in turn, is caught by the next signal handler...)

$SIG{ PIPE } = sub { close $client; exit 0 };


# The main process must expect lots of dead child processes, so it better
# deals with them, we don't want heaps of zombies

$SIG{ CHLD } = sub { 1 until waitpid( -1, WNOHANG ) == -1 };


# Check if the pnmtopng and/or ppmtojpg utility is available by trying to
# convert a trivially simple test image, otherwise we can't send the display
# and cross section windows of fsc2

my @a = `echo -n "P6 1 1 255\n000" | pnmtopng 2>/dev/null`;
$has_pnmtopng = defined $a[ 0 ];

@a = `echo -n "P6 1 1 255\n000" | ppmtojpeg 2>/dev/null`;
$has_ppmtojpeg = defined $a[ 0 ];


# Ok, fire up the server - isn't OOP plus a few helpful modules nice? ;-)

my $server = IO::Socket::INET->new( LocalPort => $port,
									Type      => SOCK_STREAM,
									Reuse     => 1,
									Listen    => $max_reqs )
	or exit 1;


# After we have the server up and running we should also make sure it gets
# shutdown correctly when fsc2 tells us to close shop

my $ppid = $$;
$SIG{ TERM } = sub { shutdown( $server, 2 ) if $$ == $ppid; exit 0; };


# Now wait for the users to hammer on our little server - at least $max_reqs
# requests can get served simultaneously. This requires the child processes
# to look out for locks on STDOUT, i.e. the write-connection to fsc2. To be
# more precise, each single server has to get a lock on STDOUT by calling
# stdout_lock() before writing to it and must release the lock only after
# reading the complete reply from fsc2.

while ( $client = $server->accept( ) ) {
  FORK:
	if ( my $pid = fork ) {         # parent on success
		close $client;
	} elsif ( defined $pid ) {      # child
		serve( );
	} elsif ( $! == EAGAIN ) {      # (hopefully) recoverable fork problem
		sleep 1;
		redo FORK;
	} else {                        # fork failed badly
		shutdown( $server, 2 );
		exit 1;
	}
}


#########################################################
# This function handles a single new connection from the outside world. It
# must close the connection when done and must never return.

sub serve {

	my $txt;
	my %f = ( 'png' => 0, 'gif' => 0, 'jpeg' => 0 );
	my $is_host_field = 0;


	# Make the client connection the default I/O channel

	select $client;
	$| = 1;

	# Skip leading blank lines from the client, give up if the client
	# closes the connection

	1 while defined( $txt = <$client> ) and $txt =~ /^\r*$/o;
	exit 0 unless defined $txt;

	# The "server" only handles well-formed GET requests...

	illegal_request( $1, $3, $4 )
		if $txt !~ m|^\s*([^ \t]+)\s+([^ \t]+)\s+HTTP/(\d+)\.(\d+)\s*\r*$|io;

	my ( $req, $file, $maj, $min ) = ( $1, $2, $3, $4 );

	# RFC2616 requires that we accept an absolute URI, i.e. an URI starting
	# with http://machine_name

	$file =~ s|^(http://$hostname)?/||io;

	# Stop on unsupported requests (i.e. everything except GET and HEAD)

	unsupported_request( $req, $maj, $min ) unless $req =~ /^(GET)|(HEAD)$/io;

	# Check if client accepts PNG, GIF or JPEG files and if it sends a
	# Host field, don't care for anything else. The client is done when it
	# sends an empty line

	while ( defined( $txt = <$client> ) and $txt !~ /^\r*$/o ) {
		next unless $txt =~ /^\s*(Accept)|(Host):/io;
		if ( $txt =~ /^\s*Accept:/io ) {
			for ( keys %f ) {
				$f{ $_ } = 1 if $txt =~ m(\s+image/$_[^a-zA-Z0-9])io;
			}
		} else {
			$is_host_field = 1;
		}
	}

	# Give up if the client bailed out in between...

	exit 0 unless defined $txt;

	# Send a not too rude reply if the client didn't send a Host field but
	# claims to be HTTP/1.1 compliant

	missing_host_field( $req, $maj, $min )
		if $maj >= 1 and $min >= 1 and ! $is_host_field;

	# Ok, now it's finally our turn to send something back to the client...

	if ( $file =~ /^(index.html*)*$/io ) {
		serve_main( \%f, $req, $maj, $min );
	} elsif ( $file =~ m{^(fsc2\.(png|gif|jpeg))$}o ) {
		serve_logo( $1, $2, $req, $maj, $min );
	} elsif ( $file =~ m{^fsc2_(a|b)\.(png|jpeg)$}o ) {
		serve_pics( $1, $2, $req, $maj, $min );
	} else {
		not_found( $file, $req, $maj, $min );
	}

	close $client;
	exit;
}


#########################################################
# Sends the client the main page, cobbled together according to what fsc2
# tells us about its state.

sub serve_main {

	my ( $f, $req, $maj, $min ) = @_;
	my @st1 = ( "IDLE", "RUNNING" , "WAITING", "FINISHED" );
	my @st2 = ( "Idle", "Experiment running",
				"<FONT COLOR=#FF0000>Waiting for user input</FONT>",
				"Experiment finished" );
	my @colors = ( "FF0000", "00FF00", "000000", "0000FF" );
	my ( $body, $state, $pic, $txt, $ext, $curve, $logo_file );


	# Ask the parent for its current state - and don't forget to set a lock
	# on STDOUT while doing so or other processes might interfere

	stdout_lock( 1 ) or exit 1;
	print STDOUT 'S';
	1 while defined ( $state = <STDIN> ) and $state =~ /^$/o;
	stdout_lock( 0 );

	return unless defined $state;

	# First send some meta-information for the browser

	print "HTTP/1.1 200 OK$crlf" . def_txt( 0, $maj, $min ) .
		  "Content-Type: text/html; charset=ISO-8859-1$crlf";

	return unless $req =~ /^GET$/io;

	# Start to cobble together the page

	$body = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\">$crlf" .
		    "<HTML>$crlf<HEAD>$crlf" .
		    "<META content=\"iso-8859-1\" http-equiv=\"charset\">$crlf" .
		    "<META name=\"author\" content=\"fsc2\">$crlf" .
		    "<META name=\"robots\" content=\"noindex\">$crlf";

	# Add the logo (per default the GIF version because some browsers don't
	# seem to deal correctly with transparency in PNG files even though they
	# claim to understand PNG) and the status information

	$logo_file = "fsc2." .
		( $f->{ 'gif' } ? "gif" : ( $f->{ 'png' } ? "png" : "jpeg" ) )
			if $f->{ 'gif' } or $f->{ 'png' } or $f->{ 'jpeg' };

	if ( $state =~ /^[0-3]$/o ) {
		$body .= "<TITLE>fsc2: $st1[ $state ]</TITLE></HEAD>$crlf";

		$body .= "<P><CENTER><IMG SRC=\"$logo_file\"" .
			     "ALT=\"fsc2\"></CENTER></P>" if defined $logo_file;

		$body .=  "<P><CENTER><H1>Status:  $st2[ $state ]</H1></CENTER>$crlf" .
			      "<CENTER>(" . strftime( "%a", localtime ) . ", "  .
			      strftime( "%d %b %G %T %Z", localtime ) .
				  ")</CENTER></P>$crlf";
	} else {
		$body .= "<TITLE>fsc2: WEIRD</TITLE></HEAD>$crlf";

		$body .= "<P><CENTER><IMG SRC=\"$logo_file\"" .
			     "ALT=\"fsc2\"></CENTER></P>" if defined $logo_file;

		$body .= "<P><CENTER><H1>Status:  Something weird is " .
			     "happening here...$crlf" .
			     "</H1></CENTER>$crlf" .
			     "<P>Ok, you seem to have found a bug in fsc2. " .
			     "Please tell nobody ;-)$crlf" .
			     "</P>$crlf</BODY></HTML>$crlf";

		print "Content-Length: " . length( $body ) . "$crlf$crlf";
		print $body;
		return;
	}

	# Now add where to look for the graphics fsc2 currently displays - only
	# PNG amd JPEG format is supported (but not GIF, for some stupid legal
	# reasons)

	if ( $f->{ 'png' } and $has_pnmtopng ) {
		$ext = "png";
	} elsif ( $f->{ 'jpeg' } and $has_ppmtojpeg ) {
		$ext = "jpeg";
	}

	if ( $state =~ /^[1-3]$/o and defined $ext ) {
		stdout_lock( 1 ) or exit 1;
		print STDOUT 'W';
		1 while defined ( $pic = <STDIN> ) and $pic =~ /^$/o;
		stdout_lock( 0 );

		unless ( defined $pic ) {
			print "Content-Length: " . length( $body ) . "$crlf$crlf";
			print $body;
			return;
		}

		$body .= "<H2>Display window:</H2>" .
			     "<P><CENTER><IMG SRC=\"fsc2_a.$ext\"" .
			     "ALT=\"Display window\"></CENTER></P>$crlf";

		if ( $pic =~ /^[23]$/ ) {
			stdout_lock( 1 ) or exit 1;
			print STDOUT 'C';
			1 while defined ( $curve = <STDIN> ) and $curve =~ /^$/o;
			stdout_lock( 0 );

			unless ( defined $curve ) {
				print "Content-Length: " . length( $body ) . "$crlf$crlf";
				print $body;
				return;
			}

			$body .= "<P><CENTER>Curve $curve</CENTER></P>$crlf"
				if $curve =~ /^[1-4]$/;
		}

		$body .= "<H2>Cross section window:</H2>" .
			     "<P><CENTER><IMG SRC=\"fsc2_b.$ext\"" .
			     "ALT=\"Cross section window\"></CENTER>$crlf"
					 if $pic =~ /^3$/;
	}

	# Finally, ask fsc2 for the contents of the error browser and, when we
	# got it (and if there's any content), pass it on to the client after
	# some changes.

	stdout_lock( 1 ) or exit 1;
	print STDOUT 'E';
	while ( <STDIN> ) {
		last if /^$/o;
		chomp;
		s/^@(C)(\d+)@(f)(.*)$/$4/o;
		if ( ! ( defined $2 and defined $colors[ $2 - 1 ] ) ) {
			$txt .= "$_$crlf";
		} else {
			$txt .= "<FONT COLOR=#" . $colors[ $2 - 1 ] .
				    ">$_</FONT>$crlf";
		}
	}
	stdout_lock( 0 );

	$body .= "<H2>Output browser:</H2>$crlf<P><PRE>$txt</PRE></P>$crlf"
		if defined $txt;
	$body .= "<HR><ADDRESS>fsc2 HTTP server v$version at $hostname Port " .
			 "$port</ADDRESS>$crlf</BODY></HTML>$crlf";

	print "Content-Length: " . length( $body ) . "$crlf$crlf";
	print $body;
}


#########################################################
# Sends the fsc2 logo file to the client if it can be found where we
# expect it (also telling the client via the expiry date that the logo
# won't change anytime in the near future, so it may happily cache it)

sub serve_logo {

	my ( $file, $ext, $req, $maj, $min ) = @_;
	my $fh;


	open( $fh, "$auxdir/$file" ) or
		return not_found( $file, $req );

	print "HTTP/1.1 200 OK$crlf" . def_txt( 1, $maj, $min ) .
		  "Accept-Ranges: none$crlf" .
		  "Content-Type: image/$ext$crlf" .
		  "Content-Length: " . ( -s "$auxdir/$file" ) . "$crlf$crlf";
	print <$fh> unless $req =~ /^HEAD$/io;

	close $fh;
}


#########################################################
# Sends a graphic to the client. fsc2 has to create it for us as a temporary
# file (in ppm format) and then will send us the file name. We still have to
# convert it into a format the browser understands and afterwards have to get
# rid of the temporary file. If the window to be shown does not exist anymore
# (or the file can't be created) we get send a '0' character by fsc2 instead
# in which case we send the "Not available" picture.

sub serve_pics {
	my ( $which, $ext, $req, $maj, $min ) = @_;
	my ( $state, $fh, $file, @data );


	# We need a special SIGPIPE handler here because we must remove the
	# temporary file fsc2 created for us...

	$SIG{ PIPE } = sub { close $fh if defined $fh;
						 unlink $file if defined $file and $file !~ /na\.png/;
						 close $client;
						 exit 0
					   };

	# Ask fsc2 for the file with the graphic

	stdout_lock( 1 ) or exit 1;
	print STDOUT $which;
	1 while defined ( $state = <STDIN> ) and $state =~ /^$/o;
	return stdout_lock( 0 ) unless defined $state;

	# If we get a positive reply from fsc2 (it's sending us a character which
	# is not '0') the next thing it sends is the name of a file with the
	# requested graphic in ppm format, which we then have to convert to png
	# before passing it on to the browser

	if ( $state !~ /^0$/o and
		 ( ( $ext eq "png" and $has_pnmtopng ) or
		   ( $ext eq "jpeg" and $has_ppmtojpeg ) ) ) {
		$file = <STDIN>;
		chomp $file;
		if ( $ext eq "png" ) {
			@data = `pnmtopng -compression 9 $file`;
		} else {
			@data = `ppmtojpeg $file`;
		}
		unlink $file;
	} elsif ( $state =~ /^0$/o ) {
		$file = "$auxdir/na.$ext";
		open( $fh, $file ) or
			return not_found( "fsc2_$which$ext", $req );
	}
	stdout_lock( 0 );

	print "HTTP/1.1 200 OK$crlf" . def_txt( 0, $maj, $min ) .
		  "Accept-Ranges: none$crlf" .
		  "Content-Type: image/$ext$crlf";

	if ( $state !~ /^0$/o and
		 ( ( $ext eq "png" and $has_pnmtopng ) or
		   ( $ext eq "jpeg" and $has_ppmtojpeg ) ) ) {
		print "Content-Length: " . len( @data ) . "$crlf$crlf";
		print @data if $req =~ /^GET$/io;
	} else {
		print "Content-Length: " . ( -s $file ) . "$crlf$crlf";
		print <$fh> if $req =~ /^GET$/io;
		close $fh;
	}
}


#########################################################
# Deals with requests for pages we don't know about...

sub not_found {
	my ( $file, $req, $maj, $min ) = @_;

	my $body = "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">$crlf" .
		       "<HTML><HEAD>$crlf" .
			   "<TITLE>404 Not Found</TITLE>$crlf" .
			   "</HEAD><BODY>$crlf" .
			   "<H1>Not Found</H1>$crlf" .
			   "<P>The requested URL ($file) was not found.</P>$crlf" .
			   "<HR><ADDRESS>fsc2 HTTP server v$version at $hostname " .
			   "Port $port</ADDRESS>$crlf</BODY></HTML>$crlf";

	print "HTTP/1.1 404 Not Found$crlf" . def_txt( 0, $maj, $min ) .
		  "Content-Type: text/html; charset=iso-8859-1$crlf" .
		  "Content-Length: " . length( $body ) . "$crlf$crlf";

	print $body if $req =~ /^GET$/io;

	close $client;
	exit;
}


#########################################################
# Deals with requests that are neither GET nor HEAD

sub unsupported_request {

	my ( $req, $maj, $min ) = @_;

    my $body = "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">$crlf" .
		       "<HTML><HEAD>$crlf" .
		       "<TITLE>501 Not implemented</TITLE>$crlf" .
		       "</HEAD><BODY>$crlf" .
		       "<H1>Not implemented</H1>$crlf" .
		       "<P>Sorry, the server understands GET and HEAD requests " .
			   "only.</P>$crlf" .
		       "</HR><ADDRESS>fsc2 HTTP server v$version at $hostname " .
			   "Port $port</ADDRESS>$crlf</BODY></HTML>$crlf";

	print "HTTP/1.1 501 Not implemented$crlf" . def_txt( 0, $maj, $min ) .
		  "Content-Type: text/html; charset=iso-8859-1$crlf" .
		  "Content-Length: "  . length( $body ) . "$crlf$crlf";

	print $body if $req =~ /^GET$/io;

	close $client;
	exit;
}


#########################################################
# Deals with malformed requests

sub illegal_request {

	my ( $req, $maj, $min ) = @_;

	my $body = "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">$crlf" .
		       "<HTML><HEAD>$crlf" .
		       "<TITLE>400 Bad Request</TITLE>$crlf" .
		       "</HEAD><BODY>$crlf" .
		       "<H1>Bad Request</H1>$crlf" .
		       "<P>Your browser send a request that this server could not " .
		       "understand</P>$crlf" .
		       "<HR><ADDRESS>fsc2 HTTP server v$version at $hostname " .
			   "Port $port</ADDRESS>$crlf</BODY></HTML>$crlf";

	print "HTTP/1.1 400 Bad Request$crlf" . def_txt( 0, $maj, $min ) .
		  "Content-Type: text/html; charset=iso-8859-1$crlf" .
          "Content-Lenght: " . length( $body ) . "$crlf$crlf";

	print $body if $req =~ /^GET$/io;

	close $client;
	exit;
}


#########################################################
# Deals with requests claiming to be HTTP/1.1 compliant but don't send
# a Host field as required by RFC2616, section 14.23.

sub missing_host_field {

	my ( $req, $maj, $min ) = @_;

	my $body = "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 4.0//EN\">$crlf" .
		   	   "<HTML>$crlf<HEAD>$crlf" .
		   	   "<TITLE>400 Bad Request</TITLE>$crlf" .
		   	   "</HEAD><BODY>$crlf" .
		   	   "<H1>Bad Request</H1>$crlf" .
		   	   "<P>Your browser send a request that this server could not " .
		   	   "understand:$crlf" .
		   	   "Client sent HTTP/1.1 request without hostname (see RFC2616 " .
		   	   "section 14.23)</P>$crlf" .
			   "</HR><ADDRESS>fsc2 HTTP server v$version at $hostname " .
			   "Port $port</ADDRESS>$crlf</BODY></HTML>$crlf";

	print "HTTP/1.1 400 Bad Request$crlf" . def_txt( 0, $maj, $min ) .
		  "Content-Type: text/html; charset=iso-8859-1$crlf" .
		  "Content-Lenght: " . length( $body ) . "$crlf$crlf";

	print $body if $req =~ /^GET$/io;

	close $client;
	exit;
}


#########################################################
# Returns some text we always have to send to the client in the meta data

sub def_txt {
	my ( $no_expire, $maj, $min ) = @_;

	my $date = rfc_1123_date( );
	my $exp_date = $no_expire ? rfc_1123_date( 'next_year' ) : $date;

	my $reply = "Date: $date$crlf" .
				"Server: fsc2/$version$crlf" .
				"Allow: GET, HEAD$crlf" .
				"Accept-Ranges: none$crlf" .
				"Expires: $exp_date$crlf";

	$reply .= "Connection: close$crlf" if $maj >= 1 and $min >= 1;
	$reply .= "Cache-Control: no-cache$crlf" unless $no_expire;
	return $reply
}


#########################################################
# If called without an argument the function returns the current (GMT) date
# in RFC 1123 format, otherwise the date in about one years time (to be used
# as the 'infinite' expiry date according to RFC 2616)

sub rfc_1123_date {
	my @gm_time = gmtime( time( ) + ( @_ == 0 ? 0 : 31536000 ) );

	return strftime( "%a", @gm_time ) . ", "  .
		   strftime( "%d %b %G %T", @gm_time ) . " GMT";
}


#########################################################
# Creates (or releases) an advisory lock on STDOUT. Uses fcntl() instead of
# flock() in a rather cryptic way (about which I am not too happy) because
# flock() does not seem to work for locking STDOUT.

sub stdout_lock {
	return defined fcntl STDOUT, F_SETLKW,
		pack( "sslll", shift( ) ? F_WRLCK : F_UNLCK, SEEK_SET, 0, 0, 0 );
}


#########################################################
# Returns the total length (in bytes) of an array

sub len {
	use bytes;

	my $l = 0;
	$l += length for @_;
	return $l;
}
