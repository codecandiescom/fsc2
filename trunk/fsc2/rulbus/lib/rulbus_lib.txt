Library for the Rulbus (Rijksuniversiteit Leiden BUS) with support
         for the rb8509_adc12, rb8510_dac12, rb8514_delay,
                 rb8515_clock and rb_generic cards

  $Id$

Contents:

    I    Rulbus Configuration File
    II   General Functions
    III  rb8509_adc12 (12-bit ADC) Functions
    IV   rb8510_dac12 (12-bit DAC) Functions
    V    rb8514_delay (Delay Card) Functions
    VI   rb8515_clock (Clock Card) Functions
	VII  rb_generic (pseudo-card for debugging) Functions
    VIII Example Programs


======================================================================


I Rulbus Configuration File
---------------------------

Before you can work with the library you must create a configuration
file for the Rulbus. It contains informations about the device file
used for the Rulbus interface, the racks attached to it and the
cards sitting in these racks. Have a look at the file 'rulbus.conf'
in the main directory of the package first, it should be mostly self-
explaining.

The configuration file may contain a line like this

  file = "/dev/rulbus_epp";

This tells the library to take the file '/dev/rulbus_epp' to be the
device file for the Rulbus interface. The name of the file must be
enclosed in single or double quotes, the equal sign and the semi-
colon are optional. If such a line isn't in the file the library
will use '/dev/rulbus_epp' per default.

For each rack connected to the Rulbus interface that you want to use
you need a line starting with the keyword 'rack' and a rack name (a
string, enclosed in either single or double quotes) and followed by a
set of further instructions enclosed in curly braces:

rack "top rack" {

   address = 3;

    rb8514_delay  "DELAY_0" {
        address         = 0x64;
		intr_delay      = 60 n;
    }

    rb8515_clock "CLOCK" {
        address         = 0x12;
    }

    rb8509_adc12 "ADC12" {
        address         = 0x68;
        num_channels    = 8;
        bipolar         = true;
		volt_per_bit    = 2.5 m;
		has_ext_trigger = true;
    }

    rb8510_dac12 "DAC12_CH0" {
        address         = 0x45;
        bipolar         = false;
        volt_per_bit    = 1.25 m;
    }

	rb_generic   "GENERIC";
}

Within the set of configuration informations for the rack you normally
should specify the rack address by a line containing the keyword 'address'
and followed by the address. The rack address can be given as a decimal
number as well as a hexadecimal number (if it starts with '0x') or as a
octal number (if it starts with a '0'). If you only have a single rack
in the file with cards in it the rack address can be omitted and the rack
is assumed to be always selected, having the default address 0c 15. When
there's more than rack with cards listed in the configuration file rack
addresses must be specified, which must be between 0 and 14.

The configuration file may contain comments: everything following the
a '#' or '//' is discarded uo to the end of the line. To create comments
spanning multiple lines the usual C syntax for comments can be used, i.e.
everything from the character sequence '/*' until the first encounter of
'*/' is also discarded (with the consequence that such comments can't be
nested).

Further entries for a rack are for the cards in the rack (as many as there
are cards). Each card description starts with the type of the rack, either
'rb8509_adc12' (for the 12-bit ADC card RB8509), 'rb8510_dac12', (for the
12-bit DAC card RB8510), 'rb8514_delay' (for the RB8514 delay card),
'rb8515_clock' (for the RB8515 clock card) or 'rb_generic' (a card type
to be discussed later) and the card name (a string, enclosed in single or
double quotes) and followed by a set of card specific informations,
enclosed in curly braces. The name of that card must be unique, i.e. the
same name can't be used for two or more cards. Using this name the card
is later going to be accessed from your program.

For each card its address should be specified by a line starting with the
keyword 'address' and followed by the numeric card address. If no address
is specified for the card a default address is used. Please note that the
default address can't be used for two cards at the same time in a single
rack. Valid card addresses are in the range between 1 and 254.

For 12-bit ADC (RB8509) cards the default address is 0xC0, for 12-bit DAC
(RB8510) cards it is 0xD0, for delay (RB8514) cards it's 0xC4 and for
clock (RB8515) cards 0xC8. No address (or only the address 0, which is
invalid for all other crads) can be specified for "generic" (rb_generic)
cards.

For 12-bit ADC (RB8509) cards additional informations to be specified are
the number of channels, if the card works in bipolar or unipolar mode and
its sensitivity.

The number of channels of the ADC card has to follow the keyword
'num_channels' and must be number between 1 and a maximum of 8 (when
less channels are specified than the card has higher numbered channels
can't be used). If not specified a default value of 8 is used.

Another entry tells if the ADC works in bipolar or unipolar mode, i.e. if
it can convert voltages symmetrical to 0 V (biploar mode) or positive
voltages only (unipolar mode). It has to be specified following the keyword
'bipolar' as a boolean value, either 'true' or 'yes' to indicates that the
card works in bipolar mode or 'false' or 'yes' (if a numerical (integer)
value is used instead 0 stands for 'false' and all other values for 'true').
If not specified the library will assume that the card works in bipolar
mode.

A line starting with the 'volt_per_bit' keyword specifies the sensitivity
of the card. There are several versions of these cards with different
sensitivities. The sensitivity has to be specified as a voltage per bit.
The following table (by Martin J. Moene <moene@biophys.LeidenUniv.nl>)
shows the voltage per bit for different ranges of the card:

      	 Voltage range      |  volt_per_bit   bipolar
      ----------------------+--------------------------
      	 0    ..  5.11875 V |    1.25 mV        0
      	 0    .. 10.2375  V |    2.5  mV        0
      	 0    .. 20.475   V |    5    mV        0
      	-5.12 ..  5.1175  V |    2.5  mV        1
       -10.24 .. 10.235   V |    5    mV        1

To calculate to 'volt_per_bit' property for other types of cards just divide
the total range by 4095. Put this value after the keyword 'volt_per_bit'
into the configuration information for the card. If not specified a default
value of 5 mV is used.

Finally, a line starting with the 'has_ext_trigger' keyword, followed
by a boolean value, tells if the card has an input connector for an
external trigger signal. If not specified the library will default to
false.

Also the 12-bit DACs (RB8510) may require some additional information.
Unless specified a default address of 0xD0 is used. And like for the
RB8509 ADC12 card also for the DAC card a 'bipolar' (a boolean value)
and a 'volt_per_bit' property (a floating point value) usually has to
be specified. Like in the case of the ADC card, the 'volt_per_bit'
value for a card can be calculated by dividing the total input range
by 4095. When not given, 'bipolar' defaults to 'true' and volt_per_bit'
to 5 mV.

Please note: For each RB8510 12-bit DAC two card entries are required,
one for each of the two inputs of the card!

The RB8514 delay card expects, beside the address which defaults to 0xC4
when not specified, a line describing the intrinsic delay of the card.
Each delay card introduces a minimum delay, which is typically in the
order of 55-65 ns. To tell the library about the exact value a line
consisting of the the keyword 'intr_delay' and the length of this
minimum delay can be specified. If not given it defaults to 60 ns.

The RB8515 clock card does not properties have any properties that can
be set in the configuration file except its address, which defaults to
0xC8.

Finally, the generic card, 'rb_generic', does not allow to specify any
properties at all, not even an address. This card type isn't meant to
stand for a "real" card but allows to read from and write to each
address in the rack in belongs to. Thus in all calls of the functions
for dealing with this card, the absolute Rulbus address has to be given.

Numerical (floating point) values used in the configuration file can be
written as a number, followed by a suffix, indicating a unit:

     suffix | meaning
     -------+-------------
        f   | femto  1e-15
        p   | pico   1e-12
		n   | nano   1e-9
        u   | micro  1e-6
        m   | milli  1e-3
        k   | kilo   1e+3
        M   | mega   1e+6
        G   | giga   1e+9
        T   | tera   1e+12


After having written a configuration file you usually will copy it to
the '/etc' directory, giving it the name 'rulbus.conf'. That's where
the library expects to find the configuration file unless you set up
the environment variable RULBUS_CONFIG_FILE with the name of the
configuration file that should be used by the library.


======================================================================


II General Functions
--------------------

The following 7 functions are general functions that can  be used
for all cards.

Most of the functions described below (including the card-specific
ones) return an integer indicating if the operation was successful
or failed. On success RULBUS_OK (which is 0) is returned while on
failure a negative value gets returned. Here is the complete list
of return codes with a short explanation:


  RULBUS_OK                           No error (success)
  RULBUS_NO_MEMORY                    Running out of memory
  RULBUS_CONF_FILE_ACCESS             No permission to open configuration file
  RULBUS_CONF_FILE_NAME_INVALID       Invalid configuration file name (probably
									  the file doesn't exist)
  RULBUS_CONF_FILE_OPEN_FAIL          Failure to opne the configuration file
  RULBUS_CF_SYNTAX_ERROR              Syntax error in the configration file
  RULBUS_CF_EOF_IN_COMMENT            End of file detected in configuration
                                      file within a comment
  RULBUS_CF_DEV_FILE_DUPLICATE        Two or more different entries in the
                                      configuration file for the device file
  RULBUS_CF_RACK_ADDR_DUPLICATE       Two or more different values for the
                                      address of a rack
  RULBUS_CF_RACK_ADDR_INVALID         Invalid rack address
  RULBUS_CF_RACK_ADDR_CONFLICT        Two or more racks have the same address
  RULBUS_CF_RACK_ADDR_DEF_DUPLICATE   Two or more racks without a specified
                                      address
  RULBUS_CF_UNSUPPORTED_CARD_TYPE     Unsupported card in configuration file
  RULBUS_CF_CARD_NAME_CONFLICT        Two or more cards with the same name
  RULBUS_CF_CARD_ADDR_INVALID         Invalid card address
  RULBUS_CF_CARD_ADDR_CONFLICT        Two or more cards in a rack have been
									  assigned the same address
  RULBUS_CF_CARD_ADDR_DUPLICATE       Two or more different address assigned
									  to the same card
  RULBUS_CF_CARD_ADDR_DEF_CONFLICT    Two or more cards of the same type in a
									  rack have no address assigned to them
  RULBUS_CF_CARD_ADDR_OVERLAP         The address ranges of two or more cards
									  in a rack overlap
  RULBUS_CF_CARD_ADDR_GENERIC         An address has been assigned to a card
									  of type 'rb_generic'
  RULBUS_CF_CARD_PROPERTY_INVALID     A property has been specifed for a card
									  that does not have this property
  RULBUS_CF_DUPLICATE_NUM_CHANNELS    Two or more different values for the
									  number of channels have been specified
									  for a card of type 'rb8509_adc12'
  RULBUS_CF_INVALID_NUM_CHANNELS      Invalid number of channels specified for
									   a card of type 'rb8509_adc12'
  RULBUS_CF_VPB_DUPLICATE             Two or more different values for the
									  'volt_per_bit' property have been
									  specified for a 
  RULBUS_CF_INVALID_VPB               An invalid (negative or zero) value has
									  been specified for the 'volt_per_bit'
									  property of a card of type 'rb8509_adc12'
									  or 'rb8910_dac12'
  RULBUS_CF_BIPLOAR_DUPLICATE         Two different values have been specified
									  for the 'bipolar' property of a card of
									  type 'rb8509_adc12' or 'rb8910_dac12'
  RULBUS_CF_INTR_DELAY_DUPLICATE      Two or more different values have been
									  specified for the 'intr_delay' property
									  of a card of type 'rb8514_delay'
  RULBUS_CF_INTR_DELAY_INVALID        An invalid (negative) value has been
									  specfied  for the 'intr_delay' property
									  of a card of type 'rb8514_delay'
  RULBUS_DEV_FILE_ACCESS              No permission to open the device file
									  for the Rulbus
  RULBUS_DEV_FILE_NAME_INVALID        Invalid device file name (probably the
									  file doesn't exist)
  RULBUS_DEV_NO_DEVICE                File does not exist (probably because
									  driver for the device isn't loaded)
  RULBUS_DEV_FILE_OPEN_FAIL           Failure to open the device file
  RULBUS_NO_INITIALIZATION            rulbus_open() hasn't been called
  RULBUS_INVALID_ARGUMENT             Invalid function argument
  RULBUS_INVALID_CARD_NAME            Specified card name does not exist
  RULBUS_INVALID_CARD_HANDLE          Specified card handle does not exist
  RULBUS_CARD_NOT_OPEN                Missing call of rulbus_card_open()
									  for card of specified handle
  RULBUS_INVALID_CARD_OFFSET          Address offset for the card is invalid
  RULBUS_WRITE_ERROR                  Write error while trying to write data
									  to the card
  RULBUS_READ_ERROR                   Read error while trying to read data from
									  the card
  RULBUS_CARD_IS_BUSY                 Card of type 'rb8614_delay' is producing
									  delay while rulbus_delay_set_delay() is
									  called without the 'force' flag being set
  RULBUS_INVALID_VOLTAGE              Output voltage of range in call of
									  rulbus_dac12_set_voltage()
  RULBUS_TIME_OUT                     Time-out error while trying to write to
									  or reading from a card 
  RULBUS_NO_CLOCK_FREQ                No input clock frequency has been set
									  before rulbus_delay_set_delay() is called


----------------------------------------------------------------------

int rulbus_open( void )

Before anything else the RULBUS must be initialized by calling this
function. It will try to read in the configuration file, which is
"/etc/rulbus.conf" (unless a different name has been compiled into
the library), but the name can be changed by setting the environment
variable RULBUS_CONFIG_FILE. If the syntax of this file is correct
and the contents are reasonable the function will then open the device
file for the rulbus interface. This is usually "/dev/rulbus" (unless
a different name has been compiled into the program) or, if set, the
name that has been set in the configuration file.

Please note that the close-on-exec flag is set for the device file
for the interface.

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


----------------------------------------------------------------------

void rulbus_close( void )

When done with the RULBUS this function should be called for a clean
up. All opened cards are closed automatically.


----------------------------------------------------------------------

int rulbus_perror( const char *s )

The function prints out a string to stderr, consisting of a string
pased to it as the argument, a colon, a blank and a short descriptive
text of the error encountered in the last invocation of one of the
functions for the board, followed by a new-line. If the argument is
NULL or an empty string the error message is printed.

The function returns the number of characters printed to stderr or
the negative value RULBUS_NO_INIT if the RULBUS isn't open (i.e.
rulbus_open() has never been called or rulbus_close() hase been
called before this function).


----------------------------------------------------------------------

const char *rulbus_strerror( void )

The function returns a string with a short descriptive text of the
error encountered in the last invocation of one of the functions for
the board (or "Success" if the last function call was successful).
Each new invocation overwrites the content of the string.


----------------------------------------------------------------------

int rulbus_card_open( const char *name )

This function must be called for a card on the RULBUS before it can
be used. It expects the name of the card (as set in the configuration
file) as the only argument.

On success the function returns a (zero or positive) integer handle,
which has to be used in all further dealings with the device. On
failure a negative value indicating the reason for the failure is
returned.


----------------------------------------------------------------------

void rulbus_card_close( int handle )

This function can be called to "deactivate" the card. Once it has been
called the card can't be used anymore unless rulbus_card_open() is
called again for the card. The function is called automatically when
the function rulbus_close() is invoked.


----------------------------------------------------------------------

int rulbus_get_card_info( const char *card_name, RULBUS_CARD_INFO *card_info )

This function can be used to obtain information about the contents
of an entry int the configuration file for a certain card without
calling rulbus_open() (and thus without accessing the hardware). All
it does is opening the configuration file, reading it in and returning
returning the information about the card specified by the string
'card_name'. It returns the information about the card in a user-
defined structure of type RULBUS_CARD_INFO which is typedef'ed to

      typedef struct {
      	  int type;
      	  int num_channels;
		  int has_ext_trigger;
      	  double volt_per_bit;
      	  int bipolar;
      	  double intr_delay;
      } RULBUS_CARD_INFO;

'type' is the type of the card, one of the (numerical) values 'rb8509_adc12',
'rb8510_dac12', 'rb8514_delay', 'rb8515_clock' or 'rb_generic'.

'num_channels' is only set for cards of type 'rb8509_adc12' and specifies
the number if input channels of the ADC card.

'has_ext_trigger' also is only set for 'rb8509_adc12' cards and is set
to 0 if the card does not have an input connector for external triggers,
otherwise to a non-zero value.

'bipolar' is only set for cards of type 'rb8509_adc12' and 'rb8510_dac12'
and tells if the card is working in bipolar (in which case it has a non-
zero value' or in unipolar mode (if it has a value of 0).

Also 'volt_per_bit' is only set for cards of type 'rb8509_adc12' and
'rb8510_dac12'. It specifies the sensitivity of the card, in the voltage
for a single bit. To find out the total range of the card multiply this
value by 4095. For bipolar card the most negative input or output voltage
is 2048 times this value, and to get the most positive voltage multiply
it by 2047.

'intr_delay' is only set for 'rb8514_delay' cards and represents the
shortest possible delay (in seconds) that can be created by the card.


======================================================================


III rb8509_adc12 (12-bit ADC) Functions
---------------------------------------

On intitialization (when rulbus_card_open() is called) the card is
set up to use channel 0, a gain of 1 and to use internal trigger
mode.


----------------------------------------------------------------------

int rulbus_rb8509_adc12_num_channels( int handle )

This function returns the number of channels of the card. This function
can fail only due to an invalid 'handle' argument, in which case
RULBUS_INVALID_HANDLE is returned.


----------------------------------------------------------------------

int rulbus_rb8509_adc12_set_channel( int handle, int channel )

This function can be called to set the the channel for which conversions
are to be done. It must be a number between 0 and one less than the
total number of channels (as specified in the configuration file for
the card).

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


----------------------------------------------------------------------

int rulbus_rb8509_adc12_set_gain( int handle, int gain )

This function allows to set the gain of the card. The 'gain' argument
can be one of the following constants

    RULBUS_RB8509_ADC12_GAIN_1
    RULBUS_RB8509_ADC12_GAIN_2
    RULBUS_RB8509_ADC12_GAIN_4
    RULBUS_RB8509_ADC12_GAIN_8

to set the gain factor to either 1, 2, 4, or 8.

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


----------------------------------------------------------------------

int rulbus_rb8509_adc12_set_trigger_mode( int handle, int mode )

This function allows to switch between the trigger modes, In internal
mode a conversion is triggered by software, i.e. by asking for a converted
value, while in external trigger mode a conversion is triggered by an
external signal. To switch to internal trigger mode call the function
with mode set to the constant RULBUS_RB8509_ADC12_INT_TRIG, or use
RULBUS_RB8509_ADC12_EXT_TRIG to switch to external trigger mode.
Please note that there are some cards that don't have an external
trigger input. These cards should be set up in the Rulbus configuration
file with the property 'has_external_trigger' being set to 'false' and
then don't allow being switched to external trigger mode.

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


----------------------------------------------------------------------

int rulbus_rb8509_adc12_properties( int handle, double *Vmax, double *Vmin,
									double *dV )

This function can be used to determine the maximum and minimum
input voltage as well as the voltage resolution of the ADC for
a gain setting of 1. The values are returned via the 'Vmax',
'Vmin' and 'dV' pointers (unless they are NULL). This function
can fail only due to an invalid 'handle' argument, in which case
RULBUS_INV_HND is returned.


----------------------------------------------------------------------

int rulbus_rb8509_adc12_check_convert( int handle, double *volts )

This function should only be used when the card is in external trigger
mode. It checks is a conversion has already happened. If this was the
case the function returns 1 and the measured voltage is returned via
the 'volts' pointer. If no conversion has happened yet, 0 is returned.
When called while the card is internal trigger mode (or does not allow
to use an external trigger) always 0 is returned. On failure the
function returns a negative value indicating the reason for the failure.


----------------------------------------------------------------------

int rulbus_rb8509_adc12_convert( int handle, double *volts )

This function can be used both in internal as well as external trigger
mode. If the card is in internal trigger mode a conversion is triggered.
When the conversion is finished the measured voltage is returned via
the 'volts' pointer. Please note: when the card is in external trigger
mode the function will only return when an external trigger has been
received.

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


======================================================================


IV rb8510_dac12 (12-bit DAC) Functions
--------------------------------------

On intitialization (when rulbus_card_open() is called) no changes
of the already set output voltage of the DAC are done and the last
set voltages remains at the output of the DAC when the connection
to the DAC is closed.


----------------------------------------------------------------------

int rulbus_rb8510_dac12_properties( int handle, double *Vmax, double *Vmin,
									double *dV )

This function can be used to determine the maximum and minimum
output voltage as well as the voltage resolution of the DAC. The
values are returned via the 'Vmax', 'Vmin' and 'dV' pointers (unless
they are NULL). This function can fail only due to an invalid
'handle' argument, in which case RULBUS_INVALID_HANDLE is returned.


----------------------------------------------------------------------

int rulbus_rb8510_dac12_set_voltage( int handle, double volts )

Using this function you can set the output voltage of the connector
associated with the handle you received when calling rulbus_card_open().
Obviously, the voltage must be within the range of voltages the DAC
can output as they were specified in the configuration file.

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


======================================================================


V rb8514_delay (Delay Card) Functions
-------------------------------------

On intitialization (when rulbus_card_open() is called) a delay it may
be currently creating is stopped, the delay is set to 0 and the creation
of start or end pulses is switched off and the polarity of start end end
pulses is set to positive. When the card is closed (either directly by a
call of rulbus_card_close() or indirectly on a call of rulbus_close())
the card is left in the state it is at that moment.


----------------------------------------------------------------------

int rulbus_rb8514_delay_set_clock_frequency( int handle, double freq )

In order to be able to create delays when passed the delay time the
library needs to know the frequency of the input clock. Therefor
befor the function rulbus_rb8514_delay_set_delay() can be called
successfully, rulbus_rb8514_delay_set_clock_frequency() must have
been called to inform the library about the clock frequency (in Hz).

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


----------------------------------------------------------------------

int rulbus_rb8514_delay_set_delay( int handle, double delay, int force )

This function can be called to set the delay to be produced by the
card. In order to be able to do so the frequency of the input clock
must have been set by a call of rulbus_rb8514_delay_set_delay().
There is a lower limit to the delay that can be set, which is the
intrinsic delay of the card (which can be specified in the Rulbus
configuration file. The upper limit depends on the inout clock
frequency and is 16777215 times the inverse of the input clock
frequency plus the intrisic delay of the card.

If the delay can't be produced exactly (because the value, reduced by
the intrinsic delay, isn't an integer multiple of the inverse of the
input clock frequency), the nearest possible delay is used instead.

Usually when the card is just in the process of creating a delay the
function will return the error RULBUS_CARD_BUSY and not set a new delay.
To force the function to set a new delay value even in this case (and
thereby ending the currently created delay prematurely) the function
must be called with the 'force' argument set to a non-zero value.

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


----------------------------------------------------------------------

int rulbus_rb8514_delay_set_raw_delay( int handle, unsigned long delay,
									   int force )

The function is for setting the number of ticks of an external clock
during which the card will output a pulse. It must be a number between
0 and 16777215 (2^24 - 1). Setting a delay of 0 will create no output
at the gate outputs, just start or end pulses if they are enabled.
Please note that each card has an intrinsic delay of the order of
60 ns that has to be added to the product of the delay set and the
input clock frequency to determine the delay created by the card.

Usually when the card is just in the process of creating a delay the
function will return the error RULBUS_CARD_BUSY and not set a new delay.
To force the function to set a new delay value even in this case (and
thereby ending the currently created delay prematurely) the function
must be called with the 'force' argument set to a non-zero value.

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


----------------------------------------------------------------------

int rulbus_rb8514_delay_set_trigger( int handle, int edge )

This function lets youu select if the delay is started on the raising
or the falling edge of an external trigger. To make the card start
on the raising edge pass it the constant RULBUS_RB8510_DELAY_RAISING_EDGE
as the second argument, otherwise RULBUS_RB8510_DELAY_FALLING_EDGE.

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


----------------------------------------------------------------------

int rulbus_rb8514_delay_set_output_pulse( int handle, int output, int type )

This function allows to set if a start and/or end pulse is to be created
at output 1 and/or 2. If the 'output' argument is RULBUS_RB8510_DELAY_OUTPUT_1
the type argument will only be applied to the setting for output 1, if
it is RULBUS_RB8510_DELAY_OUTPUT_2 'type' only applies to output 2 and
if it is RULBUS_RB8510_DELAY_OUTPUT_BOTH the 'type' argument applies to
both outputs.

The 'type' argument can be either RULBUS_RB8510_DELAY_START_PULSE,
RULBUS_RB8510_DELAY_END_PULSE or RULBUS_RB8510_DELAY_PULSE_BOTH. In the
first case only a start pulse, but no end pulse gets output, in the
second case only an end pulse and in the third case both a start and an
end pulse will be created on the selected output(s). A 'type' argument
of RULBUS_RB8510_DELAY_PULSE_NONE keeps the the delay card from out-
putting start and/or pulses on the addressed output(s).

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


----------------------------------------------------------------------

int rulbus_rb8514_delay_set_output_pulse_polarity( int handle, int type,
												   int pol )

This function lets you select the polarity of the start and/or end pulses.
The 'type' argument are the same as for the previous function, i.e. it
can be either 

    RULBUS_RB8510_DELAY_START_PULSE
    RULBUS_RB8510_DELAY_END_PULSE
    RULBUS_RB8510_DELAY_PULSE_BOTH

obviously indicating for which of the pulses the 'pol' argument is to be
applied to. The 'pol' argument determines the polarity of the selected
pulses and can be either RULBUS_RB8510_DELAY_POLARITY_POSITIVE to output
a positive voltage for the start or end pulse, or, to create pulses with
negative polarity, RULBUS_RB8510_DELAY_POLARITY_NEGATIVE.

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


----------------------------------------------------------------------

int rulbus_rb8514_delay_busy( int handle )

This function lets you determine if the card is currently creating a
delay. It returns 1 in this case or 0 if the card isn't just creating
a delay. On failure a negative value indicating the reason for the
failure is returned.


----------------------------------------------------------------------

int rulbus_rb8514_delay_software_start( int handle )

Usually, delays get started on receipt of an external trigger. But with
this function a delay can also be started via software.

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


======================================================================


VI rb8515_clock (Clock Card) Functions
--------------------------------------

On intitialization (when rulbus_card_open() is called) no changes
are done to an already set output frequency of the card and when
the connection to the card is closed will remain to be output.


----------------------------------------------------------------------

int rulbus_rb8515_clock_set_frequency( int handle, int freq )

This function lets you set the frequency of the clock card. Beside the
handle for the card (as returned by rulbus_card_open()) the function
expects the requested output frequency as the second argument in the
form of one of the following constants

    RULBUS_RB8515_CLOCK_FREQ_OFF
    RULBUS_RB8515_CLOCK_FREQ_100Hz
    RULBUS_RB8515_CLOCK_FREQ_1kHz
    RULBUS_RB8515_CLOCK_FREQ_10kHz
    RULBUS_RB8515_CLOCK_FREQ_100kHz
    RULBUS_RB8515_CLOCK_FREQ_1MHz
    RULBUS_RB8515_CLOCK_FREQ_10MHz
    RULBUS_RB8515_CLOCK_FREQ_100MHz

with hopefully obvious meanings.

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


======================================================================


VII rb_generic Functions
------------------------


Cards of type "rb_generic" aren't real cards, they are pseudo-cards,
existing only in software. They are meant for debugging purposes
only. Using such a card all addresses of a rack (between 1 and 254)
can be written to or read from, allowing to bypass the functions
for the real cards, which in some situations might be to restrictive
in their error checking, or to access cards for which no module has
been written.


----------------------------------------------------------------------

int rulbus_generic_write( int handle, unsigned char address,
						  unsigned char *data, size_t len )

Using this function 'len' bytes from buffer 'data' can be written
to a rack address (must be between 1 and 254).

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


----------------------------------------------------------------------

int rulbus_generic_read( int handle, unsigned char address,
						 unsigned char *data, size_t len )

Using this function 'len' bytes can be read from a rack address (must
be between 1 and 254), which are returned via the buffer 'data' (which
must be allocated by the caller).

On success the function returns RULBUS_OK, otherwise a negative value
indicating the reason for the failure.


======================================================================


VIII Example Programs
---------------------

The following program demonstrates how to obtain a converted voltage
from the 12-bit ADC (RB8509).


#include <stdio.h>
#include <stdlib.h>
#include <rulbus.h>

int main( void )
{
    int handle;
    double volts;


    /* Initialize the library */

    if ( rulbus_open( ) != RULBUS_OK )
        return EXIT_FAILURE;

    /* Get a handle for the 12-bit ADC card, using the name from the
       configuration file */

    if ( ( handle = rulbus_card_open( "ADC12" ) != RULBUS_OK )
        return EXIT_FAILURE;

    /* Set up card to use input channel 1 */

    if ( rulbus_adc12_set_channel( handle, 1 ) != RULBUS_OK )
        return EXIT_FAILURE;

    /* Switch on gain factor of 4 */

    if ( rulbus_adc12_set_gain( handle, RULBUS_RB8509_ADC12_GAIN_4 )
                                                                 != RULBUS_OK )
        return EXIT_FAILURE;

    /* Set internal trigger mode */

    if ( rulbus_adc12_set_trigger_mode( handle, RULBUS_RB8509_ADC12_INT_TRIG )
                                                                 != RULBUS_OK )
        return EXIT_FAILURE;

    /* Start a conversion and print out measured voltage */

    if ( rulbus_adc12_convert( handle, &volts ) != RULBUS_OK )
        return EXIT_FAILURE;

    printf( "V = %f\n", volts );

    /* Close the connection to the ADC card */

    rulbus_close_card( handle );

    /* Close connection to the Rulbus */

    rulbus_close( );

    return EXIT_SUCCESS;
}
