#!/usr/bin/perl
# -*- cperl -*-
#
#  $Id$
#
#  Copyright (C) 1999-2005 Jens Thoms Toerring
#
#  This file is part of fsc2.
#
#  Fsc2 is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2, or (at your option)
#  any later version.
#
#  Fsc2 is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with fsc2; see the file COPYING.  If not, write to
#  the Free Software Foundation, 59 Temple Place - Suite 330,
#  Boston, MA 02111-1307, USA.
#
#  This script tries to GUI-fy a suitably adapted EDL script, i.e. it takes
#  an "enhanced" EDL script and creates from it a Perl script which, when
#  run, allows the user to set parameters via a GUI, then creates an EDL
#  script from these parameters and sends it to fsc2 for execution.
#
#  Thanks to Burkhard Endeward (J.-W.-Gothe-University Frankfurt/Main) for
#  pointing out several problems with the handling of button objects.


use strict;
use warnings;

# By changing the next three variables the layout of the form can be changed!

my $label_width = 20;         # width of labels at the left of the input field
my $entry_width = 10;         # width of the input fields
my $unit_width  =  5;         # width for e.g. unit to right of the input field

my @lines;
my @vars;
my $guify_entry = '^\s*===\s*';
my $var_entry = $guify_entry .
    '([A-Za-z0-9_]+)\s+(int|float|menu|file|button)(\s*(.*))?';
my $if_entry = $guify_entry . 'if\s*';
my $elsif_entry = $guify_entry . 'elsif\s*';
my $else_entry = $guify_entry . 'else\s*$';
my $endif_entry = $guify_entry . 'endif\s*$';
my $if_level = 0;
my $lino;
my $need_file_sel = 0;

my $if = *STDIN;
my $of = *STDOUT;

if ( $ARGV[ 0 ] ) {
    usage( ) if $ARGV[ 0 ] =~ /^-h$/ or $ARGV[ 0 ] =~ /^--h(elp)?$/;
    open( $if, "<$ARGV[ 0 ]" )
        or die "Can't open input file $ARGV[ 0 ]: $!\n";
}

# Read in the complete input and do some parsing

while ( <$if> ) {

    # Just store lines with normal EDL code (plus the line number)

    unless ( /$guify_entry/o ) {
        push @lines, { line => $_, lino => $. };
        next;
    }

    # If a line starting with a 'guify' marker ends in a backslash append the
	# next line to it (which then also must start with the marker)

    my $cur_line = $_;
    $lino = $.;
    while ( $cur_line =~ /\\\s*$/ ) {
        $cur_line =~ s/(.*)\\\s*$/$1 /;
        die "Unexpected end of input file\n" unless defined( $_ = <$if> );
        die "Missing continuation at line $.\n" unless /$guify_entry/o;
        s/$guify_entry(.*)/$1/o;
        $cur_line .= $_;
    }

    # if/else/elsif/endif lines stay in the program for later handling

    if ( $cur_line =~ /$if_entry/o ) {
        die "'if' found without a condition at line $lino\n"
            if $cur_line =~ /$if_entry\s+$/o;
        $if_level++;
        push @lines, { line => $cur_line, lino => $lino };
        next;
    }

    if ( $cur_line =~ /$else_entry/o ) {
        die "'else' found without previous 'if' at line $lino\n"
            if $if_level <= 0;
        push @lines, { line => $cur_line, lino => $lino };
        next;
    }

    if ( $cur_line =~ /$elsif_entry/o ) {
        die "'elsif' found without previous 'if' at line $lino\n"
            if $if_level <= 0;
        die "'elsif' found without a condition at line $lino\n"
            if $cur_line =~ /$elsif_entry\s+$/o;
        push @lines, { line => $cur_line, lino => $lino };
        next;
    }

    if ( $cur_line =~ /$endif_entry/o ) {
        die "'endif' found without previous 'if' at line $lino\n"
            if $if_level <= 0;
        $if_level--;
        push @lines, { line => $cur_line, lino => $lino };
        next;
    }

    # Lines defining variables must be analyzed immediately

    if ( $cur_line =~ /$var_entry/o ) {
        chomp $cur_line;
        my $var_options = { name => $1, type => $2, value => undef,
                            line => $cur_line };
        if ( defined $4 ) {
            my $option = $4;
			$option = "\"\"" if $var_options->{ type } =~ /^file$/o and
								$option =~ /^\s*$/;
            die "Syntax error at line $lino, garbage after variable type\n"
                unless $option =~ /^\s*[\"\[]/o;
            analyze_var_options( $var_options, $option );
        }
        push @vars, $var_options;
		$need_file_sel = 1 if $var_options->{ type } =~ /^file$/o;
        next;
    }

    chomp $cur_line;
    $cur_line =~ s/^\s*===\s+//o;
    $cur_line = $1 if $cur_line =~ /^[A-Za-z0-9_]+\s+(.*)$/o;
    die "Invalid syntax at line $lino near \"$cur_line\"\n";
}

die "Unbalanced if-endif construct(s)\n" if $if_level > 0;
print STDERR "Warning: No variables found in input\n" if @vars == 0;

# Set values for variables that don't have been assigned a default value.
# For ints and floats use the mean of the minimum and maximum value if both
# are given, the limit when only one is given or 0 when none is set. For
# menus use the first entry and switch off buttons by default.

for ( @vars ) {
    if ( exists $$_{ value } and defined $$_{ value } ) {
        $$_{ def_value } = $$_{ value };
        next;
    }

    if ( $$_{ type } =~ /^int|float$/ ) {
        if ( defined $$_{ max } and defined $$_{ min } ) {
            $$_{ value } = 0.5 * ( $$_{ max } + $$_{ min } );
            $$_{ value } = int( $$_{ value } ) if $$_{ type } =~ /^int$/;
        } elsif ( defined $$_{ max } and ! defined $$_{ min } ) {
            $$_{ value } = $$_{ max };
        } elsif ( ! defined $$_{ max } and defined $$_{ min } ) {
            $$_{ value } = $$_{ min };
        } else {
            $$_{ value } = 0;
        }
        $$_{ def_value } = $$_{ value };
    } elsif ( $$_{ type } =~ /^menu$/ ) {
        $$_{ value } = $$_{ def_value } = $$_{ menu_entries }->[ 0 ];
	} elsif ( $$_{ type } =~ /^button$/ ) {
        $$_{ value } = $$_{ def_value } = 0;
    } else {
        $$_{ value } = $$_{ def_value } = "";
        $entry_width = 15;
    }
}

# Check the if and elsif lines for Perl syntax errors

cond_check( );

# Open the output file and write out the script

if ( $ARGV[ 1 ] ) {
    open( $of, ">$ARGV[ 1 ]" )
        or die "Can't open output file $ARGV[ 1 ]: $!\n";
}

select $of;
write_script( );

close $if if $ARGV[ 0 ];
close $of if $ARGV[ 1 ];

# Finally make the new script executable (unless we're writing to STDOUT)

chmod( 0755, $ARGV[ 1 ] ) if $ARGV[ 1 ];

# And that's it ;-)


################################################################
# Function prints out usage info

sub usage {
    print "Usage: fsc2_guify [ IN_FILE [ OUT_FILE ] ]\n" .
          "A program to GUI-fy (slightly modified) EDL scripts.\n";
    exit 0;
}


################################################################
# Function to figure out the options specified with the variables
# that the program understands

sub analyze_var_options {
    my ( $hr, $str ) = @_;
    my $res;

    if ( $hr->{ type } =~ /^float$/o ) {
        $str = get_float_limits( $hr, $str );
    } elsif ( $hr->{ type } =~ /^int$/o ) {
        $str = get_int_limits( $hr, $str );
    } elsif ( $hr->{ type } =~ /^menu$/o ) {
        $str = get_menu_entries( $hr, $str );
    }

    unless ( $hr->{ type } =~ /^file$/o ) {
        ( $res, $str ) = get_default_value( $str, $hr );
        $hr->{ value } = $res if defined $res;
    }



    ( $res, $str ) = get_string( $str, $hr );
    $hr->{ label } = defined $res ? $res : '""';

    unless ( $hr->{ type } =~ /^file$/o ) {
        ( $res, $str ) = get_string( $str );
        $hr->{ unit } = defined $res ? $res : '""';
    }

    die "Syntax error at line $lino near \"$str\"\n"
        if defined $str and $str !~ /^\s*$/;
}


################################################################
# Function for determining the limits for floating point variables
# as specified in the "enhanced" EDL script

sub get_float_limits {
    my ( $hr, $str ) = @_;
    my ( $min, $max );
    my $float_rep = '[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?';

    if ($str !~ /^\s*\[/o ) {
        $hr->{ max } = $hr->{ min } = undef;
        return $str;
    }

    if ( $str =~ /^\s*(\[\s*([^:\t ]+)?\s*:\s*([^:\t ]+)?\s*\])(\s*(.*))?$/o ) {
        $str = $5;

        $min = $2 if defined $2;
        $max = $3 if defined $3;

        die "Not a floating point number ($min) at line $lino\n"
            if defined $min and $min !~ /^$float_rep$/o;

        die "Not a floating point number ($max) at line $lino\n"
            if defined $max and $max !~ /^$float_rep$/o;

        if ( defined $min and defined $max and $min > $max ) {
            my $temp = $min;
            $min = $max;
            $max = $temp;
        }

        $hr->{ max } = $max;
        $hr->{ min } = $min;
    } else {
        $hr->{ max } = $hr->{ min } = undef;
    }

    return $str;
}


################################################################
# Function for determining the limits for initeger variables
# as specified in the "enhanced" EDL script

sub get_int_limits {
    my ( $hr, $str ) = @_;
    my ( $min, $max );
    my $int_rep = '[+-]?\d+';

    if ($str !~ /^\s*\[/o ) {
        $hr->{ max } = $hr->{ min } = undef;
        return $str;
    }

    if ( $str =~ /^(\[\s*([^:\t ]+)?\s*:\s*([^:\t ]+)?\s*\])(\s*(.*))?$/o ) {
        $str = $5;

        $min = $2 if defined $2;
        $max = $3 if defined $3;

        die "Not an integer number ($min) at line $lino\n"
            if defined $min and $min !~ /^$int_rep$/o;

        die "Not an integer number ($max) at line $lino\n"
            if defined $max and $max !~ /^$int_rep$/o;

        if ( defined( $min ) and defined( $max ) and $min > $max ) {
            my $temp = $min;
            $min = $max;
            $max = $temp;
        }

        $hr->{ max } = $max;
        $hr->{ min } = $min;
    } else {
        $hr->{ max } = $hr->{ min } = undef;
    }

    return $str;
}


################################################################
# Function for parsing the menu entries passed for meu variables

sub get_menu_entries {
    my ( $hr, $str ) = @_;
    my $string_rep = '"((\"|[^"])*)"';

    if ( $str =~
         /^s*\[\s*($string_rep(\s*,\s*$string_rep)?)\s*\](\s*(.*)?)?$/o ) {
        $str = $8;
        my $mstr = $1;
        my @menu_entries;
        $mstr =~ /^"((\\"|[^"])*)"/og;
        push @menu_entries, $1;
        push @menu_entries, $1 while $mstr =~ /\G\s*,\s*"((\\\"|[^\"])*)"/go;
        die "Less than 2 entries in menu descriptor starting at line $lino\n"
            if @menu_entries < 2;
        die "Syntax error in menu descriptor starting at line $lino\n"
            unless $' =~ /^\s*$/;
        $hr->{ menu_entries } = \@menu_entries;
    } else {
        die "Missing entries in menu descriptor starting at line $lino\n";
    }

    return $str;
}


################################################################
# Function for parsing the default values that can be specified
# for integer or float variables

sub get_default_value {
    my ( $str, $hr ) = @_;
    my $val;

    return ( undef, undef ) unless defined $str;
    return ( undef, $str ) unless
        $str =~ /^\s*\[\s*([^\]\t ]+)\s*\](\s*(.*)?)?$/o;

    $val = $1;
    $str = $3;

    if ( $hr->{ type } =~ /^int$/ ) {
        if ( $val =~ /^[+-]?\d+$/ ) {
            die "Default value for $hr->{ name } does not fit into range at " .
                "line $lino\n"
                    if ( defined $hr->{ max } and $hr->{ max } < $val ) or
                       ( defined $hr->{ min } and $hr->{ min } > $val );
            return ( $val, $str );
        } else {
            die "Default value ($val) isn't an integer number at line $lino\n";
        }
    } elsif ( $hr->{ type } =~ /^float$/ ) {
        if ( $val =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?/o ) {
            die "Default value for $hr->{ name } does not fit into range at " .
                "line $lino\n"
                    if ( defined $hr->{ max } and $hr->{ max } < $val ) or
                       ( defined $hr->{ min } and $hr->{ min } > $val );
            return ( $val, $str );
        } else {
            die "Default value ($val) isn't a floating point number at " .
                "line $lino\n";
        }
    } elsif ( $hr->{ type } =~ /^button$/ ) {
		return ( $val =~ /^on|1$/io ? 1 : 0, $str )
			if $val =~ /^on|off|1|0$/io;
		die "Default value ($val) isn't a valid initializer for a button at " .
			"line $lino\n";
	} else {
        if ( $val =~ /^\d+/o ) {
            die "Default value ($val) for $hr->{ name } is larger than the " .
                "number of menu entries at line $lino\n"
                if $val > @{ $hr->{ menu_entries } };
            die "Invalid default value of 0 for $hr->{ name } at " .
                "line $lino, must be at least 1.\n" if $val == 0;
            return ( $hr->{ menu_entries }->[ $val - 1 ], $str );
        } else {
            die "Default value ($val) isn't a positive integer number at " .
                "line $lino\n";
        }
    }
}


################################################################
# Function for extracting a double-quote-enclosed string

sub get_string {
    my $str = shift;

    return ( undef, undef ) if ! defined $str or $str =~ /^\s*$/;

    die "Syntax error at line $lino near \"$str\"\n" unless $str =~ /^\s*\"/o;

    $str =~ /^\s*(\"([^\"]|\\\")*\")(\s*(.*)?)?$/o;
    return ( $1, $4 ) if defined $1;
    return ( undef, $str );
}


################################################################
# Routine checks all conditions found in the input file by calling eval()
# on them (after prepending some code to create and initialize possibly
# needed variables and putting a '$' in front of the variable names).
# If the eval() fails we know that there must be some Perl syntax error.

sub cond_check {
    my $defs = "";

	for ( @vars ) {
		if ( $$_{ type } =~ /^int|float$/o ) {
			$defs .= "my \$$$_{ name } = $$_{ value };\n" ;
		} else {
			$defs .= "my \$$$_{ name } = \"$$_{ value }\";\n" ;
		}
	}

    for ( @lines ) {
        next unless $$_{ line } =~ /$guify_entry/o;
        $$_{ line } =~ /$guify_entry(if|else|elsif|endif)\s*(.*?)\s*$/;
        my ( $type, $rcmd ) = ( $1, $2 );
        next unless $type =~ /^if|elsif$/o;
        my $cmd = $rcmd;
        $cmd =~ s/\b$$_{ name }\b/\$$$_{ name }/g for ( @vars );

        # Disable warnings for the test call of eval

        local $SIG{ __WARN__ } = sub{ };
        eval $defs . $cmd;
        die "Syntax error in $type condition at line $$_{ lino }: \"$rcmd\"\n"
            if $@;
    }
}


################################################################
# All the rest is the routine that writes the script. That's the
# real tricky part and unfortunately also looks that way...

sub write_script {
    # Write out the start of the script

    print '#!/usr/bin/perl
# -*- cperl -*-
# Generated by fsc2_guify';
print " from $ARGV[ 0 ]" if $ARGV[ 0 ];
print " on " . `date`;

    print <<'EOT';

use strict;
use warnings;
use Tk;
use Tk::Balloon;

my @version = split /\./, $Tk::VERSION;
die "Installed Perl-Tk version is $Tk::VERSION but Tk800.022 is required.\n"
    if $version[ 0 ] + 0.001 * $version[ 1 ] < 800.022;

my %fp = ( -side => 'top',
           -fill => 'x',
           -padx => '2m',
           -pady => '2m' );
my %wp = ( -side => 'left',
           -fill => 'x',
           -expand => 1 );
my %up = ( -side => 'left' );
my $geom;

my $fsc2_how_to_run = "Test program";
my @fsc2_how_to_run = ( "Start experiment",
                        "Test program",
                        "Load into fsc2" );
my $fsc2_main_window = MainWindow->new( -title =>
							   ( split /\./, ( split /\//, $0 )[ -1 ] )[ 0 ] );
my $fsc2_main_frame = $fsc2_main_window->Frame( -relief => "ridge",
                                                -borderwidth => "1m" );
my $fsc2_balloon = $fsc2_main_frame->Balloon( );
my $fsc2_apply_frame = $fsc2_main_window->Frame( );
my $fsc2_apply_button = $fsc2_apply_frame->Button( -text => "Apply",
                                                   -command => \&write_out );
$fsc2_apply_button->bind( "all", "<Alt-a>" => \&write_out );
my $fsc2_quit_button = $fsc2_apply_frame->Button( -text => "Quit",
                 -command => sub { $fsc2_main_window->geometry =~
							   					   /^\d+x\d+([+-]\d+[+-]\d+)$/;
							   	   $geom = $1;
							   	   &store_defs;
                                   $fsc2_main_window->destroy } );
$fsc2_quit_button->bind( "all",
                         "<Alt-q>" =>
                         		sub { $fsc2_main_window->geometry =~
							   					   /^\d+x\d+([+-]\d+[+-]\d+)$/;
							   		  $geom = $1;
							   		  &store_defs;
									  $fsc2_main_window->destroy } );
$fsc2_apply_frame->pack( -side => "bottom",
                         -fill => "x",
                         -padx => "4m" );

EOT

    # Now write the code for creating the input fields for the variables

    for ( @vars ) {
        print <<"EOT";
# $$_{ line }

my \%$$_{ name };
\$$$_{ name }\{ tk_frame \} = \$fsc2_main_frame->Frame( );
\$$$_{ name }\{ tk_label \} = \$$$_{ name }\{ tk_frame \}->Label( -text => $$_{ label },
-width => $label_width,
-anchor => 'w' );
EOT

        if ( $$_{ type } =~ /^int|float$/o ) {
            print "\$$$_{ name }\{ value \} = $$_{ value };
\$$$_{ name }\{ min \} = " . ( defined $$_{ min } ? $$_{ min } : "undef" ) . ";
\$$$_{ name }\{ max \} = " . ( defined $$_{ max } ? $$_{ max } : "undef" ) . ";
\$$$_{ name }\{ tk_entry \} = \$$$_{ name }\{ tk_frame \}->Entry( -textvariable => \\\$$$_{ name }\{ value \},
-width => $entry_width,
-validate => 'key',
-validatecommand => sub{ $$_{ type }_check( shift,
( defined \$$$_{ name }\{ min \} ? \$$$_{ name }\{ min \} : undef ),
( defined \$$$_{ name }\{ max \} ? \$$$_{ name }\{ max \} : undef ) ); },
-relief => 'sunken' );
\$fsc2_balloon->attach( \$$$_{ name }\{ tk_entry \},
-balloonmsg  => \"Range: [ \" . ( defined \$$$_{ name }\{ min \} ? \$$$_{ name }\{ min \} : '-inf' ) .
\" : \" . ( defined \$$$_{ name }\{ max \} ? \$$$_{ name }\{ max \} : '+inf' ) . \" ]\" );
";
		} elsif ( $$_{ type } =~ /^button$/o ) {
            print "\$$$_{ name }\{ value \} = $$_{ value };
\$$$_{ name }\{ tk_entry \} = \$$$_{ name }\{ tk_frame \}->Checkbutton( -variable => \\\$$$_{ name }\{ value \},
-width => $entry_width );\n";
        } elsif ( $$_{ type } =~ /^menu$/o ) {
            print "\$$$_{ name }\{ value \} = \"$$_{ value }\";
my \@$$_{ name } = ( \"$$_{ menu_entries }[ 0 ]\"";
            for ( my $i = 1; $i < @{ $$_{ menu_entries } }; $i++ ) {
                print ", \"" . ${ $$_{ menu_entries } }[ $i ] . "\"";
            }
            print " );
\$$$_{ name }\{ tk_entry \} = \$$$_{ name }\{ tk_frame \}->Optionmenu( " .
"-options => \\\@$$_{ name },
-width => $entry_width,
-textvariable => \\\$$$_{ name }\{ value \} );
";
        } elsif( $$_{ type } =~ /^file$/o ) {
            print "\$$$_{ name }\{ value \} = \"$$_{ value }\";
\$$$_{ name }\{ tk_entry \} = \$$$_{ name }\{ tk_frame \}->Entry( -textvariable => \\\$$$_{ name }\{ value \},
-width => $entry_width,
-relief => 'sunken' );
";
        }

        if ( $$_{ type } =~ /^int|float|menu|button$/o ) {
            print <<"EOT";
\$$$_{ name }\{ tk_unit \} = \$$$_{ name }\{ tk_frame \}->Label( -text => $$_{ unit },
-width => $unit_width );
EOT
        } elsif ( $$_{ type } =~ /^file$/o ) {
            print <<"EOT";
\$$$_{ name }\{ tk_unit \} = \$$$_{ name }\{ tk_frame \}->Button( -text => \"...\",
-command => sub { my \$fn = \$fsc2_main_window->fsc2_filesel::show( \$$$_{ name }\{ value \} );
                  \$$$_{ name }\{ value \} = \$fn if defined \$fn;
                  \$$$_{ name }\{ tk_entry \}->xview( length( \$$$_{ name }\{ value \} ) - $entry_width ) }
);
EOT
        }

        print <<"EOT";
\$$$_{ name }\{ tk_frame \}->pack( \%fp );
\$$$_{ name }\{ tk_label \}->pack( \%wp );
\$$$_{ name }\{ tk_entry \}->pack( \%wp );
\$$$_{ name }\{ tk_unit  \}->pack( \%up );

EOT
    }

    # Finally add the menu for selection of how to run the generated EDL
    # script and the Apply- and Quit-button

    print <<"EOT";
\$fsc2_main_frame->pack( \%fp, -pady => '1m' );
\$fsc2_main_window->Optionmenu( -options => \\\@fsc2_how_to_run,
                                -textvariable => \\\$fsc2_how_to_run,
                              )->pack( -padx => '3m',
                                       -pady => '3m' );

\$fsc2_apply_button->pack( \%wp, padx => '5m', -pady => '3m' );
\$fsc2_quit_button->pack(  \%wp, padx => '5m', -pady => '3m' );

load_defs( );
\$fsc2_main_window->geometry( \$geom ) if defined \$geom;
EOT

    for ( @vars ) {
    print "\$$$_{ name }\{ tk_entry \}->xview( length( \$$$_{ name }\{ value \} ) - $entry_width );
" if $$_{ type } =~ /^file$/o;
    }

    # Ok, everything needed for the graphical interface has been done. After
    # the MainLoop() call all the funcions needed by the script follow...

    print <<"EOT";
MainLoop;


################################################################

sub int_check {
    my ( \$new, \$min, \$max ) = \@_;

    return 0 if \$new =~ /^\\+?(\\d+)?\$/ and defined \$max and \$max < 0;
    return 0 if \$new =~ /^-/ and defined \$min and \$min >= 0;
    if ( \$new =~ /^[+-]?\$/ ) {
         \$fsc2_apply_button->configure( -state => 'disabled' );
         return 1;
     }

    return 0 unless \$new =~ /^[+-]?\\d+?\$/;

    if ( ( defined \$min and \$new < \$min )
         or ( defined \$max and \$new > \$max ) ) {
         \$fsc2_apply_button->configure( -state => 'disabled' );
     } else {
         \$fsc2_apply_button->configure( -state => 'normal' );
     }
     return 1;
}


################################################################

sub float_check {
    my ( \$new, \$min, \$max ) = \@_;
    my \$float_rep = '[+-]?((\\d+(\\.(\\d+)?)?)|(\\.\\d+))([eE][+-]?\\d+)?';

    return 0 if \$new =~ /^\\+/ and defined \$max and \$max < 0;
    return 0 if \$new =~ /^-/ and defined \$min and \$min > 0;

    if ( \$new =~ /^\$float_rep\$/ ) {
        if ( ( defined \$max and \$max < \$new ) or
             ( defined \$min and \$min > \$new ) ) {
            \$fsc2_apply_button->configure( -state => 'disabled' );
        } else {
            \$fsc2_apply_button->configure( -state => 'normal' );
        }
        return 1;
    }

    if ( \$new =~ /^[+-]?(\\d+)?\\.?(\\d+)?([Ee][+-]?(\\d+)?)?\$/ ) {
         \$fsc2_apply_button->configure( -state => 'disabled' );
         return 1;
     }

     return 0;
}


################################################################

sub write_out {
    my \$fh;

    open( \$fh, \"|fsc2_\" . lc \$fsc2_how_to_run )
        or die \"Can't find utility fsc2_\" . lc \$fsc2_how_to_run . \".\\n";

EOT

	# The user may change variables from within the conditions. We must
	# avoid that these changes become visible in the rest of the script and
    # therefore use variables local to the current function.

	print "    my \$$$_{ name } = \$$$_{ name }\{ value \};\n" for ( @vars );

    # Here the body of the EDL script that the script we are just writing is
    # going to send to fsc2 is written. For normal lines we just have to
    # double all backslashes, escape double quotes and '$'s and prepend an
    # (escaped) '$' to the variable names.
    # For the possibly embedded if, else, elsif and endif commands we
    # have to built in some Perl code to allow the written script to
    # decide which parts need to be written to the EDL script depending
    # on what values or menu entries the user selected. Here the eval
    # function comes quite handy because we can simply treat the conditions
    # as some Perl code after prepending a '$' to the variable name...
    # This way the user can use even rather complicated expressions as
    # conditions (actually complete Perl scripts ;-)

    print "\n    print \$fh \"";

    for ( @lines ) {
        my $line = $$_{ line };

        if ( $line =~ /$guify_entry/o ) {
            chomp $line;
            $line =~ /$guify_entry(if|else|elsif|endif)\s*(.*?)\s*$/;
            my ( $type, $cmd ) = ( $1, $2 );

            if ( $type =~ /^if|elsif$/o ) {
                $cmd =~ s/\b$$_{ name }\b/\$$$_{ name }/g for ( @vars );
            }

            if ( $type =~ /^if$/o ) {
                print "\";
# $line
    if ( eval { $cmd } ) {
        print \$fh \"";
            } elsif ( $type =~ /^elsif$/o ) {
                print "\";
# $line
    } elsif ( eval { $cmd } ) {
        print \$fh \"";
            } elsif ( $type =~ /^else$/o ) {
                print "\";
# $line
    } else {
        print \$fh \"";
            } else {
                print "\";
# $line
    }

    print \$fh \"";
            }

            next;
        }

        $line =~ s/\\/\\\\/g;
        $line =~ s/\"/\\\"/g;
        $line =~ s{\$}{\\\$}g;

        for ( @vars ) {
            if ( $$_{ type } =~ /^int|float|menu|button$/o ) {
                $line =~ s/\b$$_{ name }\b/\$$$_{ name }/g;
            } elsif ( $$_{ type } =~ /^file$/o ) {
				$line =~ s/\b$$_{ name }\b/\\\"\$$$_{ name }\\\"/g;
            }
        }

        print $line;
    }

    print <<'EOT';
";
    close $fh;

    my $text;
    if ( $? != 0 ) {
        if ( $? >> 8 == 255 ) {
            $text = "Internal error.";
        } elsif ( $? >> 8 == 1 ) {
            $text = "Someone else is running fsc2.";
        } elsif ( $? >> 8 == 2 ) {
            $text = "fsc2 is already testing or\nrunning an experiment.";
        } elsif ( $? >> 8 == 3 ) {
            $text = "Internal error of fsc2.";
        } elsif ( $? >> 8 == 4 ) {
            $text = "Could not start fsc2.";
        } else {
            $text = "Something strange\nis going on here.";
        }

        &show_message( $text ) if $? >> 8 != 0;
    }
}


################################################################

sub show_message {
    my $text = shift;

    $fsc2_main_window->messageBox( -icon => 'error',
                                   -type => 'Ok',
                                   -title => 'Error',
                                   -message => $text );
}


################################################################

sub store_defs {
    my $fh;
    my $name = $0;

    $name =~ s|^.*?([^/]+)$|$1|;
    mkdir "$ENV{ HOME }/.fsc2", 0777 unless -e "$ENV{ HOME }/.fsc2";
    open( $fh, ">$ENV{ HOME }/.fsc2/$name" ) or return;
    print $fh "# Do not edit - created automatically!\n";
EOT

    for ( @vars ) {
        if ( $$_{ type } =~ /^int$/o ) {
            print "
    if ( \$$$_{ name }\{ value \} =~ /^[+-]?\\d+\$/o and
         ( defined \$$$_{ name }\{ max \} ? \$$$_{ name }\{ max \} >= \$$$_{ name }\{ value \} : 1 ) and
         ( defined \$$$_{ name }\{ min \} ? \$$$_{ name }\{ min \} <= \$$$_{ name }\{ value \} : 1 ) ) {
        print \$fh \"\$$$_{ name }\{ value \}\\n\";
    } else {
        print \$fh \"$$_{ def_value }\\n\";
    }
";
        } elsif ( $$_{ type } =~ /^float$/o ) {
            print "
    if ( \$$$_{ name }\{ value \} =~ /^[+-]?((\\d+(\\.(\\d+)?)?)|(\\.\\d+))([eE][+-]?\\d+)?\$/o and
         ( defined \$$$_{ name }\{ max \} ? \$$$_{ name }\{ max \} >= \$$$_{ name }\{ value \} : 1 ) and
         ( defined \$$$_{ name }\{ min \} ? \$$$_{ name }\{ min \} <= \$$$_{ name }\{ value \} : 1 ) ) {
        print \$fh \"\$$$_{ name }\{ value \}\\n\";
    } else {
        print \$fh \"$$_{ def_value }\\n\";
    }
";
        } elsif ( $$_{ type } =~ /^button$/o ) {
			print "
    print \$fh \"\$$$_{ name }\{ value \}\\n\";
";
        } elsif ( $$_{ type } =~ /^menu$|file/o ) {
            print "
    print \$fh \"\$$$_{ name }\{ value \}\\n\";
";
        }
    }
    print "
    print \$fh \"\$fsc2_how_to_run\\n\";

";

    print <<'EOT';
	print $fh "$geom\n" if defined $geom;

    close $fh;
};


################################################################

sub load_defs {
    my $fh;
    my $name = $0;
    my $ne;
    my $found;

    $name =~ s|^.*?([^/]+)$|$1|;
    if ( $ARGV[ 0 ] ) {
        open( $fh, "<$ARGV[ 0 ]" ) or return;
    } else {
        open( $fh, "<$ENV{ HOME }/.fsc2/$name" ) or return;
    }

    goto done_reading unless defined( $ne = <$fh> ) and $ne =~ /^#/;
EOT

    for ( @vars ) {
        if ( $$_{ type } =~ /^int$/o ) {
            print "
    goto done_reading unless defined( \$ne = <\$fh> )
        and \$ne =~ /^[+-]?\\d+\$/;
    chomp \$ne;
    goto done_reading if ( defined \$$$_{ name }\{ max \} and \$ne > \$$$_{ name }\{ max \} ) or
                         ( defined \$$$_{ name }\{ min \} and \$ne < \$$$_{ name }\{ min \} );
    \$$$_{ name }\{ value \} = \$ne;
";
        } elsif ( $$_{ type } =~ /^float$/o ) {
            print "
    goto done_reading unless defined( \$ne = <\$fh> )
        and \$ne =~ /^[+-]?((\\d+(\\.(\\d+)?)?)|(\\.\\d+))([eE][+-]?\\d+)?\$/o;
    chomp \$ne;
    goto done_reading if ( defined \$$$_{ name }\{ max \} and \$ne > \$$$_{ name }\{ max \} ) or
                         ( defined \$$$_{ name }\{ min \} and \$ne < \$$$_{ name }\{ min \} );
    \$$$_{ name }\{ value \} = \$ne;
";
        } elsif ( $$_{ type } =~ /^menu$/o ) {
            print"
    goto done_reading unless defined( \$ne = <\$fh> );
    chomp \$ne;
    \$found = 0;
    for ( \@$$_{ name } ) {
        if ( \$ne eq \$_) {
            \$found = 1;
            last;
        }
    }
    goto done_reading unless \$found;
    \$$$_{ name }\{ value \} = \$ne;
";
        } elsif ( $$_{ type } =~ /^button$/o ) {
            print "
    goto done_reading unless defined( \$ne = <\$fh> ) and \$ne =~ /^1|0\$/o;
    chomp \$ne;
    \$$$_{ name }\{ value \} = \$ne;
";
        } elsif ( $$_{ type } =~ /^file$/o ) {
            print "
    goto done_reading unless defined( \$ne = <\$fh> );
    chomp \$ne;
    \$$$_{ name }\{ value \} = \$ne;
";
        }
    }

    print <<'EOT';

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @fsc2_how_to_run ) {
        if ( $ne eq $_) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $fsc2_how_to_run = $ne;

    goto done_reading unless defined( $ne = <$fh> )
							 and $ne =~ /^\s*([+-]\d+[+-]\d+)\s*$/;
	$geom = $1;

  done_reading:
    close $fh;
};
EOT

	# Append the code for a file selector if it's going to be needed

	if ( $need_file_sel ) {
		print <<'EOT';


################################################################
# Package for showing a file selector

package fsc2_filesel;

use Tk;
use strict;
use warnings;

my $cur_dir;
my $cur_file;

BEGIN {
    $cur_dir = `pwd`;
    chomp $cur_dir;
}

sub show {
    my ( $top, $file ) = @_;

    my $selected = undef;

    if ( defined $file and $file =~ m|^((.*?)/)?([^/]+)$|o ) {
        $cur_file = $3;
        $cur_dir = $2 ne "" ? $2 : $1 if defined $1;
    } else {
        $cur_file = "";
    }

    my %fs;

    $fs{ top } = $top->Toplevel( '-title' => 'File Select' );
    $fs{ top }->grab;
    $fs{ dir } = $fs{ top }->Entry( -textvariable => \$cur_dir,
                                    -width => 35
                                  )->pack( -side => 'top',
                                           -fill => 'x',
                                           -padx => '2m',
                                           -pady => '1m',
                                         );
    $fs{ list } = $fs{ top }->Scrolled( 'Listbox',
                                        -selectmode => 'single',
                                        -scrollbars => 'osoe',
                                      )->pack( -side => 'top',
                                               -fill => 'both',
                                               -anchor => 's',
                                               -padx => '2m',
                                               -pady => '1m',
                                               -expand => 1 );
    populate_fs( $fs{ list }, $cur_dir );
    $fs{ file } = $fs{ top }->Entry( -textvariable => \$cur_file
                                   )->pack( -side => 'top',
                                            -fill => 'x',
                                            -padx => '2m',
                                            -pady => '1m'
                                          );
    $fs{ frame } = $fs{ top }->Frame( )->pack( -side => 'bottom' );
    $fs{ frame }->Button( -text => 'Cancel',
                          -command => sub { $selected = "" }
                        )->pack( -side => 'left',
                                 -padx => '2m',
                                 -pady => '1m'
                               );
    $fs{ frame }->Button( -text => 'Rescan',
                          -command => [ \&populate_fs, $fs{ list },
                                        $cur_dir ]
                        )->pack( -side => 'left',
                                 -padx => '2m',
                                 -pady => '1m'
                                             );
    $fs{ frame }-> Button( -text => '  Ok  ',
                           -command => sub { $selected = $cur_file }
                         )->pack( -side => 'right',
                                  -padx => '2m',
                                  -pady => '1m'
                                );
    $fs{ list }->bind( '<ButtonPress-1>' =>
                       [ \&new_selection, $fs{ list }, Ev( 'y' ) ] );
    $fs{ top }->bind( '<ButtonPress-4>' =>
                       sub { $fs{ list }->yview( scroll => -1, 'units' ) } );
    $fs{ top }->bind( '<Up>' =>
                       sub { $fs{ list }->yview( scroll => -1, 'units' ) } );
    $fs{ top }->bind( '<Prior>' =>
                       sub { $fs{ list }->yview( scroll => -1, 'page' ) } );
    $fs{ top }->bind( '<ButtonPress-5>' =>
                       sub { $fs{ list }->yview( scroll => 1, 'units' ) } );
    $fs{ top }->bind( '<Down>' =>
                       sub { $fs{ list }->yview( scroll => 1, 'units' ) } );
    $fs{ top }->bind( '<Next>' =>
                       sub { $fs{ list }->yview( scroll => 1, 'page' ) } );
    $fs{ top }->bind( '<Home>' => sub { $fs{ list }->yview( 0 ) } );
    $fs{ top }->bind( '<End>' =>
                      sub { $fs{ list }->yview( $fs{ list }->size - 1 ) } );
    $fs{ top }->bind( '<Escape>' => sub { $selected = "" } );
    $fs{ top }->bind( '<Return>' => sub { $selected = $cur_file } );
    $fs{ top }->bind( '<Tab>' =>
                      sub { populate_fs( $fs{ list }, $cur_dir ) } );

    $fs{ top }->waitVariable( \$selected );
    $fs{ top }->destroy;
    return undef if $selected =~ /^$/o;
    if ( $cur_dir =~ m|^/$|o ) {
        return "/$selected";
    } else {
        return "$cur_dir/$selected";
    }
}


################################################################

sub new_selection {
    my ( $d, $l, $y ) = @_;
    my $sel = $l->get( $l->nearest( $y ) );

    if ( $sel =~ /^d (.*)$/o ) {
        my $dir = $1;
        $cur_file = "";
        return if $dir =~ /^\.$/o;
        if ( $dir =~ /^\.\.$/o ) {
            $cur_dir =~ s|^(.*?)/[^/]+$|$1|;
            $cur_dir = "/" if $cur_dir =~ /^$/o;
            populate_fs( $l, $cur_dir );
        }
        else {
            if ( $cur_dir =~ m|^/$|o ) {
                $cur_dir .= "$dir";
            } else {
                $cur_dir .= "/$dir";
            }
            populate_fs( $l, $cur_dir );
        }
    } else {
        $cur_file = $sel;
        $cur_file =~ s/^[l ] (.*)$/$1/o;
    }
}


################################################################

sub populate_fs {
    my ( $list, $dir ) = @_;

    $list->delete( 0, 'end' );
    my @ls = `ls -a $dir`;
    for ( @ls ) {
        chomp;
        next unless -d "$dir/$_";
        $list->insert( 'end', "d $_" );
        undef $_;
    }

    for ( @ls ) {
        $list->insert( 'end', "  $_" ) if defined;
    }
}

1;
EOT
	}
}
