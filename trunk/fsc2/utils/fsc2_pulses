#!/usr/bin/perl
# -*- cperl -*-
#
# $Id$
#
# Copyright (C) 1999-2003 Jens Thoms Toerring
#
# This file is part of fsc2.
#
# Fsc2 is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# Fsc2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with fsc2; see the file COPYING.  If not, write to
# the Free Software Foundation, 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

# This script allows to display the pulse settings during an experiment.
# It takes the output of the pulser_dump_pulses() EDL function (or gets
# invoked directly by the pulser_show_pulses() function) and draws a
# graphical representation of the pulses. Using buttons in the window,
# the mouse buttons or the keyboard one can move through all pulse
# settings during the experiment (at least as far as fsc2 can figure
# them out from the test run).
#
# Key bindings:
# Page Up:     next pulse settings
# Page Down:   previous pulse settings
# Home:        initial pulse settings
# End:         final pulse settings
# Cursor keys: move around in the canvas if it doesn't completely fit into
#              the window
# Control-D:   toggle on/off displaying settings with delays
# Control-Q:   quit program
# Control-L:   redraw
#
# Mouse bindings:
# Middle button: next pulse settings
# Right button:  previous pulse settings
# Scroll up:     next pulse settings
# Scroll down:   previous pulse settings
#
# Please note that this script may use lots of memory and also may take
# quite some time before it starts displaying the pulses.


use warnings;
use strict;
use Tk;


my @version = split /\./, $Tk::VERSION;
die "Installed Perl-Tk version is $Tk::VERSION but Tk800.022 is required.\n"
    if $version[ 0 ] + 0.001 * $version[ 1 ] < 800.022;

my ( $line, $time_base, $Delay, $has_auto_pulses );
my $verbose = 0;
my $Channels = Channels->new;
my @Function_Names = qw( MW PULSE_SHAPE PHASE_1 PHASE_2 TWT TWT_GATE
						 DEFENSE DETECTION DETECTION_GATE RF RF_GATE
						 OTHER_1 OTHER_2 OTHER_3 OTHER_4 );


read_input( );
Pulse_Window->new;
MainLoop;


#---------------------------------------------------------

sub usage{

	print "Usage: fsc2_pulse [ file ]\n" .
		"    Utility to display the pulse settings of an EDL program using\n" .
		"    the output produced by the pulser_dump_pulses() EDL function.\n" .
		"    Use the -v option to get error messages.\n";
	exit 0;
}

#---------------------------------------------------------

sub read_input {

	my $if = *STDIN;
	my ( $set, $old_set ) = ( "", "" );


	# Deal with command line arguments

	if ( $ARGV[ 0 ] && $ARGV[ 0 ] =~ /^--?v(erbose)?$/ ) {
		$verbose = 1;
		shift @ARGV;
	}

	if ( $ARGV[ 0 ] ) {
		usage( ) if $ARGV[ 0 ] =~ /^--?h(elp)?$/;
		open( $if, "<" . $ARGV[ 0 ] )
			or fail( "Can't open input file " . $ARGV[ 0 ] . ": $!\n" );
	}

	# Read the time base

	defined( $line = <$if> )
		or fail(  "Premature end of input at line $..\n" );
	$line =~ /^TB: (\d+(\.\d+)?([eE][+-]?\d+)?)$/
		or fail( "Invalid input at line $..\n" );
	$time_base = $1;

	# Read the total amount of (negative) delay

	defined( $line = <$if> )
		or fail( "Premature end of input at line $..\n" );
	$line =~ /^D: (\d+)$/
		or fail( "Invalid input at line $..\n" );
	$Delay = $1;

	defined( $line = <$if> ) or fail( "Premature end of input at line $..\n" );
	$line =~ /^===$/ or fail( "Invalid input at line $..\n" );

	# Read the function/channel information

  CHANNEL_LINE:
	while( 1 ) {
		defined ( $line = <$if> )
			or fail( "Premature end of input at line $..\n" );
		last if $line =~ /^===$/;

		for ( my $i = 0; $i < @Function_Names; $i++ ) {
			if ( $line =~
				 /^($Function_Names[ $i ])(:((([A-H]|CH)?\d+)|TRIG))? ([+-]?\d+)( I)?$/ ) {
				$Channels->add_channel( \$Function_Names[ $i ], $2, $5,
										defined $6 ? 1 : 0 );
				next CHANNEL_LINE;
			}
		}

		fail( "Invalid input at line $..\n" );
	}

	# Read all pulse settings, skipping settings that are identical to the
	# previous one

	$has_auto_pulses = 0;
	my $num = 0;
	while( 1 ) {
		last unless defined ( $line = <$if> );

		if ( $line =~ /^===$/ ) {
			next if $set eq $old_set;

			$has_auto_pulses |= new_pattern( $set, $num );
			$old_set = $set;
			$set ="";
			$num++;
			next;
		}
		$set .= $line;
	}

	$has_auto_pulses |= new_pattern( $set, $num )
		if $set ne "";

	fail( "No pulses patterns defined in input.\n" ) unless
			$Channels->num_channels > 0 and $Channels->num_steps >= 0;
}

#---------------------------------------------------------

sub new_pattern {

	my ( $set, $num ) = @_;
	my $has_auto_pulses = 0;

	for ( split /\n/, $set ) {
		$has_auto_pulses = 1 if /\(\d+\)/;
		my @bits = split /\s+/;
		fail( "Invalid input at line $..\n" ) unless $#bits % 3 == 0;
		$Channels->add_pulse_list( $num, @bits );
	}

	return $has_auto_pulses;
}


#---------------------------------------------------------

sub fail {
	die shift if $verbose;
	exit 1;
}


#=========================================================================
# Creates and manages the window for displaying the pulses

package Pulse_Window;

sub new {
	my $inv = shift;
	my $class = ref( $inv ) || $inv;
	my $self = { 'top'   => MainWindow->new,
				 'dw'    => undef,
			     'step'  => 0,
				 'mag'   => 2,
				 'hstep' => 72,
				 'delay' => 0,
				 'delta' => 10,
				 'shft'  => 0,
				 'len'   => 0 };

	bless $self, $class;
	$self->init;
	return $self;
}

#---------------------------------------------------------
# Initializes the pulse window (and in turn the window for displaying
# pulse properties)

sub init {

	my $self = shift;

	$self->top->title( "Fsc2_pulses:  " . $ARGV[ 0 ] ) if $ARGV[ 0 ];

	# Find start of the very first pulse (including delays)

	defined $self->offset( $Channels->first_pulse )
		or fail( "No pulses found in input.\n" );

	# Calculate width of window to display *all* data (with and without
	# delays)

	my $h = $Channels->num_channels * $self->hstep + 80;
	my @wx = $Channels->longest_sequence;

	my $w = $self->mag * ( ( $wx[ 0 ] > $wx[ 1 ] ? $wx[ 0 ] : $wx[ 1 ] )
						   - $self->offset );

	# Blow up magnification if the pulse sequence is very short, if it's
	# very long reduce the magnification factor or to avoid strange artefacts.

	while ( $w < 400 ) {
		$w *= 2;
		$self->mag( 2 * $self->mag );
	}
	while ( $w >= 16000 ) {
		$w *= 0.5;
		$self->mag( 0.5 * $self->mag );
	}

	# Determine distance between vertical lines

	$self->delta( 25 ) if $self->mag * $self->delta < 50;
	$self->delta( 2 * $self->delta ) while $self->mag * $self->delta < 50;

	# Determine how much we must shift the pulses to the right in order to
	# be able to start the scale with a multiple of the distance of the
	# vertical lines

	$self->shft( $self->mag * ( $self->offset - $Delay -
		   int( ( $self->offset - $Delay ) / $self->delta ) * $self->delta ) );
	$self->shft( $self->shft + $self->mag * $self->delta )
		while $self->shft < 0;

	$w += $self->shft;
	$self->len( $w );

	my $height = $h;
	$height *= 0.75 while ( $height > 650 );

	# Reduce window size to something reasonable if necessary

	my $width = $w + 170;

	my @maxsize = $self->top->maxsize;
	$width = 0.75 * $maxsize[ 0 ] if $width > 0.75 * $maxsize[ 0 ];

	# Create a frame and with an embedded (scrolled) canvas

	my $f1 = $self->top->Frame;
	$self->{ 'canvas' } =
		$f1->Scrolled( 'Canvas',
					   '-relief'       => 'sunken',
					   '-scrollbars'   => 'osoe',
					   '-bd'           => 1,
					   '-width'        => $width,
					   '-height'       => $height,
					   '-background'   => 'black',
					   '-scrollregion' => [ 0, 0, $w + 170, $h ] );
	$self->top->bind( '<Left>' => sub {
						  $self->{ 'canvas' }->xviewScroll( -1, 'unit' ); } );
	$self->top->bind( '<Right>' => sub {
						  $self->{ 'canvas' }->xviewScroll( 1, 'unit' ); } );
	$self->top->bind( '<Up>' => sub {
						  $self->{ 'canvas' }->yviewScroll( -1, 'unit' ); } );
	$self->top->bind( '<Down>' => sub {
						  $self->{ 'canvas' }->yviewScroll( 1, 'unit' ); } );

	# Create a second frame with the buttons etc.

	my $f2 = $self->top->Frame;
	$self->{ 'delay_button' } =
		$f2->Checkbutton( '-state'    => 'active',
						  '-text'     => 'Show delays',
						  '-variable' => \$self->{ 'delay' },
						  '-command'  => sub { $self->draw_scale;
											   $self->redraw } );
	my $f3 = $f2->Frame;
	$self->{ 'step_label' } = $f3->Label( '-text' => 'Step:' );
	$self->{ 'step_ffb' } =
		$f3->Button( '-text'    => '<<',
					 '-width'   => '1',
					 '-command' => sub { $self->pshift( -1, 1 ) } );
	$self->{ 'step_fb' } =
		$f3->Button( '-text'    => '<',
					 '-width'   => '1',
					 '-command' => sub { $self->pshift( -1 ) } );
	$self->{ 'step_entry' } =
		$f3->Entry( '-textvariable'    => \$self->{ 'step' },
					'-width'           => 6,
					'-validate'        => 'key',
					'-validatecommand' => sub { my $n = shift;
											return 1 if $n eq "";
											return 0 unless $n =~ /^\d+$/;
											return ( $n >= 0 and
											  $n <= $Channels->num_steps ) } );
	$self->{ 'step_fw' } =
		$f3->Button( '-text'    => '>',
					 '-width'   => '1',
					 '-command' => sub { $self->pshift( 1 ) } );
	$self->{ 'step_ffw' } =
		$f3->Button( '-text'    => '>>',
					 '-width'   => '1',
					 '-command' => sub { $self->pshift( 1, 1 ) } );
	$self->{ 'close_button' } =
		$f2->Button( '-text'   => 'Close',
					 'command' => [ destroy => $self->top ] );

	$f2->pack( '-side'  => 'bottom',
			   '-fill'  => 'x' );
	$self->{ 'delay_button' }->pack( '-side' => 'left',
									 '-padx' => '4m',
									 '-pady' => '2m' );
	$f3->pack( '-side' => 'left',
			   '-padx' => '15m',
			   '-pady' => '2m',
			   '-fill' => 'x' );
	$self->{ 'step_label'   }->pack( '-side' => 'left',
									 '-padx' => '3m' );
	$self->{ 'step_ffb'     }->pack( '-side' => 'left' );
	$self->{ 'step_fb'      }->pack( '-side' => 'left' );
	$self->{ 'step_entry'   }->pack( '-side' => 'left',
									 '-padx' => '2m' );
	$self->{ 'step_fw'      }->pack( '-side' => 'left' );
	$self->{ 'step_ffw'     }->pack( '-side' => 'left' );
	$self->{ 'close_button' }->pack( '-side' => 'right',
									 '-padx' => '4m',
									 '-pady' => '2m' );

	# Pack the canvas frame only now, otherwise on reducing the window height
	# the frame with the buttons gets crushed while the canvas frame keeps
	# its size even though it's scrollable...

	$f1->pack( '-fill'   => 'both',
			   '-expand' => 1 );
	$self->{ 'canvas' }->pack( '-side'   => 'top',
							   '-fill'   => 'both',
							   '-expand' => 1 );
	$self->{ 'dw' } = Display_Window->new( $self->top );

	# Lots of key bindings...

    $self->{ 'canvas' }->CanvasBind( '<Button-2>' => sub {
										 $self->pshift( 1 ) } );
    $self->{ 'canvas' }->CanvasBind( '<Button-4>' => sub {
										 $self->pshift( 1 ) } );
    $self->{ 'canvas' }->CanvasBind( '<Button-3>' => sub {
										 $self->pshift( -1 ) } );
    $self->{ 'canvas' }->CanvasBind( '<Button-5>' => sub {
										 $self->pshift( -1 ) } );
	$self->top->bind( '<End>' => sub { $self->pshift( -1, 1 ) } );
	$self->top->bind( '<Home>' => sub { $self->pshift( 1, 1 ) } );
	$self->top->bind( '<Prior>' => sub { $self->pshift( 1 ) } );
	$self->top->bind( '<Next>' => sub { $self->pshift( -1 ) } );
	$self->top->bind( '<Control-d>' => sub { $self->{ 'delay' } ^= 1;
											 $self->draw_scale;
											 $self->redraw } );
	$self->top->bind( '<Control-q>' => [ destroy => $self->{ 'top' } ] );
	$self->{ 'step_entry' }->bind( '<Return>' => sub {
											 return if $self->{ 'step' } eq "";
											 $self->redraw; } );
	$self->{ 'step_entry' }->bind( '<KP_Enter>' => sub {
											 return if $self->{ 'step' } eq "";
											 $self->redraw; } );

	# There are sometimes problems with the automatic redraw, if they get
	# solved the next binding becomes completely useless...

	$self->top->bind( '<Control-l>' => sub{ $self->primary_draw } );

	# Draw the canvas in the initial state

	$self->primary_draw;
}

#---------------------------------------------------------

sub top {
	return shift->{ 'top' };
}

#---------------------------------------------------------

sub dw {
	return shift->{ 'dw' };
}

#---------------------------------------------------------

sub offset {
	my ( $self, $val ) = @_;

	$self->{ 'offset' } = $val if defined $val;
	return $self->{ 'offset' };
}

#---------------------------------------------------------

sub mag {
	my ( $self, $val ) = @_;

	$self->{ 'mag' } = $val if defined $val;
	return $self->{ 'mag' };
}

#---------------------------------------------------------

sub step {
	my ( $self, $val ) = @_;

	$self->{ 'step' } = $val if defined $val;
	return $self->{ 'step' };
}

#---------------------------------------------------------

sub hstep {
	my ( $self, $val ) = @_;

	$self->{ 'hstep' } = $val if defined $val;
	return $self->{ 'hstep' };
}

#---------------------------------------------------------

sub delay {
	my ( $self, $val ) = @_;

	$self->{ 'delay' } = $val if defined $val;
	return $self->{ 'delay' };
}

#---------------------------------------------------------

sub shft {
	my ( $self, $val ) = @_;

	$self->{ 'shft' } = $val if defined $val;
	return $self->{ 'shft' };
}

#---------------------------------------------------------

sub len {
	my ( $self, $val ) = @_;

	$self->{ 'len' } = $val if defined $val;
	return $self->{ 'len' };
}

#---------------------------------------------------------

sub delta {
	my ( $self, $val ) = @_;

	$self->{ 'delta' } = $val if defined $val;
	return $self->{ 'delta' };
}

#---------------------------------------------------------
# Function for changing the currently displayed step - gets either one or two
# arguments.  If there's only one it's the change of the step, if there are
# two switch either to the very first (if the first argument is negative) or
# the very last step (if the first argument is positive).

sub pshift {

	my ( $self, $delta, $special ) = @_;

	if ( ! defined $special ) {
		return if $self->step eq "";
		$self->step( $self->step + $delta );
		$self->step( 0 ) if $self->step + $delta < 0;
		$self->step( $Channels->num_steps )
			if $self->step + $delta > $Channels->num_steps;
	} else {
		$self->step( 0 ) if $delta < 0;
		$self->step( $Channels->num_steps ) if $delta > 0;
	}

	$self->redraw;
}

#---------------------------------------------------------
# Draws everything: First the scale with the vertical lines, then the channel
# names and the horizontal limes and finally calls the function to draw the
# pulses.

sub primary_draw {

	my $self = shift;
	my $c = $self->{ 'canvas' };

	$self->draw_scale;
	my $x1 = 150;
	my $x2 = 160 + $self->len;

	for ( my $i = 0; $i < $Channels->num_channels; $i++ ) {
		my $ch = $Channels->find_by_num( $i );

		my $y = 10 + ( $i + 0.5 ) * $self->hstep;
		$c->create( 'text', 10, $y,
					'-anchor' => 'w',
					'-text'   => $ch->key,
					'-fill'   => 'green' );

		$y -= 0.5 * $ch->inv * $self->hstep;
		$c->create( 'line', $x1, $y, $x2, $y, '-fill' => 'white' );
	}

	$self->redraw( );
}

#---------------------------------------------------------
# Draws the time scale below the pulses

sub draw_scale {

	my $self = shift;
	my $c = $self->{ 'canvas' };
	my $factor;
	my $unit;


	$self->{ 'canvas' }->delete( 'scale' );

	my $x1 = 150;
	my $x2 = 160 + $self->len;
	my $y1 = 10 + ( $Channels->num_channels + 0.2 ) * $self->hstep;

	$c->create( 'line', $x1, $y1, $x2, $y1,
				'-fill' => 'yellow',
				'-tags' => 'scale' );

	$y1 += 10;
	my $y2 = 10;

	if ( $time_base <= 5.0e-9 ) {
		$factor = 1.0e9;
		$unit = "ns";
	} elsif ( $time_base < 5.0e-6 ) {
		$factor = 1.0e6;
		$unit = "us";
	} elsif ( $time_base <= 5.0e-3 ) {
		$factor = 1.0e3;
		$unit = "ms";
	} else {
		$factor = 1.0;
		$unit = "s";
	}

	# $cx is the starting value to print at the vertical lines, which should
	# be a "round" number. The 'shft' member tells how much the pulses have
	# to be moved to be drawn at the correct position for the scale.

	my $cx = ( $self->offset - $Delay ) / $self->delta;
	if ( $cx != int( $cx ) ) {
		$cx = int( $cx ) - 1;
	}
	$cx *= $self->delta;

	while ( $x1 <= $x2 - 5 ) {
		$c->create( 'line', $x1, $y1, $x1, $y2,
					'-fill' => 'yellow',
					'-tags' => 'scale',
					'-dash' => [ 2, 4 ] );
		$c->create( 'text', $x1, $y1 + 10,
					'-text' => $cx * $factor * $time_base . $unit,
					'-fill' => 'green',
					'-tags' => 'scale' );
		$x1 += $self->mag * $self->delta;
		$cx += $self->delta;
	}
}

#---------------------------------------------------------
# Function redraws all pulses (after deleting existing ones) for the
# current value of 'step'.

sub redraw {

	my $self = shift;
	my $c = $self->{ 'canvas' };

	$self->dw->Leave;

	for ( my $i = 0; $i < $Channels->num_channels; $i++ ) {
		my $ch = $Channels->find_by_num( $i );
		my $j = $self->step;
		$j-- while $j > 0 and ! defined $ch->get_pulse_list( $j );

		$c->delete( $ch->key );
		my $pl = $ch->get_pulse_list( $j );

		my $y1 = 10 + ( $i + 0.5 ) * $self->hstep;
		my $y2 = 10 + $i * $self->hstep;
		my $yt = 10 + ( $i + 0.75 ) * $self->hstep;

		for my $cp ( @$pl ) {
			next if $cp->len == 0;
			my $x1 = $cp->start - $self->offset - $ch->delay + $Delay;
			my $x2 = $cp->start + $cp->len - $self->offset
					 - $ch->delay + $Delay;

			if ( $self->{ 'delay' } ) {
				$x1 += $ch->delay - $Delay;
				$x2 += $ch->delay - $Delay;
			}

			$x1 = 150 + $self->mag * $x1 + $self->shft;
			$x2 = 150 + $self->mag * $x2 + $self->shft;

			my $tag = $ch->key . ":" . $cp->num;
			$c->create( 'rectangle', $x1, $y2, $x2, $y1,
						'-tags'    => [ $ch->key, $tag ],
						'-outline' => 'white',
						'-fill'    => 'red' );
			$c->bind( $tag, '<Enter>' => sub {
						  $self->dw->Enter( $tag, $self->step,
											$self->delay ); } );
			$c->bind( $tag, '<Leave>' => sub { $self->dw->Leave; } );

			$c->create( 'text', 0.5 * ( $x1 + $x2 ), $yt,
						'-text' => $cp->num,
						'-tags' => $ch->key,
						'-fill' => 'green' );
		}
	}
}

1;


#=========================================================================
# Creates and manages the window for displaying the pulse parameters

package Display_Window;

sub new{

	my ( $inv, $mw ) = @_;
	my $class = ref( $inv ) || $inv;
	my $self = { 'w' => $mw->Toplevel,
			     'num'  => '',
			     'pos'  => '',
			     'len'  => '',
				 'func' => '',
				 'ch'   => '',
				 'dp'   => '',
				 'dn'   => '',
			     'pp'   => '',
			     'pl'   => '',
				 'pc'   => '',
				 'pf'   => '' };

	bless $self, $class;
	$self->init;
	return $self;
}

#---------------------------------------------------------
# Initializes the window for displaying pulse properties

sub init {

	my $self = shift;

	$self->{ 'w' }->title( "Pulse parameters" .
						   ( $ARGV[ 0 ] ? ":  $ARGV[ 0 ]" : "" ) );

	my $F = $self->{ 'w' }->Frame( '-relief'     => 'ridge',
								   'borderwidth' => '1m' );
	my $f = $F->Frame;
	my $l = $f->Label( '-text'   => 'Pulse number: ',
					   '-width'  => 20,
					   '-anchor' => 'w' );
	my $e = $f->Entry( '-textvariable' => \$self->{ 'num' },
						'-width'       => 20,
						'-relief'      => 'flat' );
	$f->pack( '-side'  => 'top',
			  '-padx'  => 2,
			  '-pady'  => 2 );
	$l->pack( '-side'  => 'left' );
	$e->pack( '-side'  => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text'   => 'Pulse position: ',
					'width'   => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'pos' },
					 '-width'       => 20,
					 '-relief'      => 'flat' );
	$f->pack( '-side'  => 'top',
			  '-padx'  => 2,
			  '-pady'  => 2 );
	$l->pack( '-side'  => 'left' );
	$e->pack( '-side'  => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text'         => 'Pulse length: ',
					'-width'        => 20,
					'-anchor'       => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'len' },
					 '-width'       => 20,
					 '-relief'      => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text'   => 'Pulse function: ',
					'-width'  => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'func' },
					 '-width'       => 20,
					 '-relief'      => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text'   => 'Pulse pod/channel: ',
					'-width'  => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'ch' },
					 '-width'       => 20,
					 '-relief'      => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$F->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );


	$F = $self->{ 'w' }->Frame( '-relief'      => 'ridge',
								'-borderwidth' => '1m' );

	$f = $F->Frame;
	$l = $f->Label( '-text'   => 'Distance to previous: ',
					'-width'  => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'dp' },
					'-width'        => 20,
					'-relief'       => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text'   => 'Distance to next: ',
					'-width'  => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'dn' },
					'-width'        => 20,
					'-relief'       => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$F->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );

	$F = $self->{ 'w' }->Frame( '-relief'      => 'ridge',
								'-borderwidth' => '1m' );

	# The field for showing parameters of parent pulses is only needed
	# if there are automatically created pulses

	return unless $has_auto_pulses;

	$f = $F->Frame;
	$l = $f->Label( '-text'   => 'Position of parent: ',
					'-width'  => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'pp' },
					'-width'        => 20,
					'-relief'       => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text'   => 'Length of parent: ',
					'-width'  => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'pl' },
					'-width'        => 20,
					'-relief'       => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text'   => 'Function of parent: ',
					'-width'  => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'pf' },
					'-width'        => 20,
					'-relief'       => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text'   => 'Pod/channel of parent: ',
					'-width'  => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'pc' },
					'-width'        => 20,
					'-relief'       => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$F->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );
}

#---------------------------------------------------------
# Displays the pulse parameters when the mouse is moved onto a pulse

sub Enter {

	my ( $self, $tag, $step, $is_delay ) = @_;
	my ( $f, $ch, $num ) = split /:/, $tag;

	my $pod = $Channels->find_by_key( $f . ":" . $ch );

	my $j = $step;
	$j-- while $j > 0 and ! defined $pod->get_pulse_list( $j );

	my $pl = $pod->get_pulse_list( $j );

	my $i;
	for ( $i = 0; exists $pl->[ $i ]; $i++ ) {
		last if $pl->[ $i ]->num eq $num;
	}

	my $cp = $pl->[ $i ];
	my $pp = $i > 0 ? $pl->[ $i - 1 ] : undef;
	my $np = exists( $pl->[ $i + 1 ] ) ? $pl->[ $i + 1 ] : undef;

	my ( $p1, $p2 ) = $self->pstart( $cp->start, $pod, $is_delay );

	$self->{ 'pos' } = $p1;
	$self->{ 'pos' } .= "  (" . $p2 . ")" if $p1 ne $p2;
	$self->{ 'len' } = $self->ptime( $cp->len );

	$self->{ 'func' } = $f;
	$self->{ 'ch' } = $ch;

	$self->{ 'dp' } = defined( $pp ) ?
				$self->ptime( $cp->start - $pp->start - $pp->len ) . "  (" .
				$self->ptime( $cp->start - $pp->start
							  + 0.5 * ( $cp->len - $pp->len ) ) .")" : '';
	$self->{ 'dn' } = defined( $np ) ?
				$self->ptime( $np->start - $cp->start - $cp->len ) . "  (" .
				$self->ptime( $np->start - $cp->start
							  + 0.5 * ( $np->len - $cp->len ) ) .")" : '';

	if ( $num =~ /^\((\d+)\)$/ ) {
		$self->{ 'num' } = $num . "    [auto]";
		$self->parent( $1, $step, $is_delay );
	}
	else {
		$self->{ 'num' } = $num;
	}

}

#---------------------------------------------------------
# Displays the parameters of the parent of an automatically created pulse

sub parent {

	my ( $self, $pp, $step, $is_delay ) = @_;
	my ( $pod, $cp, $pl );

	$cp = undef;
	for ( my $i = 0; $i < $Channels->num_channels; $i++ ) {
		$pod = $Channels->find_by_num( $i );
		my $j = $step;
		$j-- while $j > 0 and ! defined $pod->get_pulse_list( $j );
		$pl = $pod->get_pulse_list( $j );

		for $j ( @$pl ) {
			next unless $j->num eq $pp ;
			$cp = $j;
			last;
		}

		last if defined $cp;
	}

	my ( $p1, $p2 ) = $self->pstart( $cp->start, $pod, $is_delay );

	$self->{ 'pp' } = $p1;
	$self->{ 'pp' } .= "  (" . $p2 . ")" if $p1 ne $p2;
	$self->{ 'pl' } = $self->ptime( $cp->len );

	$self->{ 'pf' } = $pod->name;
	$self->{ 'pc' } = $pod->num;
}

#---------------------------------------------------------
# Returns the starting point of a pulse with and without delay (which of
# both comes first is determined by the $delayed_first argument)

sub pstart {

	my ( $self, $ticks, $ch, $delayed_first ) = @_;

	return ( $self->ptime( $ticks - $Delay ),
			 $self->ptime( $ticks - $ch->delay ) ) if $delayed_first;

	return ( $self->ptime( $ticks - $ch->delay ),
			 $self->ptime( $ticks - $Delay ) );
}

#---------------------------------------------------------
# Returns a string with a pulse position or length with in resonable units

sub ptime {

	my ( $self, $ticks ) = @_;

	my $t = $ticks;

	if ( $t * $time_base < 1e-5 ) {
		return $t * $time_base * 1e9 . " ns";
	} elsif ( $t * $time_base < 1e-2 ) {
		return sprintf "%.3f us", $t * $time_base * 1e6;
	} else {
		return sprintf "%.6f ms", $t * $time_base * 1e3;
	}

	return "";
}

#---------------------------------------------------------
# Clears all entries in the display window when the mouse is moved away
# from a pulse

sub Leave {
	my $self = shift;

	for ( keys %{ $self } ) {
		next if /^w$/;
		$self->{ $_ } = '';
	}
}

1;


#=========================================================================
# Topmost data object: deals with all channels

package Channels;

sub new {
	my $inv = shift;
	my $class = ref( $inv ) || $inv;
	my $self = { 'channels'     => [ ],
				 'num_steps'    => -1 };
	return bless $self, $class;
}

#---------------------------------------------------------
# Appends a new channel to the list of channels

sub add_channel {

	my $self = shift;
	push @{ $self->{ 'channels' } }, Channel->new( @_ );
}

#---------------------------------------------------------
# Returns the channel object according to its position in the list of channels

sub find_by_num {

	my ( $self, $num ) = ( shift, shift );
	return undef if $num >= @{ $self->{ 'channels' } };
	return $self->{ 'channels' }[ $num ];
}

#---------------------------------------------------------
# Returns a channel object according to the key of the channel (the key is
# the combination of function name and channel designator, separated by a
# colon).

sub find_by_key {

	my ( $self, $key ) = ( shift, shift );

	for ( @{ $self->{ 'channels' } } ) {
		return $_ if $_->key =~ /^$key$/;
	}

	return undef;
}

#---------------------------------------------------------
# Returns the total number of channels

sub num_channels {
	return scalar( @{ shift->{ 'channels' } } );
}

#---------------------------------------------------------
# Return the number of steps during the experiment

sub num_steps {
	return shift->{ 'num_steps' }
}

#---------------------------------------------------------
# Adds a new set of pulses to the channel indicated by the $key argument
# for a new step of the experiment

sub add_pulse_list {

	my ( $self, $step, $key ) = ( shift, shift, shift );
	my $ch = $self->find_by_key( $key );

	fail( "Invalid input at line $..\n" ) unless defined $ch;

	$ch->add_pulse_list( $step, @_ );
	$self->{ 'num_steps' } = $step if $step > $self->{ 'num_steps' };
}

#---------------------------------------------------------
# Returns the longest sequence of all channels with and without delays

sub longest_sequence {

	my $self = shift;
	my @duration = ( 0, 0 );

	for ( @{ $self->{ channels } } ) {
		my @l = $_->longest_sequence;
		next unless @l;
		$duration[ 0 ] = $l[ 0 ] if $duration[ 0 ] < $l[ 0 ];
		$duration[ 1 ] = $l[ 1 ] if $duration[ 1 ] < $l[ 1 ];
	}

	return @duration;
}

#---------------------------------------------------------
# Returns the earliest position of all pulses of all channels

sub first_pulse {

    my $self = shift;
    my $first;

    for ( @{ $self->{ 'channels' } } ) {
        my $e = $_->first_pulse;
		next unless defined $e;
        $first = $e if ! defined $first or $first > $e;
    }

    return $first;
}

#---------------------------------------------------------
# Returns a pulse object - to reduce memory usage a new pulse object is only
# created if there's a pulse with the same settings doesn't already exists,
# in which case a reference to the existing pulse object is returned.

sub new_pulse {
	my ( $self, $tag ) = @_;

	$self->{ $tag } = Pulse->new( $tag ) unless defined $self->{ $tag };
	return $self->{ $tag };
}

1;


#=========================================================================
# Intermediate data object: properties of a single chanel

package Channel;

sub new {
	my $inv = shift;
	my $class = ref( $inv ) || $inv;
	my $self = { 'name'  => shift,
			     'num'   => shift,
				 'delay' => shift,
				 'inv'   => shift,
			     'plist' => [ ] };

	return bless $self, $class;
}

#---------------------------------------------------------

sub key {
	my $self = shift;
	return ${ $self->{ 'name' } } . ":" . $self->{ 'num' };
}

#---------------------------------------------------------

sub name {
	return ${ shift->{ 'name' } };
}

#---------------------------------------------------------

sub num {
	return shift->{ 'num' };
}

#---------------------------------------------------------

sub delay  {
	return shift->{ 'delay' };
}

#---------------------------------------------------------

sub inv {
	return shift->{ 'inv' };
}

#---------------------------------------------------------
# Adds a new set of pulses for a new step of the experiment - to reduce
# memory usage a new pulse list is only created if the previous pulse list
# isn't identical to the new one, otherwise a reference to the last
# previously defined one is used instead.

sub add_pulse_list {

	my ( $self, $step ) = ( shift, shift );

	my $pstep;

	for ( $pstep = $step - 1; $pstep > 0; $pstep-- ) {
		last if defined $self->{ 'plist' }[ $pstep ];
	}

	$self->{ 'plist' }[ $step ] = $self->{ 'plist' }[ $pstep ]->comp( @_ )
		if $pstep > 0;
	$self->{ 'plist' }[ $step ] = Pulse_List->new( @_ )
		unless defined $self->{ 'plist' }[ $step ];
}

#---------------------------------------------------------
# Returns the list of pulses for a certain step

sub get_pulse_list {

	my ( $self, $step ) = ( shift, shift );

	fail( "Invalid pulse list index\n" ) if $step < 0;

	return $self->{ 'plist' }[ $step ]->{ 'list' }
		if defined $self->{ 'plist' }[ $step ] and
		   exists $self->{ 'plist' }[ $step ]->{ 'list' };
	return undef;
}

#---------------------------------------------------------
# Returns the longest sequence length for the channel with and without delays

sub longest_sequence {

	my $self = shift;
	my @duration = ( 0, 0 );

	for ( @{ $self->{ 'plist' } } ) {
		next unless defined $_;
		my $len = $_->len;
		$duration[ 0 ] = $len if $duration[ 0 ] < $len;
		$duration[ 1 ] = $len - $self->{ 'delay' } + $Delay
			if $duration[ 1 ] < $len - $self->{ 'delay' } + $Delay;
	}

	return @duration;
}

#---------------------------------------------------------
# Returns the very first position (including delays) of a pulse of the channel

sub first_pulse {

    my $self = shift;
    my $first;

    for ( @{ $self->{ 'plist' } } ) {
		next unless defined $_;
        my $e = $_->start;
		next unless defined $e;
		$e -= $self->{ 'delay' };
		$first = $e if ! defined $first or $first > $e;
    }

    return $first;
}

1;


#=========================================================================
# List of all pulses belonging to a channel

package Pulse_List;

sub new {
	my $inv = shift;
	my ( $num, $start, $len );
	my $class = ref( $inv ) || $inv;
	my $self = { 'list'  => [ ],
			     'start' => undef,
			     'len'   => 0 };
	return bless $self, $class unless @_;

	$self->{ 'start' } = $_[ 1 ];
	while ( @_ ) {
		( $num, $start, $len ) = ( shift, shift, shift );
		my $tag = $num . "," . $start . "," . $len;
		push @{ $self->{ 'list' } }, $Channels->new_pulse( $tag );
	}
	$self->{ 'len' } = $start + $len;
	return bless $self, $class;
}

#---------------------------------------------------------
# Compares an existing pulse pattern to the settings for a new one to be
# created. If both the patterns are identical a reference to the already
# existing pulse pattern is returned, otherwise 'undef' gets returned.

sub comp {
	my $self = shift;

	return undef unless @{ $self->{ 'list' } } == @_ / 3;
	for ( @{ $self->{ 'list' } } ) {
		return undef unless $_->comp( @_ );
	}
	return $self;
}

#---------------------------------------------------------
# Returns the total length of the pulse list (i.e. start postition plus
# length of the last pulse) or 0 if there's no pulse in the pulse list

sub len {
	return shift->{ 'len' };
}

#---------------------------------------------------------
# Returns the position of the first pulse in the list or 'undef' if
# there's no pulse in the pulse list

sub start {
	return shift->{ 'start' };
}

1;


#=========================================================================
# The most basic data object: a single pulse

package Pulse;

sub new {
	my ( $inv, $tag ) = @_;
	my $class = ref( $inv ) || $inv;
	return bless \$tag, $class;
}

#---------------------------------------------------------
# Function tests if the settings of a pulse object are identical to
# the values passed to the function.

sub comp {
	return ${ shift( ) } eq shift( ) . "," . shift( ) . "," . shift( );
}

#---------------------------------------------------------

sub num {
	${ shift( ) } =~ /^(\(?\d+\)?)/o;
	return $1;
}

#---------------------------------------------------------

sub start {
	${ shift( ) } =~ /,(\d+),/o;
	return $1;
}

#---------------------------------------------------------

sub len {
	${ shift( ) } =~ /,(\d+)$/o;
	return $1;
}

1;
