#!/usr/bin/perl
# -*- cperl -*-
#
# $Id$
#
# Copyright (C) 1999-2002 Jens Thoms Toerring
#
# This file is part of fsc2.
#
# Fsc2 is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# Fsc2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with fsc2; see the file COPYING.  If not, write to
# the Free Software Foundation, 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.


use warnings;
use strict;
use Tk;


my @version = split /\./, $Tk::VERSION;
die "Installed Perl-Tk version is $Tk::VERSION but Tk800.022 is required.\n"
    if $version[ 0 ] + 0.001 * $version[ 1 ] < 800.022;

my ( $line, $time_base, $Delay, $has_auto_pulses );
my $verbose = 0;
my $if = *STDIN;
my $Channels = Channels->new;

read_input( );
Pulse_Window->new;
MainLoop;


#---------------------------------------------------------

sub usage{

	print "Usage: fsc2_pulse [ file ]\n" .
		"A program to display the pulse settings of an EDL program.\n";
	exit 0;
}

#---------------------------------------------------------

sub read_input {

	my @Function_Names = qw( MW PULSE_SHAPE PHASE_1 PHASE_2 TWT TWT_GATE
							 DEFENSE DETECTION DETECTION_GATE RF RF_GATE
							 OTHER_1 OTHER_2 OTHER_3 OTHER_4 );

	if ( $ARGV[ 0 ] ) {
		if ( $ARGV[ 0 ] =~ /^-v$/ ) {
			$verbose = 1;
			shift @ARGV;
		}
		usage( ) if $ARGV[ 0 ] =~ /^-h$/ or $ARGV[ 0 ] =~ /^--h(elp)?$/;
		open( $if, "<" . $ARGV[ 0 ] )
			or die "Can't open input file " . $ARGV[ 0 ] . ": $!\n";
	}

	# Read the time base

	if ( $verbose ) {
		defined( $line = <$if> ) or die "Premature end of input at line $..\n";
		$line =~ /^TB: (\d+(\.\d+)?([eE][+-]?\d+)?)$/
			or die "Invalid input at line $..\n";
	} else {
		defined( $line = <$if> ) or exit 1;
		$line =~ /^TB: (\d+(\.\d+)?([eE][+-]?\d+)?)$/ or exit 1;
	}

	$time_base = $1;

	# Read the total negative delay

	if ( $verbose ) {
		defined( $line = <$if> ) or die "Premature end of input at line $..\n";
		$line =~ /^D: (\d+)?$/ or die "Invalid input at line $..\n";
	} else {
		defined( $line = <$if> ) or exit 1;
		$line =~ /^D: (\d+)?$/ or exit 1;
	}

	$Delay = $1;

	if ( $verbose ) {
		defined( $line = <$if> ) or die "Premature end of input at line $..\n";
		$line =~ /^===$/ or die "Invalid input at line $..\n";
	} else {
		defined( $line = <$if> ) or exit 1;
		$line =~ /^===$/ or exit 1;
	}

	# Read in the function/channel information

	while( 1 ) {
		if ( $verbose ) {
			defined ( $line = <$if> )
				or die "Premature end of input at line $..\n";
		} else {
			defined ( $line = <$if> ) or exit 1;
		}
		last if $line =~ /^===$/;

		my $i;

		for ( $i = 0; $i <= $#Function_Names; $i++ ) {
			if ( $line =~ /^(($Function_Names[ $i ]):(\d+)) (\d+)$/ ) {
				$Channels->add_channel( $1, $2, $3, $4 );
				last;
			}
		}

		if ( $verbose ) {
			die "Invalid input at line $..\n" unless $i <= $#Function_Names;
		} else {
			exit 1 unless $i <= $#Function_Names;
		}
	}

	# Read the all the pulse settings

	$has_auto_pulses = 0;
	my $num = 0;
	while( 1 ) {
		last unless defined ( $line = <$if> );
		if ( $line =~ /^===$/ ) {
			$num++;
			next;
		}

		$has_auto_pulses = 1 if $line =~ /\(\d+\)/;
		my @bits = split /\s+/, $line;
		if ( $verbose ) {
			die "Invalid input at line $..\n" unless $#bits % 3 == 0;
		} else {
			exit 1 unless $#bits % 3 == 0;
		}
		$Channels->add_pulse_list( $num, @bits );
	}

	if ( $verbose ) {
		die "No pulses patterns defined in input.\n" unless
			$Channels->num_channels > 0 and $Channels->num_steps >= 0;
	} else {
		exit 1
			unless $Channels->num_channels > 0 and $Channels->num_steps >= 0;
	}
}


#=========================================================================

package Pulse_Window;

sub new {
	my $inv = shift;
	my $class = ref( $inv ) || $inv;
	my $self = { 'top' => MainWindow->new,
			     'step' => 0,
				 'mag' => 2,
				 'hstep' => 72,
				 'delay' => 0 };
	bless $self, $class;

	# Find the start of the first pulse (including function delays)

	my $off = $Channels->first_pulse;
	if ( $Delay == 0 and $off < 0 ) {
		$self->{ 'offset' } = - $off;
	} else {
		$self->{ 'offset' } = 0;
	}

	# Calculate width of window to display *all* data

	my $h = $Channels->num_channels * $self->{ 'hstep' } + 80;
	my $w = $self->{ 'mag' } * ( $Channels->longest_sequence + $Delay );

	# Blow up magnification if the pulse sequence is very short, if it's
	# very long we have to reduce the magnification factor (maximum width
	# is halve of a short int, i.e. about 32000, from the look of it)

	while ( $w < 400 ) {
		$w *= 2;
		$self->{ 'mag' } *= 2;
	}
	while ( $w > 32000 ) {
		$w *= 0.5;
		$self->{ 'mag' } *= 0.5;
	}

	$self->{ 'len' } = $w;

	# Reduce window size to something reasonable if necessary

	my $width = $w + 170;
	my @maxsize = $self->{ 'top' }->maxsize;
	$width = 0.75 * $maxsize[ 0 ] if $width > 0.75 * $maxsize[ 0 ];

	# Create a frame and with an embedded canvas (either a normal one or,
	# if the the place needed to display all data is larger than the window
	# size, a scrolled canvas)

	my $f1 = $self->{ 'top' }->Frame;
	if ( $width >= $w + 170 ) {
		$self->{ 'canvas' } =
			$f1->Canvas( '-relief' => 'sunken',
						 '-bd' => 1,
						 '-width' => $width,
						 '-height' => $h,
						 '-background' => 'black' );
	} else {
		$self->{ 'canvas' } =
			$f1->Scrolled( 'Canvas',
						   '-relief' => 'sunken',
						   '-scrollbars' => 's',
						   '-bd' => 1,
						   '-width' => $width,
						   '-height' => $h,
						   '-background' => 'black',
						   '-scrollregion' => [ 0, 0, $w + 170, $h ] );
		$self->{ 'top' }->bind( '<Left>' => sub {
						   $self->{ 'canvas' }->xviewScroll( -1, 'unit' ); } );
		$self->{ 'top' }->bind( '<Right>' => sub {
						   $self->{ 'canvas' }->xviewScroll( 1, 'unit' ); } );

	}

	$f1->pack( '-fill' => 'x' );
	$self->{ 'canvas' }->pack( '-side' => 'top', '-fill' => 'x' );

	# Create a second frame with the buttons etc.

	my $f2 = $self->{ 'top' }->Frame;
	$self->{ 'delay_button' } =
		$f2->Checkbutton( '-state' => 'active',
						  '-text' => 'Show delays',
						  '-variable' => \$self->{ 'delay' },
						  '-command' => sub { $self->draw_scale;
											  $self->redraw } );
	my $f3 = $f2->Frame;
	$self->{ 'step_label' } = $f3->Label( '-text' => 'Step:' );
	$self->{ 'step_ffb' } =
		$f3->Button( '-text' => '<<',
					 '-width' => '1',
					 '-command' => sub { $self->pshift( -1, 1 ) } );
	$self->{ 'step_fb' } =
		$f3->Button( '-text' => '<',
					 '-width' => '1',
					 '-command' => sub { $self->pshift( -1 ) } );
	$self->{ 'step_entry' } =
		$f3->Entry( '-textvariable' => \$self->{ 'step' },
					'-width' => 6,
					'-validate' => 'key',
					'-validatecommand' => sub { my $n = shift;
												return 1 if $n eq "";
												return 0 unless $n =~ /^\d+$/;
												return ( $n >= 0 and
											  $n <= $Channels->num_steps ) } );
	$self->{ 'step_fw' } =
		$f3->Button( '-text' => '>',
					 '-width' => '1',
					 '-command' => sub { $self->pshift( 1 ) } );
	$self->{ 'step_ffw' } =
		$f3->Button( '-text' => '>>',
					 '-width' => '1',
					 '-command' => sub { $self->pshift( 1, 1 ) } );
	$self->{ 'close_button' } =
		$f2->Button( '-text' => 'Close',
					 'command' => [ destroy => $self->{ 'top' } ] );

	$f2->pack( '-side' => 'top', '-fill' => 'x' );
	$self->{ 'delay_button' }->pack( 'side' => 'left',
									 'padx' => '4m',
									 'pady' => '2m' );
	$f3->pack( '-side' => 'left',
			   'padx' => '15m',
			   'pady' => '2m',
			   '-fill' => 'x' );
	$self->{ 'step_label' }->pack( 'side' => 'left',
								   'padx' => '3m' );
	$self->{ 'step_ffb' }->pack( 'side' => 'left' );
	$self->{ 'step_fb' }->pack( 'side' => 'left' );
	$self->{ 'step_entry' }->pack( 'side' => 'left',
								   'padx' => '2m' );
	$self->{ 'step_fw' }->pack( 'side' => 'left' );
	$self->{ 'step_ffw' }->pack( 'side' => 'left' );
	$self->{ 'close_button' }->pack( 'side' => 'right',
									 'padx' => '4m',
									 'pady' => '2m' );

	# Lots of key bindings...

    $self->{ 'canvas' }->CanvasBind( '<Button-2>' => sub {
										 $self->pshift( 1 ); } );
    $self->{ 'canvas' }->CanvasBind( '<Button-4>' => sub {
										 $self->pshift( 1 ); } );
    $self->{ 'top' }->bind( '<Up>' => sub {
										 $self->pshift( 1 ); } );
    $self->{ 'top' }->bind( '<Shift-Up>' => sub {
										 $self->pshift( 10 ); } );
    $self->{ 'canvas' }->CanvasBind( '<Button-3>' => sub {
										 $self->pshift( -1 ); } );
    $self->{ 'canvas' }->CanvasBind( '<Button-5>' => sub {
										 $self->pshift( -1 ); } );
    $self->{ 'top' }->bind( '<Down>' => sub {
										 $self->pshift( -1 ); } );
    $self->{ 'top' }->bind( '<Shift-Down>' => sub {
										 $self->pshift( -10 ); } );
	$self->{ 'top' }->bind( '<End>' => sub {
										 $self->pshift( -1, 1 ); } );
	$self->{ 'top' }->bind( '<Home>' => sub {
										 $self->pshift( 1, 1 ); } );
	$self->{ 'top' }->bind( '<Prior>' => sub {
										 $self->pshift(
									       int( 0.1 * $Channels->num_steps ) );
									     } );
	$self->{ 'top' }->bind( '<Next>' => sub {
										 $self->pshift(
									     - int( 0.1 * $Channels->num_steps ) );
									     } );
	$self->{ 'top' }->bind( '<Control-d>' => sub {
								              $self->{ 'delay' } ^= 1;
											  $self->draw_scale;
											  $self->redraw } );
	$self->{ 'top' }->bind( '<Control-q>' => [ destroy => $self->{ 'top' } ] );
	$self->{ 'step_entry' }->bind( '<Return>' => sub {
									   return if $self->{ 'step' } eq "";
									   $self->redraw; } );
	$self->{ 'step_entry' }->bind( '<KP_Enter>' => sub {
									   return if $self->{ 'step' } eq "";
									   $self->redraw; } );

	$self->{ 'dw' } = Display_Window->new( $self->{ 'top' } );

	# Draw the canvas in the initial state

	$self->primary_draw;

	return $self;
}

#---------------------------------------------------------
# Function for changing the current step - gets either one or two arguments.
#If there's only one it's the change of the step, if there are two switch
# either to the very first (if the first argument is negative) or the very
# last step (if the first argument is positive).

sub pshift {

	my ( $self, $delta, $special ) = @_;

	if ( ! defined $special ) {
		return if $self->{ 'step' } eq "";
		$self->{ 'step' } += $delta;
		$self->{ 'step' } = 0 if $self->{ 'step' } + $delta < 0;
		$self->{ 'step' } = $Channels->num_steps
			if $self->{ 'step' } + $delta > $Channels->num_steps;
   } else {
	   $self->{ 'step' } = 0 if $delta < 0;
	   $self->{ 'step' } = $Channels->num_steps if $delta > 0;
   }

	$self->redraw;
}

#---------------------------------------------------------

sub primary_draw {

	my $self = shift;
	my $c = $self->{ 'canvas' };

	$self->draw_scale;
	for ( my $i = 0; $i < $Channels->num_channels; $i++ ) {
		my $ch = $Channels->find_by_num( $i );

		my $y = 10 + ( $i + 0.5 ) * $self->{ 'hstep' };
		$c->create( 'text', 10, $y, '-anchor' => 'w', '-text' => $ch->key,
					'-fill' => 'green' );

		my $x1 = 150;
		my $x2 = 160 + $self->{ 'len' };
		$c->create( 'line', $x1, $y, $x2, $y, '-fill' => 'white' );
	}
	$self->redraw;
}

#---------------------------------------------------------

sub draw_scale {

	my $self = shift;
	my $c = $self->{ 'canvas' };
	my $factor;
	my $unit;


	$self->{ 'canvas' }->delete( 'scale' );

	my $x1 = 150;
	my $x2 = 160 + $self->{ 'len' };
	my $y1 = 10 + ( $Channels->num_channels + 0.2 ) * $self->{ 'hstep' };

	$c->create( 'line', $x1, $y1, $x2, $y1, '-fill' => 'yellow',
				'-tags' => 'scale' );

	$y1 += 10;
	my $y2 = 10;

	if ( $time_base <= 5e-9 ) {
		$factor = 1e9;
		$unit = "ns";
	} elsif ( $time_base < 5e-6 ) {
		$factor = 1e6;
		$unit = "us";
	} else {
		$factor = 1e3;
		$unit = "ms";
	}

	my $delay;
	if ( $self->{ 'delay' } ) {
		 $delay = $Delay;
	 } else {
		$delay = $self->{ 'offset' };
	}

	my $del = 10;
	if ( $self->{ 'mag' } * $del < 50 ) {
		$del = 25;
	}
	while( $self->{ 'mag' } * $del < 50 ) {
		$del *= 2;
	}

	my $cx = 0;
	my $x = 150 + $self->{ 'mag' } * $delay;
	while ( $x <= $x2 - 10 ) {
		$c->create( 'line', $x, $y1, $x, $y2, '-fill' => 'yellow',
					'-tags' => 'scale', '-dash' => [ 2, 4 ] );
		$c->create( 'text', $x, $y1 + 10,
					'-text' => $cx * $time_base * $factor . $unit,
					'-fill' => 'green', '-tags' => 'scale' );
		$x += $self->{ 'mag' } * $del;
		$cx += $del;
	}

	$cx = - $del;
	$x = 150 + $self->{ 'mag' } * ( $delay - $del );
	while ( $x > $x2 - 10 ) {
		$x -= $self->{ 'mag' } * $del;
		$cx -= $del;
	}
	while ( $x >= $x1 ) {
		$c->create( 'line', $x, $y1, $x, $y2, '-fill' => 'yellow',
					'-tags' => 'scale', '-dash' => [ 2, 4 ] );
		$c->create( 'text', $x, $y1 + 10,
					'-text' => $cx * $time_base * $factor . $unit,
					'-fill' => 'green', '-tags' => 'scale' );
		$x -= $self->{ 'mag' } * $del;
		$cx -= $del;
	}

}

#---------------------------------------------------------
# Function redraws all pulses (after deleting the existing ones)
# for the current value of 'step'.

sub redraw {

	my $self = shift;
	my $c = $self->{ 'canvas' };
	my $step = $self->{ 'step' };

	$self->{ 'dw' }->Leave;

	for ( my $i = 0; $i < $Channels->num_channels; $i++ ) {
		my $ch = $Channels->find_by_num( $i );
		my $j = $step;
		$j-- while $j > 0 and ! defined $ch->get_pulse_list( $j );

		$c->delete( $ch->key );
		my $pl = $ch->get_pulse_list( $j );

		my $y1 = 10 + ( $i + 0.5 ) * $self->{ 'hstep' };
		my $y2 = 10 + $i * $self->{ 'hstep' };
		my $yt = 10 + ( $i + 0.75 ) * $self->{ 'hstep' };

		for my $cp ( @$pl ) {
			my $x1 = $cp->start - ( $self->{ delay } ?
								  0 : $ch->{ 'delay' } - $self->{ 'offset' } );
			my $x2 = $cp->start + $cp->len - ( $self->{ delay } ?
								  0 : $ch->{ 'delay' } - $self->{ 'offset' } );
			$x1 = 150 + $self->{ mag } * $x1;
			$x2 = 150 + $self->{ mag } * $x2;

			my $tag = $ch->key . ":" . $cp->num;
			$c->create( 'rectangle', $x1, $y2, $x2, $y1,
						'-tags' => $tag,
						'-outline' => 'white', '-fill' => 'red' );
			$c->bind( $tag, '<Enter>' => sub {
						  $self->{ 'dw' }->Enter( $tag, $step,
												  $self->{ 'delay' } ); } );
			$c->bind( $tag, '<Leave>' => sub { $self->{ 'dw' }->Leave; } );
			$c->addtag( $ch->key, 'withtag' => $tag );

			$c->create( 'text', 0.5 * ( $x1 + $x2 ), $yt,
						'-text' => $cp->num,
						'-tags' => $ch->key,
						'-fill' => 'green' );
		}
	}

}

#=========================================================================

package Display_Window;

sub new{

	my ( $inv, $mw ) = @_;
	my $class = ref( $inv ) || $inv;
	my $self = { 'w' => $mw->Toplevel,
			     'num' => '',
			     'pos' => '',
			     'len' => '',
				 'func' => '',
				 'ch'   => '',
				 'dp'   => '',
				 'dn'   => '',
			     'pp'   => '',
			     'pl'   => '',
				 'pc'   => '',
				 'pf'   => '' };

	$self->{ 'w' }->title( 'Pulse parameters' );

	my $F = $self->{ 'w' }->Frame( '-relief' => 'ridge',
								   'borderwidth' => '1m' );
	my $f = $F->Frame;
	my $l = $f->Label( '-text' => 'Pulse number: ', 'width' => 20,
					   '-anchor' => 'w' );
	my $e = $f->Entry( '-textvariable' => \$self->{ 'num' },
						'-width' => 20,
						'-relief' => 'flat' );
	$f->pack( '-side' => 'top', 'padx' => 2, 'pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text' => 'Pulse position: ', 'width' => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'pos' },
					 '-width' => 20,
					 '-relief' => 'flat' );
	$f->pack( '-side' => 'top', 'padx' => 2, 'pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text' => 'Pulse length: ', 'width' => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'len' },
					 '-width' => 20,
					 '-relief' => 'flat' );
	$f->pack( '-side' => 'top', 'padx' => 2, 'pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text' => 'Pulse function: ', 'width' => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'func' },
					 '-width' => 20,
					 '-relief' => 'flat' );
	$f->pack( '-side' => 'top', 'padx' => 2, 'pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text' => 'Pulse pod/channel: ', 'width' => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'ch' },
					 '-width' => 20,
					 '-relief' => 'flat' );
	$f->pack( '-side' => 'top', 'padx' => 2, 'pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$F->pack( '-side' => 'top', 'padx' => 2, 'pady' => 2 );


	$F = $self->{ 'w' }->Frame( '-relief' => 'ridge',
								'borderwidth' => '1m' );

	$f = $F->Frame;
	$l = $f->Label( '-text' => 'Distance to previous: ', 'width' => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'dp' },
					 '-width' => 20,
					 '-relief' => 'flat' );
	$f->pack( '-side' => 'top', 'padx' => 2, 'pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text' => 'Distance to next: ', 'width' => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'dn' },
					 '-width' => 20,
					 '-relief' => 'flat' );
	$f->pack( '-side' => 'top', 'padx' => 2, 'pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$F->pack( '-side' => 'top', 'padx' => 2, 'pady' => 2 );

	$F = $self->{ 'w' }->Frame( '-relief' => 'ridge',
								'borderwidth' => '1m' );

	if ( $has_auto_pulses ) {
		$f = $F->Frame;
		$l = $f->Label( '-text' => 'Position of parent: ', 'width' => 20,
						'-anchor' => 'w' );
		$e = $f->Entry( '-textvariable' => \$self->{ 'pp' },
						'-width' => 20,
						'-relief' => 'flat' );
		$f->pack( '-side' => 'top', 'padx' => 2, 'pady' => 2 );
		$l->pack( '-side' => 'left' );
		$e->pack( '-side' => 'right' );

		$f = $F->Frame;
		$l = $f->Label( '-text' => 'Length of parent: ', 'width' => 20,
						'-anchor' => 'w' );
		$e = $f->Entry( '-textvariable' => \$self->{ 'pl' },
						'-width' => 20,
						'-relief' => 'flat' );
		$f->pack( '-side' => 'top', 'padx' => 2, 'pady' => 2 );
		$l->pack( '-side' => 'left' );
		$e->pack( '-side' => 'right' );

		$f = $F->Frame;
		$l = $f->Label( '-text' => 'Function of parent: ', 'width' => 20,
						'-anchor' => 'w' );
		$e = $f->Entry( '-textvariable' => \$self->{ 'pf' },
						'-width' => 20,
						'-relief' => 'flat' );
		$f->pack( '-side' => 'top', 'padx' => 2, 'pady' => 2 );
		$l->pack( '-side' => 'left' );
		$e->pack( '-side' => 'right' );

		$f = $F->Frame;
		$l = $f->Label( '-text' => 'Pod/channel of parent: ', 'width' => 20,
						'-anchor' => 'w' );
		$e = $f->Entry( '-textvariable' => \$self->{ 'pc' },
						'-width' => 20,
						'-relief' => 'flat' );
		$f->pack( '-side' => 'top', 'padx' => 2, 'pady' => 2 );
		$l->pack( '-side' => 'left' );
		$e->pack( '-side' => 'right' );

		$F->pack( '-side' => 'top', 'padx' => 2, 'pady' => 2 );
	}

	return bless $self, $class;
}

#---------------------------------------------------------

sub Enter {

	my ( $self, $tag, $step, $is_delay ) = @_;
	my ( $f, $ch, $num ) = split /:/, $tag;

	my $pod = $Channels->find_by_key( $f . ":" . $ch );

	my $j = $step;
	$j-- while $j > 0 and ! defined $pod->get_pulse_list( $j );

	my $pl = $pod->get_pulse_list( $j );

	my $i;
	for ( $i = 0; exists $pl->[ $i ]; $i++ ) {
		last if $pl->[ $i ]->num eq $num;
	}

	my $cp = $pl->[ $i ];
	my $pp = $i > 0 ? $pl->[ $i - 1 ] : undef;
	my $np = exists( $pl->[ $i + 1 ] ) ? $pl->[ $i + 1 ] : undef;

	my ( $p1, $p2 ) = $self->pstart( $cp->start, $pod, $is_delay );

	if ( $p1 ne $p2 ) {
		$self->{ 'pos' } = $p1 . "  (" . $p2 . ")";
	} else {
		$self->{ 'pos' } = $p1;
	}
	$self->{ 'len' } = $self->ptime( $cp->len );

	$self->{ 'func' } = $f;
	$self->{ 'ch' } = $ch;

	$self->{ 'dp' } = defined( $pp ) ?
				$self->ptime( $cp->start - $pp->start - $pp->len ) . "  (" .
				$self->ptime( $cp->start - $pp->start
							  + 0.5 * ( $cp->len - $pp->len ) ) .")" : '';
	$self->{ 'dn' } = defined( $np ) ?
				$self->ptime( $np->start - $cp->start - $cp->len ) . "  (" .
				$self->ptime( $np->start - $cp->start
							  + 0.5 * ( $np->len - $cp->len ) ) .")" : '';

	if ( $num =~ /^\((\d+)\)$/ ) {
		$self->{ 'num' } = $num . "    [auto]";
		$self->parent( $1, $step, $is_delay );
	}
	else {
		$self->{ 'num' } = $num;
	}

}

#---------------------------------------------------------

sub parent {

	my ( $self, $pp, $step, $is_delay ) = @_;
	my ( $pod, $cp, $pl );

	$cp = undef;
	for ( my $i = 0; $i < $Channels->num_channels; $i++ ) {

		$pod = $Channels->find_by_num( $i );
		my $j = $step;
		$j-- while $j > 0 and ! defined $pod->get_pulse_list( $j );
		$pl = $pod->get_pulse_list( $j );

		for $j ( @$pl ) {
			next unless $j->num eq $pp ;
			$cp = $j;
			last;
		}

		last if defined $cp;
	}

	my ( $p1, $p2 ) = $self->pstart( $cp->start, $pod, $is_delay );

	if ( $p1 ne $p2 ) {
		$self->{ 'pp' } = $p1 . "  (" . $p2 . ")";
	} else {
		$self->{ 'pp' } = $p1;
	}
	$self->{ 'pl' } = $self->ptime( $cp->len );

	$self->{ 'pf' } = $pod->{ 'name' };
	$self->{ 'pc' } = $pod->{ 'num' };
}

#---------------------------------------------------------

sub pstart {

	my ( $self, $ticks, $ch, $is_delay ) = @_;

	if ( $is_delay ) {
		return ( $self->ptime( $ticks - $Delay ),
				 $self->ptime( $ticks - $ch->{ 'delay' } ) );
	}

	return ( $self->ptime( $ticks - $ch->{ 'delay' } ),
			 $self->ptime( $ticks - $Delay ) );
}

#---------------------------------------------------------

sub ptime {

	my ( $self, $ticks ) = @_;

	my $t = $ticks;

	if ( $t * $time_base < 1e-5 ) {
		return $t * $time_base * 1e9 . " ns";
	} elsif ( $t * $time_base < 1e-2 ) {
		return sprintf "%.3f us", $t * $time_base * 1e6;
	} else {
		return sprintf "%.6f ms", $t * $time_base * 1e3;
	}

	return "";
}

#---------------------------------------------------------

sub Leave {

	my $self = shift;
	$self->{ 'num' } = '';
	$self->{ 'pos' } = '';
	$self->{ 'len' } = '';
	$self->{ 'func' } = '';
	$self->{ 'ch' } = '';
	$self->{ 'dp' } = '';
	$self->{ 'dn' } = '';
	$self->{ 'pp' } = '';
	$self->{ 'pl' } = '';
	$self->{ 'pf' } = '';
	$self->{ 'pc' } = '';
}

1;


#=========================================================================

package Channels;

sub new {
	my $inv = shift;
	my $class = ref( $inv ) || $inv;
	my $self = { 'num_channels' => 0,
				 'num_steps'    => -1,
				 'channels'     => [ ] };
	return bless $self, $class;
}

#---------------------------------------------------------

sub add_channel {

	my $self = shift;
	$self->{ 'num_channels' }++;
	push @{ $self->{ 'channels' } }, Channel->new( @_ );
}

#---------------------------------------------------------

sub find_by_num {

	my ( $self, $num ) = ( shift, shift );
	return undef if $num > $self->num_channels;
	return $self->{ 'channels' }[ $num ];
}

#---------------------------------------------------------

sub find_by_key {

	my ( $self, $key ) = ( shift, shift );

	for ( @{ $self->{ 'channels' } } ) {
		return $_ if $_->key eq $key;
	}

	return undef;
}

#---------------------------------------------------------

sub num_channels {
	my $self = shift;
	return $self->{ 'num_channels' }
}

#---------------------------------------------------------

sub num_steps {
	my $self = shift;
	return $self->{ 'num_steps' }
}

#---------------------------------------------------------

sub add_pulse_list {

	my ( $self, $step, $key ) = ( shift, shift, shift );

	my $ch = $self->find_by_key( $key );

	if ( $verbose ) {
		die "Invalid input at line $..\n" unless defined $ch;
	} else {
		exit 1 unless defined $ch;
	}

	$ch->add_pulse_list( $step, @_ );
	$self->{ 'num_steps' } = $step if $step > $self->{ 'num_steps' };
}

#---------------------------------------------------------

sub longest_sequence {

	my $self = shift;
	my $duration = 0;

	for ( @{ $self->{ channels } } ) {
		my $l = $_->longest_sequence;
		next unless defined $l;
		$duration = $l if $duration < $l;
	}

	return $duration - $Delay;
}

#---------------------------------------------------------

sub first_pulse {

    my $self = shift;
    my $first;

    for ( @{ $self->{ channels } } ) {
        my $e = $_->first_pulse;
		next unless defined $e;
        $first = $e if ! defined $first or $first > $e;
    }

    return $first;
}

1;


#=========================================================================

package Channel;

sub new {
	my $inv = shift;
	my $class = ref( $inv ) || $inv;
	my $self = { 'key' => shift,
				 'name' => shift,
			     'num'  => shift,
				 'delay' => shift,
			     'plist' => { } };

	return bless $self, $class;
}

#---------------------------------------------------------

sub key {

	return shift->{ 'key' };
}

#---------------------------------------------------------

sub delay  {

	return shift->{ 'delay' };
}

#---------------------------------------------------------

sub add_pulse_list {

	my ( $self, $step ) = ( shift, shift );
	$self->{ 'plist' }{ $step } = Pulse_List->new( @_ );
}

#---------------------------------------------------------

sub get_pulse_list {

	my ( $self, $step ) = ( shift, shift );

	if ( $verbose ) {
		die "Invalid pulse list index\n" if $step < 0;
	} else {
		exit 1 if $step < 0;
	}

	return $self->{ 'plist' }{ $step }
		if exists $self->{ 'plist' }{ $step };
	return undef;
}

#---------------------------------------------------------

sub longest_sequence {

	my $self = shift;
	my $duration = 0;

	for ( keys %{ $self->{ 'plist' } } ) {
		my $len = $self->{ 'plist' }{ $_ }->len;
		$duration = $len if $duration < $len;
	}

	return $duration;
}

#---------------------------------------------------------

sub first_pulse {

    my $self = shift;
    my $first;

    for ( keys %{ $self->{ 'plist' } } ) {
        my $e = $self->{ 'plist' }{ $_ }->start;
		next unless defined $e;
		$e -= $self->{ 'delay' };
		$first = $e if ! defined $first or $first > $e;
    }

    return $first;
}

1;


#=========================================================================

package Pulse_List;

sub new {
	my $inv = shift;
	my $class = ref( $inv ) || $inv;
	my $self = [ ];
	push @$self, Pulse->new( shift, shift, shift ) while ( @_ );
	return bless $self, $class;
}

#---------------------------------------------------------

sub len {

	my $self = shift;
	my $duration = 0;

	for ( @$self ) {
		my $l = $_->start + $_->len;
		$duration = $l if $duration < $l;
	}

	return $duration;
}

#---------------------------------------------------------

sub start {

    my $self = shift;
    my $start;

    for ( @$self ) {
        my $s = $_->start;
        $start = $s if ! defined $start or $start > $s;
    }

    return $start;
}

1;


#=========================================================================

package Pulse;

sub new {
	my $inv = shift;
	my $class = ref( $inv ) || $inv;
	my $self = { 'num' => shift,
				 'start' => shift,
				 'len' => shift };
	return bless $self, $class;
}

#---------------------------------------------------------

sub num {
	return shift->{ 'num' };
}

#---------------------------------------------------------

sub start {
	return shift->{ 'start' };
}

#---------------------------------------------------------

sub len {
	return shift->{ 'len' };
}

1;
