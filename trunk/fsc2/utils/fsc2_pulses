#!/usr/bin/perl
# -*- cperl -*-
#
# $Id$
#
# Copyright (C) 1999-2002 Jens Thoms Toerring
#
# This file is part of fsc2.
#
# Fsc2 is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# Fsc2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with fsc2; see the file COPYING.  If not, write to
# the Free Software Foundation, 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.


use warnings;
use strict;
use Tk;


my @version = split /\./, $Tk::VERSION;
die "Installed Perl-Tk version is $Tk::VERSION but Tk800.022 is required.\n"
    if $version[ 0 ] + 0.001 * $version[ 1 ] < 800.022;

my ( $line, $time_base, $Delay, $has_auto_pulses );
my $verbose = 0;
my $if = *STDIN;
my $Channels = Channels->new;

read_input( );
Pulse_Window->new;
MainLoop;


#---------------------------------------------------------

sub usage{

	print "Usage: fsc2_pulse [ file ]\n" .
		"A program to display the pulse settings of an EDL program.\n";
	exit 0;
}


#---------------------------------------------------------

sub read_input {

	my @Function_Names = qw( MW PULSE_SHAPE PHASE_1 PHASE_2 TWT TWT_GATE
							 DEFENSE DETECTION DETECTION_GATE RF RF_GATE
							 OTHER_1 OTHER_2 OTHER_3 OTHER_4 );

	if ( $ARGV[ 0 ] ) {
		if ( $ARGV[ 0 ] =~ /^-v$/ ) {
			$verbose = 1;
			shift @ARGV;
		}
		usage( ) if $ARGV[ 0 ] =~ /^-h$/ or $ARGV[ 0 ] =~ /^--h(elp)?$/;
		open( $if, "<" . $ARGV[ 0 ] )
			or die "Can't open input file " . $ARGV[ 0 ] . ": $!\n";
	}

	# Read the time base

	if ( $verbose ) {
		defined( $line = <$if> ) or die "Premature end of input at line $..\n";
		$line =~ /^TB: (\d+(\.\d+)?([eE][+-]?\d+)?)$/
			or die "Invalid input at line $..\n";
		$time_base = $1;
	} else {
		defined( $line = <$if> ) or exit 1;
		$line =~ /^TB: (\d+(\.\d+)?([eE][+-]?\d+)?)$/ or exit 1;
		$time_base = $1;
	}

	# Read the total negative delay

	if ( $verbose ) {
		defined( $line = <$if> ) or die "Premature end of input at line $..\n";
		$line =~ /^D: (\d+)$/ or die "Invalid input at line $..\n";
		$Delay = $1;
	} else {
		defined( $line = <$if> ) or exit 1;
		$line =~ /^D: (\d+)$/ or exit 1;
		$Delay = $1;
	}

	if ( $verbose ) {
		defined( $line = <$if> ) or die "Premature end of input at line $..\n";
		$line =~ /^===$/ or die "Invalid input at line $..\n";
	} else {
		defined( $line = <$if> ) or exit 1;
		$line =~ /^===$/ or exit 1;
	}

	# Read in the function/channel information

	while( 1 ) {
		if ( $verbose ) {
			defined ( $line = <$if> )
				or die "Premature end of input at line $..\n";
		} else {
			defined ( $line = <$if> ) or exit 1;
		}
		last if $line =~ /^===$/;

		my $i;

		for ( $i = 0; $i <= $#Function_Names; $i++ ) {
			if ( $line =~
				 /^(($Function_Names[ $i ]):([A-H]?\d+)) ([+-]?\d+)( I)?$/ ) {
				$Channels->add_channel( $1, $2, $3, $4, defined $5 ? 1 : 0 );
				last;
			}
		}

		if ( $verbose ) {
			die "Invalid input at line $..\n" unless $i <= $#Function_Names;
		} else {
			exit 1 unless $i <= $#Function_Names;
		}
	}

	# Read the all the pulse settings

	$has_auto_pulses = 0;
	my $num = 0;
	while( 1 ) {
		last unless defined ( $line = <$if> );
		if ( $line =~ /^===$/ ) {
			$num++;
			next;
		}

		$has_auto_pulses = 1 if $line =~ /\(\d+\)/;
		my @bits = split /\s+/, $line;
		if ( $verbose ) {
			die "Invalid input at line $..\n" unless $#bits % 3 == 0;
		} else {
			exit 1 unless $#bits % 3 == 0;
		}
		$Channels->add_pulse_list( $num, @bits );
	}

	if ( $verbose ) {
		die "No pulses patterns defined in input.\n" unless
			$Channels->num_channels > 0 and $Channels->num_steps >= 0;
	} else {
		exit 1
			unless $Channels->num_channels > 0 and $Channels->num_steps >= 0;
	}
}


#=========================================================================
# Creates and manages the window for displaying the pulses

package Pulse_Window;

sub new {
	my $inv = shift;
	my $class = ref( $inv ) || $inv;
	my $self = { 'top'   => MainWindow->new,
			     'step'  => 0,
				 'mag'   => 2,
				 'hstep' => 72,
				 'delay' => 0,
				 'shift' => 0,
				 'del'   => 10 };

	bless $self, $class;

	# Find the start of the first pulse (including delays)

	$self->{ 'offset' } = $Channels->first_pulse;

	if ( $verbose ) {
		die "No pulses found in input.\n" unless defined $self->{ 'offset' };
	} else {
		exit 1 unless defined $self->{ 'offset' };
	}

	# Calculate width of window to display *all* data (with and without
	# delays)

	my $h = $Channels->num_channels * $self->{ 'hstep' } + 80;
	my @wx = $Channels->longest_sequence;

	my $w = $self->{ 'mag' } * ( ( $wx[ 0 ] > $wx[ 1 ] ? $wx[ 0 ] : $wx[ 1 ] )
								 - $self->{ 'offset' } );

	# Blow up magnification if the pulse sequence is very short, if it's
	# very long reduce the magnification factor or to avoid strange artefacts.

	while ( $w < 400 ) {
		$w *= 2;
		$self->{ 'mag' } *= 2;
	}
	while ( $w >= 16000 ) {
		$w *= 0.5;
		$self->{ 'mag' } *= 0.5;
	}

	# Determine distance between vertical lines

	if ( $self->{ 'mag' } * $self->{ 'del' } < 50 ) {
		$self->{ 'del' } = 25;
	}
	while( $self->{ 'mag' } * $self->{ 'del' } < 50 ) {
		$self->{ 'del' } *= 2;
	}

	my $cx = int( $self->{ 'offset' } / $self->{ 'del' } ) * $self->{ 'del' };
	$self->{ 'shift' } = $self->{ 'mag' } * ( $cx - $self->{ 'offset' } );
	while ( $self->{ 'shift' } > 0 ) {
		$self->{ 'shift' } -= $self->{ 'mag' } * $self->{ 'del' };
	}

	$w -= $self->{ 'shift' };
	$self->{ 'len' } = $w;

	my $height = $h;
	$height *= 0.75 while ( $height > 650 );

	# Reduce window size to something reasonable if necessary

	my $width = $w + 170;

	my @maxsize = $self->{ 'top' }->maxsize;
	$width = 0.75 * $maxsize[ 0 ] if $width > 0.75 * $maxsize[ 0 ];

	# Create a frame and with an embedded (scrolled) canvas

	my $f1 = $self->{ 'top' }->Frame;
	$self->{ 'canvas' } =
		$f1->Scrolled( 'Canvas',
					   '-relief'       => 'sunken',
					   '-scrollbars'   => 'osoe',
					   '-bd'           => 1,
					   '-width'        => $width,
					   '-height'       => $height,
					   '-background'   => 'black',
					   '-scrollregion' => [ 0, 0, $w + 170, $h ] );
	$self->{ 'top' }->bind( '<Left>' => sub {
						   $self->{ 'canvas' }->xviewScroll( -1, 'unit' ); } );
	$self->{ 'top' }->bind( '<Right>' => sub {
						   $self->{ 'canvas' }->xviewScroll( 1, 'unit' ); } );
	$self->{ 'top' }->bind( '<Up>' => sub {
						   $self->{ 'canvas' }->yviewScroll( -1, 'unit' ); } );
	$self->{ 'top' }->bind( '<Down>' => sub {
						   $self->{ 'canvas' }->yviewScroll( 1, 'unit' ); } );


	# Create a second frame with the buttons etc.

	my $f2 = $self->{ 'top' }->Frame;
	$self->{ 'delay_button' } =
		$f2->Checkbutton( '-state'    => 'active',
						  '-text'     => 'Show delays',
						  '-variable' => \$self->{ 'delay' },
						  '-command'  => sub { $self->draw_scale;
											   $self->redraw } );
	my $f3 = $f2->Frame;
	$self->{ 'step_label' } = $f3->Label( '-text' => 'Step:' );
	$self->{ 'step_ffb' } =
		$f3->Button( '-text'    => '<<',
					 '-width'   => '1',
					 '-command' => sub { $self->pshift( -1, 1 ) } );
	$self->{ 'step_fb' } =
		$f3->Button( '-text'    => '<',
					 '-width'   => '1',
					 '-command' => sub { $self->pshift( -1 ) } );
	$self->{ 'step_entry' } =
		$f3->Entry( '-textvariable'    => \$self->{ 'step' },
					'-width'           => 6,
					'-validate'        => 'key',
					'-validatecommand' => sub { my $n = shift;
											return 1 if $n eq "";
											return 0 unless $n =~ /^\d+$/;
											return ( $n >= 0 and
											  $n <= $Channels->num_steps ) } );
	$self->{ 'step_fw' } =
		$f3->Button( '-text'    => '>',
					 '-width'   => '1',
					 '-command' => sub { $self->pshift( 1 ) } );
	$self->{ 'step_ffw' } =
		$f3->Button( '-text'    => '>>',
					 '-width'   => '1',
					 '-command' => sub { $self->pshift( 1, 1 ) } );
	$self->{ 'close_button' } =
		$f2->Button( '-text'   => 'Close',
					 'command' => [ destroy => $self->{ 'top' } ] );

	$f2->pack( '-side' => 'bottom', '-fill'  => 'x' );
	$self->{ 'delay_button' }->pack( 'side'  => 'left',
									 '-padx' => '4m',
									 '-pady' => '2m' );
	$f3->pack( '-side' => 'left',
			   '-padx' => '15m',
			   '-pady' => '2m',
			   '-fill' => 'x' );
	$self->{ 'step_label'   }->pack( 'side'  => 'left',
									 '-padx' => '3m' );
	$self->{ 'step_ffb'     }->pack( 'side' => 'left' );
	$self->{ 'step_fb'      }->pack( 'side' => 'left' );
	$self->{ 'step_entry'   }->pack( 'side'  => 'left',
									 '-padx' => '2m' );
	$self->{ 'step_fw'      }->pack( 'side' => 'left' );
	$self->{ 'step_ffw'     }->pack( 'side' => 'left' );
	$self->{ 'close_button' }->pack( 'side'  => 'right',
									 '-padx' => '4m',
									 '-pady' => '2m' );

	# Pack the canvas frame only now, otherwise on reducing the window height
	# the frame with the buttons gets crushed while the canvas frame keeps
	# its size even though it's scrollable...

	$f1->pack( '-fill'   => 'both',
			   '-expand' => 1 );
	$self->{ 'canvas' }->pack( '-side'   => 'top',
							   '-fill'   => 'both',
							   '-expand' => 1 );
	$self->{ 'dw' } = Display_Window->new( $self->{ 'top' } );

	# Lots of key bindings...

    $self->{ 'canvas' }->CanvasBind( '<Button-2>' => sub {
										 $self->pshift( 1 ); } );
    $self->{ 'canvas' }->CanvasBind( '<Button-4>' => sub {
										 $self->pshift( 1 ); } );
    $self->{ 'canvas' }->CanvasBind( '<Button-3>' => sub {
										 $self->pshift( -1 ); } );
    $self->{ 'canvas' }->CanvasBind( '<Button-5>' => sub {
										 $self->pshift( -1 ); } );
	$self->{ 'top' }->bind( '<End>' => sub { $self->pshift( -1, 1 ); } );
	$self->{ 'top' }->bind( '<Home>' => sub { $self->pshift( 1, 1 ); } );
	$self->{ 'top' }->bind( '<Prior>' => sub { $self->pshift( 1 ); } );
	$self->{ 'top' }->bind( '<Next>' => sub { $self->pshift( -1 ); } );
	$self->{ 'top' }->bind( '<Control-d>' => sub {
								              $self->{ 'delay' } ^= 1;
											  $self->draw_scale;
											  $self->redraw } );
	$self->{ 'top' }->bind( '<Control-q>' => [ destroy => $self->{ 'top' } ] );
	$self->{ 'step_entry' }->bind( '<Return>' => sub {
											 return if $self->{ 'step' } eq "";
											 $self->redraw; } );
	$self->{ 'step_entry' }->bind( '<KP_Enter>' => sub {
											 return if $self->{ 'step' } eq "";
											 $self->redraw; } );

	# There are sometimes problems with the automatic redraw, if they get
	# solved the next binding becomes useless...

	$self->{ 'top' }->bind( '<Control-l>' => sub{ $self->primary_draw } );

	# Draw the canvas in the initial state

	$self->primary_draw;

	return $self;
}


#---------------------------------------------------------
# Function for changing the currently displayed step - gets either one or two
# arguments.  If there's only one it's the change of the step, if there are
# two switch either to the very first (if the first argument is negative) or
# the very last step (if the first argument is positive).

sub pshift {

	my ( $self, $delta, $special ) = @_;

	if ( ! defined $special ) {
		return if $self->{ 'step' } eq "";
		$self->{ 'step' } += $delta;
		$self->{ 'step' } = 0 if $self->{ 'step' } + $delta < 0;
		$self->{ 'step' } = $Channels->num_steps
			if $self->{ 'step' } + $delta > $Channels->num_steps;
	} else {
		$self->{ 'step' } = 0 if $delta < 0;
		$self->{ 'step' } = $Channels->num_steps if $delta > 0;
	}

	$self->redraw;
}


#---------------------------------------------------------
# Draws everything: First the scale with the vertical lines, then the channel
# names and the horizontal limes and finally calls the function to draw the
# pulses.

sub primary_draw {

	my $self = shift;
	my $c = $self->{ 'canvas' };

	$self->draw_scale;
	my $x1 = 150;
	my $x2 = 170 + $self->{ 'len' };

	for ( my $i = 0; $i < $Channels->num_channels; $i++ ) {
		my $ch = $Channels->find_by_num( $i );

		my $y = 10 + ( $i + 0.5 ) * $self->{ 'hstep' };
		$c->create( 'text', 10, $y,
					'-anchor' => 'w',
					'-text'   => $ch->key,
					'-fill'   => 'green' );

		$y -= 0.5 * $ch->{ 'inv' } * $self->{ 'hstep' };
		$c->create( 'line', $x1, $y, $x2, $y, '-fill' => 'white' );
	}

	$self->redraw( );
}


#---------------------------------------------------------

sub draw_scale {

	my $self = shift;
	my $c = $self->{ 'canvas' };
	my $factor;
	my $unit;


	$self->{ 'canvas' }->delete( 'scale' );

	my $x1 = 150;
	my $x2 = 170 + $self->{ 'len' };
	my $y1 = 10 + ( $Channels->num_channels + 0.2 ) * $self->{ 'hstep' };

	$c->create( 'line', $x1, $y1, $x2, $y1,
				'-fill' => 'yellow',
				'-tags' => 'scale' );

	$y1 += 10;
	my $y2 = 10;

	if ( $time_base <= 5e-9 ) {
		$factor = 1e9;
		$unit = "ns";
	} elsif ( $time_base < 5e-6 ) {
		$factor = 1e6;
		$unit = "us";
	} else {
		$factor = 1e3;
		$unit = "ms";
	}

	# $cx is the starting value to print at the vertical lines, which should
	# be a round number. The 'shift' member tells how much the pulses have
	# to be moved to be drawn at the correct position for the scale.

	my $cx = int( $self->{ 'offset' } / $self->{ 'del' } ) * $self->{ 'del' };
	$self->{ 'shift' } = $self->{ 'mag' } * ( $cx - $self->{ 'offset' } );
	while ( $self->{ 'shift' } > 0 ) {
		$self->{ 'shift' } -= $self->{ 'mag' } * $self->{ 'del' };
		$cx -= $self->{ 'del' };
	}
	my $x = 150;

	while ( $x <= $x2 - 5 ) {
		$c->create( 'line', $x, $y1, $x, $y2,
					'-fill' => 'yellow',
					'-tags' => 'scale',
					'-dash' => [ 2, 4 ] );
		$c->create( 'text', $x, $y1 + 10,
					'-text' => $cx * $factor * $time_base . $unit,
					'-fill' => 'green',
					'-tags' => 'scale' );
		$x += $self->{ 'mag' } * $self->{ 'del' };
		$cx += $self->{ 'del' };
	}
}


#---------------------------------------------------------
# Function redraws all pulses (after deleting the existing ones)
# for the current value of 'step'.

sub redraw {

	my $self = shift;
	my $c = $self->{ 'canvas' };
	my $step = $self->{ 'step' };

	$self->{ 'dw' }->Leave;

	for ( my $i = 0; $i < $Channels->num_channels; $i++ ) {
		my $ch = $Channels->find_by_num( $i );
		my $j = $step;
		$j-- while $j > 0 and ! defined $ch->get_pulse_list( $j );

		$c->delete( $ch->key );
		my $pl = $ch->get_pulse_list( $j );

		my $y1 = 10 + ( $i + 0.5 ) * $self->{ 'hstep' };
		my $y2 = 10 + $i * $self->{ 'hstep' };
		my $yt = 10 + ( $i + 0.75 ) * $self->{ 'hstep' };

		for my $cp ( @$pl ) {
			my $x1 = $cp->start - $self->{ 'offset' };
			my $x2 = $cp->start + $cp->len - $self->{ 'offset' };

			if ( $self->{ 'delay' } ) {
				$x1 += $ch->{ 'delay' } - $Delay;
				$x2 += $ch->{ 'delay' } - $Delay;
			}

			$x1 = 150 + $self->{ mag } * $x1 - $self->{ 'shift' };
			$x2 = 150 + $self->{ mag } * $x2 - $self->{ 'shift' };

			my $tag = $ch->key . ":" . $cp->num;
			$c->create( 'rectangle', $x1, $y2, $x2, $y1,
						'-tags'    => $tag,
						'-outline' => 'white',
						'-fill'    => 'red' );
			$c->bind( $tag, '<Enter>' => sub {
						  $self->{ 'dw' }->Enter( $tag, $step,
												  $self->{ 'delay' } ); } );
			$c->bind( $tag, '<Leave>' => sub { $self->{ 'dw' }->Leave; } );
			$c->addtag( $ch->key, 'withtag' => $tag );

			$c->create( 'text', 0.5 * ( $x1 + $x2 ), $yt,
						'-text' => $cp->num,
						'-tags' => $ch->key,
						'-fill' => 'green' );
		}
	}

}


#=========================================================================
# Creates and manages the window for displaying the pulse parameters

package Display_Window;

sub new{

	my ( $inv, $mw ) = @_;
	my $class = ref( $inv ) || $inv;
	my $self = { 'w' => $mw->Toplevel,
			     'num'  => '',
			     'pos'  => '',
			     'len'  => '',
				 'func' => '',
				 'ch'   => '',
				 'dp'   => '',
				 'dn'   => '',
			     'pp'   => '',
			     'pl'   => '',
				 'pc'   => '',
				 'pf'   => '' };

	$self->{ 'w' }->title( 'Pulse parameters' );

	my $F = $self->{ 'w' }->Frame( '-relief'     => 'ridge',
								   'borderwidth' => '1m' );
	my $f = $F->Frame;
	my $l = $f->Label( '-text'   => 'Pulse number: ',
					   '-width'   => 20,
					   '-anchor' => 'w' );
	my $e = $f->Entry( '-textvariable' => \$self->{ 'num' },
						'-width'       => 20,
						'-relief'      => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx'  => 2,
			  '-pady'  => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text'   => 'Pulse position: ',
					'width'   => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'pos' },
					 '-width'       => 20,
					 '-relief'      => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx'  => 2,
			  '-pady'  => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text'         => 'Pulse length: ',
					'-width'        => 20,
					'-anchor'       => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'len' },
					 '-width'       => 20,
					 '-relief'      => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text'   => 'Pulse function: ',
					'-width'  => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'func' },
					 '-width'       => 20,
					 '-relief'      => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text'   => 'Pulse pod/channel: ',
					'-width'  => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'ch' },
					 '-width'       => 20,
					 '-relief'      => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$F->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );


	$F = $self->{ 'w' }->Frame( '-relief'      => 'ridge',
								'-borderwidth' => '1m' );

	$f = $F->Frame;
	$l = $f->Label( '-text'   => 'Distance to previous: ',
					'-width'  => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'dp' },
					'-width'        => 20,
					'-relief'       => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$f = $F->Frame;
	$l = $f->Label( '-text'   => 'Distance to next: ',
					'-width'  => 20,
					'-anchor' => 'w' );
	$e = $f->Entry( '-textvariable' => \$self->{ 'dn' },
					'-width'        => 20,
					'-relief'       => 'flat' );
	$f->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );
	$l->pack( '-side' => 'left' );
	$e->pack( '-side' => 'right' );

	$F->pack( '-side' => 'top',
			  '-padx' => 2,
			  '-pady' => 2 );

	$F = $self->{ 'w' }->Frame( '-relief'      => 'ridge',
								'-borderwidth' => '1m' );

	if ( $has_auto_pulses ) {
		$f = $F->Frame;
		$l = $f->Label( '-text'   => 'Position of parent: ',
						'-width'  => 20,
						'-anchor' => 'w' );
		$e = $f->Entry( '-textvariable' => \$self->{ 'pp' },
						'-width'        => 20,
						'-relief'       => 'flat' );
		$f->pack( '-side' => 'top',
				  '-padx' => 2,
				  '-pady' => 2 );
		$l->pack( '-side' => 'left' );
		$e->pack( '-side' => 'right' );

		$f = $F->Frame;
		$l = $f->Label( '-text'   => 'Length of parent: ',
						'-width'  => 20,
						'-anchor' => 'w' );
		$e = $f->Entry( '-textvariable' => \$self->{ 'pl' },
						'-width'        => 20,
						'-relief'       => 'flat' );
		$f->pack( '-side' => 'top',
				  '-padx' => 2,
				  '-pady' => 2 );
		$l->pack( '-side' => 'left' );
		$e->pack( '-side' => 'right' );

		$f = $F->Frame;
		$l = $f->Label( '-text'   => 'Function of parent: ',
						'-width'  => 20,
						'-anchor' => 'w' );
		$e = $f->Entry( '-textvariable' => \$self->{ 'pf' },
						'-width'        => 20,
						'-relief'       => 'flat' );
		$f->pack( '-side' => 'top',
				  '-padx' => 2,
				  '-pady' => 2 );
		$l->pack( '-side' => 'left' );
		$e->pack( '-side' => 'right' );

		$f = $F->Frame;
		$l = $f->Label( '-text'   => 'Pod/channel of parent: ',
						'-width'  => 20,
						'-anchor' => 'w' );
		$e = $f->Entry( '-textvariable' => \$self->{ 'pc' },
						'-width'        => 20,
						'-relief'       => 'flat' );
		$f->pack( '-side' => 'top',
				  '-padx' => 2,
				  '-pady' => 2 );
		$l->pack( '-side' => 'left' );
		$e->pack( '-side' => 'right' );

		$F->pack( '-side' => 'top',
				  '-padx' => 2,
				  '-pady' => 2 );
	}

	return bless $self, $class;
}


#---------------------------------------------------------
# Displays the pulse parameters when the mouse is moved onto a pulse

sub Enter {

	my ( $self, $tag, $step, $is_delay ) = @_;
	my ( $f, $ch, $num ) = split /:/, $tag;

	my $pod = $Channels->find_by_key( $f . ":" . $ch );

	my $j = $step;
	$j-- while $j > 0 and ! defined $pod->get_pulse_list( $j );

	my $pl = $pod->get_pulse_list( $j );

	my $i;
	for ( $i = 0; exists $pl->[ $i ]; $i++ ) {
		last if $pl->[ $i ]->num eq $num;
	}

	my $cp = $pl->[ $i ];
	my $pp = $i > 0 ? $pl->[ $i - 1 ] : undef;
	my $np = exists( $pl->[ $i + 1 ] ) ? $pl->[ $i + 1 ] : undef;

	my ( $p1, $p2 ) = $self->pstart( $cp->start, $pod, $is_delay );

	if ( $p1 ne $p2 ) {
		$self->{ 'pos' } = $p1 . "  (" . $p2 . ")";
	} else {
		$self->{ 'pos' } = $p1;
	}
	$self->{ 'len' } = $self->ptime( $cp->len );

	$self->{ 'func' } = $f;
	$self->{ 'ch' } = $ch;

	$self->{ 'dp' } = defined( $pp ) ?
				$self->ptime( $cp->start - $pp->start - $pp->len ) . "  (" .
				$self->ptime( $cp->start - $pp->start
							  + 0.5 * ( $cp->len - $pp->len ) ) .")" : '';
	$self->{ 'dn' } = defined( $np ) ?
				$self->ptime( $np->start - $cp->start - $cp->len ) . "  (" .
				$self->ptime( $np->start - $cp->start
							  + 0.5 * ( $np->len - $cp->len ) ) .")" : '';

	if ( $num =~ /^\((\d+)\)$/ ) {
		$self->{ 'num' } = $num . "    [auto]";
		$self->parent( $1, $step, $is_delay );
	}
	else {
		$self->{ 'num' } = $num;
	}

}


#---------------------------------------------------------
# Displays the parameters of the parent of an automatically created pulse

sub parent {

	my ( $self, $pp, $step, $is_delay ) = @_;
	my ( $pod, $cp, $pl );

	$cp = undef;
	for ( my $i = 0; $i < $Channels->num_channels; $i++ ) {

		$pod = $Channels->find_by_num( $i );
		my $j = $step;
		$j-- while $j > 0 and ! defined $pod->get_pulse_list( $j );
		$pl = $pod->get_pulse_list( $j );

		for $j ( @$pl ) {
			next unless $j->num eq $pp ;
			$cp = $j;
			last;
		}

		last if defined $cp;
	}

	my ( $p1, $p2 ) = $self->pstart( $cp->start, $pod, $is_delay );

	if ( $p1 ne $p2 ) {
		$self->{ 'pp' } = $p1 . "  (" . $p2 . ")";
	} else {
		$self->{ 'pp' } = $p1;
	}
	$self->{ 'pl' } = $self->ptime( $cp->len );

	$self->{ 'pf' } = $pod->name;
	$self->{ 'pc' } = $pod->num;
}


#---------------------------------------------------------

sub pstart {

	my ( $self, $ticks, $ch, $is_delay ) = @_;

	return ( $self->ptime( $ticks - $Delay + $ch->{ 'delay' } ),
			 $self->ptime( $ticks ) ) if $is_delay;

	return ( $self->ptime( $ticks ),
			 $self->ptime( $ticks - $Delay + $ch->{ 'delay' } ) );
}


#---------------------------------------------------------
# Returns a string with a pulse position or length with in resonable units

sub ptime {

	my ( $self, $ticks ) = @_;

	my $t = $ticks;

	if ( $t * $time_base < 1e-5 ) {
		return $t * $time_base * 1e9 . " ns";
	} elsif ( $t * $time_base < 1e-2 ) {
		return sprintf "%.3f us", $t * $time_base * 1e6;
	} else {
		return sprintf "%.6f ms", $t * $time_base * 1e3;
	}

	return "";
}


#---------------------------------------------------------
# Clears all entries in the display window when the mouse is moved away
# from a pulse

sub Leave {
	my $self = shift;

	for ( keys %{ $self } ) {
		next if /^w$/;
		$self->{ $_ } = '';
	}
}

1;


#=========================================================================
# Topmost data object: deals with all channels

package Channels;

sub new {
	my $inv = shift;
	my $class = ref( $inv ) || $inv;
	my $self = { 'channels'     => [ ],
				 'num_steps'    => -1 };
	return bless $self, $class;
}


#---------------------------------------------------------
# Appends a new channel to the list of channels

sub add_channel {

	my $self = shift;
	push @{ $self->{ 'channels' } }, Channel->new( @_ );
}


#---------------------------------------------------------
# Returns the channel object according to its position in the list of channels

sub find_by_num {

	my ( $self, $num ) = ( shift, shift );
	return undef if $num >= @{ $self->{ 'channels' } };
	return $self->{ 'channels' }[ $num ];
}


#---------------------------------------------------------
# Returns a channel object according to the key of the channel

sub find_by_key {

	my ( $self, $key ) = ( shift, shift );

	for ( @{ $self->{ 'channels' } } ) {
		return $_ if $_->key =~ /^$key$/;
	}

	return undef;
}


#---------------------------------------------------------
# Returns the total number of channels

sub num_channels {
	return scalar( @{ shift->{ 'channels' } } );
}


#---------------------------------------------------------
# Return the number of steps during the experiment

sub num_steps {
	return shift->{ 'num_steps' }
}


#---------------------------------------------------------

sub add_pulse_list {

	my ( $self, $step, $key ) = ( shift, shift, shift );

	my $ch = $self->find_by_key( $key );

	if ( $verbose ) {
		die "Invalid input at line $..\n" unless defined $ch;
	} else {
		exit 1 unless defined $ch;
	}

	$ch->add_pulse_list( $step, @_ );
	$self->{ 'num_steps' } = $step if $step > $self->{ 'num_steps' };
}


#---------------------------------------------------------
# Returns the longest sequence of all channels with and without delays

sub longest_sequence {

	my $self = shift;
	my @duration = ( 0, 0 );

	for ( @{ $self->{ channels } } ) {
		my @l = $_->longest_sequence;
		next unless @l;
		$duration[ 0 ] = $l[ 0 ] if $duration[ 0 ] < $l[ 0 ];
		$duration[ 1 ] = $l[ 1 ] if $duration[ 1 ] < $l[ 1 ];
	}

	return @duration;
}


#---------------------------------------------------------
# Returns the earliest postion of all the pulses of all channels

sub first_pulse {

    my $self = shift;
    my $first;

    for ( @{ $self->{ 'channels' } } ) {
        my $e = $_->first_pulse;
		next unless defined $e;
        $first = $e if ! defined $first or $first > $e;
    }

    return $first;
}

1;


#=========================================================================
# Intermediate data object: properties of a single chanel

package Channel;

sub new {
	my $inv = shift;
	my $class = ref( $inv ) || $inv;
	my $self = { 'key'   => shift,
				 'name'  => shift,
			     'num'   => shift,
				 'delay' => shift,
				 'inv'   => shift,
			     'plist' => { } };

	return bless $self, $class;
}


#---------------------------------------------------------

sub key {
	return shift->{ 'key' };
}


#---------------------------------------------------------

sub name {
	return shift->{ 'name' };
}


#---------------------------------------------------------

sub num {
	return shift->{ 'num' };
}


#---------------------------------------------------------

sub delay  {
	return shift->{ 'delay' };
}


#---------------------------------------------------------


sub inv {
	return shift->{ 'inv' };
}


#---------------------------------------------------------

sub add_pulse_list {

	my ( $self, $step ) = ( shift, shift );
	$self->{ 'plist' }{ $step } = Pulse_List->new( @_ );
}


#---------------------------------------------------------

sub get_pulse_list {

	my ( $self, $step ) = ( shift, shift );

	if ( $verbose ) {
		die "Invalid pulse list index\n" if $step < 0;
	} else {
		exit 1 if $step < 0;
	}

	return $self->{ 'plist' }{ $step }
		if exists $self->{ 'plist' }{ $step };
	return undef;
}


#---------------------------------------------------------
# Returns the longest sequence length for the channel with and without delays

sub longest_sequence {

	my $self = shift;
	my @duration = ( 0, 0 );

	for ( keys %{ $self->{ 'plist' } } ) {
		my $len = $self->{ 'plist' }{ $_ }->len;
		$duration[ 0 ] = $len if $duration[ 0 ] < $len;
		$duration[ 1 ] = $len + $self->{ 'delay' } - $Delay
			if $duration[ 1 ] < $len + $self->{ 'delay' } - $Delay;
	}

	return @duration;
}


#---------------------------------------------------------

sub first_pulse {

    my $self = shift;
    my $first;

    for ( keys %{ $self->{ 'plist' } } ) {
        my $e = $self->{ 'plist' }{ $_ }->start;
		next unless defined $e;
		$e += $self->{ 'delay' } - $Delay if $Delay;
		$first = $e if ! defined $first or $first > $e;
    }

    return $first;
}

1;


#=========================================================================
# List of all pulses belonging to a channel

package Pulse_List;

sub new {
	my $inv = shift;
	my $class = ref( $inv ) || $inv;
	my $self = [ ];
	push @$self, Pulse->new( shift, shift, shift ) while ( @_ );
	return bless $self, $class;
}


#---------------------------------------------------------
# Returns total length of the pulse list (i.e. start postition plus
# length of the last pulse) or 0 if there's no pulse in the pulse list

sub len {
	my $self = shift;
	return 0 if @$self == 0;
	return $self->[ -1 ]->start + $self->[ -1 ]->len;
}


#---------------------------------------------------------
# Returns the position of the first pulse in the list or 'undef' if
# there's no pulse in the pulse list

sub start {
	my $self = shift;
	return undef if @$self == 0;
	return $self->[ 0 ]->start;
}

1;


#=========================================================================
# Most basic data object: a single pulse

package Pulse;

sub new {
	my $inv = shift;
	my $class = ref( $inv ) || $inv;
	my $self = { 'num'   => shift,
				 'start' => shift,
				 'len'   => shift };
	return bless $self, $class;
}


#---------------------------------------------------------

sub num {
	return shift->{ 'num' };
}


#---------------------------------------------------------

sub start {
	return shift->{ 'start' };
}


#---------------------------------------------------------

sub len {
	return shift->{ 'len' };
}

1;
