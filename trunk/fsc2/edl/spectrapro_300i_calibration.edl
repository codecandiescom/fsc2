  /*---------------------------------------------------------------*/
  /* EDL script for doing a calibration of the combination of the  */
  /* Acton SpectraPro 300i monochromator and the Roper Scientific  */
  /* Spec-10 CCD camera.                                           */
  /*                                                               */
  /* The script tries to determine the values of the pixel offset  */
  /* from the center (due to misalignments between monochromator   */
  /* and the CCD chip), the inclusion angle and the focal length   */
  /* of the monochromator and the angle the CCD chip is out of     */
  /* the focal plane.                                              */
  /*                                                               */
  /* A calibration is done in several steps:                       */
  /* 1. Select the grating for which the calibration is to be done */
  /* 2. Monochromator is set to 0 nm. Now adjust the pixel offset  */
  /* so that the 0th order maximum is exactly at the zero position */
  /*    of the scale                                               */
  /* 3. Select the center wavelengths so that a well known line is */
  /*    once at the left side of the display and once at the right */
  /*    side. Repeat this for at least 2 calibration lines (to get */
  /*    a minimum of 4 data sets). Each time measure the position  */
  /*    of the line relative to the displayed scale. The data for  */
  /*    center wavelength, line wavelength, line position and      */
  /*    diffraction order (shown in the main windows lower browser */
  /*    after the "Add data set" button has been pressed) are used */
  /*    to calculate the calibration parameters. The calculated    */
  /*    parameters are displayed when at least 4 data sets have    */
  /*    been entered.                                              */
  /* 4. Repeat the above procedure until calibrations for all      */
  /*    gratings.                                                  */
  /* 5. When the script gets stopped by clicking on the "Stop"     */
  /*    select a file for writing out the calibration parameter.   */
  /*    The default extension for the file is ".calib".            */
  /*                                                               */
  /* $Id$ */
  /*                                                               */
  /* Copyright (C) 1999-2003 Jens Thoms Toerring                   */
  /*                                                               */
  /* This file is part of fsc2.                                    */
  /*                                                               */
  /* Fsc2 is free software; you can redistribute it and/or modify  */
  /* it under the terms of the GNU General Public License as       */
  /* published by the Free Software Foundation; either version 2,  */
  /* or (at your option) any later version.                        */
  /*                                                               */
  /* Fsc2 is distributed in the hope that it will be useful,       */
  /* but WITHOUT ANY WARRANTY; without even the implied warranty   */
  /* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See  */
  /* the GNU General Public License for more details.              */
  /*                                                               */
  /* You should have received a copy of the GNU General Public     */
  /* License along with fsc2; see the file COPYING.  If not, write */
  /* to the Free Software Foundation, 59 Temple Place - Suite 330, */
  /* Boston, MA 02111-1307, USA.                                   */
  /*---------------------------------------------------------------*/


DEVICES:

spectrapro_300i;          /* Acton SpectraPro 300i monochromator */
rs_spec10;                /* Roper Scientific Spec-10 CCD camera */


VARIABLES:

exposure_time = 0.01 s;    /* exposure time for CCD camera */
NUM_GRATINGS = 2;         /* number of installed gratings */

ia_def = 30.3;            /* default value of inclusion angle */
fl_def = 0.3 m;           /* default value of focal length */
da_def = 0.0;             /* default value of detector angle */

LW_def_1200 = 50;         /* default linewidth (in pixel) for a grating
							 with 1200 grooves per mm */

/* -> There is nothing that needs changes below this line <- */

State = 0;                /* state the program is currently in:
							 0: start up, 1: selection of grating,
							 2: determination of center position,
							 3: fitting of calibration paramters */

W[ 2 ];                   /* with and height of CCD chip */
CG = 1;                   /* number of current grating */
GN[ NUM_GRATINGS ],       /* grating buttons in first form */
LW,
CP,
cp0,
cp1,
DO,                       /* Execute button */
GO,                       /* Continue etc. button */
CL,                       /* input field for 0th order line position */
CWL,                      /* input field for center wavelength */
DFO,                      /* input field for diffraction order */
LWL,                      /* input field for wavelength of line */
LP,                       /* input field for line position */
ADD,                      /* button for adding new data set */
RESET_LAST,               /* button for clearing latest data set */
RESET_ALL,                /* button for clearing all data sets */
IA,                       /* output field for inclusion angle */
FL,                       /* output field for focal length */
DA,                       /* output field for detector angle */
DONE;                     /* Done button */

cwl,                      /* last entered center wavelength */
Dfo,                      /* last entered diffraction order */
lwl,                      /* last entered line wavelength */
lp;                       /* last entered line position */
Count[ NUM_GRATINGS ];    /* number of entered data sets for gratings */

Spec[ * ];                /* array of currently displayed spectrum */

I;                        /* counter */
new_val, New_val;         /* intermediate values */

scale[ 2 ];               /* x-axis scaling values */

l[ * ];                   /* array of line wavelengths */
lc[ * ];                  /* array of center wavelengths */
M[ * ];                   /* array of diffraction orders */
px[ * ];                  /* array of line positions (in pixel) */
calib[ NUM_GRATINGS, * ]; /* matrix of calibration parameter */

CWL_is_set;
io_def[ NUM_GRATINGS ],
ig_def[ NUM_GRATINGS ],
io[ NUM_GRATINGS ],
ig[ NUM_GRATINGS ],
io_new,
ig_new,
ia,                       /* currently used inclusion angle */
fl,                       /* currently used focal length */
da;                       /* currently used detector angle */

File;                     /* file handle for calibration file */


PREPARATIONS:

W = ccd_camera_pixel_area( );
init_1d( 1, W[ 1 ], "Pixel number" );


EXPERIMENT:

ccd_camera_exposure_time( exposure_time );

FOR I = 1 : NUM_GRATINGS {
	io_def[ I ] = monochromator_init_offset( I );
	ig_def[ I ] = monochromator_init_adjust( I );
}

set_seed( );

FOREVER
{
	/* Always update the displayed curve during the calibration procedure. */

	IF State > 1 {
		Spec = ccd_camera_get_spectrum( );
		display_1d( 1, Spec );
	}

/***************************************************************************/
/*                                                                         */
/*                            STAGE 0                                      */
/*                                                                         */
/***************************************************************************/

	/* At the very start (or after the calibration of one of the gratings has
	   been finished) create the first form for selecting the grating to be
	   calibrated. */

	IF State == 0 {

		ia = ia_def;
		fl = fl_def;
		da = da_def;

		clear_curve_1d( );
		hide_toolbox( 1 );
		GN[ 1 ] = button_create( "RADIO_BUTTON", "Grating #1" );
		FOR I = 2 : NUM_GRATINGS {
			GN[ I ] = button_create( "RADIO_BUTTON", GN[ 1 ],
									 sprint( "Grating \##", I ) );
		}

		button_state( GN[ CG ], "ON" );
		GO = button_create( "NORMAL_BUTTON", "Start Calibration" );
		hide_toolbox( 0 );
	    change_label_1d( "Line position [pixel]" );
		State = 1;
	} 

/***************************************************************************/
/*                                                                         */
/*                            STAGE 1                                      */
/*                                                                         */
/***************************************************************************/

	/* When a grating has been selected create the form for calibrating the
	   grating offset angle. */

	IF State == 1 & button_state( GO ) {

		/* Figure out which grating to calibrate. */

		FOR I = 1 : NUM_GRATINGS {
			IF button_state( GN[ I ] ) {
				CG = I;
				BREAK
			}
		}

		/* Remove the toolbox */

		hide_toolbox( 1 );
		button_delete( GO );
		FOR I = NUM_GRATINGS : 1 : -1 {
			button_delete( GN[ I ] );
		}
		hide_toolbox( 0 );

		/* Reset the number of calibration values for the selected grating. */

		Count[ CG ] = 0;

		/* Calculate the range around the highest measured value used when
		   trying to find a peak */

		LW = round( 0.5 * LW_def_1200 * monochromator_groove_density( CG )
				    / 1.2e6 );

		/* Remove any possibly existing calibration, then get scaling in
		   pixel units and set the x-axis accordingly (taking into account
		   a possibly already set pixel offset). */

		monochromator_set_calibration( CG, "OFF" );
		scale = monochromator_wavelength_axis( );
		change_scale_1d( scale[ 1 ], scale[ 2 ] );

		/* Switch the monochromator to the selected grating and go to a
		   a center wavelength of 0 nm. */

		monochromator_grating( CG );
		monochromator_wavelength( 0.0 );

		/* Set the monochromator grating parameters back to the values they
		   had at the start of the program */

		io[ CG ] = io_def[ CG ];
		io_new = io[ CG ];
		ig[ CG ] = ig_def[ CG ];
		ig_new = io[ CG ];

		print( "Setting init offset to start value\n" );
		monochromator_init_offset( CG, io[ CG ]	);
		print( "Setting init adjust to start value\n" );
		monochromator_init_adjust( CG, ig[ CG ]	);

		/* Create the next form for adjusting the pixel offset. */

		hide_toolbox( 1 );
		LP  = output_create( "FLOAT_OUTPUT", 0.0, "Line position [pixel]" );
		DO = button_create( "NORMAL_BUTTON", "Calibrate offset" );
		GO = button_create( "NORMAL_BUTTON", "Continue" );
		hide_toolbox( 0 );
		State = 2;

		State = 2;
		NEXT;
	}

/***************************************************************************/
/*                                                                         */
/*                            STAGE 2                                      */
/*                                                                         */
/***************************************************************************/

	/* Deal with the user adjusting the pixel offset. */

	IF State == 2 & toolbox_changed( ) {

		/* The "Calibrate offset" button starts a offset calibration sequence
		   that consists of determining the current line position, changing
		   the grating offset a bit, finding the new line position, calculating
		   the offset and then the offset that hopefully gets the line to the
		   center of the detector. Finally the the grating offset is set to
		   this value and, again, the peak position is determined. */

		IF button_state( DO ) {

			/* Try to find the current peak position (in units of pixels
			   relative to the left edge) by first looking for the largest
			   value in the spectrum (which should always be near to the 0th
			   order line) and then doing a peak finding. */

			Spec = ccd_camera_get_spectrum( );
			display_1d( 1, Spec );

			CP = index_of_max( Spec );

			IF CP - LW < 1 | CP + LW > W[ 1 ] {
				show_message( "Line seems to be too near to the edge.\n" );
				NEXT;
			}

			cp0 = find_peak( slice( Spec, CP - LW, 2 * LW + 1 ) )
				  + CP - LW - 1;

			IF cp0 < 0 {
				show_message( "Can't find a line.\n" );
				NEXT;
			}

			IF cp0 < 1 | cp0 + LW > W[ 1 ] {
				show_message( "Line seems to be too near to the edge.\n" );
				NEXT;
			}

			print( "Found peak at #\n", cp0 );

			draw_marker_1d( round( cp0 ) );
			output_value( LP, cp0 - 1 + scale[ 1 ] );

			/* Now set a slightly different offset - use a randomized value
			   to avoid doing the same all over again in case the user does
			   another run. Then try to find the line at its new position. */

			io_new = io[ CG ] + 0.2 + 0.1 * ( random( ) - 0.5 ); 

			print( "Changing init offset to #\n", io_new );

			monochromator_init_offset( CG, io_new );

			Spec = ccd_camera_get_spectrum( );
			display_1d( 1, Spec );

			CP = index_of_max( Spec );

			IF CP - LW < 1 | CP + LW > W[ 1 ] {
				show_message( "Line seems to be too near to the edge.\n" );
				NEXT;
			}

			cp1 = find_peak( slice( Spec, CP - LW, 2 * LW + 1 ) )
				  + CP - LW - 1;

			IF cp1 < 0 {
				show_message( "Can't find a line.\n" );
				NEXT;
			}
			IF cp1 < 1 | cp1 > W[ 1 ] {
				show_message( "Line seems to be too near to the edge.\n" );
				NEXT;
			}

			print( "Found peak at #\n", cp1 );

			clear_marker_1d( );
			draw_marker_1d( round( cp1 ) );
			output_value( LP, cp1 - 1 + scale[ 1 ] );

			/* Calculate the offset that should move the line to the zero
			   position and set the monochromator accordingly */

			io_new = io[ CG ] - ( cp0 - 0.5 * ( W[ 1 ] - 1 ) )
								* ( io_new - io[ CG ] ) / ( cp1 - cp0 );

			print( "Changing init offset to #\n", io_new );

			monochromator_init_offset( CG, io_new );

			/* Get another spectrum and again find the line */

			Spec = ccd_camera_get_spectrum( );
			display_1d( 1, Spec );

			CP = index_of_max( Spec );

			IF CP - LW < 1 | CP + LW > W[ 1 ] {
				show_message( "Line seems to be too near to the edge.\n" );
				NEXT;
			}

			cp1 = find_peak( slice( Spec, CP - LW, 2 * LW + 1 ) )
				  + CP - LW - 1;

			IF cp1 < 0 {
				show_message( "Can't find a line.\n" );
				NEXT;
			}
			IF cp1 < 1 | cp1 > W[ 1 ] {
				show_message( "Line seems to be too near to the edge.\n" );
				NEXT;
			}

			print( "Found peak at #\n", cp1 );

			clear_marker_1d( );
			draw_marker_1d( round( cp1 ) );
			output_value( LP, cp1 - 1 + scale[ 1 ] );
		}

		/* When the user is satisfied delete the form and create a new one
		   for adjusting the grating rotation parameter. */

		IF button_state( GO ) {

			io[ CG ] = io_new;

			hide_toolbox( 1 );
			button_delete( GO );
			button_delete( DO );
			output_delete( LP );

			CWL = input_create( "FLOAT_INPUT", 0.0,
								"Reference wavelength [nm]" );
			cwl = 0.0;
			CWL_is_set = 0;

			LP  = input_create( "FLOAT_INPUT", 0.0, "Line position [nm]" );
			lp  = 0.0;

			CL = button_create( "NORMAL_BUTTON", "Find peak" );
			DO = button_create( "NORMAL_BUTTON", "Accept position" );
			GO = button_create( "NORMAL_BUTTON", "Continue" );

			monochromator_set_calibration( CG, io[ CG ], ig[ CG ],
										   ia, fl, da );
			scale = monochromator_wavelength_axis( );
			change_scale_1d( scale[ 1 ] / 1 nm, scale[ 2 ] / 1 nm );
			change_label_1d( "Wavelength [nm]" );

			clear_marker_1d( );
		}
	}

/***************************************************************************/
/*                                                                         */
/*                            STAGE 3                                      */
/*                                                                         */
/***************************************************************************/

	/* The next step is the determination of the rotation parameter for the
	   grating. */

	IF State == 3 & toolbox_changed( ) {

		/* Deal with changes of wavelength of the reference line. */

		IF input_changed( CWL )
		{
			new_val = input_value( CWL );
			IF new_val < 50 | new_val > 1400 {
				input_value( CWL, cwl );
				NEXT;
			}

			cwl = new_val;
			monochromator_wavelength( cwl * 1 nm );

			scale = monochromator_wavelength_axis( );
			change_scale_1d( scale[ 1 ] / 1 nm, scale[ 2 ] / 1 nm );

			/* Change the line position field to display the new center
			   wavelength */

			monochromator_init_adjust( CG, ig_new );

			input_value( LP, cwl );
			lp = 0.5 * W[ 1 ];
			output_value( LP, ( ( lp - 1 ) * scale[ 2 ] + scale[ 1 ] ) / 1nm );
			CWL_is_set = 1;
			clear_marker_1d( );
			draw_marker_1d( round( lp ) );

			CWL_is_set = 1;
			NEXT;
		}

		/* Deal with changes of the line position */

		IF input_changed( LP )
		{
			/* Reference wavelength must be set first */

			IF ! CWL_is_set {
				input_value( LP, 0.0 );
			}

			/* Calculate pixel postion (relative to left edge) of the newly
			   entered wavelength. If it's within the visible range redraw
			   the marker, otherwise reset to the previous wavelength */

			new_val = input_value( LP );
			new_val = ( new_val * 1nm - scale[ 1 ] ) / scale[ 2 ] + 1;

			IF round( new_val ) < 1 | round( new_val ) > W[ 1 ] {
				input_value( LP,
							 ( ( lp - 1 ) * scale[ 2 ] + scale[ 1 ] ) / 1nm );
			} ELSE {
				lp = new_val;
				clear_marker_1d( );
				draw_marker_1d( round( lp ) );
			}
		}

		/* Deal with clicks on the "Find peak" button */

		IF button_changed( CL )
		{
			/* Reference wavelength must be set first */

			IF ! CWL_is_set {
				input_value( LP, 0.0 );
			}

			/* Try to find the line at the position the user entered. Complain
			   if the position is very near to the limits or mno line can
			   be found */

			IF round( lp - LW ) < 1 | round( lp + LW ) > W[ 1 ] {
				show_message( "Line is too near to the edge." );
				NEXT;
			}

			new_val = find_peak( slice( Spec, round( lp - LW ), 2 * LW + 1 ) )
				      + lp - LW - 1;

			IF new_val < 0 {
				show_message( "Sorry, can' find a line, try again." );
				NEXT;
			}

			lp = new_val;
			input_value( LP, ( lp * scale[ 2 ] + scale[ 1 ] ) / 1 nm );
			clear_marker_1d( );
			draw_marker_1d( round( lp ) );
		}

		/* Deal with clicks on the "Accept position" button. */

		IF button_state( DO ) {

			/* Reference wavelength must be set first */

			IF ! CWL_is_set {
				input_value( LP, 0.0 );
			}

			IF ( ig_new == ig[ CG ] )
			{
				cp0 = input_value( LP );
				ig_new = ig[ CG ] + 0.2 + 0.1 * ( random( ) - 0.5 ); 
				monochromator_init_adjust( CG, ig_new );
				clear_marker_1d( );
			} ELSE {
				cp1 = input_value( LP );
				ig[ CG ] -=   ( cp0 - 0.5 * ( W[ 1 ] - 1 ) )
							* ( io_new - ig[ CG ] ) / ( cp1 - cp0 );
				monochromator_init_adjust( CG, ig[ CL ] );
				ig_new = ig[ CG ];
				clear_marker_1d( );
			}
		}

		/* When the user is satisfied delete the form and create a new one
		   for adjusting the dispersion properties of the grating. */

		IF button_state( GO ) {
			CWL = input_create( "FLOAT_INPUT", 0.0, "Center wavelength [nm]" );
			cwl = 0.0;

			DFO = input_create( "INT_INPUT", 1, "Diffraction order" );
			Dfo = 1;

			LWL = input_create( "FLOAT_INPUT", 0.0,
								"Wavelength of line [nm]" );
			lwl = 0.0;

			LP  = input_create( "FLOAT_INPUT", 0.0, "Line position [nm]" );
			lp  = 0.0;

			ADD = button_create( "NORMAL_BUTTON", "Add new data set" );
			RESET_LAST = button_create( "NORMAL_BUTTON",
										"Remove latest data set" );
			RESET_ALL = button_create( "NORMAL_BUTTON", "Reset all" );
			DONE = button_create( "NORMAL_BUTTON", "Done" );
			hide_toolbox( 0 );

			/* If necessary shorten the arrays for the data sets. */

			IF size( l ) >= 4 {
				l  = slice( l, 1, 1 );
				lc = slice( lc, 1, 1 );
				M  = slice( M, 1, 1 );
				px = slice( px, 1, 1 );
			}

			State = 3;
		}
	}

/***************************************************************************/
/*                                                                         */
/*                            STAGE 5                                      */
/*                                                                         */
/***************************************************************************/

	/* Deal with changes of the dispersion properties of the grating. */

	IF State == 4 & toolbox_changed( ) {

		/* Deal with changes of the center wavelength - must be between 0 nm
		   and 1400 nm - and set the monochromator accordingly. Finally
		   change the x-axis scaling to fit the new center wavelength. */

		IF input_changed( CWL ) {
			new_val = input_value( CWL );
			IF new_val < 0 | new_val > 1400 {
				input_value( CWL, cwl );
				NEXT;
			}

			cwl = new_val;
			monochromator_wavelength( cwl * 1 nm );

			monochromator_set_calibration( CG, io[ CG ], ig[ CG ],
										   ia, fl, da );
			scale = monochromator_wavelength_axis( );
			change_scale_1d( scale[ 1 ] / 1 nm, scale[ 2 ] / 1 nm );
			change_label_1d( "Wavelength [nm]" );
		}

		/* Deal with changes of the diffraction order - must be larger
		   than 0. */

		IF input_changed( DFO ) {
			New_val = input_value( DFO );
			IF New_val > 0 {
				Dfo = New_val;
			} ELSE {
				input_value( DFO, Dfo );
			}
		}

		/* Deal with changes of the wavelength of the line under consideration
		   - must be at least 0 nm and below 10 um (such a large value could
		   only happen for gratings with less than 10 grooves per mm). */

		IF  input_changed( LWL ) {
			new_val = input_value( LWL );
			IF new_val < 0 | new_val > 10000 {
				input_value( LWL, lwl );
				NEXT;
			}
			lwl = new_val;
		}

		/* Deal with changes of the line position - the value must be within
		   the currently displayed wavelength range. */

		IF input_changed( LP ) {
			new_val = input_value( LP );
			new_val = ( new_val * 1 nm - scale[ 1 ] ) / scale[ 2 ]
					  - 0.5 * ( W[ 1 ] - 1 );
			IF abs( new_val ) < 0.5 * W[ 1 ] {
				lp = new_val;
			} ELSE {
				input_value( LP, ( ( lp + 0.5 * ( W[ 1 ] - 1 ) ) * scale[ 2 ]
							 + scale[ 1 ] ) / 1 nm );
			}
		}

		/* Deal with clicks on the "Add new data set" button. */

		IF button_state( ADD ) {

			/* Avoid that the user accidentally adds the same data set a
			   second time. */

			IF Count[ CG ] > 0 &
			   abs( cwl - lc[ Count[ CG ] ] / 1 nm ) < 1.0e-3 &
			   abs( lwl - l[ Count[ CG ] ] / 1 nm ) < 1.0e-3 &
			   Dfo == M[ Count[ CG ] ] &
			   abs( lp - px[ Count[ CG ] ] ) < 1.0e-3 {
				NEXT;
			}

			/* Add the data set to the arrays for the data sets and increase
			   the count for the current grating. Then print out the accepted
			   values. */

			Count[ CG ] += 1;
			lc[ Count[ CG ] ] = cwl * 1 nm;
			l[ Count[ CG ] ] = lwl * 1 nm;
			M[ Count[ CG ] ] = Dfo;
			px[ Count[ CG ] ] = lp;

			print( "#:  # nm,  #,  # nm,  # nm\n", Count[ CG ],
				   l[ Count[ CG ] ] / 1 nm, M[ Count[ CG ] ],
				   lc[ Count[ CG ] ] / 1 nm,
				   ( ( px[ Count[ CG ] ] + 0.5 * ( W[ 1 ] - 1 ) ) * scale[ 2 ]
				   + scale[ 1 ] ) / 1 nm );

			/* If there are at least 4 data sets calculate the the new
			   calibration data and put them into the output fields. When
			   this is the fourth data set the output fields need to be
			   created. */

			IF ( Count[ CG ] >= 4 )
			{
				calib[ CG ] = monochromator_calibration( CG, l, lc, M, px );

				/* Change the x-axis scale to reflect the new calibration. */

				ia = calib[ CG, 1 ];
				fl = calib[ CG, 2 ];
				da = calib[ CG, 3 ];

				monochromator_set_calibration( CG, io[ CG ], ig[ CG ],
											   ia, fl, da );
				scale = monochromator_wavelength_axis( );
				change_scale_1d( scale[ 1 ] / 1 nm, scale[ 2 ] / 1 nm );
				input_value( LP, ( ( lp + 0.5 * ( W[ 1 ] - 1 ) ) * scale[ 2 ]
							 + scale[ 1 ] ) / 1 nm );

				IF Count[ CG ] == 4 {
					hide_toolbox( 1 );
					button_delete( DONE );
					IA = output_create( "FLOAT_OUTPUT", calib[ CG, 1 ],
										"Inclusion angle [degree]" );
					FL = output_create( "FLOAT_OUTPUT", calib[ CG, 2 ] / 1 mm,
										"Focal length [mm]" );
					DA = output_create( "FLOAT_OUTPUT", calib[ CG, 3 ],
										"Dectector angle [degree]" );
					DONE = button_create( "NORMAL_BUTTON", "Done" );
					hide_toolbox( 0 );
				} ELSE {
					output_value( IA, calib[ CG, 1 ] );
					output_value( FL, calib[ CG, 2 ] / 1 mm );
					output_value( DA, calib[ CG, 3 ] );
				}
			}
		}

		/* Deal with clicks on the "Reset all" button - clear the arrays for
		   the data sets and remove the output fields for the calibration
		   data if necessary. */

		IF button_state( RESET_ALL ) & Count[ CG ] > 0 {
			print( "Deleting all data sets for grating \##\n", CG );
			hide_toolbox( 1 );
			IF Count[ CG ] >= 4 {
				output_delete( DA, FL, IA );

				/* Go back to the default scaling of the x-axis. */

				ia = ia_def;
				fl = fl_def;
				da = da_def;

				monochromator_set_calibration( CG, io[ CG ], ig[ CG ],
											   ia, fl, da );
				scale = monochromator_wavelength_axis( );
				change_scale_1d( scale[ 1 ] / 1 nm, scale[ 2 ] / 1 nm );
				input_value( LP, ( ( lp + 0.5 * ( W[ 1 ] - 1 ) ) * scale[ 2 ]
							 + scale[ 1 ] ) / 1 nm );
			}
			Count[ CG ] = 0;
			IF size( l ) >= 4 {
				l  = slice( l, 1, 1 );
				lc = slice( lc, 1, 1 );
				M  = slice( M, 1, 1 );
				px = slice( px, 1, 1 );
			}
			hide_toolbox( 0 );
		}

		/* Deal with clicks on the "Remove latest data set" - remove the data
		   set from the arrays for the data sets and, if necessary (i.e.
		   when going from 4 to 3 data set) remove the output fields for
		   the calibration. */

		IF button_state( RESET_LAST ) & Count[ CG ] > 0 {
			print( "Removing latest data set for grating \##\n", CG );
			IF Count[ CG ] == 4 {
				hide_toolbox( 1 );
				output_delete( DA, FL, IA );
				hide_toolbox( 0 );

				/* Go back to the default scaling of the x-axis. */

				ia = ia_def;
				fl = fl_def;
				da = da_def;

				monochromator_set_calibration( CG, io[ CG ],ig[ CG ],
											   ia, fl, da );
				scale = monochromator_wavelength_axis( );
				change_scale_1d( scale[ 1 ] / 1 nm, scale[ 2 ] / 1 nm );
				input_value( LP, ( ( lp + 0.5 * ( W[ 1 ] - 1 ) ) * scale[ 2 ]
							 + scale[ 1 ] ) / 1 nm );
			}

			Count[ CG ] -= 1;

			IF Count[ CG ] >= 3 {
				l = slice( l, 1, Count[ CG ] );
				lc = slice( lc, 1, Count[ CG ] );
				M = slice( M, 1, Count[ CG ] );
				px = slice( px, 1, Count[ CG ] );
			}

			IF Count[ CG ] >= 4 {
				calib[ CG ] = monochromator_calibration( CG, l, lc, M, px );

				/* Change x-axis to reflect the changed calibration. */

				ia = calib[ CG, 1 ];
				fl = calib[ CG, 2 ];
				da = calib[ CG, 3 ];

				monochromator_set_calibration( CG, io[ CG ], ig[ CG ],
											   ia, fl, da );
				scale = monochromator_wavelength_axis( );
				change_scale_1d( scale[ 1 ] / 1 nm, scale[ 2 ] / 1 nm );
				input_value( LP, ( ( lp + 0.5 * ( W[ 1 ] - 1 ) ) * scale[ 2 ]
							 + scale[ 1 ] ) / 1 nm );

				output_value( IA, calib[ CG, 1 ] );
				output_value( FL, calib[ CG, 2 ] / 1 mm );
				output_value( DA, calib[ CG, 3 ] );
			}
		}

		/* Deal with clicks on the "Done" button - remove the form. */

		IF button_state( DONE ) {
			print( "\n" );
			hide_toolbox( 1 );
			button_delete( DONE );
			IF Count[ CG ] >= 4 {
				output_delete( DA, FL, IA );
			}
			button_delete( RESET_ALL, RESET_LAST, ADD );
			input_delete( LP, DFO, LWL, CWL );
			hide_toolbox( 0 );
			State = 0;
		}
	}
}

/***************************************************************************/
/*                                                                         */
/*                            STAGE 5                                      */
/*                                                                         */
/***************************************************************************/

ON_STOP:

/* Check if there was a complete calibration for at least one if the
   gratings. */

FOR I = 1 : NUM_GRATINGS {
	IF Count[ I ] >= 4 {
		BREAK;
	}
}

/* If there is a valid calibration ask the user for a calibration file and
   write out all sets of complete calibration data into it. */

IF I <= NUM_GRATINGS {
	File = get_file( "Select name of the calibration file:", "*.calib", "", "",
				     "calib" );

	FOR I = 1 : NUM_GRATINGS {
		IF Count[ I ] < 4 {
			NEXT;
		}

		fsave( File, "\# Calibration parameter for grating \##\n\n", I );
		fsave( File, "INIT_OFFSET_#      =  #\n", I, io[ I ] );
		fsave( File, "INIT_ADJUST_#      =  #\n", I, ig[ I ] );
		fsave( File, "INCLUSION_ANGLE_#  =  #\n", I, calib[ I, 1 ] );
		fsave( File, "FOCAL_LENGTH_#     =  # mm\n", I, calib[ I, 2 ] / 1 mm );
		fsave( File, "DETECTOR_ANGLE_#   =  #\n\n", I, calib[ I, 3 ] );
	}
}
