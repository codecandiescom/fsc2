@c $Id$
@c
@c Copyright (C) 1999-2002 Jens Thoms Toerring
@c
@c This file is part of fsc2.
@c
@c Fsc2 is free software; you can redistribute it and/or modify
@c it under the terms of the GNU General Public License as published by
@c the Free Software Foundation; either version 2, or (at your option)
@c any later version.
@c
@c Fsc2 is distributed in the hope that it will be useful,
@c but WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with fsc2; see the file COPYING.  If not, write to
@c the Free Software Foundation, 59 Temple Place - Suite 330,
@c Boston, MA 02111-1307, USA.


@node EDL, Built-in Functions, GUI, Top
@chapter @acronym{EDL}
@cindex @acronym{EDL}

@ifinfo
@menu
* Basics::                  Basic principles.
* Sections::                The sections of an EDL program.
* Syntax::                  Basic syntax of EDL programs.
* Variables::               Using variables and arrays.
* Arithmetic::              Doing calculations with variables.
* Control structures::      Flow control in EDL programs.
* Miscellaneous::           Additional syntactic elements
@end menu
@end ifinfo

To do an experiment using @acronym{fsc2} you have to write a program
describing the experiment. While this may look like a daunting task if
you have no programming experience at all it has the advantage that you
have complete control over the way the experiment is done. You don't
have to rely on some programmer (who probably isn't around when you need
him or her most) to have got everything right before you even started
planning the experiment. And writing @acronym{EDL} programs really isn't
that difficult.


@node Basics, Sections, EDL, EDL
@section Basics

An @acronym{EDL} program is roughly structured along the way an
experiment is done. Before you start an experiment you first have to
select the devices to be used and set them up. So the first part of an
@acronym{EDL} program simply consists of a few lines specifying the
devices to be controlled by the program and setting their parameter,
i.e.@: the time base of the digitizer, the sensitivity of the lock-in
amplifier or which pulses are to be created by the pulse generator. And
as you would now start the experiment the second part of the
@acronym{EDL} program describes how the experiment is to be done.

To give you an impression how an @acronym{EDL} program may look like
here's the program for a cw-EPR experiment:
@example
DEVICES:
  er035m_s;              // gaussmeter module
  aeg_x_band;            // magnet module
  sr530;                 // lock-in amplifier module

VARIABLES:
  start_field = 3360.0 G;
  end_field   = 3450.0 G;
  field_step  =    0.5 G;

  field = start_field;
  I = 1;
  data;

PREPARATIONS:
  magnet_setup( start_field, field_step );
  init_1d( );

EXPERIMENT:
  WHILE field <= end_field
  @{
      data = lockin_get_data( );
      display( I, data );
      save( data );
      I = I + 1;
      field = sweep_up( );
      wait( lockin_time_constant( ) );
  @}
@end example

Obviously, the very first section of the program, starting with the
keyword @code{DEVICES:}, specifies the names of the devices to be used
(everything after the double-slashes are comments). In the example these are
the Bruker ER035M gaussmeter, the AEG X-band magnet and the Stanford
Research lock-in amplifier SR530.

In the following section, starting with the keyword @code{VARIABLES:},
all variables that are used in the program are listed and, if
appropriate, initialized. The first three variables are for storing the
start and end field of the field sweep as well as the step width between
the data points. The next variable @code{field} will later be used for
storing the current field value and is initialized to the value of the
start field.  Finally, a counter variable @code{I}, initialized to 1,
and another variable, @code{data}, later to be used for storing the data
received from the lock-in amplifier, are declared.

In the next section, after the @code{PREPARATIONS:} keyword, devices can
be set up. The function @code{magnet_setup()} tells the magnet to start
with the field stored in the variable @w{@code{start_field}} and to use
a step size of @w{@code{field_step}}. The next function call,
@code{init_1d()}, tells the program that this is a 1-dimensional
experiment and to use the appropriate kind of display for the data.

Now we're already done with the preparations and can start the
experiment, as indicated by the keyword @code{EXPERIMENT:}. The whole
experiment is done in a loop that is repeated as long as the field
(stored in the variable @code{field}) is less or equal to
@code{end_field}. To tell the program where the loop starts and ends all
statements belonging to the loop are enclosed in curly braces,
`@code{@{}' and `@code{@}}'.

The first thing to do in the experiment loop is to fetch a new data
point from the lock-in amplifier, storing it in the variable @code{data}.
Next, we have to display the data point, which is done via the call of
the @code{display()} function. Here two arguments are used, the number
of the point, stored in the variable @code{I}, and the value of the
new data point.

Of course, we also need to write the data point to a file. This is done
by the call of the function @code{save()} that automatically writes its
argument to a file. When the function is called for the first time it
prompts you for the name of the file to use.

What remains to be done is to increment the counter variable @code{I}
and to sweep up the field. The function @code{sweep_up()} returns the new
value of the field, which is then used in the test of the loop condition
to decide if the experiment is finished, i.e.@: the end field is
reached.

The last function call of @code{wait()} with the result of a call of the
function @code{lockin_time_constant()} as the argument makes the program
wait for the time constant of the lock-in amplifier to give it enough
time to measure a new data point.

When you have written such a program (using, for example, a simple ASCII
editor) you load it into @acronym{fsc2} and press the test or the start
button.  @acronym{fsc2} will now analyze the program very thoroughly. It
will not only check for misspelt keywords, undefined variables,
non-existent functions, syntax errors etc.@: but will also repeat the
loop in the experiment section as often as in the real experiment to
find out if no errors will happen during the experiment. This includes,
for example, checking that the field will not be sweeped into regions
the magnet or the gauss-meter can not handle (e.g.@: by incidentally
setting an end field value of @w{34500.0 G} the magnet can't produce
instead of @w{3450.00 G}). So you can be reasonable sure that the
experiment will not abort due to a faulty @acronym{EDL} program after it
has run for 2 hours and you have to start all over again.

As you can already see form the example most of an @acronym{EDL} program
consists of function calls. Functions can be divided into two
categories, built-in functions and device functions. Built-in functions
(like @code{init_1d()}, @code{display()}, @code{save()} and
@code{wait()}) are always available, even when there is no
@code{DEVICES} section. In contrast, device functions are bound to
certain devices and can only be called when the device they are defined
for is listed in the @code{DEVICES} section. For example, the functions
@w{@code{lockin_sensitivity()}}, @w{@code{lockin_time_constant()}} and
@w{@code{lockin_get_data()}} are obviously targeted at the lock-in
amplifier and are only available when a lock-in amplifier module is
specified. Most of these functions are available for all types of
lock-in amplifiers (possibly with minor variations) so that using a
different lock-in amplifier usually doesn't require a major rewrite of
the @acronym{EDL} program but just changing the lock-ins name in the
@code{DEVICES} section.

To find out about all built-in and device functions, their arguments and
when they may be used have a look at the later parts of this manual.


@node Sections, Syntax, Basics, EDL
@section Sections
@cindex section


As you already have seen in the example above, an @acronym{EDL} program
consists of several section. There are up to 6 different sections. These
are:
@example
DEVICES
VARIABLES
ASSIGNMENTS
PHASES
PREPARATIONS
EXPERIMENT
@end example

The first and last two you have already seen: The @code{DEVICES} section
is simply a list of all the devices that will be used in the experiment
(or at least the ones that are going to be controlled by the computer).

Please note that the section keywords always have to be followed by a
colon, `@code{:}'. Another important syntax element is the semicolon,
`@code{;}', that indicates the logical end of a line of code. So, you
also have to write a semicolon after each of the device names.

The @code{VARIABLES} section for declaring and initializing variables
has also already been discussed in the example.

Because pulses play such an important role in modern EPR experiments
lots of elements for handling pulses and the pulser, that creates them,
are built into @acronym{fsc2}. There are even two sections,
@code{ASSIGNMENTS} and @code{PHASES} exclusively devoted to the pulser
setup. The basic setup of the pulser (e.g.@: setting the time base and
trigger mode as well as setting up the pulser channels) is done in the
@code{ASSIGNMENTS} section while the @code{PHASES} section is all about
phase-cycling -- here you will have to define the phase sequences to be
used in the experiment as well as the way the resulting echos will be
added up. Because this is a rather extensive subject (and because of the
different ways pulsers are used in the supported spectrometers) an
in-depth discussion of both these sections is part of a whole chapter
(@pxref{Using Pulsers}).

As you already have seen, the @code{PREPARATIONS} section is for setting
up the other devices and the graphics. This is also the section where
pulses are going to be defined. For more details about this also see the
chapter about pulse generators and pulses.

Finally, there is the @code{EXPERIMENT} section. As you already have
seen this section usually consists of one or more loops, possibly nested.


While the sections of an @acronym{EDL} file don't have to appear in the
sequence they are listed above it is probably best not to experiment too
much with this. In any case, if it exists the @code{EXPERIMENT} section
must always be the last one.

All the section keywords can be abbreviated, here's the complete list of
valid section keywords:
@itemize @bullet
@item @code{DEVICES}, or @code{DEV}, @code{DEVS}, @code{DEVICE}
@cindex @code{DEVICES} section
@item @code{VARIABLES}, or @code{VAR}, @code{VARS}, @code{VARIABLE}
@cindex @code{VARIABLES} section
@item @code{ASSIGNMENTS}, or @code{ASS}, @code{ASSIGNMENT}
@item @code{PHASES}, or @code{PHA}, @code{PHAS}, @code{PHASE}
@item @code{PREPARATIONS}, or @code{PREP}, @code{PREPS}, @code{PREPARATION}
@cindex @code{PREPARATIONS} section
@item @code{EXPERIMENT}, or @code{EXP}
@cindex @code{EXPERIMENT} section
@end itemize


Beside these sections there is a label that looks similar to a section
label, the
@itemize @bullet
@item @code{ON_STOP}
@end itemize
@cindex @code{ON_STOP} label
@noindent
label. It can only be used within the @code{EXPERIMENT} section. The
@code{ON_STOP} label can be used to guarantee that a certain part of the
program is going to be executed even after the user hit the @code{Stop}
button. This part of the @code{EXPERIMENT} section will probably contain
code that stores previously unsaved data and does other things that are
necessary before the experiment really stops.  When @acronym{fsc2}
executes the code following the @code{ON_STOP} label it can't be stopped
via the the @code{Stop} button.

@node Syntax, Variables, Sections, EDL
@section Syntax

There are a few basic rules about the syntax of @acronym{EDL} programs.
Each program consists of one or more sections that always start with one
of the section keywords listed in the previous section. Each keyword has
to be followed immediately (i.e.@: without any spaces, tabulator or
newline characters in between) by a colon, `@code{:}'.

Each section of the program consists of statements. What a valid
statement is may depend on the section (e.g.@: in the @code{DEVICES}
section all valid statements are just names of devices while in
other sections a valid statement may be a complicated equation), but in
all cases a statement must always end in a semicolon, `@code{;}'.
There is nothing special about continuing a statement on a new line
(i.e.@: a statement can span several lines), @acronym{fsc2} recognizes
where a statement ends by the semicolon.

Within a statement all characters like spaces, tabulator characters and
newlines have no relevance at all (except separating variable names). So
there's no difference at all between the three following statements:
@example
start_field=3360.0 G;
start_field       =               3360.0G;
                  start_field=
        3360.0 G;
@end example

@acronym{EDL} programs use lots of function calls. There are no obvious
differences between variable names and function names (all start with a
character, followed by more characters, numbers or underscore
characters). To make clear that a word is a function it has to
be followed by a pair of parenthesis, `@code{(}' and `@code{)}', even if
the function doesn't accept arguments (spaces, tabulator or newline
characters are allowed between the function name and the opening
parenthesis). If a function does accept more than one argument its
arguments have to be separated by commas.


@node Variables, Arithmetic, Syntax, EDL
@section Variables
@cindex variables
@cindex arrays


Within the @code{VARIABLES}, @code{ASSIGNMENTS}, @code{PREPARATIONS} and
@code{EXPERIMENT} section variables may be used. Each variable that is
used in an @acronym{EDL} program must be declared, i.e.@: it has to be
listed in the @code{VARIABLES} section before it may be used. The start
of the @code{VARIABLES} section is indicated by a line stating
@example
VARIABLES:
@end example


@subsection Variable names

Names of variables (and also of functions) always start with a
character, i.e.@: A-Z or a-z. The remaining part of the variable name
can consist of characters, numbers and the underscore character,
'@code{_}' (or shorter, if you like regular expressions, valid names
follow the following pattern: @code{[A-Za-z][A-Za-z_0-9]*}). Thus,
'@code{AbC_12x}' and '@code{aBc_12X}' are legal variable names, while
'@code{12xy}' or '@code{_Yx2}' are not. Please note that the variable
names are case sensitive, i.e.@: '@code{XY}', '@code{Xy}', '@code{xY}'
and '@code{xy}' are four completely different variables!

The name of a variable can, in principle, consist of as many characters
as you wish (I hope nobody is going to the extent of creating a variable
name with, say, a few hundred thousand characters just to prove me wrong
-- I tested it only with two variables with names consisting of 10000
characters each and differing only in the very last character...)

There are some names that can't be used for variables. First of all,
variable names may not be identical to function names, neither built-in
nor device function names. Second, some combination of characters are
already used for physical units as well as combinations of these with
the characters @code{n} (nano), @code{u} (micro), @code{m} (milli),
@code{k} (kilo) and @code{M} (mega).  Here's the complete list:
@quotation
@multitable {Hz} {Decibel (and @code{ndb, udb, mdb, kdb} and @code{Mdb})}
@item @code{s}  @tab Seconds (and @code{ns, us, ms, ks} and @code{Ms})
@item @code{G}  @tab Gauss (and @code{nG, uG, mG, kG} and @code{MG})
@item @code{T}  @tab Tesla (and @code{nT, uT, mT, kT} and @code{MT})
@item @code{V}  @tab Volt (and @code{nV, uV, mV, kV} and @code{MV})
@item @code{A}  @tab Ampere (and @code{nA, uA, mA, kA} and @code{MA})
@item @code{Hz} @tab Hertz (and @code{nHz, uHz, mHz, kHz} and @code{MHz})
@item @code{dB} @tab Decibel (and @code{ndB, udB, mdB, kdB} and @code{MdB})
@item @code{db} @tab Decibel (and @code{ndb, udb, mdb, kdb} and @code{Mdb})
@end multitable
@end quotation

Finally, the keywords used by @acronym{EDL} also may not be used as
variable names (to make it easier to avoid these, they are all spelled
with capitals only). In the appendix you'll find a list of (hopefully) all
reserved words.


@subsection Variable types

Variables can be divided into two classes, variables to hold integer
values and variables for storing floating point values.

Integer variables (on machines with 32-bit processors) can hold data in
the interval @w{[-2^31, 2^31 - 1]}, i.e.@: they run from @w{-2147483648}
all the way up to @w{+2147483647}. In contrast, floating point variables
can have much larger values (up to ca.@: 10^300), the exact limits
depending on the machine @acronym{fsc2} is running on.

To distinguish between integer and floating point variables the case of
the first character of the variables name is important: if the name
starts with an upper case letter, i.e.@: A-Z, it's an integer variable
while a lower case character, i.e.@: a-z, indicates a floating point
variable. (Actually, changing just one line of the program allows to set
a completely different behavior.)


@subsection Arrays

Beside `normal' variables you can also use arrays. The names of arrays
follow the same convention as that of normal variables, i.e.@: if an
array name starts with an upper case character it is an integer array
and if it starts with a lower case character it's a floating point
array. To define an array in the @code{VARIABLES} section just append
the sizes of the dimensions of the array, separated by commas, in square
brackets. E.g.
@example
F[ 100 ];
b[ 4, 7, 3 ];
@end example
@noindent
defines a 1-dimensional array @code{F} of 100 integers and a
3-dimensional floating point array @code{b} of rank 4x7x3.


All elements of an arrays are automatically initialized to zero. On the
other hand, arrays can also be initialized within the @acronym{EDL} file
by equating the array to a list of values, enclosed in curly braces:
@example
C[ 3 ] = @{ 2, 1, -1 @};
d[ 5 ] = @{ sqrt( 2.0 ), sqrt( 3.0 ) + 1 @};
E[ 2, 3 ] = @{ 1, 2, 3, 4, 5, 6 @};
@end example
@noindent
The first line in the example shows the simplest way -- each element of
the integer array @code{C} is initialized by an element from the
list. In the second line there are less initializers than the array
@code{d} has elements, thus only the first two elements are set, i.e.@:
@code{d[ 1 ]} and @code{d[ 2 ]}, while the remaining elements are
automatically set to zero. Besides, you can see that function calls,
arithmetic etc.@: can be used in the initialization. The third example
shows the initialization of a multidimensional array, the elements of
the array @code{E} being set starting with the first row and continuing
with the next rows until all initializers are used up. Thus the array
@code{E} will be initialized to
@example
E[ 1, 1 ] = 1     E[ 1, 2 ] = 2     E[ 1, 3 ] = 3
E[ 2, 1 ] = 4     E[ 2, 2 ] = 5     E[ 2, 3 ] = 6
@end example


There are some situations where one doesn't know the size of an array in
advance, e.g.@: arrays to be used for storing a trace from a digitizer,
so declaring its size in advance in the @code{VARIABLES} section is not
possible. Therefor, one may also define arrays with the size of the last
dimension remaining undefined by specifying a @code{*} instead of a
number:
@example
G[ * ];
h[ 2, * ];
@end example
@noindent
This defines an 1-dimensional integer array @code{G} with a still
undefined number of elements and a 2-dimensional floating point matrix
@code{h} with two rows of unknown length. The sizes of these arrays
remain undefined until 1-dimensional arrays are assigned to them. The
following assignment will set the length of @code{G} to 3 by assigning
the second row of elements of @code{E} to @code{G}:
@example
G = E[ 2 ];
@end example
@noindent
because the length of the rows of @code{E} is three. After this assignment
the size of @code{G} is fixed and can't be changed anymore.

In the same way the assignment
@example
h[ 2 ] = d;
@end example
@noindent
will set the rank of @code{h} to 2x5 (because the length of @code{d} is 5).

Of course, these are somewhat contrived examples, in a real experiments
arrays with undefined sizes are usually used for storing data received
from functions that return arrays of a size that would be difficult or
impossible to determine before the experiment is actually started,
e.g.@: curves fetched from a digitizing oscilloscope.


@node Arithmetic, Control structures, Variables, EDL
@section Arithmetic
@cindex Arithmetic

Of course, @acronym{fsc2} understands the usual arithmetic operations,
i.e.@: addition, subtraction, multiplication and division, represented
by the characters `@code{+}', `@code{-}', `@code{*}' and `@code{/}'.
@cindex + (addition operator)
@cindex - (subtraction operator)
@cindex * (multiplication operator)
@cindex / (division operator)
They can be used with simple integer and floating point values as well
as with 1-dimensional arrays (see below for more information). If one of
the values is a floating point value the result is also a floating point
number - only if both values are integers the result is also an
integer. This also holds for the division -- if you divide two integers
the result is still an integer, see below.

Some care has to be taken in arithmetic with integers.
@cindex integer overflow
@cindex integer underflow
@cindex overflow, integers
@cindex underflow, integers
@cindex range of integers
@cindex integers, range of
The range of values an integer variable can have is restricted to the
interval @w{[-2147483648, +2147483647]}, i.e.@: @w{[-2^31, 2^31 - 1]}
(at least on a 32-bit processor). Thus, it isn't to difficult to create
numbers with greater values, e.g.@: by multiplication, that can't be
represented by an integer! In this case the result of the operation will
be completely bogus, e.g.@:
@example
1000000 * 3000 = -1294967296
@end example
@noindent
(There is actually some logic behind this result but that doesn't help
too much.) So, if you suspect the result of an integer operation to
exceed the range of representable values, convert the values to floating
point type (using the function @code{float()}) before you do the
potentially problematic arithmetic operation.

Of course, there are also limits to the range of numbers representable
by a floating point number. Fortunately, these limits are much larger -
typically the maximum size of floating point numbers is in the range of
10^300.
@cindex floating point numbers, range of
@cindex range of floating point numbers
@cindex floating point overflow
@cindex floating point underflow
@cindex overflow, floating point numbers
@cindex underflow, floating point numbers


Another important point about calculations involving integers concerns
the division. The result of the division of two integer values is again
an integer value. For non-integer results this is achieved by simply
truncating the digits following the decimal point. Thus, typical results
are
@example
7 / 2 = 3     8 / 3 = 2     -7 / 2 = -3
@end example
@cindex / (division operator)
@cindex integer division
@noindent
To avoid this truncation convert at least one of the values used in the
division to a floating point type by using the @code{float()} function,
i.e.@:
@example
float( 7 ) / 2 = 3.5    8 / float( 3 ) = 2.666666667
@end example


Beside the normal arithmetic operations there are two often needed
operations, the modulo function and the exponentiation. For the modulo
operation the percent sign @code{%}
@findex % (modulo operator)
@cindex modulo operator
is used and the result is the remainder of the division, e.g.@
@example
7 % 3 = 1         6.5 % 2.5 = 1.5 
@end example
@noindent
For the exponentiation the caret character @code{^} is to be used, e.g.@:
@findex ^ @r{(exponentiation)}
@cindex exponentiation
@example
3^2 = 9           6.5^1.5 = 16.5718134219...
@end example
@noindent
As the usual mathematics dictate non-integer exponents can only be used
with non-negative bases!


@subsection Assignment operators
@cindex assignment operators
@cindex @code{=} (assignment)
@cindex @code{+=} (add and assign)
@cindex @code{-=} (subtract and assign)
@cindex @code{*=} (multiply and assign)
@cindex @code{/=} (divide and assign)
@cindex @code{%=} (modulo and assign)
@cindex @code{^=} (exponentiation and assign)

When assigning to a variable usually the assignment operator `@code{=}'
is used. But there are often cases where a variable just has to be
incremented as in
variable:
@example
I = I + 1;
@end example
@noindent
This assignment can be shortened (and sometimes made more readable) by
using the `add and assign' operator `@code{+=}':
@example
I += 1;
@end example
@noindent
Assignment operators mixed with arithmetic can also be used with all
other arithmetic operators, i.e.@: you may use all of the following
assignment operators
@example
+=     -=     *=     /=     %=     ^=
@end example


@subsection Operator precedence
@cindex operator precedence

Usually one doesn't need to think about the precedence of operators. We
already learned in primary school that multiplication and division have
higher precedence than addition and subtraction and, of course, a
programming language should follow these rules. But sometimes there are
cases where it is necessary to know the precedence exactly, i.e.@: the
exact sequence an expression is evaluated.

The unary operators (unary in the sense that they apply only to one
number or variable) `@code{+}' and `@code{-}', i.e.@: the operators
defining the sign of a number, have the highest precedence. There is a
further operator, to be discussed later, having the same precedence, the
logical negation operator, `@code{!}'. The evaluation of an expression
with more than one of these operators is from the right to the left,
i.e.@:
@example
 !-x    @r{will be treated as if written as}    ! ( - x )
@end example
@noindent
(This is not a very useful example but here for sake of completeness.)

The exponentiation operator, `@code{^}', has the next highest
precedence, i.e.@: it binds more tightly than any other binary operator
(i.e.@: an operator involving two numbers or variables). If there is
more than one of these operators in a row the expression will be
evaluated from the right to the left:
@example
 2^3^4    @r{will be treated as if written as}    2^(3^4)
@end example


The operator with the next lower precedence is the modulo operator,
`@code{%}'. Expressions with more than one `@code{%}' in a row will be
evaluated left to right, i.e.@:
@example
 31 % 6 % 2    @r{will be treated as if written as}    ( 31 % 6 ) % 2
@end example


Now follow the multiplication and division operators, `@code{*}' and
`@code{/}. Both have exactly the same precedence and expressions
involving more than one of these operators are evaluated left to right,
i.e.@:
@example
 3 * 20 / 7    @r{will be treated as if written as}    ( 3 * 20 ) / 7
@end example
@noindent
(Take care: The order of evaluation can make a lot of a difference - due
to the rules of integer division @code{(3 * 20) / 7} will evaluate to
@code{8}, while @code{3 * (20 / 7)} would result in @code{6}).


The next lower precedence operators are the addition and subtraction
operators, `@code{+}' and `@code{-}'. Also for these operators
expressions involving more than one of these operators are evaluated
left to right:
@example
 13 + 4 - 5    @r{will be treated as if written as}    ( 13 + 4 ) - 5
@end example
@noindent
Usually, this won't matter a lot, but if you're dealing with very large
numbers and there's danger of an overflow to occur knowing the rules of
evaluation can become important.

The next lower precedence operators are the logical operators to be
discussed in more detail below, i.e.@: the logical @i{and} operator,
`@code{&}, the logical @i{or} operator, `@code{|}' and the logical
@i{exclusive or} (xor) operator, `@code{~}'. Expressions containing more
than one of these operators are always evaluated from the left to the
right of the expression:
@example
 a | b & c    @r{will be treated as if written as}    ( a | b ) & c
@end example
@noindent
To make your intentions more clear to human readers of your
@acronym{EDL} programs it's probably a good idea to use parenthesis in
these cases even if they are not strictly required.

Finally, the lowest precedence operators are the comparison operators
(also the be discussed below in more detail), i.e.@: the test for equality,
`@code{==}' (not to be confused with the assignment operator
`@code{=}'), the test for inequality, `@code{!=}', and the remaining
four comparison operators `@code{<}', `@code{<=}', `@code{>}' and
`@code{>=}', i.e.@: @i{less than}, @i{less or equal}, @i{larger} and
@i{larger or equal}. If more than one of these operators appears in an
expression evaluation is done left to right.

Actually, there are also the assignment operators. But these are only
used after all of the other operators have been evaluated, so there is
never a necessity to enclose the right hand of an equation in
parenthesis. And since only one assignment operator is allowed in a
statement you don't have to worry about the order of evaluation.

Of course, the precedence of operators and the sequence they are
evaluated in can always be changed by using parenthesis. So, if in
doubt, use parenthesis -- this won't slow down the program but will
often make the program easier to understand.


@subsection Arithmetic with arrays
@cindex Arithmetic with arrays

Beside the usual arithmetic with numbers it is also possible to use
arithmetic with one-dimensional arrays. As long as the sizes of two
arrays are identical they can be added or subtracted. For example, if
the arrays @code{a} and @code{b} are defined as
@example
  a[ 3 ] = @{ 0.5,  1.0,  2.0 @};
  b[ 3 ] = @{ 1.0, -2.0, -3.0 @};
@end example
@noindent
they can be added and subtracted in an element-by-element fashion,
resulting in
@example
  a + b      ->   @{  1.5, -1.0, -1.0 @}
  a - b      ->   @{ -0.5,  3.0,  5.0 @}
@end example
@noindent
Of course, you can also invert the sign of all the elements of an array
by simply prepending it with a minus sign
@example
  -a         ->   @{ -0.5, -1.0, -2.0 @};
@end example

But it's also possible to add a number to each element of an array or
to subtract a number (or to subtract all array elements from a number):
@example
  a + 5      ->   @{ 5.5, 6.0, 7.0 @}
  a - 3      ->   @{ -2.5, -2.0, -1.0 @}
  3 - a      ->   @{ 2.5, 2.0, 1.0 @}
@end example

Multiplication and division are also possible with whole arrays. Again,
these operations are implemented in a element-by-element way, i.e.@:
multiplying two arrays is not a dot product but results again in an
array of the same size as both the original arrays. The same holds for
the division. With the arrays @code{a} and @code{b} defined above the
results are:
@example
  a * b      ->   @{ 0.5, -2.0, -6.0 @}
  a / b      ->   @{ 0.5, -0.5, -0.666667 @}
  b / a      ->   @{ 2.0, -2.0, -1.5 @}
@end example

Multiplication and division of an array with a number is also defined as
shown here:
@example
  a * 2      ->   @{ 1.0, 2.0, 4.0 @}
  a / 3      ->   @{ 0.166667, 0.333333, 0.666667 @}
  3 / a      ->   @{ 6.0, 3.0, 1.5 @}
@end example

Finally, calculation of the modulo function and exponentiation can be
done with whole arrays. These operations are again implemented as
element-by-element calculations, i.e.@: always resulting in an array:
@example
  a % b      ->   @{ 0.5, 1.0, 2.0 @}
  b % a      ->   @{ 0.0, 0.0, -1.0 @}
  a ^ b      ->   @{ 0.5, 1.0, 0.125 @}
  b ^ a      ->   @{ 1.0, -2.0, 9.0 @}
@end example

Of course, the same operations can also be applied to a mixture of
arrays and simple numbers, also resulting in arrays:
@example
  a % 0.3    ->   @{ 0.2, 0.1, 0.2 @}
  1.3 % a    ->   @{ 0.3, 0.3, 0.7 @}
  a ^ 2      ->   @{ 0.25, 1.0, 4.0 @}
  2 ^ a      ->   @{ 1.414215, 2.0, 4.0 @}
@end example

Further, the built-in arithmetic functions can (as far as this makes any
sense) be applied to arrays. In every case the function is applied to
each element of the array, thus the result is another array with its
elements being the results of applying the function to each of the input
array elements. For example, again using the array @code{a} defined
above, applying the @code{sqrt()} function results in:
@example
  sqrt( a )  ->   @{ 0.7071068, 1.0, 1.1414215 @}
@end example

Finally, for obvious reasons, when computed assignments are used
(i.e.@: `@code{+=}', `@code{-=}', `@code{*=}', `@code{/=}', `@code{%=}'
or `@code{^=}') the left hand side variable of an equation has to be an
array when arithmetic with arrays is used.


@node Control structures, Miscellaneous, Arithmetic, EDL
@section Control structures
@cindex Control structures
@cindex Flow control


Within the @code{EXPERIMENT} section flow control structures can be
used. These are @code{REPEAT}, @code{WHILE}, @code{UNTIL}, @code{FOR} and
@code{FOREVER} loops and @code{IF-ELSE} and @code{UNLESS-ELSE}
constructs. (Please note: all of these keywords have to be spelt in
upper case letters!).


Most flow control construct keywords are followed by a condition and all
are then followed by a block of statements. Such a block of statements
has to be enclosed in curly braces (@code{@{} and @code{@}}) and may
contain as many statements as needed (and still fit into the computers
memory).


@anchor{REPEAT loops}
@subsection REPEAT loops
@cindex REPEAT loops

The most simple construct is the @code{REPEAT} loop. What is needed
following the keyword @code{REPEAT} is a number and a block with
commands. The number should be an integer number (or an expression
resulting in an integer).  The following block of statements will now be
repeated as many times as specified by the number (or
expression). Here's an example:
@example
  I = 0;
  SUM = 0;

  REPEAT 100 @{
      I = I + 1;
      SUM = SUM + I;
  @}
@end example

This snippet will calculate the sum of all integers between 1 and 100
(of course, there are more elegant ways to do this, but it's just an
example). After the initialization of the two variables `@code{I}' and
`@code{SUM}' the @code{REPEAT} loop starts with 100 as the number of
repetitions. Now, in curly braces, i.e.@: between `@code{@{}' and
`@code{@}}', follow the statements to be executed in the loop.

Please note: If the number of repetitions of the loop is a variable or
an expression the variable or expression will be evaluated just once at
the very start, i.e.@: once before the loop is executed, so if you
change the value of the variable (or the variables involved in the
expression) within the loop the number of repetitions won't change.



@anchor{WHILE loops}
@subsection WHILE loops
@cindex WHILE loops


Nearly as simple a construct is the @code{WHILE} loop, but instead of a
simple number following the keyword a condition is needed. Usually, this
will be a comparison between two numbers, but also a simple number will
suffice -- if its value is non-zero it will be interpreted as TRUE. Of
course, the keyword and the condition have to be followed by a block of
statements.

Again, an example:
@example
  I = 1;
  Fact = 1;

  WHILE I <= 6 @{
      Fact = Fact * I;
      I = I + 1;
  @}
@end example

This program snippet (that also could have been written using a
@code{REPEAT} loop) calculates the factorial of 6. After initializing
the variables @code{I} and @code{Fact} it is tested in the loop
condition if @code{I} is still not larger that 6. If this is true, the
following block of statements is executed.

Here is a complete list of the comparison operators between two
expressions (e.g.@: numbers):

@quotation
@cindex == (equal to)
@cindex equal to `=='
@cindex != (unequal to)
@cindex unequal to `!='
@cindex < (less than)
@cindex less than `<'
@cindex <= (less or equal)
@cindex less or equal `<='
@cindex > (larger than)
@cindex larger than `>'
@cindex >= (larger or equal)
@cindex larger or equal `>='
@multitable {@code{==}} {true if left hand side is @i{equal} to right hand side}
@item @code{==} @tab  true if left hand side is @i{equal} to right hand side
@item @code{!=} @tab  true if left and right hand side are @i{unequal}
@item @code{<}  @tab  true if left side is @i{less than} right side
@item @code{<=} @tab  true if left side is @i{less or equal} to right side
@item @code{>}  @tab  true if left side is @i{greater than} right side
@item @code{>=} @tab  true if left side is @i{greater or equal} to right side
@end multitable
@end quotation

Please note, that using comparisons between floating point numbers may
not work as you expect them to do. This is a result of the way floating
point numbers are stored by computers internally, i.e.@: as binary
numbers. Many numbers, that can be expressed easily in the decimal
system, e.g.@: @code{0.1}, are, when expressed using the binary system,
infinite fractions. But because the computer can only store a finite
number of bits for the number rounding errors will occur. Thus
@code{0.1} and the result of e.g.@: @code{0.7 / 7} can be different
numbers, in which case a comparison for equality will fail.

Here is now an example for using simple numbers in a condition,
using the fact that a non-zero value is always interpreted as TRUE:
@example
  I = 6;
  Fact = 1;

  WHILE I @{
      Fact *= I;
      I -= 1;
  @}
@end example

This example does exactly the same as the previous one, i.e.@: it
calculates the factorial of 6. But the difference is that we start with
`I' set to 6 and than decrement it successively. Thus we can use
`@code{I}' in the loops condition by simply checking if it still is
non-zero and thus the condition still TRUE and repeating the loop as
long as it is.

Sometimes, you may want to check not for the truth but for the falsehood
of an expression. In this case you have to prepend the expression with a
exclamation mark, `@code{!}', to reverse the meaning of a test (or use
an @code{UNTIL} loop, see below).

If you want to check for combinations of expressions you can use the
logical @code{AND}, @code{OR} or @code{XOR} (exclusive or)
operators. Here is a list of these operators and their meaning:

@quotation
@cindex ! (negation operator)
@cindex negation operator `!'
@cindex & (logical and operator)
@cindex and operator `&'
@cindex logical and operator  `&'
@cindex | (logical or operator)
@cindex or operator `|'
@cindex logical or operator `|'
@cindex ~ (logical xor operator)
@cindex xor operator `~'
@cindex logical xor operator `~'
@multitable {~} {@i{exclusive or}: true if left or right hand side expressions are true but not both}
@item @code{!} @tab @i{not}: negates truth of an expression
@item @code{&} @tab @i{and}: true if both left and right hand side expressions are true
@item @code{|} @tab @i{or}: true if at least one of the left and right hand side expressions is true
@item @code{~} @tab @i{exclusive or}: true if either left or right hand side expression is true (but not both)
@end multitable
@end quotation

@b{Please note}: For both the logical @strong{or} operator ('@code{|}')
and the logical @strong{and} operator ('@code{&}') the expressions are
always only evaluated as far as necessary to determine the final
result. Thus for the condition
@example
A == 0 | B != 3
@end example
@noindent
only the first part, @code{A == 0}, is tested when @code{A} is @code{0}
because in this case the result is already known to be true and does not
depend on the second comparison. The same holds for expressions like
@example
A != 0 & lockin_phase( ) > 90
@end example
@noindent
If @code{A} equals @code{0} the whole expression is already known to be
false even though the lock-ins phase may be less then 90 degrees. Thus
the call of the function @code{lockin_phase()} will never be made.

@b{Thus the sequence in conditions containing the logical or and and
operator is important.}

To make it more clear please understand that the code (please read about
the @code{IF} and @code{ELSE} constructs below for more details)
@example
IF A == 0 | B != 3 @{
    do_something( );
@}
@end example
@noindent
is treated as if you would have written
@example
IF A == 0 @{
    do_some_thing( );
@} ELSE IF B != 3 @{
    do_something( );
@}
@end example
@noindent
In the same way
@example
IF A != 0 & lockin_phase( ) > 90 @{
    do_something( );
@}
@end example
@noindent
is logically equivalent to
@example
IF A != 0 @{
    IF lockin_phase( ) > 90 @{
        do_something( );
    @}
@}
@end example


@c This still leads to 2 reduce/reduce conflicts in the parsers...

@c All comparison operators may also be used with strings. The test
@c for equality has its usual meaning (but take care, in the comparison
@c lower and upper case characters are treated as different). The
@c comparison for larger or smaller is based on the ASCII values of the
@c characters of the string, not the lengths of the strings. For example,
@c the comparison of the strings @code{"ON"} and @code{"OFF"} will result
@c in @code{"ON"} being larger than @code{"OFF"} because for the first
@c characters where the strings differ, @code{'N'} and @code{'F'},
@c @code{'N'} has a higher ASCII value than @code{'F'}.


@anchor{UNTIL loops}
@subsection UNTIL loops
@cindex UNTIL loops

Directly related to the @code{WHILE} loop is the @code{UNTIL} loop. The
only difference is that, instead of repeating the loop until the
condition becomes false, the @code{UNTIL} loop is repeated until the
loop condition becomes true. Thus, the second example for calculating
the factorial of 6 also could have been written as
@example
  I = 6;
  Fact = 1;

  UNLESS I == 0 @{
      Fact *= I;
      I -= 1;
  @}
@end example



@anchor{FOR loops}
@subsection FOR loops
@cindex FOR loops

Before the @code{WHILE} loop one has to initialize the loop variable and
within the statement block it has to be updated. In many cases (for
example in both the examples for the @code{WHILE} loop above) it is
simpler to use a @code{FOR} loop instead, because setting the loop
variable as well as updating it is automatically done in its condition
part. Here's an example that does exactly the same as the first of the
two examples for @code{WHILE} loops:
@cindex FOR
@example
  Fact = 1;
  FOR I = 1 : 6 @{
      Fact *= I;
  @}
@end example

At the very start of the @code{FOR} loop the loop variable `@code{I}' is
set to 1 and the loop block is run using this value. When it is done,
`@code{I}' is automatically incremented by 1 and tested if it is still
not larger than 6. If this is @code{TRUE} the loop is repeated with the
new value of `@code{I}'. Take care: You can change `@code{I}' also
within the loop, but you only should do this if you really mean it and
know what you're doing!

But you can also reproduce the second version of the factorial
calculation using a @code{FOR} loop. Here it is:
@example
  Fact = 1;
  FOR I = 6 : 1 : -1 @{
      Fact *= I;
  @}
@end example

Now `@code{I}' starts of with the value 6 and the third value in the
@code{FOR} loop condition part is the value to be used for incrementing
`@code{I}'. In our case it is -1, so `@code{I}' actually will be
decremented until it is smaller than 1 (the second value in the
@code{FOR} loop condition). As you see, @code{FOR} loop variables can
not only be incremented by 1 but by any value (integer or floating point
ones). And, of course, the loop variable don't have to be an integer
variable!

Please note, that after the end of a @code{FOR} loop the loop variable
don't has the value it had in the last run through the loop but has been
incremented one more time. I.e.@: after the end of the loop
@example
  FOR I = 1 : 10 : 1 @{
      do_something( );
  @}
@end example
@noindent
the loop variable @code{I} has the value @code{11} and not @code{10}.


@anchor{FOREVER loops}
@subsection FOREVER loops
@cindex FOREVER loops

There are situations where one wants to have the program running as long
as the STOP button hasn't been pressed. While something like this can be
realized by using i.e.@: a @code{REPEAT} loop with a huge number of
repeats, this would take extremely long to test the program before the
@code{EXPERIMENT} is started. In these cases a @code{FOREVER} loop is
more convenient because the content of the loop is only tested once so
the experiment can start much faster. For obvious reasons, a
@code{FOREVER} loop doesn't need a loop condition and the loop block
starts directly after the @code{FOREVER} keyword.

@quotation
@cartouche
There is a disadvantage of using a @code{FOREVER} loop: Because
@acronym{fsc2} can't determine in advance when the @code{FOREVER} loop
is going to be terminated it is not possible to test these loops
thoroughly in the test run, i.e.@ before the experiment is
started. Instead, in the test run a @code{FOREVER} loop is just run once
to do a plausibility check, but further tests are not feasible. Thus, it
can not be guaranteed that the experiment will run without errors.
Therefore, the use of @code{FOREVER} loops should be restricted to
preliminary experiments, e.g.@: when trying to figure out the optimum
parameters for an experiment.
@end cartouche
@end quotation


@anchor{NEXT statement}
@subsection NEXT statement
@cindex NEXT

Under certain conditions one doesn't want to execute all remaining
statements of a loop but to go back to the test of the loop condition
immediately. Whenever the keyword @code{NEXT} is encountered in a loop
all the remaining statements are skipped and the program jumps back to
the test of the loop condition (where the loop counter of @code{WHILE},
@code{UNTIL}, @code{REPEAT} or @code{FOR} loops is set to the next
value).


@anchor{BREAK statement}
@subsection BREAK statement
@cindex BREAK

There also may be situations where one doesn't want to continue with a
loop until the loop condition becomes satisfied but where one has to
exit the loop immediately. For this purpose the keyword @code{BREAK} is
to be used. If it is found as the next statement to be executed in a
loop the program immediately jumps to the first statement following the
loops block.


@anchor{IF-ELSE constructs}
@subsection IF-ELSE constructs
@cindex IF
@cindex ELSE 
@cindex IF-ELSE


Finally, there are the @code{IF-ELSE} constructs, functioning as in most
other programming languages. In the simplest case you just have the
@code{IF} part to execute some instructions only under certain
conditions. In this case you start with the @code{IF} keyword, followed
by the condition that has to be met in order to run the following code
and then the statements enclosed in curly braces. Here's an simple
example:
@example
  IF x < 0 @{
      x *= -1.0;
@}
@end example
@noindent
Here the variable @code{x} is multiplied by @code{-1} only if @code{x}
is negative, i.e.@: it basically just sets @code{x} to its absolute
value (there's also the built-in function @code{abs()} for calculating
the absolute value of variable which is probably a lot faster).

By using the @code{ELSE} statement you can specify an alternative with
statements to be executed if the @code{IF} condition is not being met.
Again the block of alternative statements must be enclosed in curly
braces:
@example
  IF x >= 0 @{
      x = 1.0;
  @} ELSE @{
      x = 0.0;
  @}
@end example
@noindent

But things can also get more complex -- you may follow the @code{ELSE}
directly by another @code{IF}. Let's assume that you need to set
@code{x} to 1 if it's larger than 1, to 0 if it belongs to the interval
@w{[ 0, 1 ]} and to -1 if it's smaller than 0. Then you could use:
@example
  IF x > 1.0 @{
      x = 1.0;                 // x is larger than 1
  @} ELSE IF x >= 0.0 @{
      x = 0.0;                 // x must be element of [ 0, 1 ]
  @} ELSE @{
      x = -1.0;                // last exit: x is less than 0
  @}
@end example
@noindent


@anchor{UNLESS-ELSE constructs}
@subsection UNLESS-ELSE constructs
@cindex UNLESS
@cindex ELSE 
@cindex UNLESS-ELSE

@code{UNLESS} is identical to @code{IF} with the only exception that the
condition is not tested for truth but for falsehood, i.e.@: while in an
@code{IF} construct the following block of statements is executed when
the condition is true, in @code{UNLESS} constructs the block is only
executed when the condition test fails. Of course, also with the
@code{UNLESS} an alternative can be specified with an @code{ELSE} block
(but in contrast to @code{IF} more than one @code{ELSE} doesn't make too
much sense).


@quotation
@cartouche
As already mentioned for @code{FOREVER} loops also @code{IF-ELSE} and
@code{UNLESS-ELSE} constructs introduce some problems for testing an
@acronym{EDL} program before the real experiment is done. This happens
when the condition to be tested depends either on user input (e.g.@:
tests if the user pressed a button etc.) or on the results of a
measurement itself. In these cases the flow of control of the program
can not be known in advance and thus a thorough test is impossible. Thus
it can happen that the test run of the experiment succeeds but the
actual experiment stops with an error that could not be anticipated.
@end cartouche
@end quotation

@node Miscellaneous, , Control structures, EDL
@section Miscellaneous
@cindex Miscellaneous
@cindex Miscellaneous

The remaining of this chapter covers a few additional syntactic elements
that didn't fit into any of the previous sections.

@anchor{#INCLUDE statement}
@subsection @code{#INCLUDE} statement
@cindex #INCLUDE statement

Everywhere within an @acronym{EDL} program one can include another
@acronym{EDL} file. This is done using the @code{#INCLUDE} keyword,
followed by the name of the file to be included, and has the same effect
as if the included file had been pasted into the current @acronym{EDL}
program. Included files may also contain @code{#INCLUDE} statements, up
to 16 levels deep.


@anchor{#EXIT statement}
@subsection @code{#EXIT} statement
@cindex #EXIT statement

When the @code{#EXIT} statement is found in an @acronym{EDL} program
this is equivalent to the end of the file - everything following the
statement is discarded. In the main file of an @acronym{EDL} program
this means that this is the end of the @acronym{EDL} program. If instead
the current file is an included file (see the @code{#INCLUDE} statement)
@acronym{fsc2} will immediately return to reading the file the current
file was included from.


@anchor{#QUIT statement}
@subsection @code{#QUIT} statement
@cindex #QUIT statement

When the @code{#QUIT} statement is encountered in a file @acronym{fsc2}
immediately treats this as the complete end of the @acronym{EDL} program
and won't read any further lines. In the main file of an @acronym{EDL}
this is equivalent to the @code{#EXIT} statement. But while in an
included @acronym{EDL} file @code{#EXIT} will induce @acronym{fsc2} to
return to the including file, @code{#QUIT} makes @acronym{fsc2} stop
completely, i.e.@: it will not even return to higher level @acronym{EDL}
files.
