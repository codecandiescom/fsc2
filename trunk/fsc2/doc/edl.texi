@c  $Id$
@c
@c  Copyright (C) 1999-2005 Jens Thoms Toerring
@c
@c  This file is part of fsc2.
@c
@c  Fsc2 is free software; you can redistribute it and/or modify
@c  it under the terms of the GNU General Public License as published by
@c  the Free Software Foundation; either version 2, or (at your option)
@c  any later version.
@c
@c  Fsc2 is distributed in the hope that it will be useful,
@c  but WITHOUT ANY WARRANTY; without even the implied warranty of
@c  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c  GNU General Public License for more details.
@c
@c  You should have received a copy of the GNU General Public License
@c  along with fsc2; see the file COPYING.  If not, write to
@c  the Free Software Foundation, 59 Temple Place - Suite 330,
@c  Boston, MA 02111-1307, USA.


@node EDL, Built-in Functions, Web Server, Top
@chapter @code{EDL}
@cindex @code{EDL}

@ifinfo
@menu
* Basics::                  Basic principles.
* Sections::                The sections of an EDL script.
* Syntax::                  Basic syntax of EDL scripts.
* Variables::               Using variables and arrays.
* Assignment operations::   Assigning to variables.
* Array ranges::            Indexing parts of arrays
* Arithmetic::              Doing calculations with variables.
* Conditional  operator::   Using the '? : ' construct
* Control structures::      Flow control in EDL scripts.
* Miscellaneous::           Additional syntactic elements
@end menu
@end ifinfo

To do an experiment using @code{fsc2} you have to write a script
describing the experiment. While this may look like a daunting task if
you have no programming experience at all it has the advantage that you
have complete control over the way the experiment will be done. You
don't have to rely on some programmer (who probably isn't around when
you need him or her most) to have gotten everything right before you
even started planning the experiment. And writing @code{EDL} scripts
really isn't that difficult.


@node Basics, Sections, EDL, EDL
@section Basics

An @code{EDL} script is structured similarly to the way an experiment
is done. Before you start an experiment you first have to select the
devices to be used and set them up. So the first part of an @code{EDL}
script are just a few lines specifying the devices to be controlled by
the program and then setting their parameters, e.g.@: the time base of
the digitizer, the sensitivity of the lock-in amplifier or which pulses
are to be created by the pulse generator. And as you would now start the
experiment the second part of the @code{EDL} script describes how the
experiment is to be done.

To give you a first impression how an @code{EDL} script may look like
here's a script for a simple cw-EPR experiment:
@example
DEVICES:
  er035m_s;                    // gaussmeter module
  aeg_x_band;                  // magnet module
  sr530;                       // lock-in amplifier module

VARIABLES:
  start_field = 3360.0 G;
  end_field   = 3450.0 G;
  field_step  =    0.5 G;

  field = start_field;
  I = 1;
  data;

PREPARATIONS:
  magnet_setup( start_field, field_step );
  init_1d( );

EXPERIMENT:
  WHILE field <= end_field
  @{
      data = lockin_get_data( );
      display( I, data );
      save( data );
      I = I + 1;
      field = sweep_up( );
      wait( lockin_time_constant( ) );
  @}
@end example

Obviously, the very first section of the script, starting with the
section keyword @code{DEVICES}, specifies the names of the devices to be used
(everything after the double-slashes are comments). In the example these are
the Bruker ER035M gaussmeter, the AEG X-band magnet and the Stanford
Research lock-in amplifier SR530.

In the following section, starting with the section keyword
@code{VARIABLES}, all variables that are going to be used in the
@code{EDL} script are listed and, if appropriate, initialized. The
first three variables are for storing the start and end field of the
field sweep as well as the field step width to do between measuring new
data points. The next variable @code{field} will later be used for
storing the actual field value and is initialized to the value of the
start field. Finally, a counter variable @code{I}, initialized to 1, and
another variable, @code{data}, for the data obtained from the lock-in
amplifier, are declared.

In the next section, following the @code{PREPARATIONS} section keyword,
the devices are set up. The function @code{magnet_setup()} tells the
magnet to start with the field stored in the variable
@w{@code{start_field}} and to use a field step size of
@w{@code{field_step}}. This will also make the magnet automatically go
to the start field (after some calibration) when the experiment starts.

The next function call, @code{init_1d()}, tells the program that this is
an 1-dimensional experiment and to use the appropriate kind of display
for the data.

Now we're already done with the preparations and can start the
experiment, as indicated by the section keyword @code{EXPERIMENT}. The
whole experiment is done in a loop that is repeated as long as the
actual field (stored in the variable @code{field}) isn't larger than the
@code{end_field}. To tell the program where the loop starts and ends all
the statements belonging to the loop are enclosed in curly braces,
`@code{@{}' and `@code{@}}'.

The first thing to do in the experiment loop is to fetch a new data
point from the lock-in amplifier, storing it in the variable @code{data}.
Next, we have to display the data point, which is done via the call of
the function @code{display()}. Here two arguments are used, the number
of the point, stored in the variable @code{I}, and the value of the
new data point.

Of course, we also need to write the new data point to a data file. This
is done by the call of the function @code{save()} that automatically
writes its argument to a file. When the function is called for the first
time it prompts you for the name of the file to be used.

What remains to be done is to increment the counter variable @code{I}
and to sweep up the field. The function @code{sweep_up()} increments the
field by the amount you specified previously in the call of
@code{magnet_init()} (in the @code{PREPARATIONS} section) and returns
the new value of the field, which is later used in the test of the loop
condition to decide if the experiment is finished, i.e.@: the end field
is reached.

The last function call of @code{wait()} with the result of a call of the
function @code{lockin_time_constant()} as the argument makes the program
wait for the time constant of the lock-in amplifier to give it enough
time to measure a new data point.

When you have written such a script (using, for example, a simple ASCII
editor) you load it into @code{fsc2} and press the @code{Test} or the
@code{Start} button. @code{fsc2} will now analyze the script very
thoroughly. It will not only check for misspelt keywords, undefined
variables, non-existent functions, syntax errors etc.@: but will also
repeat the loop in the experiment section as often as in the real
experiment to find out if no errors will happen during the
experiment. This includes, for example, checking that the field is not
swept into regions the magnet or the gauss-meter can not handle (e.g.@:
by incidentally setting an end field value of @w{34500.0 G} which the
magnet can't produce). So you can be reasonable sure that the experiment
will not be aborted due to a faulty @code{EDL} script after it has
already run for 2 hours and you have to start all over again.

As you can already see from the example most of an @code{EDL} script
consists of function calls. Functions can be divided into two
categories, built-in functions and device functions. Built-in functions
(like @code{init_1d()}, @code{display()}, @code{save()} and
@code{wait()}) are always available, even when there is no
@code{DEVICES} section. In contrast, device functions are bound to
certain devices and can only be called when the device they are defined
for is listed in the @code{DEVICES} section. For example, the functions
@w{@code{lockin_sensitivity()}}, @w{@code{lockin_time_constant()}} and
@w{@code{lockin_get_data()}} are obviously targeted at lock-in
amplifiers and are only available when a lock-in amplifier module is
specified in the @code{DEVICES} section. Most of these functions are
available for all types of lock-in amplifiers (possibly with minor
variations) so that using a different lock-in amplifier usually doesn't
require a major rewrite of the @code{EDL} script but just changing the
lock-in's name in the @code{DEVICES} section.

To find out about all built-in and device functions, their arguments and
where they may be used have a look at the next two chapters of this
manual, @pxref{Built-in Functions} and @pxref{Device Functions}.


@node Sections, Syntax, Basics, EDL
@section Sections
@cindex section


As you already have seen in the example above, an @code{EDL} script
consists of section. There are up to 6 different types of
sections. These are specified by the following section keywords:
@example
DEVICES
VARIABLES
ASSIGNMENTS
PHASES
PREPARATIONS
EXPERIMENT
@end example
@noindent
Please note that the section keywords always have to be followed by a
colon, @code{:}.

@cindex @code{DEVICES} section
The first and last two sections have already been used in our example
script: The @code{DEVICES} section consists simply of a list of all the
devices that will be used in the experiment (or at least the ones that
are going to be controlled by the computer).

@cindex @code{VARIABLES} section
The @code{VARIABLES} section for declaring and initializing variables
has also already been discussed in the example.

Because pulses play an important role in modern EPR experiments lots of
elements for handling pulses and the pulsers that creates them are built
into @code{fsc2}. Thus, there are even two special sections,
@code{ASSIGNMENTS} and @code{PHASES}, exclusively devoted to the pulser
setup. The basic setup of the pulser (e.g.@: setting the time base and
trigger mode as well as setting up the pulser channels) is done in the
@code{ASSIGNMENTS} section while the @code{PHASES} section is all about
phase-cycling -- here you may have to define the phase sequences to be
used in the experiment as well as the way the resulting echos will be
added up. Because this is a rather extensive subject (and because of the
different ways pulsers are used in the supported spectrometers) an
in-depth discussion of both these sections is part of a whole chapter
(@pxref{Using Pulsers}).

@cindex @code{PREPARATIONS} section
As you already have seen, the @code{PREPARATIONS} section is for setting
up all the other devices and initializing graphics -- basically the
things you would do before actually starting an experiment. This is also
the section where pulses are going to be defined. Again, for more
details about this last topic see the chapter about pulse generators and
pulses (@pxref{Using Pulsers}).

@cindex @code{EXPERIMENT} section
Finally, there is the @code{EXPERIMENT} section. As you already have
seen this section usually consists of one or more loops, possibly nested,
where data are acquired and stored.

While the sections of an @code{EDL} script don't have to appear in the
sequence in which they are listed above it is probably best not to
experiment too much with this. In any case, if it exists the
@code{EXPERIMENT} section must always be the last one.

All the section keywords can be abbreviated, here's the complete list of
valid section keywords:
@itemize @bullet
@item @code{DEVICES}, or @code{DEV}, @code{DEVS}, @code{DEVICE}
@item @code{VARIABLES}, or @code{VAR}, @code{VARS}, @code{VARIABLE}
@item @code{ASSIGNMENTS}, or @code{ASS}, @code{ASSIGNMENT}
@item @code{PHASES}, or @code{PHA}, @code{PHAS}, @code{PHASE}
@item @code{PREPARATIONS}, or @code{PREP}, @code{PREPS}, @code{PREPARATION}
@item @code{EXPERIMENT}, or @code{EXP}
@end itemize

Beside these sections there is a label that looks very similar to a
section label, the
@itemize @bullet
@item @code{ON_STOP}
@end itemize
@cindex @code{ON_STOP} label
@noindent
label (which also must be followed by a colon, @code{:}). It can only be
used within the @code{EXPERIMENT} section. The @code{ON_STOP} label can
be used to guarantee that a certain part of the @code{EXPERIMENT}
section is going to be executed even after the user hit the @code{Stop}
button. It will probably contain code that stores previously unsaved
data and does other things that are necessary before the experiment
really stops.  When @code{fsc2} executes the code following the
@code{ON_STOP} label it won't react to the @code{Stop} button anymore.


@node Syntax, Variables, Sections, EDL
@section Syntax

There are a few basic rules about the syntax of @code{EDL} script.  Each
script consists of one or more sections that always start with one of
the section keywords listed above. Each section keyword has to be
followed immediately (i.e.@: without any spaces, tabulator or newline
characters in between) by a colon, `@code{:}'.

The sections of the script consist of statements. What a valid statement
is may depend on the section (e.g.@: in the @code{DEVICES} section all
valid statements are just names of devices while in other sections a
valid statement may be a complicated equation), but a statement must
@strong{always} end in a semicolon, `@code{;}'.  There is nothing
special about continuing a statement on a new line (i.e.@: a statement
can span several lines), @code{fsc2} recognizes where a statement ends
by the semicolon.

Within a statement all characters like spaces, tabulator characters and
newlines have no relevance at all (except separating variable names). So
there's no difference at all between the three following statements:
@example
start_field=3360.0 G;
start_field       =               3360.0G;
                  start_field=
        3360.0 G;
@end example
@noindent
The only thing you have to take care of is that you don't have a line
break between a number and its unit (e.g.@: between the @code{3360.0}
and the @code{G}), only space and tabulator characters are allowed as
separators.

@code{EDL} scripts use lots of function calls. There are no obvious
differences between variable names and function names (all start with a
character, followed by more characters, numbers or underscore
characters). To make clear that a word is a function it has to
be followed by a pair of parenthesis, `@code{(}' and `@code{)}', even if
the function doesn't accept arguments (spaces, tabulator or newline
characters are allowed between the function name and the opening
parenthesis). If a function does accept more than one argument its
arguments have to be separated by commas.


@node Variables, Assignment operations, Syntax, EDL
@section Variables
@cindex variables
@cindex arrays


Within the @code{VARIABLES}, @code{ASSIGNMENTS}, @code{PREPARATIONS} and
@code{EXPERIMENT} section variables may be used. Each variable that is
used in an @code{EDL} script must have been declared previously, i.e.@:
it has to be listed in the @code{VARIABLES} section before it may be
used. The start of the @code{VARIABLES} section is indicated by a line
stating
@example
VARIABLES:
@end example


@anchor{Variable names}
@subsection Variable names
@cindex Variable names

Names of variables (and also of functions) always start with a
character, i.e.@: A-Z or a-z. The remaining part of the variable name
can consist of characters, numbers and underscore characters,
'@code{_}' (or shorter, if you know regular expressions, valid names
follow the following pattern: @code{[A-Za-z][A-Za-z_0-9]*}). Thus,
'@code{AbC_12x}' and '@code{aBc_12X}' are legal variable names, while
'@code{12xy}' or '@code{_Yx2}' are not. Please note that the variable
names are case sensitive, i.e.@: '@code{XY}', '@code{Xy}', '@code{xY}'
and '@code{xy}' are all different variables!

The name of a variable can, in principle, consist of as many characters
as you wish (I hope nobody is going to the trouble of creating a variable
name with, say, a few hundred thousand characters just to prove me wrong
-- I tested it only with two variables with names consisting of 10000
characters each and differing only in the last character...)

There are some combinations of characters that can't be used as variable
names. First of all, variable names may not be identical to function
names, neither built-in nor device function names.

Further, the keywords used by @code{EDL} also may not be used as
variable names (to make it easier to avoid these, they are all spelled
with capitals only). In the appendix you'll find a list of (hopefully)
all reserved words.

Finally, some combinations of characters take on a special meaning when
they follow a number directly (i.e.@: with only spaces or tabulator
characters in between). These are some physical units with or without
the characters @code{n} (nano), @code{u} (micro), @code{m} (milli),
@code{k} (kilo) @code{M} (mega) and @code{G} (giga) (only wave numbers can't
be preceeded by such a character).  Here's the complete list:
@quotation
@multitable { @code{cm^-1} } {Decibel (and @code{ndbm, udbm, mdbm, kdbm, Mdbm} and @code{Gdbm})}
@item @code{s}     @tab Seconds (and @code{ns, us, ms, ks, Ms} and @code{Gs})
@item @code{m}     @tab Meter (and @code{nm, um, mm, km, Mm} and @code{Gm})
@item @code{G}     @tab Gauss (and @code{nG, uG, mG, kG, MG} and @code{GG})
@item @code{T}     @tab Tesla (and @code{nT, uT, mT, kT, MT} and @code{GT})
@item @code{V}     @tab Volt (and @code{nV, uV, mV, kV, GV} and @code{GV})
@item @code{A}     @tab Ampere (and @code{nA, uA, mA, kA, GA} and @code{GA})
@item @code{Hz}    @tab Hertz (and @code{nHz, uHz, mHz, kHz, GHz} and @code{GHz})
@item @code{K}     @tab Kelvin (and @code{nK, uK, mK, kK, MK} and @code{GK})
@item @code{dB}    @tab Decibel (and @code{ndB, udB, mdB, kdB, MdB} and @code{GdB})
@item @code{dBm}   @tab Decibel (and @code{ndBm, udBm, mdBm, kdBm, MdBm} and @code{GdBm})
@item @code{cm^-1} @tab wave numbers, i.e.@: inverse of a @code{cm}
@end multitable
@end quotation
@noindent
Please note that all device functions return values in units of seconds,
meters, Gauss, Volts, Amperes, Hertz, Kelvin, dB and cm^-1 or products
of these units. While you can use Tesla in the @code{EDL} script all
functions return values in Gauss!


@anchor{Variable types}
@subsection Variable types
@cindex Variable types

Variables can be divided into two classes, variables to hold integer
values and variables for storing floating point values.

Integer variables (on machines with 32-bit processors) can hold data in
the interval @w{[-2^31, 2^31 - 1]}, i.e.@: they run from @w{-2147483648}
all the way up to @w{+2147483647}. In contrast, floating point variables
can have much larger values (typically up to ca.@: 10^300), the exact
limits depending on the machine @code{fsc2} is running on. The larger
range for floating point numbers comes with a price: they have only a
limited precision, normally not more than about 14 to 15 digits can be
trusted and rounding errors can lead to quite large errors if not used
with great care in calculations.

To distinguish between integer and floating point variables the case of
the first character of the variables name is important: if the name
starts with an upper case letter, i.e.@: A-Z, it's an integer variable
while variables starting with a lower case character, i.e.@: a-z, are
floating point variables. (Actually, changing just one line of
@code{fsc2} allows to change to a completely different behavior.)


@anchor{Arrays and matrices}
@subsection Arrays and matrices
@cindex Arrays and matrices

Beside `normal' variables you can also use arrays and matrices (i.e.@:
more-dimensional arrays). The names of arrays follow the same convention
as that of normal variables, i.e.@: if an array name starts with an
upper case character it's an array consisting of integers only and if it
starts with a lower case character it's a floating point array. To
define a normal, fixed sized array in the @code{VARIABLES} section just
append the sizes of the dimensions of the array, separated by commas, in
square brackets. E.g.@: the lines
@example
F[ 100 ];
b[ 4, 7, 3 ];
@end example
@noindent
define an 1-dimensional array @code{F} of 100 integers and a
3-dimensional floating point array @code{b} of rank 4x7x3. Indices of
arrays start with 1 (like in MathLab and FORTRAN, but this can actually
be easily changed if you adjust a single line in the code for
@code{fsc2}...).

All elements of an arrays are automatically initialized to zero. On the
other hand, 1-dimensional arrays can also be initialized within the
@code{EDL} file by equating the array to a list of values, enclosed in
curly braces:
@example
C[ 3 ] = @{ 2, 1, -1 @};
d[ 5 ] = @{ sqrt( 2.0 ), sqrt( 3.0 ) + 1 @};
@end example
@noindent
The first line in the example shows the simplest way -- each element of
the integer array @code{C} is initialized by an element from the
list. In the second line there are less initializers than the array
@code{d} has elements, thus only the first two elements are set, i.e.@:
@code{d[1]} and @code{d[2]}, while the remaining elements are
automatically set to zero. Besides, you can see that function calls,
arithmetic etc.@: can be used in the initialization.

To initialize more-dimensional arrays you must enclose the 1-dimensional
arrays they basically are built up from each in a pair of curly braces,
but you also can use an already initialized matrix of a lower dimension.
You may also leave out parts of the initialization by using a pair of
empty curly braces as an empty set (the dimension of the empty set is
recognized automatically, so you won't need empty sets within empty
sets).
@example
E[ 3, 4 ] = @{ @{ 1, 2, 3 @},
              @{ 4, 5, 6 @} @};
F[ 2, 3, 4 ] = @{ @{ @{ 1, 2, 3, 4 @},
                   @{ @},
                   @{ 9, 8, 7, 6 @},
                   @{ 3, 5, 7, 9 @}
                  @},
                  E
               @};
G[ 4, 3, 4 ] = @{ @{ @},
                 @{ E[ 3 ], E[ 2 ], E[ 1 ] @}
               @};
@end example
@noindent
In the last statement of the example sub-arrays of the matrix @code{E}
are used, e.g.@: @code{E[3]} is the whole third sub-array of @code{E}.
You also need not to specify as many initializer elements as there are
elements in the matrix to be initialized, for missing elements the
matrix remains uninitialized.

You can also initialize all elements of an array or a matrix by just
equating it to a number:
@example
D[ 3 ] = 1;
f[ 3, 6 ] = sqrt( 42.0 );
@end example
This will assign the value 1 to all elements of the array @code{D} and
the square root of 42 to all 18 elements of the 2-dimensional matrix
@code{f}.


@anchor{Variable sized arrays and matrices}
@subsection Variable sized arrays and matrices
@cindex Variable sized arrays and matrices

There are some situations where one doesn't know the size of an array in
advance, e.g.@: the size of the array to be used for storing a trace
from a digitizer or the of the 2-dimensional field for a complete
picture from a CCD-camera. So declaring the size in advance in the
@code{VARIABLES} section is not possible. Therefore it is also possible
to create arrays with sizes that change automatically when required. This
is done by specifying a @code{*} instead of a number for the size:
@example
M[ * ];
h[ 2, * ];
I[ *, *, * ];
@end example
@noindent
This defines an 1-dimensional integer array @code{G} with a non-fixed
(and still unknown) number of elements, a 2-dimensional floating point
matrix @code{h} with two rows of unknown length and a 3-dimensional
array with all sizes being variable sized.

The only restriction in declaring variable sized matrices is that you
can't declare matrices with only the higher dimensions being variable
sized but the lower ones fixed. I.e.@: the following definition is
@strong{not} possible:
@example
h[ *, 2 ];  /* WRONG! */
@end example

The length of the 1-dimensional array @code{M} from the above example
remains undetermined until a value has been assigned to at least one
of the array element. If you now assign a value to the 25th element
like this
@example
M[ 25 ] = 42;
@end example
@noindent
the array will suddenly have 25 elements with the first 24 being set to
zero and the 25th set to @code{42}. You can also lengthen the array at
a later time by assigning a value to an element with an higher index,
e.g.
@example
M[ 50 ] = 84;
@end example
@noindent
Now the array has 50 elements, the newly added elements between and
including the 25th and 49th being initialized to zero.

But there's also another way to change the size of the array. You can
assign another array to @code{M} and in this case the length of @code{M}
is resized to fit the length of the array you assign to it. E.g.@: if
you had an array defined as
@example
H[ 10 ] = @{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 @};
@end example
@noindent
and you now assign @code{H} to @code{M}
@example
M = H;
@end example
@noindent
@code{M} will also have 10 elements with the same values as the
elements of @code{H}.

Some care has to be taken: it is also possible to shrink the length of a
variable sized array by assigning another array to it. If @code{M}
had already been given a length by e.g.@: assigning a value to its 25th
element then assigning it the shorter array @code{H} will automatically
shorten it to 10 elements and the values stored in the 11th to the 25th
element are lost.

To understand how more-dimensional, variable sized arrays work it is
probably best to think of them not in terms of matrices but of arrays
of arrays (of arrays... etc.). For example, a two-dimensional array like
@example
j[ *, * ];
@end example
@noindent
can be thought of as an array (of still undetermined length) of arrays
which also have no length yet (or a length of 0). When you now assign
a value to one an element like this
@example
j[ 7, 9 ] = 3.1415927;
@end example
@noindent
the 7th sub-array of @code{j} will suddenly spring into existence,
having a length of 9 (with all elements of this sub-array except the 9th
being initialized to 0). But this does @strong{not} also create other
sub-arrays -- the 1st to the 6th sub-array are still undefined (having a
length of 0).

Only if you assign a value to the elements of one of these other
sub-arrays it will start be created, e.g.@: by having
@example
j[ 3, 2 ] = 2.7182818;
@end example
@noindent
Now both the 3rd and the 7th sub-array of @code{j} exist - but no others
(i.e.@: the 1st, 2nd, 4th, 5th and 6th sub-array do not exist yet and
trying to use a value of one of these sub-arrays will result in an error
message). And both these sub-arrays have different lengths, the 3rd
sub-array has a length of only 2, while the 7th sub-array has a length
of 9.

Of course, the sub-arrays can also be created by assigning another
array. E.g.
@example
k[ 3 ] = @{ -1.0, 0. 1.0 @};
j[ 5 ] = k;
@end example
@noindent
will create the 5th sub-array of @code{j} with a length of 3 and its
values being identical to the ones of the array @code{k}. From this
example you can also see, that sub-arrays of an array can be simply
specified by off the index for the element of the sub-array, i.e.@:
@code{j[5]} stands for the complete 5th sub-array of @code{j} (and the
@code{k} on the right hand side represents the complete array @code{k}).

But @code{j} can also be set by assigning another 2-dimensional matrix
to it.
@example
l[ 3, 2 ] = @{ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 @};
j = l;
@end example
@noindent
Since @code{l} is a matrix of rank 3x2 after the assignment @code{j}
will have the same rank (and the elements of @code{j} and @code{l}
will, of course, be identical).

The same, of course, can be done with "matrices" of higher dimensions.
If you have a 3-dimensional matrix you can assign numbers to its
elements, 1-dimensional arrays to its sub-sub-arrays, 2-dimensional
"matrices" to its sub-matrices and, of course, assign a complete
3-dimensional matrix to it.


@node Assignment operations, Array ranges, Variables, EDL
@section Assignment operations
@cindex Assignment operations

Assignments of the kind described above also work with fixed sized
arrays and matrices but, of course, then the sizes of the quantities on
the left and the right side must be identical or an error will be
flagged.

But @code{fsc2} tries to be even more clever: when the dimensions of a
quantity the left side of an equation is larger than the dimension of
the quantity on the right hand side it tries to assign the quantity on
the right hand side to as many elements or sub-arrays on the left hand
side as possible. You already have seen this in the discussion of the
initialization of (fixed size) arrays and matrices: when a number is
assigned to an array or matrix all elements of the array or matrix are
set to this number. To repeat:
@example
B[ 3 ] = 9;
b[ 2, 9 ] = sin( atan( 1.0 ) );
@end example
@noindent
sets all elements of the array @code{B} to 9 and all 18 elements of the
2-dimensional matrix @code{b} to the sine of 45 degrees (atan(1)
evaluates to a quarter of pi).

The same assignment can also be done for variable sized arrays and
matrixes, but only the already existing elements can be set (if i.e.@:
only a single sub-array of a 2-dimensional "matrix" has been created yet
only the elements of this sub-array can be set).

But this does not only work for numbers on the right hand side but also
for arrays and even matrices. When you have for example a 2-dimensional
matrix on the left hand side and a one-dimensional array on the right 
the array is automatically assigned to all of the sub-arrays of the
matrix. If you have in the @code{VARIABLES} section:
@example
z1[ 2 ] = @{ 3, 5 @};
z2[ 2, * ] = xx;
@end example
@noindent
this will set up both the sub-arrays of @code{z2} to have 2 elements each
and set both sub-arrays to the same values as the ones of @code{z1}.

Within the other sections you have to write this a bit differently (but
even simpler) indicate that you want to set all sub-arrays of @code{z2}
at once by just writing
@example
z2 = z1;
@end example
@noindent
It's basically just an abbreviation for the longer form
@example
z2[ 1 ] = z1;
z2[ 2 ] = z1;
@end example
@noindent
or the even longer form of
@example
z2[ 1, 1 ] = z1[ 1 ];
z2[ 1, 2 ] = z1[ 2 ];
z2[ 2, 1 ] = z1[ 1 ];
z2[ 2, 2 ] = z1[ 2 ];
@end example

Of course, the same also works with arrays of higher dimensions. If you
have e.g.@: a 3-dimensional matrix, assigning it a number will set all
of its elements (i.e.@: the elements of the sub-sub-arrays its made up
from), assigning it an 1-dimensional arrays will set all sub-sub-arrays
to be identical to the 1-dimensional array on the right hand side,
assigning it a 2-dimensional matrix will set all its sub-matrices and
assigning it another 3-dimensional matrix will make the matrix on the
left hand side identical to the one on the right hand side. Of course,
if the matrix on the left hand side isn't variable sized, its sizes must
fit the sizes of the quantity on the right hand side.

With dynamically sized arrays some care has to be taken when doing
assignments. That's because the size of the array on the left hand side
automatically gets adjusted to the one on the right hand side. This
includes even cases where the size of array on the right hand side is
still unknown. In this case all information about the size of the left
hand side array and its elements are discarded and it will now be
treated as if its size never had been set. Since in most cases this may
be not what you want a warning is printed to inform you about this
potential problem.


@node Array ranges, Arithmetic, Assignment operations, EDL
@section Array ranges
@cindex Array ranges

Until now we were talking about array indexing as if it would only be
possible to index a single element or whole subarrays, i.e.@: if we
have an array defined in the @code{VARIABLES} section as
@example
k[ 5, 8 ];
@end example
@noindent
then the first element of the first row or the last subarray would be
indexed as
@example
k[ 1, 1 ]
k[ 5 ]
@end example
But it is also possible to parts of array by using range indexing. E.g.@:
@example
k[ 1, 2 : 4 ]
@end example
@noindent
is an one-dimensional array, consisting of the second to the fourth element
of the first row of @code{k}. And
@example
k[ 2 : 4, 7 ]
@end example
@noindent
is also an one-dimensional array of the three elements, having the
values @code{k[2,7]}, @code{k[3,7]} and @code{k[4,7]}. Finally,
@example
k[ 2 : 4, 3 : 7 ]
@end example
@noindent
is a two-dimensional array of rank @code{3x5}. Using
@example
k[ 2 : 4, 3 : 7 ] += 1;
@end example
@noindent
would add @code{1} to the third to seventh element of the second to
fourth row of the array @code{k}.

Array indexing with ranges can be used on both the left as well as
the right hand side of an assignment.


@node Arithmetic, Conditional operator, Array ranges, EDL
@section Arithmetic
@cindex Arithmetic

Of course, @code{fsc2} understands the usual arithmetic operations,
i.e.@: addition, subtraction, multiplication and division, represented
by the characters `@code{+}', `@code{-}', `@code{*}' and `@code{/}'.
@cindex + (addition operator)
@cindex - (subtraction operator)
@cindex * (multiplication operator)
@cindex / (division operator)
They can be used with simple integer and floating point values as well
as with 1-dimensional arrays (see below for more information). If one of
the values is a floating point value the result is also a floating point
number - only if both values are integers the result is also an
integer. This also holds for the division -- if you divide two integers
the result is still an integer, see below.

Some care has to be taken in arithmetic with integers.
@cindex integer overflow
@cindex integer underflow
@cindex overflow, integers
@cindex underflow, integers
@cindex range of integers
@cindex integers, range of
The range of values an integer variable can have is restricted to the
interval @w{[-2147483648, +2147483647]}, i.e.@: @w{[-2^31, 2^31 - 1]}
(at least on a 32-bit processor). Thus, it isn't to difficult to create
numbers with greater values, e.g.@: by multiplication, that can't be
represented by an integer! In this case the result of the operation will
be completely bogus, e.g.@:
@example
1000000 * 3000 = -1294967296
@end example
@noindent
(There is actually some logic behind this result but that doesn't help
too much.) So, if you suspect the result of an integer operation to
exceed the range of representable values, convert the values to floating
point type (using the function @code{float()}) before you do the
potentially problematic arithmetic operation.

Of course, there are also limits to the range of numbers representable
by a floating point number. Fortunately, these limits are much larger -
typically the maximum size of floating point numbers is in the range of
10^300.
@cindex floating point numbers, range of
@cindex range of floating point numbers
@cindex floating point overflow
@cindex floating point underflow
@cindex overflow, floating point numbers
@cindex underflow, floating point numbers


Another important point about calculations involving integers concerns
the division. The result of the division of two integer values is again
an integer value. For non-integer results this is achieved by simply
truncating the digits following the decimal point. Thus, typical results
are
@example
7 / 2 = 3     8 / 3 = 2     -7 / 2 = -3
@end example
@cindex / (division operator)
@cindex integer division
@noindent
To avoid this truncation convert at least one of the values used in the
division to a floating point type by using the @code{float()} function,
i.e.@:
@example
float( 7 ) / 2 = 3.5    8 / float( 3 ) = 2.666666667
@end example


Beside the normal arithmetic operations there are two often needed
operations, the modulo function and the exponentiation. For the modulo
operation the percent sign @code{%}
@findex % (modulo operator)
@cindex modulo operator
is used and the result is the remainder of the division, e.g.@
@example
7 % 3 = 1         6.5 % 2.5 = 1.5 
@end example
@noindent
For the exponentiation the caret character @code{^} is to be used, e.g.@:
@findex ^ @r{(exponentiation)}
@cindex exponentiation
@example
3^2 = 9           6.5^1.5 = 16.5718134219...
@end example
@noindent
As mathematics dictate non-integer exponents can only be used with
non-negative bases!


@anchor{Arithmetic-assignment operators}
@subsection Arithmetic-assignment operators
@cindex Arithmetic-assignment operators
@cindex @code{+=} (add and assign)
@cindex @code{-=} (subtract and assign)
@cindex @code{*=} (multiply and assign)
@cindex @code{/=} (divide and assign)
@cindex @code{%=} (modulo and assign)
@cindex @code{^=} (exponentiation and assign)

When assigning to a variable usually the assignment operator `@code{=}'
is used. But there are often cases where a variable just has to be
incremented as in
variable:
@example
I = I + 1;
@end example
@noindent
This assignment can be shortened (and sometimes made more readable) by
using the `add and assign' operator `@code{+=}':
@example
I += 1;
@end example
@noindent
Assignment operators mixed with arithmetic can also be used with all
other arithmetic operators, i.e.@: you may use all of the following
assignment operators
@example
+=     -=     *=     /=     %=     ^=
@end example


@anchor{Operator precedence}
@subsection Operator precedence
@cindex Operator precedence

Usually one doesn't need to think about the precedence of operators. We
already learned in primary school that multiplication and division have
higher precedence than addition and subtraction and, of course, a
programming language should follow these rules. But sometimes there are
cases where it is necessary to know the precedence exactly, i.e.@: the
exact sequence an expression is evaluated.

The unary operators (unary in the sense that they apply only to one
number or variable) `@code{+}' and `@code{-}', i.e.@: the operators
defining the sign of a number, have the highest precedence. There is a
further operator, to be discussed later, having the same precedence, the
logical negation operator, `@code{!}'. The evaluation of an expression
with more than one of these operators is from the right to the left,
i.e.@:
@example
 !-x    @r{will be treated as if written as}    ! ( - x )
@end example
@noindent
(This is not a very useful example but here for sake of completeness.)

The exponentiation operator, `@code{^}', has the next highest
precedence, i.e.@: it binds more tightly than any other binary operator
(i.e.@: an operator involving two numbers or variables). If there is
more than one of these operators in a row the expression will be
evaluated from the right to the left:
@example
 2^3^4    @r{will be treated as if written as}    2^(3^4)
@end example


The operator with the next lower precedence is the modulo operator,
`@code{%}'. Expressions with more than one `@code{%}' in a row will be
evaluated left to right, i.e.@:
@example
 31 % 6 % 2    @r{will be treated as if written as}    ( 31 % 6 ) % 2
@end example


Now follow the multiplication and division operators, `@code{*}' and
`@code{/}. Both have exactly the same precedence and expressions
involving more than one of these operators are evaluated left to right,
i.e.@:
@example
 3 * 20 / 7    @r{will be treated as if written as}    ( 3 * 20 ) / 7
@end example
@noindent
(Take care: The order of evaluation can make a lot of a difference - due
to the rules of integer division @code{(3 * 20) / 7} will evaluate to
@code{8}, while @code{3 * (20 / 7)} would result in @code{6}).


The next lower precedence operators are the addition and subtraction
operators, `@code{+}' and `@code{-}'. Also for these operators
expressions involving more than one of these operators are evaluated
left to right:
@example
 13 + 4 - 5    @r{will be treated as if written as}    ( 13 + 4 ) - 5
@end example
@noindent
Usually, this won't matter a lot, but if you're dealing with very large
numbers and there's danger of an overflow to occur knowing the rules of
evaluation can become important.

The next lower precedence operators are the logical operators to be
discussed in more detail below, i.e.@: the logical @i{and} operator,
`@code{AND}' or `@code{&}', the logical @i{or} operator, `@code{OR}' or
`@code{|}' and the logical @i{exclusive or} (xor) operator, `@code{XOR}'
or `@code{~}'. Expressions containing more than one of these operators
are always evaluated from the left to the right of the expression:
@example
 a OR b AND c  @r{will be treated as if written as}  ( a OR b ) AND c
@end example
@noindent
or
@example
 a | b & c     @r{will be treated as if written as}  ( a | b ) & c
@end example
@noindent
To make your intentions more clear to human readers of your
@code{EDL} scripts it's probably a good idea to use parenthesis in
these cases even if they are not strictly required.

The operators with the second-lowest precedence are the comparison operators
(also the be discussed below in more detail), i.e.@: the test for equality,
`@code{==}' (not to be confused with the assignment operator
`@code{=}'), the test for inequality, `@code{!=}', and the remaining
four comparison operators `@code{<}', `@code{<=}', `@code{>}' and
`@code{>=}', i.e.@: @i{less than}, @i{less or equal}, @i{larger} and
@i{larger or equal}. If more than one of these operators appears in an
expression evaluation is done left to right.

Finally, the lowest precedence has the conditional operator, which
has the form
@example
 expression_1 ? expression_2 : expression_3
@end example
@noindent
Which tests @code{expression_1} and then results in @code{expression_2}
if the result of the test was positive or in @code{expression_3} if the
test failed, a more detailed explanation is given below. The low
precedence means that all the three expressions are always evaluated

Actually, there are also the assignment operators. But these are only
used after all of the other operators have been evaluated, so there is
never a necessity to enclose the right hand of an equation in
parenthesis. And since only one assignment operator is allowed in a
statement you don't have to worry about the order of evaluation.

Of course, the precedence of operators and the sequence they are
evaluated in can always be changed by using parenthesis. So, if in
doubt, use parenthesis -- this won't slow down the program but will
often make the script easier to understand.


@anchor{Arithmetic with arrays and matrices}
@subsection Arithmetic with arrays and matrices
@cindex Arithmetic with arrays and matrices

Beside the usual arithmetic with numbers it is also possible to use
whole arrays and more-dimensional matrices in arithmetic expressions.
Lets start with 1-dimensional arrays. As long as the sizes of the two
arrays are identical they can be added or subtracted as if they were
numbers. For example, if the arrays @code{a} and @code{b} are defined
as
@example
  a[ 3 ] = @{ 0.5,  1.0,  2.0 @};
  b[ 3 ] = @{ 1.0, -2.0, -3.0 @};
@end example
@noindent
they can be added and subtracted in an element-by-element fashion,
resulting in
@example
  a + b      ->   @{  1.5, -1.0, -1.0 @}
  a - b      ->   @{ -0.5,  3.0,  5.0 @}
@end example
@noindent
Of course, you can also invert the sign of all the elements of an array
by simply prepending it with a minus sign
@example
  -a         ->   @{ -0.5, -1.0, -2.0 @};
@end example

But it's also possible to add a number to each of the elements of an
array or to subtract a number (or to subtract all array elements from a
number):
@example
  a + 5      ->   @{ 5.5, 6.0, 7.0 @}
  a - 3      ->   @{ -2.5, -2.0, -1.0 @}
  3 - a      ->   @{ 2.5, 2.0, 1.0 @}
@end example

Multiplication and division are also possible with whole arrays. Again,
these operations are implemented in an element-by-element way, i.e.@:
multiplying two arrays is not a dot product but results again in an
array of the same size as both the original arrays. The same holds for
the division. With the arrays @code{a} and @code{b} defined above the
results are:
@example
  a * b      ->   @{ 0.5, -2.0, -6.0 @}
  a / b      ->   @{ 0.5, -0.5, -0.666667 @}
  b / a      ->   @{ 2.0, -2.0, -1.5 @}
@end example

Multiplication and division of an array with a number is also defined as
shown here:
@example
  a * 2      ->   @{ 1.0, 2.0, 4.0 @}
  a / 3      ->   @{ 0.166667, 0.333333, 0.666667 @}
  3 / a      ->   @{ 6.0, 3.0, 1.5 @}
@end example

Finally, calculation of the modulo function and exponentiation can be
done with whole arrays. These operations are again implemented as
element-by-element calculations, i.e.@: always resulting in an array:
@example
  a % b      ->   @{ 0.5, 1.0, 2.0 @}
  b % a      ->   @{ 0.0, 0.0, -1.0 @}
  a ^ b      ->   @{ 0.5, 1.0, 0.125 @}
  b ^ a      ->   @{ 1.0, -2.0, 9.0 @}
@end example

Of course, the same operations can also be applied to a mixture of
arrays and simple numbers, also resulting in arrays:
@example
  a % 0.3    ->   @{ 0.2, 0.1, 0.2 @}
  1.3 % a    ->   @{ 0.3, 0.3, 0.7 @}
  a ^ 2      ->   @{ 0.25, 1.0, 4.0 @}
  2 ^ a      ->   @{ 1.414215, 2.0, 4.0 @}
@end example

All these kinds of arithmetics also work with more-dimensional arrays.
If the size of two matrices are identical they can be added together
or subtracted from each other, then elements can be multiplicated or
divided in an element by element fashion (take care, multiplication
of two 2-dimensional matrices does @strong{don't} work in the usual
mathematical way, but the first elements of the first rows of both
matrices get multiplicated, forming the first element of the first row
of the resulting matrix). And also the modulo and exponentiation
operations work as well as the negation.

And as for 1-dimensional arrays a single number can be e.g.@: added to
each of the elements of a more-dimensional array. I.e.@: if @code{M} is
a 3-dimensional matrix you can add the number 3 to each of it's elements
(as far as they exist yet in the case of variable sized matrices) by
simply writing
@example
M += 3;
@end example
@noindent
Of course, this also works with all the other kinds of arithmetic
operations. The only requirement is, if @code{M} is a variable sized
matrix, all elements exist, i.e.@: if for example a sub-array isn't yet
defined @code{fsc2} will flag an error because it doesn't know how to
add a number to an array that not exists yet.

If you want to add a number to only a sub-array of the matrix
@example
M[ 2 ] += 3;
@end example
@noindent
would add 3 to each elements of the 2nd sub-array of @code{M} (which is
a matrix of rank 4x5).

But you can also add a whole 1-dimensional array to each of the
sub-arrays of a matrix. Lets again assume that @code{M} 3-dimensional,
e.g. a matrix of rank 3x4x5. If @code{a} is now an 1-dimensional array
of length 5 you can add it to all of @code{M}'s 12 sub-sub-arrays by
writing
@example
M += a;
@end example
@noindent
If you would have to write the same using just the elements you would
have to write 60 additions instead, i.e.@:
@example
M[ 1, 1, 1 ] += a[ 1 ];
M[ 1, 1, 2 ] += a[ 2 ];
...
M[ 1, 1, 5 ] += a[ 5 ];
M[ 1, 2, 1 ] += a[ 1 ];
...
...
M[ 3, 4, 5 ] += a[ 5 ];
@end example
@noindent
Of course, this could also be done using a @code{FOR} loop, see below,
but would still be a lot longer.

If you instead want to add the array @code{a} only to all the sub-array
in the 2nd set of sub-arrays of @code{M} you could simply write
@example
M[ 2 ] += a;
@end example
@noindent
instead of doing it explicitely in the longer form
@example
M[ 2, 1 ] += a;
M[ 2, 2 ] += a;
M[ 2, 3 ] += a;
M[ 2, 4 ] += a;
@end example

You can also directly add a 2-dimensional matrix to all sub-matrices of
a 3-dimensional matrix, or, generally, you can add a n-dimensional
matrix to all n-dimensional sub-matrices of a m-dimensional matrix,
given that m is larger than n and that the ranks of the sub-matrices are
identical, by just writing them as if they were simple numbers. The same
holds for all the other types of arithmetic operations. In all cases
@code{fsc2} will automatically try to get it right and spare you from
having to write all kinds of loops to get the same effect.

You can also mix objects of different ranks in an expression: if
@code{M} is, for example, a 3-dimensional matrix, @code{N} is a
2-dimensional matrix and @code{R} an 1-dimensional array you can write
@example
M += N - R * 3;
@end example
@noindent
In this case each element of @code{R} will first be multiplied by 3 and
the resulting array is then subtracted from each of the sub-arrays of
@code{N}. Finally, @code{N} is added to each of the sub-matrices of
@code{M}.


Further, the built-in arithmetic functions can (as far as this makes any
sense) be applied to arrays and matrices. In every case the function is
applied to each element of the array or matrix, thus the result is
another array or matrix of the same rank with its elements being the
results of applying the function to each of the input array
elements. For example, again using the array @code{a} defined above,
applying the @code{sqrt()} function results in:
@example
  sqrt( a )  ->   @{ 0.7071068, 1.0, 1.1414215 @}
@end example

Finally, for obvious reasons, when computed assignments are used
(i.e.@: `@code{+=}', `@code{-=}', `@code{*=}', `@code{/=}', `@code{%=}'
or `@code{^=}') the left hand side variable of an equation has to be an
array when arithmetic with arrays is used.


@node Conditional operator, Control structures, Arithmetic, EDL
@section Conditional operator
@cindex Conditional operator
@cindex Conditional operator

Quite often it is necessary to decide which part of the code of a
script to execute and have this decision depend on the result of a
calculation or external input. For these cases a construct is helpful
that allows to tell the program to do something if e.g.@: the result of
a calculation is less then @code{0} and to do something else if the
result was larger or equal to @code{0}.  An admittedly somewhat
contrived example would be the calculation of the square root of a
number, making sure the number is multiplied by -1 before calculating
the root in case it's negative. Using the conditional operator this can
be written as
@example
sqrt_of_val = ( val < 0.0 ) ? sqrt( -1.0 * val ) : sqrt( val );
@end example
@noindent
The conditional operator is somewhat special in that it consists of both
the question mark, @code{?}, and the colon, @code{:}. It tells the
program to evaluate the expression before the question mark and then,
depending on the result, execute either the expression before or after
the colon. In the example it is tested if @code{val} is smaller than
@code{0}, and if this is true, the square root of @code{val} multiplied
by @code{-1} is taken, otherwise the square root of just @code{val}
itself.

Beside comparison for the number on the left hand side being smaller
than the number on the right hand side, several other operators for
comparisons exist. Now follows a complete list of such comparison
operators, which can only be applied to expressions that result in
numbers, e.g.@: either simple numbers, numerical variables or numerical
results of a calculation, but never to arrays:
@quotation
@cindex == (equal to)
@cindex equal to `=='
@cindex != (unequal to)
@cindex unequal to `!='
@cindex < (less than)
@cindex less than `<'
@cindex <= (less or equal)
@cindex less or equal `<='
@cindex > (larger than)
@cindex larger than `>'
@cindex >= (larger or equal)
@cindex larger or equal `>='
@multitable {@code{==}} {true if left hand side is @i{equal} to the right hand side}
@item @code{==} @tab  true if left hand side is @i{equal} to the right hand side
@item @code{!=} @tab  true if left and right hand side are @i{unequal}
@item @code{<}  @tab  true if left side is @i{less than} right side
@item @code{<=} @tab  true if left side is @i{less or equal} to right side
@item @code{>}  @tab  true if left side is @i{greater than} right side
@item @code{>=} @tab  true if left side is @i{greater or equal} to right side
@end multitable
@end quotation

Please note that using comparisons between floating point numbers may
not work as you may expect them to do. This is a result of the finite
precision of floating point numbers.  Thus, for example, @code{0.1} and
the result of e.g.@: @code{0.7 / 7} can have different values, in which
case a comparison for equality will fail! Thus comparison for equality
should in principle only be used with integer numbers.

All these comparison operators actually do a calculation, resulting in a
new number. When you see something like @code{a <= b} this evaluates to
@code{1} if the expression is true (i.e.@: if the value of @code{a} is
less or equal to the value of @code{b}), and otherwise to @code{0}. In
the test of the conditional execution operator (i.e.@: everything before
the question mark) it is checked if the result is a non-zero number,
which then is taken as true, or if it's zero, which is interpreted as
meaning false. Thus instead of an expression with a comparison operator
the test part could also consist of just a simple number and what is
going to be executed of the two alternatives after the question mark
depends on the value of this number: if it is non-zero the first
alternative is used, but if it is zero the second. Thus it would be
valid to write:
@example
exp_of_val = val ? exp( val ) : 1;
@end example
@noindent
This checks if @code{val} is non-zero, in which case the exponential of
@code{val} is calculated by doing a function call, otherwise, if
@code{val} is @code{0}, the correct result of @code{1} is written out
directly instead of using a slightly slower function call.

One has to be a bit careful when using the operator for conditional
execution because it has a very low precedence. After
@example
x1 = 1.0 + val < 0 ? 5 : 9;
x2 = 1.0 + ( val < 0 ? 5 : 9 );
@end example
@noindent
@code{x1} and @code{x2} will have different values. In the first line it
is checked if @code{val} plus @code{1.0} is smaller than @code{0} and
@code{x1} is set accordingly to either @code{5} or @code{9}, while in
the second line it is checked if @code{val} is less than @code{0} and,
depending on the result, either @code{5} or @code{9} is added to
@code{1.0}, resulting in @code{6} or @code{10}. Also the following two
assignments may result in different values, at least if @code{val} is
negative:
@example
x1 = val < 0 ? 5 : 9 + 1;
x2 = ( val < 0 ? 5 : 9 ) + 1;
@end example
The value of @code{x1} will be either set to @code{5} or @code{10} (the
sum of @code{9} and @code{1}, while @code{x2} will be set to @code{6} or
@code{10}. Thus it is to be recommended to use parentheses to make sure
that the evaluation happens as expected except in trivial cases.

Beside comparison operators also logical operators can be used in the
test part of the condition operator. They are discussed in detail in the
next section, but they work very similarly to the comparison operators
in that they always result in a value of either @code{1} or @code{0},
standing for true or false, respectively.

Finally, the same effect as with the conditional operator can also be
achieved by using an @code{IF-ELSE} construct (see below), but only
within the @code{EXPERIMENT} section of an @code{EDL} script --
everywhere else only the conditional operator can be used.


@node Control structures, Miscellaneous, Conditional operator, EDL
@section Control structures
@cindex Control structures
@cindex Flow control


Within the @code{EXPERIMENT} section flow control structures can be
used. These are @code{REPEAT}, @code{WHILE}, @code{UNTIL}, @code{FOR} and
@code{FOREVER} loops and @code{IF-ELSE} and @code{UNLESS-ELSE}
constructs. (Please note: all of these keywords have to be spelt in
upper case letters!).


Most flow control construct keywords are followed by a condition and all
are then followed by a block of statements. Such a block of statements
has to be enclosed in curly braces (@code{@{} and @code{@}}) and may
contain as many statements as needed (and still fit into the computers
memory).


@anchor{REPEAT loops}
@subsection REPEAT loops
@cindex REPEAT loops

The most simple construct is the @code{REPEAT} loop. What is needed
following the keyword @code{REPEAT} is a number and a block with
commands. The number should be an integer number (or an expression
resulting in an integer).  The following block of statements will now be
repeated as many times as specified by the number (or
expression). Here's an example:
@example
  I = 0;
  SUM = 0;

  REPEAT 100 @{
      I = I + 1;
      SUM = SUM + I;
  @}
@end example

This snippet will calculate the sum of all integers between 1 and 100
(of course, there are more elegant ways to do this, but it's just an
example). After the initialization of the two variables `@code{I}' and
`@code{SUM}' the @code{REPEAT} loop starts with 100 as the number of
repetitions. Now, in curly braces, i.e.@: between `@code{@{}' and
`@code{@}}', follow the statements to be executed in the loop.

Please note: If the number of repetitions of the loop is a variable or
an expression the variable or expression will be evaluated just once at
the very start, i.e.@: once before the loop is executed, so if you
change the value of the variable (or the variables involved in the
expression) within the loop the number of repetitions won't change.



@anchor{WHILE loops}
@subsection WHILE loops
@cindex WHILE loops


Nearly as simple a construct is the @code{WHILE} loop, but instead of a
simple number following the keyword a condition is needed. Usually, this
will be a comparison between two numbers, but also a simple number will
suffice -- if its value is non-zero it will be interpreted as TRUE. Of
course, the keyword and the condition have to be followed by a block of
statements.

Again, an example:
@example
  I = 1;
  Fact = 1;

  WHILE I <= 6 @{
      Fact = Fact * I;
      I = I + 1;
  @}
@end example

This snippet (that also could have been written using a @code{REPEAT}
loop) calculates the factorial of 6. After initializing the variables
@code{I} and @code{Fact} it is tested in the loop condition if @code{I}
is still not larger that 6. If this is true, the following block of
statements is executed.

Here is now an example for using simple numbers in a condition,
using the fact that a non-zero value is always interpreted as TRUE:
@example
  I = 6;
  Fact = 1;

  WHILE I@{
      Fact *= I;
      I -= 1;
  @}
@end example

This example does exactly the same as the previous one, i.e.@: it
calculates the factorial of 6. But the difference is that we start with
`I' set to 6 and than decrement it successively. Thus we can use
`@code{I}' in the loops condition by simply checking if it still is
non-zero and thus the condition still TRUE and repeating the loop as
long as it is.

Sometimes, you may want to check not for the truth but for the falsehood
of an expression. In this case you have to prepend the expression with
an exclamation mark, `@code{!}', or the equivalent logical @i{not}
operator, `@code{NOT}', to reverse the meaning of a test (or use an
@code{UNTIL} loop, see below).

If you want to check for combinations of expressions you can use the
logical @code{AND}, @code{OR} or @code{XOR} (exclusive or)
operators. Here is a list of these operators and their meaning:

@quotation
@cindex ! (negation operator)
@cindex NOT (negation operator)
@cindex negation operator `!'
@cindex negation operator `NOT'
@cindex & (logical and operator)
@cindex AND (logical and operator)
@cindex and operator `&'
@cindex and operator `AND'
@cindex logical and operator `&'
@cindex logical and operator `AND'
@cindex | (logical or operator)
@cindex AND (logical or operator)
@cindex or operator `|'
@cindex or operator `OR'
@cindex logical or operator `|'
@cindex logical or operator `OR'
@cindex ~ (logical xor operator)
@cindex XOR (logical xor operator)
@cindex xor operator `~'
@cindex xor operator `XOR'
@cindex logical xor operator `~'
@cindex logical xor operator `XOR'
@multitable {@code{AND} or @code{&}} {@i{exclusive or}: true if left or right hand side expressions are true but not both}
@item @code{NOT} or @code{!} @tab @i{not}: negates truth of an expression
@item @code{AND} or @code{&} @tab @i{and}: true if both left and right hand side expressions are true
@item @code{OR} or @code{|} @tab @i{or}: true if at least one of the left and right hand side expressions is true
@item @code{XOR} or @code{~} @tab @i{exclusive or}: true if either left or right hand side expression is true (but not both)
@end multitable
@end quotation

@b{Please note}: For both the logical @strong{or} operator (`@code{OR}'
or `@code{|}') and the logical @strong{and} operator (`@code{AND}' or
`@code{&}') the expressions are always only evaluated as far as
necessary to determine the final result. Thus for the condition
@example
A == 0 OR B != 3
@end example
@noindent
only the first part, @code{A == 0}, is tested when @code{A} is @code{0}
because in this case the result is already known to be true and does not
depend on the second comparison. The same holds for expressions like
@example
A != 0 AND lockin_phase( ) > 90.0
@end example
@noindent
If @code{A} equals @code{0} the value of the whole expression is already
known to be false even though the lock-ins phase may be less then 90 degrees.
Thus no call of the function @code{lockin_phase()} will be done.

@b{Thus the sequence in conditions containing the logical "or" and "and"
operator is important.}

To make it more clear please understand that the code (please read about
the @code{IF} and @code{ELSE} constructs below for more details)
@example
IF A == 0 OR B != 3 @{
    do_something( );
@}
@end example
@noindent
is treated as if you would have written
@example
IF A == 0 @{
    do_some_thing( );
@} ELSE IF B != 3 @{
    do_something( );
@}
@end example
@noindent
In the same way
@example
IF A != 0 AND lockin_phase( ) > 90 @{
    do_something( );
@}
@end example
@noindent
is logically equivalent to
@example
IF A != 0 @{
    IF lockin_phase( ) > 90 @{
        do_something( );
    @}
@}
@end example


All comparison operators may also be used with strings. The test
for equality has its usual meaning (but take care, in the comparison
lower and upper case characters are treated as different). The
comparison for larger or smaller than is based on the ASCII values of the
characters of the string, not the lengths of the strings. For example,
the comparison of the strings @code{"ON"} and @code{"OFF"} will result
in @code{"ON"} being larger than @code{"OFF"} because for the first
characters where the strings differ, @code{'N'} and @code{'F'},
@code{'N'} has a higher ASCII value than @code{'F'}.


@anchor{UNTIL loops}
@subsection UNTIL loops
@cindex UNTIL loops

Directly related to the @code{WHILE} loop is the @code{UNTIL} loop. The
only difference is that, instead of repeating the loop until the
condition becomes false, the @code{UNTIL} loop is repeated until the
loop condition becomes true. Thus, the second example for calculating
the factorial of 6 also could have been written as
@example
  I = 6;
  Fact = 1;

  UNTIL I== 0 @{
      Fact *= I;
      I -= 1;
  @}
@end example



@anchor{FOR loops}
@subsection FOR loops
@cindex FOR loops

Before the start of a @code{WHILE} loop one usually has to initialize a
loop variable and within the statement block one has to update it. In
many cases (for example in both the examples for the @code{WHILE} loop
above) it's much simpler to use a @code{FOR} loop instead, because
setting the loop variable as well as updating it is automatically done
in its condition part. Here's an example that does exactly the same as
the first of the two examples for @code{WHILE} loops:
@cindex FOR
@example
  Fact = 1;
  FOR I = 1 : 6 @{
      Fact *= I;
  @}
@end example

At the very start of the @code{FOR} loop the loop variable `@code{I}' is
set to 1 and the loop block is run using this value. When it is done,
`@code{I}' is automatically incremented by 1 and tested if it is still
less or equal to 6. If this is @code{TRUE} the loop is repeated with the
new value of `@code{I}'. Take care: You can change `@code{I}' also
within the loop, but you only should do this if you really mean it and
know what you're doing!

But you can also reproduce the second version of the factorial
calculation using a @code{FOR} loop. Here it is:
@example
  Fact = 1;
  FOR I = 6 : 1 : -1 @{
      Fact *= I;
  @}
@end example

Now `@code{I}' starts of with the value 6 and the third value in the
@code{FOR} loop condition part is the value to be used for incrementing
`@code{I}'. In this case it is -1, so `@code{I}' actually will be
decremented until it is smaller than 1 (the second value in the
@code{FOR} loop condition). As you see, @code{FOR} loop variables can
not only be incremented by 1 but by any value (integer or floating point
ones). And, of course, the loop variable don't have to be an integer
variable!

Please note that after the end of a @code{FOR} loop the loop variable
does not has the value it had in the last run through the loop but that
it has been incremented (or decremented) one more time. I.e.@: after the
end of the loop
@example
  FOR I = 1 : 9 : 2 @{
      do_something( );
  @}
@end example
@noindent
the loop variable @code{I} has the value @code{11} and not @code{9}.


@anchor{FOREVER loops}
@subsection FOREVER loops
@cindex FOREVER loops

There are situations where one wants to have the program running as long
as the @code{STOP} button doesn't get pressed. While something like this
can be realized by using i.e.@: a @code{REPEAT} loop with a huge number
of repeats, this would take extremely long when testing the script before
the @code{EXPERIMENT} is started. In these cases a @code{FOREVER} loop is
more convenient because the content of the loop is only tested once, so
the experiment can start much faster. For obvious reasons, a
@code{FOREVER} loop doesn't have a loop condition and the loop block
starts directly after the @code{FOREVER} keyword.

@quotation
@cartouche
There is a disadvantage of using a @code{FOREVER} loop: because
@code{fsc2} can't determine in advance when the @code{FOREVER} loop is
going to be terminated it is not possible to test the loop thoroughly in
the test run, i.e.@ before the experiment is started. Instead, in the
test run a @code{FOREVER} loop is just run once to do a plausibility
check, but further tests are not feasible. Thus, it can not be
guaranteed that the experiment will run without errors.  Therefore the
use of @code{FOREVER} loops should be restricted to preliminary
experiments, e.g.@: when trying to figure out the optimum parameters for
an experiment, unless you're quite sure you know what you are doing.
@end cartouche
@end quotation


@anchor{NEXT statement}
@subsection NEXT statement
@cindex NEXT

Sometimes under certain conditions one doesn't want to execute all
remaining statements of a @code{WHILE}, @code{UNTIL}, @code{REPEAT} or
@code{FOR} loop but to go back to the test of the loop condition
immediately. Whenever the keyword @code{NEXT} is encountered in a loop
all the remaining statements are skipped and the program jumps directly
back to the test of the loop condition.


@anchor{BREAK statement}
@subsection BREAK statement
@cindex BREAK

There also may be situations where one doesn't want to continue with a
loop until the loop condition becomes satisfied but where one has to
exit the loop immediately. For this purpose the keyword @code{BREAK} is
to be used. If it is found as the next statement to be executed in a
loop the program immediately jumps to the first statement following the
loops block.


@anchor{IF-ELSE constructs}
@subsection IF-ELSE constructs
@cindex IF
@cindex ELSE 
@cindex IF-ELSE


Finally, there is the @code{IF-ELSE} construct, functioning as in most
other programming languages. In the simplest case you just have the
@code{IF} part to execute some instructions only under certain
conditions. In this case you start with the @code{IF} keyword, followed
by the condition that has to be met in order to run the following code
and then the statements enclosed in curly braces. Here's an simple
example:
@example
  IF x < 0 @{
      x *= -1.0;
@}
@end example
@noindent
Here the variable @code{x} is multiplied by @code{-1} only if @code{x}
is negative, i.e.@: it basically just sets @code{x} to its absolute
value (there's also the built-in function @code{abs()} for calculating
the absolute value of variable which is probably a lot faster).

By using the @code{ELSE} statement you can specify an alternative with
statements to be executed if the @code{IF} condition is not being met.
Also the block of alternative statements must be enclosed in curly
braces:
@example
  IF x >= 0 @{
      x = 1.0;
  @} ELSE @{
      x = 0.0;
  @}
@end example
@noindent

But things can also get more complex -- you may follow the @code{ELSE}
directly by another @code{IF}. Let's assume that you need to set
@code{x} to 1 if it's larger than 1, to 0 if it belongs to the interval
@w{[ 0, 1 ]} and to -1 if it's smaller than 0. Then you could use:
@example
  IF x > 1.0 @{
      x = 1.0;                 // x is larger than 1
  @} ELSE IF x >= 0.0 @{
      x = 0.0;                 // x must be element of [ 0, 1 ]
  @} ELSE @{
      x = -1.0;                // otherwise x is less than 0
  @}
@end example
@noindent


@anchor{UNLESS-ELSE constructs}
@subsection UNLESS-ELSE constructs
@cindex UNLESS
@cindex ELSE 
@cindex UNLESS-ELSE

@code{UNLESS} is identical to @code{IF} with the only exception that the
condition is not tested for truth but for falsehood, i.e.@: while in an
@code{IF} construct the following block of statements is executed when
the condition is true, in @code{UNLESS} constructs the block is only
executed when the condition test fails. Of course, also with the
@code{UNLESS} an alternative can be specified with an @code{ELSE} block.


@quotation
@cartouche
As already mentioned for @code{FOREVER} loops also @code{IF-ELSE} and
@code{UNLESS-ELSE} constructs introduce some problems for testing an
@code{EDL} script before the real experiment is done. This happens
when the condition to be tested depends either on user input (e.g.@:
tests if the user pressed a button etc.) or on the results of a
measurement itself. In these cases the flow of control of the program
can not be known in advance and thus a thorough test is impossible. Thus
it can happen that the test run of the experiment succeeds but the
actual experiment stops with an error that could not be anticipated.
@end cartouche
@end quotation

@node Miscellaneous, , Control structures, EDL
@section Miscellaneous
@cindex Miscellaneous
@cindex Miscellaneous

The remaining of this chapter covers a few additional syntactic elements
that didn't fit into any of the previous sections.

@anchor{#INCLUDE statement}
@subsection @code{#INCLUDE} statement
@cindex #INCLUDE statement

Everywhere within an @code{EDL} script one can include another
@code{EDL} file. This is done using the @code{#INCLUDE} keyword,
followed by the name of the file to be included, and has the same effect
as if the included file had been pasted into the current @code{EDL}
script, replacing the @code{#Include} statement. Included files
themselves may contain further @code{#INCLUDE} statements, up to 16
levels deep.

The name of the file to be included must follow the @code{#INCLUDE}
directly (i.e.@: on the same line and only with spaces and tab
characters in between). It must be included either in double quotes
(i.e.@: it must have the form @code{"..."}) or in angle braces
'@code{<}' and '@code{>}' (i.e.@: be of the form @code{<...>}).

When the file name is enclosed in double quotes @code{fsc2} tries to
figure out the location where it is stored by the following algorithm:
@itemize
@item If the name starts with a slash, '@code{/}', it is assumed that the
      file is given with a complete, absolute path.
@item If the file name starts with a tilde followed directly by a slash,
      i.e.@: with "@code{~/}", the tilde is replaced by the name of
      the users home directory.
@item If the file name starts with any other character its path is taken
      to be relative to the path of the file it is included from.
@end itemize

If the file name is enclosed in @code{<} and @code{>} a default include
directory compiled into @code{fsc2} will prepended to the file name,
whatever the name of the file is. If no default directory has been
compiled into @code{fsc2} an error message is printed and interpretation
of the script stops.

If the included file can't be opened an error message is printed and
interpretation of the @code{EDL} script is abandoned.


@anchor{#EXIT statement}
@subsection @code{#EXIT} statement
@cindex #EXIT statement

When the @code{#EXIT} statement is found in an @code{EDL} script this is
equivalent to the end of the file - everything following the statement
is discarded. In the main file of an @code{EDL} script this signifies
the end of the @code{EDL} script. If the file containing the
@code{#EXIT} statement is an included file (see the @code{#INCLUDE}
statement above) @code{fsc2} will immediately return to reading the file
the file was included from.


@anchor{#QUIT statement}
@subsection @code{#QUIT} statement
@cindex #QUIT statement

When the @code{#QUIT} statement is encountered in an @code{EDL} script
@code{fsc2} treats this as the complete end of the @code{EDL} script and
won't read any further lines. In the main file of an @code{EDL} this is
equivalent to the @code{#EXIT} statement. But within an included
@code{EDL} file @code{#EXIT} will induce @code{fsc2} to return to the
including file while @code{#QUIT} makes @code{fsc2} stop completely,
i.e.@: it will not even return to higher level @code{EDL} files.
