@c $Id$

@node EDL, Built-in Functions, Overview, Top
@chapter @acronym{EDL}
@cindex @acronym{EDL}

@ifinfo
@menu
* Basics::                  Basic principles.
* Sections::                The sections of an EDL program.
* Syntax::                  Basic syntax of EDL programs.
* Variables::               Using variables and arrays.
* Arithmetic::              Doing calculations with variables.
* Control structures::      Flow control in EDL programs.
* Miscellaneous::           Additional syntactic elements
@end menu
@end ifinfo


@node Basics, Sections, EDL, EDL
@section Basics


To do an experiment using @acronym{fsc2} you have to write a program
describing how the experiment is to be done. While this may seem to be a
daunting task if you have no programming experience at all this has the
advantage that you have complete control over the way the experiment is
done. So you don't have to rely on some programmer (who probably isn't
around when you need him most) to have got everything right. And writing
@acronym{EDL} programs really isn't that difficult.


An @acronym{EDL} program is roughly structured along the way an
experiment is done. Before you start an experiment you first have to
select the devices to be used and set them up. So also the first part of
an @acronym{EDL} program mainly consists of specifying the devices to be
controlled by the program and setting their parameter, i.e.@: the time
base of the digitizer or which pulses are to be created by the pulse
generator.  And as you would now start the experiment the second part of
the @acronym{EDL} program describes how the experiment is to be done.

To give you an impression here's an example for a relatively simple cw-EPR
experiment:
@example
DEVICES:

er035m_s;              // gaussmeter module
aeg_x_band;            // magnet module
sr530;                 // lock-in amplifier module

VARIABLES:

start_field = 3360.0 G;
end_field   = 3450.0 G;
field_step  =    0.5 G;

field = start_field;
I = 1;
data;

PREPARATIONS:

magnet_setup( start_field, field_step );
lockin_sensitivity( 5 uV );
lockin_time_constant( 300 ms );
init_1d( );

EXPERIMENT:

WHILE field <= end_field
@{
    data = lockin_get_data( );
    display( I, data );
    save( data );
    I = I + 1;
    field = sweep_up( );
    wait( 300 ms );
@}
@end example

Obviously, the very first section of the program, starting with the
keyword @code{DEVICES:}, is for specifying the names of the devices to
be used (everything after the double-slashes are comments). In the
example these are the Bruker ER035M gaussmeter, the AEG X-band magnet
and the Stanford Research lock-in amplifier SR530.

In the following section, started by the keyword @code{VARIABLES:}, all
variables that are going to be used in the program are listed and, if
appropriate, initialized. The first variables are for storing the start
and end field of the field sweep as well as the step width between the
data points. The variable @code{field} will later be used for storing the
current field value and is initialized to the value of the start field.
Finally, a counter variable @code{I}, initialized to 1, and another
variable, @code{data}, for storing the data received from the lock-in
amplifier, are declared.

In the next section, headed by the @code{PREPARATIONS:} keyword, the
devices are set. In the function @code{magnet_setup} the magnet is setup
to start with the field stored in the variable @w{@code{start_field}}
and to use a step size of @w{@code{field_step}}. Next, the lock-in
amplifier is set to a sensitivity of @w{5 uV} and a time constant of
@w{300 ms}. The last function call in the section, @code{init_1d()},
tells the program that this is a 1-dimensional experiment and to use the
appropriate kind of display for the data.

Now we're already done with the preparations and can start the
experiment, as indicated by the keyword @code{EXPERIMENT}. The whole
experiment is done in a loop that is repeated as long as the value
currently stored in the variable @code{field} is less or equal to
@code{end_field}. To tell the program where the loop starts and ends all
statements belonging to the loop are enclosed in curly braces,
`@code{@{}' and `@code{@}}'.

The first thing to do in the experiment loop is to fetch a new data
point from the lock-in amplifier and to store it in the variable
@code{data}.  Next we have to display the data point, which is done via
the call of the @code{display} function. Here two arguments are used,
the number of the point, stored in the variable @code{I}, and the value
of the corresponding data point.

Of course, we also need to save the data point in a file. This is done
by the call of the function @code{save} that automatically writes its
argument to a file. When the function is called the first time it will
prompt you for the name of the file to use.

What remains to be done is to increment the counter variable @code{I}
and to sweep up the field. The function @code{sweep_up} returns the new
value of the field, which is then used in the test of the loop condition
to decide if the experiment is finished, i.e.@: the end field is
reached.

The last function call of @code{wait} makes the program wait for @w{300
ms} (the lock-in amplifiers time constant) to give the lock-in amplifier
time to measure a new data point.


When you have written such a program (e.g.@: using a simple ASCII
editor) you load it into @acronym{fsc2} and press the test or the start
button. @acronym{fsc2} will now analyze the program very thoroughly. It
will not only check for misspelt keywords, undefined variables, syntax
errors etc.@: but will also repeat the loop in the experiment section as
often as in the real experiment to find out if no errors will happen in
the experiment. This includes for example checking that the field will
not be sweeped into regions the magnet or the gaussmeter can not handle
etc.@: (e.g.@: by incidentally setting an end field value of @w{34500.0
G} the magnet can't produce). So you can be reasonable sure that the
experiment will not crash due to a faulty program after it has run for 2
hours and you have to start all over again.


As you can already see form the example most of a @acronym{EDL} program
consists of function calls. Functions can be devided into two
categories, built-in functions and device functions. Built-in functions
(like @code{init_1d}, @code{display}, @code{save} and @code{wait}) are
always available, even when there is no @code{DEVICES} section. In
contrast, device functions are bound to certain devices and are only
usable when the device they belong to is listed in the @code{DEVICE}
section. For example, the functions @w{@code{lockin_sensitivity}},
@w{@code{lockin_time_constant}} and @w{@code{lockin_get_data}} are
obviously targeted at the lock-in amplifier and are only available when
a lock-in is specified. Fortunately, these functions usually will be
available for all types of lock-in amplifiers (possibly with minor
variations) so that using a different lock-in does not require a major
rewrite of the @acronym{EDL} program except changing its name in the
@code{DEVICES} section.

To find out about all built-in and device functions, their arguments,
the sections of and etc.@: have a look at the appropriate parts of this
manual.


@node Sections, Syntax, Basics, EDL
@section Sections
@cindex section


As you already have seen in the example above, an @acronym{EDL} program
consists of several section. There are up to 6 different sections. These
are:
@example
DEVICES
VARIABLES
ASSIGNMENTS
PHASES
PREPARATIONS
EXPERIMENT
@end example


The first and last two you have already seen: The @code{DEVICES} section
is simply a list of all the devices that will be used in the experiment
(or at least the ones that are going to be controlled by the computer).

Please note that the section keyword has always to be followed by a
colon, `@code{:}'. Another important syntax element is the semicolon,
`@code{;}', that always ends a line of code. So, you also have to write
a semicolon after each of the device names.

The @code{VARIABLES} section for declaring and initializing variables
did also appear already in the example.

Because pulses play such an important r@^ole in modern EPR experiments
lots of elements for handling pulses and the pulser that creates them is
built-in into @acronym{fsc2}. This is also reflected in two of the
sections, @code{ASSIGNMENTS} and @code{PHASES} being exclusively devoted
to the pulser setup. The basic setup of the pulser (e.g.@: setting the
time base and trigger mode as well as setting up the pulser channels) is
done in the @code{ASSIGNMENTS} section while the @code{PHASES} section
is all about phase-cycling -- here you will have to define the phase
sequences to be used in the experiment as well as the way the resulting
echos will be added up. Because this is a rather extensive subject (and
because of the different ways the pulser is integrated into the
supported spectrometers, an in-depth explanation of both these sections
is part of a whole chapter.

As you already have seen the @code{PREPARATIONS} section is for setting
up the other devices and the graphics. But this is also the section
where the pulses are going to be defined. For more details about this
see the chapter about pulse generators and pulses.


Finally, there is the @code{EXPERIMENT} section. As you already have
seen this section usually consists of one or more loops (possibly with
more loops nested into the main loops).


While the sections of the @acronym{EDL} file don't have to appear in the
sequence they are listed above it is probably best not to experiment to
much with this. In any case, if it exists the @code{EXPERIMENT} section
must always be the last.

All the section keywords can be abbreviated, here's the complete list of
valid section keywords:

@itemize @bullet
@item @code{DEVICES}, @code{DEV}, @code{DEVS}, @code{DEVICE}
@item @code{ASSIGNMENTS}, @code{ASS}, @code{ASSIGNMENT}
@item @code{VARIABLES}, @code{VAR}, @code{VARS}, @code{VARIABLE}
@item @code{PHASES}, @code{PHA}, @code{PHAS}, @code{PHASE}
@item @code{PREPARATIONS}, @code{PREP}, @code{PREPS}, @code{PREPARATION}
@item @code{EXPERIMENT}, @code{EXP}
@end itemize


@node Syntax, Variables, Sections, EDL
@section Syntax

There are a few basic rules about the syntax of @acronym{EDL} programs.
Each program consists of one or more sections that always start with one
of the section keywords listed in the previous section. Each keyword has
to be followed immediately (i.e.@: without any spaces, tabulator or
newline characters in between) by a colon, `@code{:}'.

Each section of the program consists of statements. What a valid
statement is may depend on the section (e.g.@: in the @code{DEVICES}
section all valid statements are just the names of devices while in
other sections a valid statement may be a complicated equation), but in
all cases a statement must always be ended with a semicolon, `@code{;}'.
There is nothing special about continuing a statement on a new line
(i.e.@: a statement can span several lines), @acronym{fsc2} recognizes
where a statement ends by the semicolon.

Within a statement all characters like spaces, tabulator characters and
newlines have no relevance at all (except separating variable names). So
there's no difference at all between the three following statements:
@example
start_field=3360.0 G;
start_field       =               3360.0G;
                  start_field=
        3360.0 G;
@end example

@acronym{EDL} programs use lots of function calls. There are no obvious
differences between variable names and function names (all start with a
character, followed by more characters, numbers or underscore
characters). To make clear that a word is a function it has to
be followed by a pair of parenthesis, `@code{(}' and `@code{)}', even if
the function doesn't accept arguments (spaces, tabulator or newline
characters are allowed between the function name and the opening
parenthesis). If the function does accept more than one argument the
arguments have to be separated by commas.



@node Variables, Arithmetic, Syntax, EDL
@section Variables
@cindex variables
@cindex @code{VARIABLES} section
@cindex @code{VAR} section
@cindex @code{VARS} section
@cindex @code{VARIABLE} section
@cindex arrays


Within the @code{VARIABLES}, @code{ASSIGNMENTS}, @code{PREPARATIONS} and
@code{EXPERIMENT} section variables may be used. Each variable to be
used has to be declared, i.e.@: it has to be listed in the
@code{VARIABLES} section before it may be used. The start of the
@code{VARIABLES} section is declared by a line stating
@example
VARIABLES:
@end example



@subsection Variable names

Names of variables must always start with a character, i.e.@: A-Z and
a-z. The remaining part of the variable name can consist of characters,
numbers and the underscore character, '@code{_}' (or shorter, if you
like regular expressions, valid names follow the following pattern:
@code{[A-Za-z][A-Za-z_0-9]*}). Thus, '@code{AbC_12x}' and
'@code{aBc_12X}' are legal variable names, while '@code{12xy}' or
'@code{_Yx2}' aren't. Please take note that the variable names are case
sensitive, i.e.@: '@code{XY}', '@code{Xy}', '@code{xY}' and '@code{xy}'
are four different variable names!

The name of a variable can, in principle, consist of as many characters
as you wish (I hope nobody is going to the extent to create a variable
name with, say, a few hundred thousand characters just to prove me wrong
-- I tested it only with two variables with names 10000 characters long,
differing only in the very last character @code{;-)}

There are a few exceptions to the valid variable names because a few
characters or character combinations are already used for physical units
as well as combinations of these with the characters @code{n} (nano),
@code{u} (micro), @code{m} (milli), @code{k} (kilo) and @code{M} (mega).
Here's the complete list:
@quotation
@multitable {Hz} {Hertz (and @code{nHz, uHz, mHz, kHz} and @code{MHz})}
@item @code{s}  @tab Seconds (and @code{ns, us, ms, ks} and @code{Ms})
@item @code{G}  @tab Gauss (and @code{nG, uG, mG, kG} and @code{MG})
@item @code{T}  @tab Tesla (and @code{nT, uT, mT, kT} and @code{MT})
@item @code{V}  @tab Volt (and @code{nV, uV, mV, kV} and @code{MV})
@item @code{A}  @tab Ampere (and @code{nA, uA, mA, kA} and @code{MA})
@item @code{Hz} @tab Hertz (and @code{nHz, uHz, mHz, kHz} and @code{MHz})
@item @code{dB} @tab Decibel (and @code{ndB, udB, mdB, kdB} and @code{MdB})
@end multitable
@end quotation

Of course, also the reserved words can't be used as variable names. But
they are easy to avoid, because all reserved words are spelt in all capital
letters only.


@subsection Variable types


Variables can be divided into two classes, variables to hold integer
values and variables for storing floating point values.

Integer variables (on machines with 32-bit processors) can hold data in
the interval @w{[-2^31, 2^31 - 1]}, i.e.@: they run from @w{-2147483648}
all the way up to @w{+2147483647}. In contrast, floating point variables
can have much larger values (up to ca.@: 10^300), the exact limits
depending on the machine @acronym{fsc2} is running on.

To distinguish between integer and floating point variables the
following convention is used: The names of all integer variables start
with a upper case letter, i.e.@: A-Z, while the names of floating point
variables start with a lower case character, i.e.@: a-z.


@subsection Arrays


Beside `normal' variables you can also use arrays of variables. The
types of the arrays follow the same convention as with normal variables,
i.e.@: if the name starts with an upper case character it is an integer
array, if it starts with a lower case character it is a floating point
array. To define an array append the sizes of the dimensions of the
array, separated by commas, in square brackets. E.g.
@example
A[ 100 ];
b[ 4, 7, 3 ];
@end example
@noindent
defines a 1-dimensional integer array @code{A} with 100 elements and a
floating point array @code{b} of rank 4x7x3.


Arrays are automatically initialized to zero for all elements. On the
other hand, arrays can be initialized also within the @acronym{EDL} file
by equating it to a list of values, enclosed in curly braces.
@example
C[ 3 ] = @{ 2, 1, -1 @};
d[ 5 ] = @{ sqrt( 2.0 ), sqrt( 3.0 ) @};
E[ 2, 3 ] = @{ 1, 2, 3, 4, 5, 6 @};
@end example
@noindent
The first line in the example shows the standard way -- each element of
@code{C} is initialized by an element from the list. In the second line
there are less initializers then elements array @code{d}, and only the
first two elements are set, i.e.@: @code{d[ 1 ]} and @code{d[ 2 ]},
while the remaining elements are set to zero. The third examples shows
the initialization of a multidimensional array, the elements of the
array @code{E} being set starting with the first row and continuing to
with the next rows until all initializers are used up. I.e.@: the array
@code{E} will be initialized to
@example
E[ 1, 1 ] = 1     E[ 1, 2 ] = 2     E[ 1, 3 ] = 3
E[ 2, 1 ] = 4     E[ 2, 2 ] = 5     E[ 2, 3 ] = 6
@end example


There are some situations where on can't know the size of an array
already in the @code{VARIABLES} section. Therefor, one may also define
arrays with the size of the last dimension remaining undefined by
specifying a @code{*} instead of a number.
@example
G[ * ];
h[ 2, * ];
@end example
@noindent
This defines an 1-dimensional integer array @code{G} with a still
undefined number of elements and a floating point matrix @code{h} with
two rows of undefined length. The sizes of these arrays remain undefined
until 1-dimensional arrays are assigned to them. The following
assignment will set the length of @code{G} to 3
@example
G = E[ 2 ];
@end example
@noindent
because the length of a row of @code{E} is three. The assignment will
copy the elements of the second row of @code{E} to @code{G}. After this
assignment the size of @code{G} is fixed and can't be changed anymore.

In the same way the assignment
@example
h[ 2 ] = d;
@end example
@noindent
will set the rank of @code{h} to 2x5 (because the length of @code{d} is 5).

Of course, these are somewhat contrived examples, in a real experiments
arrays with undefined sizes are usually used for storing data received
from functions that return arrays of a size that would be difficult to
determine before the experiment is actually started, e.g.@: curves
fetched from a digitizing oscilloscope.

@node Arithmetic, Control structures, Variables, EDL
@section Arithmetic
@cindex Arithmetic

There are the usual arithmetic operations built into @acronym{fsc2},
i.e.@: addition, subtraction, multiplication and division, not too
surprisingly represented by the characters `@code{+}', `@code{-}',
`@code{*}' and `@code{/}'.
@cindex + (addition operator)
@cindex - (subtraction operator)
@cindex * (multiplication operator)
@cindex / (division operator)
They can be applied to simple integer and floating point values (see
below how they may be used with 1-dimensional arrays). If one of the
values is a floating point value the result is also a floating point
number - only if both values are integer the result also has integer
type.

Some care has to be taken in arithmetic with integers.
@cindex integer overflow
@cindex integer underflow
@cindex overflow, integers
@cindex underflow, integers
@cindex range of integers
@cindex integers, range of
The range of values an integer variable can have is restricted to the
interval @w{[-2147483648, +2147483647]}, i.e.@: @w{[-2^31, 2^31 - 1]}
(at least on a 32-bit processor). Thus, it isn't to difficult to create
numbers with greater values, e.g.@: by multiplication, that can't be
represented by an integer! In this case the result of the operation will
be completely bogus, e.g.@:

@example
1000000 * 3000 = -1294967296
@end example
@noindent
(There is actually some logic behind this result but that doesn't help
much.)  So, if you suspect the result of an integer operation to exceed
the range of representable values, convert the values to floating point
type (see the function @code{float()} below) before you do the
potentially problematic arithmetic operation.

Of course, there are also limits to the range of numbers representable by a
floating point number. Fortunately, these limits are much larger - typically
the size of the maximum numbers is in the range of 10^300.
@cindex floating point numbers, range of
@cindex range of floating point numbers
@cindex floating point overflow
@cindex floating point underflow
@cindex overflow, floating point numbers
@cindex underflow, floating point numbers

Another important point about calculations involving integers concerns the
division. The result of the division of two integer values is again an integer
value. For non-integer results this is achieved by simply truncating the
digits following the decimal point. Thus, typical results are

@example
7 / 2 = 3     8 / 3 = 2     -7 / 2 = -3
@end example
@cindex / (division operator)
@cindex integer division
@noindent
To avoid this truncation convert (see the function @code{float()} below)
at least one of the values used in the division to floating point type,
i.e.@:

@example
float( 7 ) / 2 = 3.5    8 / float( 3 ) = 2.666666667
@end example


Beside the normal arithmetic operations there are two more operations,
the modulo function and the exponentiation. For the modulo operation the
percent sign @code{%}
@findex % (modulo operator)
@cindex modulo operator
is used and the result is the remainder of the division, e.g.@:

@example
7 % 3 = 2         6.5 % 2.5 = 1.5 
@end example


For the exponentiation the caret character @code{^} is to be used, e.g.@:
@findex ^ @r{(exponentiation)}
@cindex exponentiation

@example
3^2 = 9           6.5^1.5 = 16.5718134219...
@end example
@noindent
As usual, non-integer exponents can only be used with non-negative bases!


@subsection Assignment operators
@cindex assignment operators
@cindex @code{=} (assignment)
@cindex @code{+=} (add and assign)
@cindex @code{-=} (subtract and assign)
@cindex @code{*=} (multiply and assign)
@cindex @code{/=} (divide and assign)
@cindex @code{%=} (modulo and assign)
@cindex @code{^=} (exponentiation and assign)

When assigning to a variable usually the assignment operator `@code{=}'
is used. But there are many cases where just a number is added to a
variable and one would have to write
@example
I = I + 1;
@end example
This assignment can be shortened (and sometimes made more readable) by
using the `add and assign' operator `@code{+=}':
@example
I += 1;
@end example
Assignment operators mixed with arithmetic can also be used with all
other arithmetic operators, i.e.@: you may use all of the following
assignment operators
@example
+=     -=     *=     /=     %=     ^=
@end example


@subsection Operator precedence
@cindex operator precedence


Usually one doesn't think about the precedence of operators. We already
learned in primary school that multiplication and division have higher
precedence than addition or subtraction. Of course, a programming
language should follow this rules. But sometimes there are cases where
it is necessary to know exactly the precedence, i.e.@: the exact
sequence an expression is evaluated.

The unary `@code{+}' and `@code{-}' operators have the highest
precedence, i.e.@: the operators defining the sign of a number. There is
a further operator, to be discussed later, having the same precedence,
the logical negation operator, `@code{!}'. The evaluation of an
expression with more than one of these operators is from the right to
the left, i.e.@:
@example
 !-x    @r{will be treated as if written as}    ! ( - x )
@end example
@noindent
(This is not a very useful example but here for sake of completeness.)

The exponentiation operator, `@code{^}', has the next highest
precedence, i.e.@: it binds more tightly than any other binary
operator. If there is more than one of these operators in a row the
expression will be evaluated from the right to the left:
@example
 2^3^4    @r{will be treated as if written as}    2^(3^4)
@end example

The operator with the next lower precedence is the modulo operator,
`@code{%}'. Expressions with more than one `@code{%}' in a row will be
evaluated left to right, i.e.@:
@example
 31 % 6 % 2    @r{will be treated as if written as}    ( 31 % 6 ) % 2
@end example


Now the multiplication and division operators, `@code{*}' and `@code{/},
follow. Both have exactly the same precedence and expressions involving
more than one of these operators are evaluated left to right, i.e.@:
@example
 3 * 22 / 7    @r{will be treated as if written as}    ( 3 * 22 ) / 7
@end example
@noindent
(Take care: This can make a lot of a difference when e.g.@: integer
multiplication is involved.)

The next lower precedence operators are the addition and subtraction
operators, `@code{+}' and `@code{-}'. Also for these operators
expressions are evaluated left to right:
@example
 13 + 4 - 5    @r{will be treated as if written as}    ( 13 + 4 ) - 5
@end example
@noindent
Usually, this won't matter a lot, but if you're dealing with very large
numbers and there's danger of an overflow to occur knowing the rules of
evaluation can become important.

The next lower precedence operators are the logical operators to be
discussed in more detail below, i.e.@: the logical @i{and} operator,
`@code{&}, the logical @i{or} operator, `@code{|}' and the logical
@i{exclusive or} (xor) operator, `@code{~}'. Expressions containing more
than one of these operators are always evaluated from the left to the
right of the expression:
@example
 a | b & c    @r{will be treated as if written as}    ( a | b ) & c
@end example
But to make your intentions more clear to human readers of your
@acronym{EDL} programs it's probably a good idea to use the
parenthesis even when they are not required.

Finally, the lowest precedence operators are the comparison operators
(also the be discussed below in more detail), i.e.@: the test for equality,
`@code{==}' (not to be confused with the assignment operator
`@code{=}'), the test for inequality, `@code{!=}', and the remaining
four comparison operators `@code{<}', `@code{<=}', `@code{>}' and
`@code{>=}', i.e.@: @i{less than}, @i{less or equal}, @i{larger} and
@i{larger or equal}. If more than one of these operators appears in an
expression evaluation is done left to right.

Actually, there are also the assignment operators. But these are only
used after all of the other operators have been evaluated, so there is
never a necessity to enclose the right hand of an equation in
parenthesis. And since only one assignment operator is allowed in a
statement you don't have to worry about the order of evaluation.

Of course, the precedence of operators and the sequence they are
evaluated in can always be changed by using parenthesis. So, if in doubt,
use parenthesis -- this won't slow down the program significantly.


@subsection Arithmetic with arrays
@cindex Arithmetic with arrays


Beside the usual arithmetic with numbers it is also possible to use
arithmetic with (one-dimensional) arrays. Also all built-in functions
can (as far as this makes any sense) can be applied to these kinds of
arrays.

As long as the sizes of two arrays are identical they can be added or
subtracted. If the arrays @code{a} and @code{b} are defined as
@example
      a[ 3 ] = @{ 0.5, 1.0, 2.0 @};
      b[ 3 ] = @{ 1.0, -2.0, -3.0 @};
@end example
@noindent
they can be added and subtracted in a element-by-element fashion,
resulting in
@example
      a + b      ->   @{ 1.5, -1.0, -1.0 @}
      a - b      ->   @{ -0.5, 3.0, 5.0 @}
@end example
@noindent
Of course, you can also invert the sign of all the elements of an array
by simply prepending a minus sign
@example
      - a        ->   @{ -0.5, -1.0, -2.0 @};
@end example

But it's also possible to add or subtract a number from each element of
an array:
@example
      a + 5      ->   @{ 5.5, 6.0, 7.0 @}
      a - 3      ->   @{ -2.5, -2.0, -1.0 @}
@end example

Also multiplication and division is possible with arrays. Again, this
operations are implemented in a element-by-element way, i.e.@:
multiplying to arrays is not a dot product but results again in an
array. The same holds for the division. With the arrays @code{a} and
@code{b} defined above the results are:
@example
      a * b      ->   @{ 0.5, -2.0, -6.0 @}
      a / b      ->   @{ 0.5, -0.5, -0.666667 @}
      b / a      ->   @{ 2.0, -2.0, -1.5 @}
@end example

Again, also multiplication and division of an array with a number is
defined as shown here:
@example
      a * 2      ->   @{ 1.0, 2.0, 4.0 @}
      a / 3      ->   @{ 0.166667, 0.333333, 0.666667 @}
      3 / a      ->   @{ 6.0, 3.0, 1.5 @}
@end example

Finally, also calculation of the modulo and exponentiation can be done on
arrays. Also these operations are implemented as element-by-element
calculations, i.e.@: resulting in an array:
@example
      a % b      ->   @{ 0.5, 1.0, 2.0 @}
      b % a      ->   @{ 0.0, 0.0, -1.0 @}
      a ^ b      ->   @{ 0.5, 1.0, 0.125 @}
      b ^ a      ->   @{ 1.0, -2.0, 9.0 @}
@end example

Of course, the same operations can also be applied to a mixture of
arrays and simple numbers, also resulting in arrays:
@example
      a % 0.3    ->   @{ 0.2, 0.1, 0.2 @}
      1.3 % a    ->   @{ 0.3, 0.3, 0.7 @}
      a ^ 2      ->   @{ 0.25, 1.0, 4.0 @}
      2 ^ a      ->   @{ 1.414215, 2.0, 4.0 @}
@end example

All the built-in arithmetic functions can be applied to arrays. In every
case the function is applied to each element of the array, thus the
result is another array with its elements being the results of applying
the function to each of the input array elements. For example, again
using the array @code{a} defined above, applying the @code{sqrt()}
function results in:
@example
      sqrt( a )  ->   @{ 0.7071068, 1.0, 1.1414215 @}
@end example

Finally, for obvious reasons, when computed assignments are used
(i.e.@: `@code{+=}', `@code{-=}', `@code{*=}', `@code{/=}', `@code{%=}'
or `@code{^=}') the left hand side variable of an equation has to be an
array when arithmetic with arrays is used.



@node Control structures, Miscellaneous, Arithmetic, EDL
@section Control structures
@cindex Control structures
@cindex Flow control


Within the @code{EXPERIMENT} section flow control structures can be
used. These are @code{REPEAT}, @code{WHILE}, @code{UNTIL}, @code{FOR} and
@code{FOREVER} loops and @code{IF}-@code{ELSE} constructs. (Please note:
all of these keywords have to be spelt in capital letters!).


Most flow control construct keywords are followed by a condition and all
are then followed by a block of statements. Such a block of statements
has to be enclosed in curly braces and may contain as many statements as
needed (or still fit into the memory).


@subsection REPEAT loops
@anchor{REPEAT loops}
@cindex REPEAT loops

The most simple construct is the @code{REPEAT} loop. What is needed
following the keyword @code{REPEAT} is a number and a block with
commands. The number should be an integer number (or an expression
resulting in an integer).  The following block of statements will now be
repeated as many times as specified by the number (or
expression). Here's an example:


@example
    I = 0;
    SUM = 0;

    REPEAT 100 @{
        I = I + 1;
        SUM = SUM + I;
    @}
@end example

This snippet will calculate the sum of all integers between 1 and 100
(of course, there are more elegant ways to do this, but it's just an
example). After the initialization of the two variables `@code{I}' and
`@code{SUM}' the @code{REPEAT} loop starts with 100 as the number of
repetitions. Now, in curly braces, i.e.@: between `@code{@{}' and
`@code{@}}', follow the statements to be executed in the loop.


@subsection WHILE loops
@anchor{WHILE loops}
@cindex WHILE loops


Nearly as simple a construct is the @code{WHILE} loop: following the
keyword a condition is needed first. Usually, this will be a comparison
between two numbers, but also a simple number will suffice -- if its
value is non-zero it will be interpreted as TRUE. Of course, the keyword
and the condition have to be followed by a block of statements.

Again, an example:

@example
    I = 1;
    Fact = 1;

    WHILE I <= 6 @{
        Fact = Fact * I;
        I = I + 1;
    @}
@end example

This program snippet (that could also have been written using a
@code{REPEAT} loop) calculates the factorial of 6. After initializing
the variables `@code{I}' and `@code{Fact}' it is tested in the loop
condition if `@code{I}' is still not larger that 6. If this is true, the
following block of statements is executed.

Here is a complete list of the comparison operators between two
expressions (e.g.@: numbers):

@quotation
@cindex == (equal to)
@cindex equal to `=='
@cindex != (unequal to)
@cindex unequal to `!='
@cindex < (less than)
@cindex less than `<'
@cindex <= (less or equal)
@cindex less or equal `<='
@cindex > (larger than)
@cindex larger than `>'
@cindex >= (larger or equal)
@cindex larger or equal `>='
@multitable {@code{==}} {true if left hand side is @i{equal} to right hand side}
@item @code{==} @tab  true if left hand side is @i{equal} to right hand side
@item @code{!=} @tab  true if left and right hand side are @i{unequal}
@item @code{<}  @tab  true if left side is @i{less than} right side
@item @code{<=} @tab  true if left side is @i{less or equal} to right side
@item @code{>}  @tab  true if left side is @i{greater than} right side
@item @code{>=} @tab  true if left side is @i{greater or equal} to right side
@end multitable
@end quotation

And here is also an example for using simple numbers in a condition,
using the fact that a non-zero value is always interpreted as TRUE:

@example
    I = 6;
    Fact = 1;

    WHILE I  @{
        Fact = Fact * I;
        I = I - 1;
    @}
@end example

This example does exactly the same as the previous one, i.e.@: it
calculates the factorial of 6. But the difference is that we start with
`I' set to 6 and than decrement it successively. Thus we can use
`@code{I}' in the loops condition by simply checking if it still is
non-zero and thus the condition still TRUE and repeating the loop as
long as it is.

Sometimes, you may want to check not for the truth but for the falsehood
of an expression. In this case you have to prepend the expression with a
exclamation mark, `@code{!}', to reverse the meaning of a test.

If you want to check for combinations of expressions you can use the
logical @code{AND}, @code{OR} or @code{XOR} (exclusive or)
operators. Here is a list of these operators and their meaning:

@quotation
@cindex ! (negation operator)
@cindex negation operator `!'
@cindex & (logical and operator)
@cindex and operator `&'
@cindex logical and operator  `&'
@cindex | (logical or operator)
@cindex or operator `|'
@cindex logical or operator `|'
@cindex ~ (logical xor operator)
@cindex xor operator `~'
@cindex logical xor operator `~'
@multitable {~} {@i{exclusive or}: true if left or right hand side expressions are true but not both}
@item @code{!} @tab @i{not}: negates truth of an expression
@item @code{&} @tab @i{and}: true if both left and right hand side expressions are true
@item @code{|} @tab @i{or}: true if at least one of the left and right hand side expressions is true
@item @code{~} @tab @i{exclusive or}: true if either left or right hand side expression is true (but not both)
@end multitable
@end quotation


@subsection UNTIL loops
@anchor{UNTIL loops}
@cindex UNTIL loops

Directly related to the @code{WHILE} loop is the @code{UNTIL} loop. The
only difference is that, instead of repeating until the loop condition
becomes false, the @code{UNTIL} loop is repeated until the loop
condition becomes true.



@subsection FOR loops
@anchor{FOR loops}
@cindex FOR loops

Before the @code{WHILE} loop one often has to initialize the loop
variables and within the statement block the loop variable has to be
updated. In many cases (for example in both the examples fro the
@code{WHILE} loop) it is simpler to use a @code{FOR} loop instead,
because setting the loop variable as well as updating the loop is
automatically done in the condition part. Here's an example that does
exactly the same as the first of the two examples for @code{WHILE}
loops:
@cindex FOR

@example
    Fact = 1;
    FOR I = 1:6 @{
        Fact = Fact * I;
    @}
@end example

At the very start of the @code{FOR} loop the loop variable `@code{I}' is
set to 1 and the block is run using this value. When it is done,
`@code{I}' is automatically incremented by 1 and tested if it is still
not larger than 6. If this is TRUE the loop is repeated with the new
value of `@code{I}'. Take care: You can change `@code{I}' also within
the loop, but you only should do this if you really mean it and know
what you're doing!

But you can also reproduce the second version of the factorial
calculation using a @code{FOR} loop. Here it is:

@example
    Fact = 1;
    FOR I = 6:1:-1 @{
        Fact = Fact * I;
    @}
@end example

Now `@code{I}' starts of with the value 6 and the third value in the
@code{FOR} loop condition part is the value to be used for incrementing
`@code{I}'. In our case it is -1, so `@code{I}' actually will be
decremented until it is smaller than 1 (the second value in the
@code{FOR} loop condition). As you see, @code{FOR} loop variables can
not only be incremented by 1 but by any value (integer or floating point
ones). And, of course, the loop variable don't have to be an integer
variable!


@subsection FOREVER loops
@anchor{FOREVER loops}
@cindex FOREVER loops

There can be situations where one wants to have the program running as
long as the STOP button is hasn't been pressed. While something like
this can be realized by using i.e.@: a @code{REPEAT} loop with a huge
number of repeats, this could take extremely long to test the program
before the @code{EXPERIMENT} is started.  In these cases a
@code{FOREVER} loop is more convenient because the content of the loop
is only tested once so the experiment can start much faster. For obvious
resons, a @code{FOREVER} loop doesn't expect a loop condition but the
statements of loop immediately following the @code{FOREVER} keyword.

But there's also a disadvantage: Because the @code{EXPERIMENT} section
isn't thoroughly tested it can't be guaranteed that the experiment will
run without errors. Thus the use of @code{FOREVER} loops should be
restricted to test runs where one wants to figure out the optimum
parameter for an experiment.


@subsection NEXT statement
@anchor{NEXT statement}
@cindex NEXT

Under certain conditions one doesn't want to execute all statements of a
loop but to go back to the test of the loop condition
immediately. Whenever the keyword @code{NEXT} appears as the next
statement to be executed in a loop the remaining statements are skipped
and the program jumps back to the test of the loop condition (with the
loop counter in @code{REPEAT} and @code{FOR} loops being set to the next
value).


@subsection BREAK statement
@anchor{BREAK statement}
@cindex BREAK

There may be situations where one doesn't want to continue with a loop
until the loop condition becomes untrue but where one has to leave the
loop immediately. For this purpose the keyword @code{BREAK} can be used.
If it is found as the next statement in a loop to be executed the
program jumps to the first statement following the loop body.



@subsection IF-ELSE constructs
@anchor{IF-ELSE constructs}
@cindex IF
@cindex ELSE 
@cindex IF-ELSE


Finally there's the @code{IF-ELSE} construct. It works as in most other
programming languages. In the simplest case you just have the @code{IF}
part to execute some instructions only under certain conditions. In this
case you start with the @code{IF} keyword, followed by the condition
that has to be met in order to run the following code and, finally, the
statements enclosed in curly braces. Here's an simple example:
@example
IF x < 0 @{
    x *= -1.0;
@}
@end example
@noindent
This is a basically a function that calculates the absolute value of the
variable @code{x} (there's also the built-in function @code{abs()} for
doing this which is probably a lot faster).

By using the @code{ELSE} you can specify an alternative, with the
statements to be executed if the @code{IF} condition not being met again
enclosed in curly braces. One more example:
@example
IF x >= 0 @{
    x = 1.0;
@} ELSE @{
    x = 0.0;
@}
@end example
@noindent
This is basically the Heavyside function that is zero for all arguments
less than zero and one everywhere else.

But things can get even more complex -- you can follow the @code{ELSE}
directly by another @code{IF}. Let's assume that you need to set
@code{x} to 1 if it's larger than 1, to 0 if it belongs to the interval
@w{[ 0, 1 ]} and to -1 if it's smaller than 0. Then you could use:
@example
IF x > 1.0 @{
    x = 1.0;                 // x is larger than 1
@} ELSE IF x >= 0.0 @{
    x = 0.0;                 // x must be element of [ 0, 1 ]
@} ELSE @{
    x = -1.0;                // last exit: x is less than 0
@}
@end example
@noindent


@node Miscellaneous, , Control structures, EDL
@section Miscellaneous
@cindex Miscellaneous
@cindex Miscellaneous

The following covers a few additional syntactic elements that didn't fit
into any of the previous sections.

@subsection @code{#include} statement
@anchor{#include statement}
@cindex #include statement

Everywhere within an @acronym{EDL} program one can include another
@acronym{EDL} file. This is done using the @code{#include} keyword,
followed by the name of the file to be included, and has the same effect
as if the included file had been pasted into the current @acronym{EDL}
program. Included files may also contain @code{#include} statements, up
to 16 levels deep.


@subsection @code{#exit} statement
@anchor{#exit statement}
@cindex #exit statement

When the @code{#exit} statement is found in an @acronym{EDL} program
this is equivalent to end of the file - everything following the
statement is discarded. In the main file of an @acronym{EDL} program
means that this is the end of the @acronym{EDL} program. If instead the
current file is an included file (see the @code{#include} statement)
@acronym{fsc2} will immediately return to parsing the file from which
the current file was included.


@subsection @code{#quit} statement
@anchor{#quit statement}
@cindex #quit statement

When the @code{#quit} statement is encountered in a file @acronym{fsc2}
immediately treats this as the complete end of the @acronym{EDL} program
and won't parse any further lines. In the main file of an @acronym{EDL}
this is equivalent to the @code{#exit} statement. But while in an included
@acronym{EDL} file @code{#exit} will induce @acronym{fsc2} to return to
the including file, @code{#quit} makes @acronym{fsc2} stop completely,
i.e.@: it will not even return to higher level @acronym{EDL} files.
