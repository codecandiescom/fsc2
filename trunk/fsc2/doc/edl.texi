@c $Id$

@node @acronym{EDL}, Functions, Overview, Top
@chapter @acronym{EDL}
@cindex @acronym{EDL}

This chapter describes the @acronym{EDL} language (@b{E}xperiment
@b{D}escription @b{L}anguage).

@ifinfo
@menu
* Basics::                  Basic principles.
* Sections::                The sections of an EDL program.
* Devices::
* Variables::               Using variables and arrays.
* Arithmetic::              Doing calculations with variables.
* Arithmetic with arrays::  Calculations involving arrays.
* Control structures::      Flow control in an EDL program.
@end menu
@end ifinfo


@node Basics, Sections, EDL, EDL
@section Basics
@cindex basic @acronym{EDL} structure 



@acronym{EDL} is in many respects quite similar to other computer
languages like C, @acronym{FORTRAN} or @acronym{BASIC} etc. You can use
variables to do computations, you have flow control structures like
if-else-constructs and for- and while-loops and there is a set of
built-in functions. On the other hand, since the purpose of
@acronym{EDL} is to describe an @acronym{EPR} experiment, there are also
some differences. The most noticeable is the overall structure of an
@acronym{EDL} program.

Each @acronym{EDL} program is divided into a set of sections that are
somewhat related to the way an experiment is done. Due to the different
purposes of the sections there are differences in the syntax to be used
in the various sections. These are explained in the next sections.



@node Sections, Devices, Basics, EDL
@section Sections
@cindex section


Each @acronym{EDL} file consists of up to 6 different sections. These are:
@example
DEVICES
VARIABLES
ASSIGNMENTS
PHASES
PREPARATIONS
EXPERIMENT
@end example


In an experiment you will first decide which devices to use. This is
reflected in the @code{DEVICES} section of an @acronym{EDL} file where
you simply list all the devices to be used in the experiment (at least
the ones that are going to be controlled by the computer).

The next section, @code{VARIABLES}, unfortunately hasn't a real-world
equivalent -- here you have to declare all variables and arrays you will
use in the rest of the program and, optionally, initialize them.

Next, in a pulsed experiment, you will probably set up the pulser. This
is partly done in the @code{ASSIGNMENTS} section.

For a pulsed experiment you may also want to decide about the kind of
phase-cycling to use in the experiment -- this goes into the
@code{PHASES} section.

Now follows the @code{PREPARATIONS} section: here all the devices are
set up. For example, here you define all pulses, i.e.@: their positions
and lengths as well as the way they should be changed in the
experiment. Or you tell the program the start value of the magnetic
field and the amount the field has to be increased (or decreased)
between data points.

And when you're done with setting up the devices you will finally start
the experiment: this coincides with the start of the @code{EXPERIMENT}
section.


While the sections of the @acronym{EDL} file don't have to appear in this
sequence it is probably best not to experiment to much with this. In any
case, if it exists the @code{EXPERIMENT} section must always be the
last.

Please note that each section label must be immediately followed by a colon `@code{:}'.

All the section labels can be abbreviated, here's the complete list of
accepted section keywords:

@itemize @bullet
@item @code{DEVICES}, @code{DEV}, @code{DEVS}, @code{DEVICE}
@item @code{ASSIGNMENTS}, @code{ASS}, @code{ASSIGNMENT}
@item @code{VARIABLES}, @code{VAR}, @code{VARS}, @code{VARIABLE}
@item @code{PHASES}, @code{PHA}, @code{PHAS}, @code{PHASE}
@item @code{PREPARATIONS}, @code{PREP}, @code{PREPS}, @code{PREPARATION}
@item @code{EXPERIMENT}, @code{EXP}
@end itemize


@node Devices, Variables, Sections, EDL
@section Devices
@cindex devices


The @code{DEVICES} section has a very simple syntax, after a line with just
@example
DEVICES:
@end example
@noindent
to announce the start of this section, a semicolon separated list of the
devices to be used in the experiment follows. It doesn't matter if you
write the device names with lower or upper case letters, they will
automatically be converted to all lower case.


@node Variables, Arithmetic, Devices, EDL
@section Variables
@cindex variables
@cindex arrays


Within the @code{VARIABLES}, @code{ASSIGNMENTS}, @code{PREPARATIONS} and
@code{EXPERIMENT} section variables may be used. Each variable to be
used has to be declared, i.e.@: it has to be listed in the
@code{VARIABLES} section before it may be used. The start of the
@code{VARIABLES} section is declared by a line stating
@example
VARIABLES:
@end example



@subsection Variable names

Names of variables must always start with a character, i.e.@: A-Z and
a-z. The remaining part of the variable name can consist of characters,
numbers and the underscore character, '@code{_}' (or shorter, if you
like regular expressions: @code{[A-Za-z][A-Za-z_0-9]*}). Thus,
'@code{AbC_12x}' and '@code{aBc_12X}' are legal variable names, while
'@code{12xy}' or '@code{_Yx2}' aren't. Please take note that the
variable names are case sensitive, i.e.@: '@code{XY}', '@code{Xy}',
'@code{xY}' and '@code{xy}' are four different variable names!


There are a few exceptions to the valid variable names because a few
characters or character combinations are already used for physical units
as well as combinations of these with the characters @code{n} (nano),
@code{u} (micro), @code{m} (milli), @code{k} (kilo) and @code{M} (mega).
Here's the complete list:
@quotation
@multitable{Hz} {Hertz (and @code{nHz, uHz, mHz, kHz} and @code{MHz})}
@item s @tab Seconds (and @code{ns, us, ms, ks} and @code{Ms})
@item G @tab Gauss (and @code{nG, uG, mG, kG} and @code{MG})
@item T @tab Tesla (and @code{nT, uT} and @code{mT})
@item V @tab Volt (and @code{nV, uV, mV, kV} and @code{MV})
@item A @tab Ampere (and @code{nA, uA, mA, kA} and @code{MA})
@item Hz @tab Hertz (and @code{nHz, uHz, mHz, kHz} and @code{MHz})
@item dB @tab dB (deci-Bell)
@end multitable
@end quotation

Of course, also the reserved words can't be used as variable names. But
they are easy to avoid, because all reserved words are spelt in all capital
letters only.


@subsection Variable types


Variables can be divided into two classes, variables to hold integer
values and variables for storing floating point values.

Integer variables can hold data from the interval @w{[-2^31, 2^31 - 1]},
i.e. they run from -2147483648 all the way up to +2147483647. In
contrast, floating point variables can have much larger values (up to
ca.@: 10^300), the exact limits depending on the machine @acronym{fsc2}
is running on.

To distinguish between integer and floating point variables the
following convention is used: The names of all integer variables start
with a upper case letter, i.e.@: A-Z, while the names of floating point
variables start with a lower case character, i.e.@: a-z.



@node Arithmetic, Control structures, Variables, EDL
@section Arithmetic
@cindex Arithmetic

There are the usual arithmetic operations built into @acronym{fsc2},
i.e.@: addition, subtraction, multiplication and division, not too
surprisingly represented by the characters `@code{+}', `@code{-}',
`@code{*}' and `@code{/}'.
@cindex + (addition operator)
@cindex - (subtraction operator)
@cindex * (multiplication operator)
@cindex / (division operator)
They can be applied to simple integer and floating point values (see
below how they may be used with 1-dimensional arrays). If one of the
values is a floating point value the result is also a floating point
number - only if both values are integer the result also has integer
type.

Some care has to be taken in arithmetic with integers.
@cindex integer overflow
@cindex integer underflow
@cindex overflow, integers
@cindex underflow, integers
@cindex range of integers
@cindex integers, range of
The range of values an integer variable can have is restricted to the
interval @w{[-2147483648, +2147483647]}, i.e.@: @w{[-2^31, 2^31 - 1]}
(at least on a 32-bit processor). Thus, it isn't to difficult to create
numbers with greater values, e.g.@: by multiplication, that can't be
represented by an integer! In this case the result of the operation will
be completely bogus, e.g.@:

@example
1000000 * 3000 = -1294967296
@end example
@noindent
(There is actually some logic behind this result but that doesn't help
much.)  So, if you suspect the result of an integer operation to exceed
the range of representable values, convert the values to floating point
type (see the function @code{float()} below) before you do the
potentially problematic arithmetic operation.

Of course, there are also limits to the range of numbers representable by a
floating point number. Fortunately, these limits are much larger - typically
the size of the maximum numbers is in the range of 10^300.
@cindex floating point numbers, range of
@cindex range of floating point numbers
@cindex floating point overflow
@cindex floating point underflow
@cindex overflow, floating point numbers
@cindex underflow, floating point numbers

Another important point about calculations involving integers concerns the
division. The result of the division of two integer values is again an integer
value. For non-integer results this is achieved by simply truncating the
digits following the decimal point. Thus, typical results are

@example
7 / 2 = 3     8 / 3 = 2     -7 / 2 = -3
@end example
@cindex / (division operator)
@cindex integer division
@noindent
To avoid this truncation convert (see the function @code{float()} below)
at least one of the values used in the division to floating point type,
i.e

@example
float( 7 ) / 2 = 3.5    8 / float( 3 ) = 2.666666667
@end example


Beside the normal arithmetic operations there are two more operations,
the modulo function and the exponentiation. For the modulo operation the
percent sign @code{%}
@findex % (modulo operator)
@cindex modulo operator
is used and the result is the remainder of the division, e.g.@:

@example
7 % 3 = 2         6.5 % 2.5 = 1.5 
@end example


For the exponentiation the caret character @code{^} is to be used, e.g.@:
@findex ^ @r{(exponentiation)}
@cindex exponentiation

@example
3^2 = 9           6.5^1.5 = 16.5718134219...
@end example
@noindent
As usual, non-integer exponents can only be used with non-negative bases!


@subsection Assignment operators
@cindex assignment operators
@cindex =
@cindex +=
@cindex -=
@cindex *=
@cindex /=
@cindex %=
@cindex ^=

When assigning to a variable usually the `@code{=}' operator is
used. But there are many cases where e.g.@: just a number is added to a
variable and one would have to write
@example
I = I + 1;
@end example
This assignment can be shortened (and sometimes made more readable) by
using the `add and assign' operator `@code{+=}':
@example
I += 1;
@end example
Assignment operators mixed with arithmetic can also be used with all
other arithmetic operators, i.e.@: you may use all of the following
assignment operators
@example
+=     -=     *=     /=     %=     ^=
@end example


@subsection Operator precedence
@cindex operator precedence


Usually one doesn't think about the precedence of operators. We already
learned in primary school that multiplication and division has a higher
precedence than addition or subtraction. Of course, a programming
language should follow this rules. But sometimes there are cases where
it is necessary to know exactly the precedence and also in which
sequence an expression is evaluated.

the unary `@code{+}' and '@code{-}' operators have the highest
precedence, i.e.@: the operators defining the sign of a number. There is
a further operator, to be discussed later, having the same precedence,
the logical negation operator, `@code{!}'. The evaluation of an
expression with more than one of these operators is from the right to
the left, i.e.@:
@example
 !-x    @r{will be treated as if written as}    ! ( - x )
@end example
@noindent
(This is not a very useful example but here for sake of completeness.)

The exponentiation operator, `@code{^}', has the next highest
precedence, i.e.@: it `binds' more thightly than any other binary
operator. If there is more than one of these operators in a row the
expression will evaluated from the right to the left:
@example
 2^3^4    @r{will be treated as if written as}    2^(3^4)
@end example

The operator with the next lower precedence is the modulo operator,
`@code{%}'. Expressions with more than one `@code{%}' in a row will be
evaluated left to right, i.e.
@example
 31 % 6 % 2    @r{will be treated as if written as}    ( 31 % 6 ) % 2
@end example


Now the multiplication and division operators, `@code{*}' and `@code{/},
follow. Both have exactly the same precedence and expressions involving
more than one of these operators are evaluated left to right, i.e.
@example
 3 * 22 / 7    @r{will be treated as if written as}    ( 3 * 22 ) / 7
@end example
@noindent
(Take care: This can make a lot of a difference when e.g.@: integer
multiplication is involved.)

The next lower precedence operators are the addition and subtraction
operators, `@code{+}' and `@code{-}'. Also for these operators
expressions are evaluated left to right:
@example
 13 + 4 - 5    @r{will be treated as if written as}    ( 13 + 4 ) - 5
@end example
@noindent
Usually, this won't matter a lot, but if you're dealing with very large
numbers and there's danger of an overflow to occur knowing the rules of
evaluation can become important.

The next lower precedence operators are the logical operators to be
discussed in more detail below, i.e.@: the logical @i{and} operator,
`@code{&}, the logical @i{or} operator, `@code{|}' and the logical
@i{exclusive or} (xor) operator, `@code{~}'. Expressions containing more
than one of these operators are always evaluated from the left to the
right of the expression:
@example
 a | b & c    @r{will be treated as if written as}    ( a | b ) & c
@end example

Finally, the lowest precedence operators are the comparision operators
(also the be discussed below in more detail), the test for equality,
`@code{==}' (not to be confused with the assignement operator
`@code{=}'), the test for inequality, `@code{!=}', and the remaining
four comparison operators `@code{<}', `@code{<=}', `@code{>}' and
`@code{>=}', i.e.@: @i{less than}, @i{less or equal}, @i{larger} and
@i{larger or equal}. If more than one of these operators appears in an
expression evaluation is done left to right.

Actually, there are also the assignement operators. But these are only
used after all of the other operators have been evaluated, so there is
never a necessity to enclose the right hand of an equation with
parenthesis. And since only one assignement operator is allowed in a
statement you don't have to worry about the order of evaluation.

Of course, the precedence of operators and the sequence they are
evaluated in can always be changed by using parenthesis. So, if in doubt,
use parenthesis -- this won't slow down the program significantly.


@subsection Arithmetic with arrays
@cindex Arithmetic with arrays


Beside the usual artithmetic with numbers it is also possible to use
arithmetic with (one-dimensional) arrays. Also all built-in functions
can (as far as this makes any sense) can be applied to these kinds of
arrays.

As long as the sizes of two arrays are identical they can be added or
subtracted. If the arrays @code{a} and @code{b} are defined as
@example
      a[ 3 ] = @{ 0.5, 1.0, 2.0 @};
      b[ 3 ] = @{ 1.0, -2.0, -3.0 @};
@end example
they can be added and subtracted in a element-by-element fashion,
resulting in
@example
      a + b      ->   @{ 1.5, -1.0, -1.0 @}
      a - b      ->   @{ -0.5, 3.0, 5.0 @}
@end example
On the other hand, it is also possible to add or subtract a number from
each element of an array:
@example
      a + 5      ->   @{ 5.5, 6.0, 7.0 @}
      a - 3      ->   @{ -2.5, -2.0, -1.0 @}
@end example

Also multiplication and division is possible with arrays. Again, this
operations are implemented in a element-by-element way, i.e.@:
multiplying to arrays is not a dot product but results again in an
array. The same holds for the division. With the arrays @code{a} and
@code{b} defined above the results are:
@example
      a * b      ->   @{ 0.5, -2.0, -6.0 @}
      a / b      ->   @{ 0.5, -0.5, -0.666667 @}
      b / a      ->   @{ 2.0, -2.0, -1.5 @}
@end example

Again, also multiplication and division of an array with a number is
defined as shown here:
@example
      a * 2      ->   @{ 1.0, 2.0, 4.0 @}
      a / 3      ->   @{ 0.166667, 0.333333, 0.666667 @}
      3 / a      ->   @{ 6.0, 3.0, 1.5 @}
@end example

Finally, also calculation of the modulo and exponentiation can be done on
arrays. Also these operations are implemented as element-by-element
calculations, i.e.@: resulting in an array:
@example
      a % b      ->   @{ 0.5, 1.0, 2.0 @}
      b % a      ->   @{ 0.0, 0.0, -1.0 @}
      a ^ b      ->   @{ 0.5, 1.0, 0.125 @}
      b ^ a      ->   @{ 1.0, -2.0, 9.0 @}
@end example

Of course, the same operations can also be applied to a mixture of
arrays and simple numbers, also resulting in arrays:
@example
      a % 0.3    ->   @{ 0.2, 0.1, 0.2 @}
      1.3 % a    ->   @{ 0.3, 0.3, 0.7 @}
      a ^ 2      ->   @{ 0.25, 1.0, 4.0 @}
      2 ^ a      ->   @{ 1.414215, 2.0, 4.0 @}
@end example

All the built-in arithmetic functions can be applied to arrays. In every
case the function is applied to each element of the array, thus the
result is another array with its elements being the results of applying
the function to each of the input array elements. For example, again
using the array @code{a} defined above, applying the @code{sqrt()}
function results in:
@example
      sqrt( a )  ->   @{ 0.7071068, 1.0, 1.1414215 @}
@end example

Finally, for obvious reasons, when computed assignements are used
(i.e.@: `@code{+=}', `@code{-=}', `@code{*=}', `@code{/=}', `@code{%=}'
or `@code{^=}') the left hand side variable of an equation has to be an
array when arithmetic with arrays is used.



@node Control structures, , Arithmetic, EDL
@section Control structures
@cindex Control structures
@cindex Flow control


Within the @code{EXPERIMENT} section flow control structures can be
used. These are @code{REPEAT}, @code{WHILE} and @code{FOR} loops and
@code{IF}-@code{ELSE} constructs. (Please note: all of these keywords
have to be spelt in capital letters!).


Most flow control construct keywords are followed by a condition and all
are then followed by a block of statements. Such a block of statements
has to be enclosed in curly braces and may contain as many statements as
needed (or still fit into the memory).


@subsection REPEAT loops
@cindex REPEAT loops

The most simple construct is the @code{REPEAT} loop. What is needed
following the keyword @code{REPEAT} is a number and a block with
commands. The number should be an integer number (or an expression
resulting in an integer).  The following block of statements will now be
repeated as many times as specified by the number (or
expression). Here's an example:


@example
    I = 0;
    SUM = 0;

    REPEAT 100 @{
        I = I + 1;
        SUM = SUM + I;
    @}
@end example

This snippet will calculate the sum of all integers between 1 and 100
(of course, there are more elegant ways to do this, but it's just an
example). After the initialisation of the two variables `@code{I}' and
`@code{SUM}' the @code{REPEAT} loop starts with 100 as the number of
repetitions. Now, in curly braces, i.e.@: between `@code{@{}' and
`@code{@}}', follow the statements to be executed in the loop.


@subsection WHILE loops
@cindex WHILE loops


Nearly as simple a construct is the @code{WHILE} loop: following the
keyword a condition is needed first. Usually, this will be a comparison
between two numbers, but also a simple number will suffice -- if its
value is non-zero it will be interpreted as TRUE. Of course, the keyword
and the condition have to be followed by a block of statements.

Again, an example:

@example
    I = 1;
    Fact = 1;

    WHILE I <= 6 @{
        Fact = Fact * I;
        I = I + 1;
    @}
@end example

This program snippet (that could also have been written using a
@code{REPEAT} loop) calculates the factorial of 6. After initialising
the variables `@code{I}' and `@code{Fact}' it is tested in the loop
condition if `@code{I}' is still not larger that 6. If this is true, the
following block of statements is executed.

Here is a complete list of the comparison operators between two
expressions (e.g.@: numbers):

@quotation
@multitable{==} { compare for equality (don't confuse with single
`@code{=}' that is used in assignments)}
@item @code{==} @tab
compare for equality (don't confuse with single `@code{=}' that is
used in assignments)
@item @code{!=} @tab
TRUE if the numbers are unequal
@item @code{<} @tab
TRUE if the left side expression is smaller than the
right side expression
@item @code{<=} @tab
TRUE if the left side expression is smaller or equal to the
right side expression
@item @code{>} @tab
TRUE if the left side expression is larger than the
right side expression
@item @code{>=} @tab
TRUE if the left side expression is larger or equal to the
right side expression
@end multitable
@end quotation
@cindex == (comparison operator)
@cindex comparison operator
@cindex != (unequality)
@cindex unequality `!='
@cindex < (less than)
@cindex less than `<'
@cindex <= (less or equal)
@cindex less or equal `<='
@cindex > (larger than)
@cindex larger than `>'
@cindex >= (larger or equal)
@cindex larger or equal `>='


And here is also an example for using simple numbers in a condition,
using the fact that a non-zero value is always interpreted as TRUE:

@example
    I = 6;
    Fact = 1;

    WHILE I  @{
        Fact = Fact * I;
        I = I - 1;
    @}
@end example

This example does exactly the same as the previous one, i.e.@: it
calculates the factorial of 6. But the difference is that we start with
`I' set to 6 and than decrement it successively. Thus we can use
`@code{I}' in the loops condition by simply checking if it still is
non-zero and thus the condition still TRUE and repeating the loop as
long as it is.

Sometimes, you may want to check not for the truth but for the falsehood
of an expression. In this case you have to prepend the expression with a
exclamation mark, `!', to reverse the meaning of a test.

If you want to check for combinations of expressions you can use the
logical @code{AND}, @code{OR} or @code{XOR} (exclusive or)
operators. Here is a list of these operators and their meaning:

@quotation
@multitable{~} {exclusive or: TRUE if left or right hand side expressions are TRUE but not both}
@item @code{!} @tab not: Negate truth of an expression
@item @code{&} @tab and: TRUE if left and right hand side expressions are TRUE
@item @code{|} @tab or: TRUE if left or right hand side expressions are TRUE
@item @code{~} @tab exclusive or: TRUE if left or right hand side expressions are TRUE but not both
@end multitable
@end quotation
@cindex ! (negation operator)
@cindex negation operator `!'
@cindex & (logical and operator)
@cindex and operator `&'
@cindex logical and operator  `&'
@cindex | (logical or operator)
@cindex or operator `|'
@cindex logical or operator `|'
@cindex ~ (logical xor operator)
@cindex xor operator `~'
@cindex logical xor operator `~'



@subsection FOR loops
@cindex FOR loops


Before the @code{WHILE} loop on often has to initialise the loop
variables and within the statement block the loop variable has to been
updated. In many cases (for example in both the preceeding examples) it
is simpler to use a @code{FOR} loop instead, because setting the loop
variable as well as updating it is aromatically done in the condition
part. Here's an example that does exactly the same as the first of the
two preceeding examples:
@cindex FOR

@example
    Fact = 1;
    FOR I = 1:6 @{
        Fact = Fact * I;
    @}
@end example

At the very start of the @code{FOR} loop the loop variable `@code{I}' is
set to 1 and the block is run using this value. When it is done,
`@code{I}' is automatically incremented by 1 and tested if it is still
not larger than 6. If this is TRUE the loop is repeated with the new
value of `@code{I}'. Take care: You can change `@code{I}' also within
the loop, but you only should do this if you really mean it and know
what you're doing!

But we also can reproduce the second version of the factorial
calculation using a @code{FOR} loop. Here it is:

@example
    Fact = 1;
    FOR I = 6:1:-1 @{
        Fact = Fact * I;
    @}
@end example

Now `@code{I}' starts of with the value 6 and the third value in the
@code{FOR} loop condition part is the value to be used for incrementing
`@code{I}'. In our case it is -1, so `@code{I}' actually will be
decremented until it is smaller than 1 (the second value in the
@code{FOR} loop condition). As you see, @code{FOR} loop variables can
not only be incremented by 1 but by any value (integer or floating point
ones). And, of course, the loop variable don't have to be an integer
variable!


@section IF-ELSE constructs
@cindex IF
@cindex ELSE 
@cindex IF-ELSE


Finally there's the @code{IF}-@code{ELSE} construct.
