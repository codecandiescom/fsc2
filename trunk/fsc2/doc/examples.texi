@c  $Id$
@c
@c  Copyright (C) 1999-2008 Jens Thoms Toerring
@c
@c  This file is part of fsc2.
@c
@c  Fsc2 is free software; you can redistribute it and/or modify
@c  it under the terms of the GNU General Public License as published by
@c  the Free Software Foundation; either version 2, or (at your option)
@c  any later version.
@c
@c  Fsc2 is distributed in the hope that it will be useful,
@c  but WITHOUT ANY WARRANTY; without even the implied warranty of
@c  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c  GNU General Public License for more details.
@c
@c  You should have received a copy of the GNU General Public License
@c  along with fsc2; see the file COPYING.  If not, write to
@c  the Free Software Foundation, 59 Temple Place - Suite 330,
@c  Boston, MA 02111-1307, USA.


@node Example EDL Scripts, Command Line Options, Using Pulsers, fsc2
@chapter Example EDL Scripts


Since it is often much easier to understand a new language from examples
then by just learning the vocabulary and the syntax here are a few
example @code{EDL} scripts, together with an explanation of how they
work. If the explanations looks overly verbose please bear with me, I
tried to make it as comprehensive and easy to understand as possible.
Please note that the discussion of @code{EDL} functions used in the
example scripts isn't complete in all cases, sometimes a function may
accept more parameters than mentioned here etc.@:, please always look up
the full documentation in the previous chapters when in doubt.


@ifnottex

@menu
* An enhanced cw-EPR experiment::
* GUI-fying the script::
* cw-EPR monitor script::
* Hahn-echo detected EPR script::
* ESEEM script::
* Time-resolved EPR script::
@end menu

@end ifnottex


@node An enhanced cw-EPR experiment, GUI-fying the script, Example EDL Scripts, Example EDL Scripts
@section An enhanced cw-EPR experiment

In the chapter describing the @code{EDL} language (@pxref{EDL}) already
a script for doing a very simple @i{cw}-EPR experiment was given. Here
we will now enhance this script a bit to allow e.g.@: multiple runs over
the field range:
@example
 1 DEVICES:
 2   er035m_s;              // gaussmeter module
 3   aeg_x_band;            // magnet module
 4   sr530;                 // lock-in amplifier module
 5 
 6 VARIABLES:
 7   start_field    = 3360.0 G;
 8   end_field      = 3450.0 G;
 9   field_step     =    0.5 G;
10   Number_of_runs = 10;
11 
12   field = start_field;
13   Number_of_points = 1 + int( ( start_field - end_field ) 
14                               / field_step );
15   data;
16   mean_data[ Number_of_points ];
17   I, J;
18   File_1, File_2;
19   tc;
20 
21 PREPARATIONS:
22   magnet_setup( start_field, field_step );
23   init_1d( 2, Number_of_points, start_field, field_step,
24            "Magnetic field [G]", "Signal strength [uV]"  );
25 
26 EXPERIMENT:
27 
28   File_1 = get_file( "File for storing all runs:" );
29   File_2 = get_file( "File for storing end results:" );
30 
31   tc = lockin_time_constant( );
32 
33   FOR I = 1 : Number_of_runs
34   @{
35     FOR J = 1 : Number_of_points
36     @{
37       wait( tc );
38       data = lockin_get_data( );
39       mean_data[ J ] += data;
40       display_1d( J, data / 1 uV, 1,
41                   J, mean_data[ J ] / ( I * 1 uV ), 2 );
42       fsave( File_1, "# #\n", field, data );
43       field = sweep_up( );
44     @}
45 
46     fsave( File_1, "\n" );
47     field = magnet_reset_field( );
48     clear_curve( 1 );
49   @}
50 
51   fsave( File_2, "% Start field     = # G\n", start_field );
52   fsave( File_2, "% End field       = # G\n", end_field );
53   fsave( File_2, "% Field step      = # G\n", field_step );
54   fsave( File_2, "% Number of runs  = #\n", Number_of_runs );
55   fsave( File_2, "% Time constant   = # ms\n", tc / 1 ms );
56   save( File_2, mean_data / Number_of_runs );
@end example

The @code{DEVICES} section is identical to the original script, again we
use the AEG X-band magnet (controlled via the Bruker @w{ER 035 M}
gaussmeter) and the @w{SR 530} lock-in amplifier.

Also the first lines of the @code{VARIABLES} section are identical, we
need three variables for the start field, the end field and the field
step size. But now also another variable for the number of runs we'll do
during the experiment is needed, which we declare in line 10.

The following variables are all auxiliary variables. @code{Number_of_points}
is automatically initialized to the number of points during one run (we got
to add 1, otherwise we wouldn't get the last point of the field range). The
next variables, @code{data} and @code{mean_data} are both for storing the
results f the experiment. But since (as the name indicates) @code{mean_data}
is going to be used to store the mean value of all data points it needs to
be an array with enough space for all points of the spectrum.

The variables @code{I} and @code{J} are simple counters and
@code{File_1} and @code{File_2} are integer variables that we will be
used for file handles -- we are going to use two files, one for storing
intermediate results, i.e.@: all single run spectra, and a second one
for saving the end results, i.e.@: the mean values of the data from all
runs. Finally, @code{tc} is going to be used for the lock-in's time
constant.

Also the first line of the @code{PREPARATIONS} section hasn't changed,
again we set up the magnet using @code{magnet_setup()}
(@pxref{magnet_setup()}) to be started at a field as stored in the
variable @code{start_field} and tell it, that sweeps will be done with
step sizes of @code{field_step}.

But the graphics initialization using the function @code{init_1d()}
(@pxref{init_1d()}) in line 23 has been changed a bit. Instead of using
the defaults, we now request 2 curves (one for the newly measured data
points and one for the mean values of all runs don so far).  Also, we
indicate that the curves will be @code{Number_of_points} long.  The next
two values set up the scale of the @i{x}-axis: the @i{x}-axis should
start with a value of @code{start_field} and the difference between two
points in @i{x}-direction is @code{field_step}. Finally, we also set
labels for the @i{x}- and @i{y}-axis: the values at the @i{x}-axis are
the magnetic fields (in Gauss) and the @i{y}-axis will represent the
measured signal intensity in microvolt.

The first thing done in the @code{EXPERIMENT} section is asking the user
to supply two file names -- what we get back from the functions are
integer numbers that are going to be used later to indicate into which
of the two files data are to be written to (should the user hit the
@code{Cancel} button to indicate that (s)he doesn't want to write out
the data to a file the number returned will tell @code{fsc2} not to
open a file and skip commands for writing data to this file).

The next step (line 31) is to determine the lock-in amplifiers time
constant, we will have to wait for this time after a field sweep step to
give the lock-in enough time to measure a new value.

The actual experiment now consists of two loops, a main loop for doing
all the consecutive runs over the field range, and an embedded loop for
acquiring, displaying and storing each data point in a run. Both loops
are realized by @code{FOR} loops because for both we know exactly how
many times each one has to be repeated.

Within the inner loop, i.e.@: for each data point we wait for the
lock-in amplifiers time constant to measure a new data point at the
current field, which we then fetch from the lock-in amplifier (line 38)
and store it in the variable @code{data}. The new value now gets added
to the appropriate element of the array of mean values.

In line 40/41 the new data value and the new mean value both are
displayed on the screen. The first three arguments of the call of the
function @code{display_1d()} (@pxref{display_1d()}) are the
@i{x}-coordinate, which is just the loop counter variable, the
@i{y}-coordinate, the new data value but devided by @code{1 uV}
because the value returned by the lock-in amplifiers is always in Volts
and we want to display the value in code micro-Volts, and the number of
the curve, @code{1}. The next three arguments are for the new mean
value, we only have to take care to divide the @code{mean_data} array
element by @code{I}, the number of runs done so far.

If you have trouble understanding why the @i{x}-coordinate is passed to
@code{display_1d()} (@pxref{display_1d()}) as an integer numbers but on
the screen the scale is being shown in field units, here's an explanation:
in the @code{init_1d()} function call (@pxref{init_1d()}) during the
@code{PREPARATIONS} section we told the program that the first @i{x}-axis
value would be at a field of the value of @code{start_field} and that all
following fields would be equally spaced by a field difference according
to the value of the second variable, @code{field_step}. The program uses
this information to convert a @i{x}-coordinate of @code{1} to make the
data point appear at the field scale value of @code{start_field}, a
@i{x}-coordinate of @code{2} at @code{start_value + field_step} etc.

The next instruction (line 42) stores the newly measured value, together
with the current field, in the first file. In this case we use the
function @code{fsave()} (@pxref{fsave()}) to write both the current field
(as stored in the variable @code{field}) and the new data into the
(first) file. According to the format string both values will appear on
one line.

All now still to be done in the inner loop is to sweep to a new magnetic
field (which, according to the our call of @code{magnet_setup()}
(@pxref{magnet_setup()}) in the @code{PREPARATIONS} section is supposed to
be @code{field_step()} higher than the current value). When the magnet has
reached the new field the @code{sweep_up()} function (@pxref{sweep_up()})
returns the new field value which gets stored in the variable
@code{field}.

When the inner loop has been repeated @code{Number_of_points} times we
have reached the end field and now have to start a new scan. First we
write an empty line into the file for the data of all runs in order to
have a visual indication where the data of the new run start. Then we
have to set the field back to the start field, which can be done by
calling the function @code{magnet_reset_field()}
(@pxref{magnet_reset_field()}) (you actually also could also tell
the magnet to go to a field of @code{start_field()} by calling
@code{magnet_field()} (@pxref{magnet_field()}) with @code{start_field()}
as its only argument). Finally, we have to remove the data of the last
run from the screen but keeping the curve with the mean values. This is
done by calling the function @code{clear_curve()} (@pxref{clear_curve()})
with the number of the curve to be removed (which is 1) as the parameter.
Then we proceed with the inner loop.

When the experiment finally is done, i.e.@: when we're finished doing the
@code{Number_of_runs} repetitions of the field sweep we end up at line
51 where we now can store the whole array of mean values, together with
some information about the experimental parameters. Please note that
using the function @code{save()} (@pxref{save()}) it is possible to write
whole (one-dimensional) arrays with one call. You also see here an example
of arithmetic done on arrays: all array elements of @code{mean_data} are
automatically divided by @code{Number_of_runs} before being written to
the file.


@node GUI-fying the script, cw-EPR monitor script, An enhanced cw-EPR experiment, Example EDL Scripts
@section GUI-fying the script

Looking again at the above script one may recognize that there are only
a few variables that always need to be edited when doing a new experiment.
These are the start and end field, the field step size and the number of
runs. Having to edit the script all of the time can become rather tedious.
But there's a simple method to add a graphical user interface to the
program that lets one set these parameters and does not require to load
the script into an editor, change it and then load the script into @code{fsc2}.

All what's needed is to add and change a few lines.:
@example
 1 === START_FIELD float [ 1460 : 19900 ] [ 3360 ] "Start field:" "G"
 2 === END_FIELD float [ 1460 : 19900 ] [ 3450 ] "End field:" "G"
 3 === FIELD_STEP float [ 1.1e-3 : ] [ 0.5 ] "Field step:" "G"
 4 === NUMBER_OF_RUNS int [ 1 : ] [ 10 ] "Number of runs:"
 5 DEVICES:
 6   er035m_s;              // gaussmeter module
 7   aeg_x_band;            // magnet module
 8   sr530;                 // lock-in amplifier module
 9 
10 VARIABLES:
11 === if START_FIELD < END_FIELD
12   start_field    = START_FIELD G;
13   end_field      = END_FIELD G;
14 === else
15   start_field    = END_FIELD G;
16   end_field      = START_FIELD G;
17 === endif
19   field_step     = FIELD_STEP G;
20   Number_of_runs = NUMBER_OF_RUNS;
21 
22   field = start_field;
23   Number_of_points = 1 + int( ( start_field - end_field ) 
24                               / field_step );
25   data;
26   mean_data[ Number_of_points ];
27   I, J;
38   File_1, File_2;
39   tc;
30 
31 PREPARATIONS:
32   magnet_setup( start_field, field_step );
33   init_1d( 2, Number_of_points, start_field, field_step,
34            "Magnetic field [G]", "Signal strength [uV]"  );
35 
36 EXPERIMENT:
37 
38   File_1 = get_file( "File for storing all runs:" );
39   File_2 = get_file( "File for storing end results:" );
40 
41   tc = lockin_time_constant( );
42 
43   FOR I = 1 : Number_of_runs
44   @{
45     FOR J = 1 : Number_of_points
46     @{
47       wait( tc );
48       data = lockin_get_data( );
49       mean_data[ J ] += data;
50       display_1d( J, data / 1 uV, 1,
51                   J, mean_data[ J ] / ( I * 1 uV ), 2 );
52       fsave( File_1, "# #\n", field, data );
53       field = sweep_up( );
54     @}
55 
56     fsave( File_1, "\n" );
57     field = magnet_reset_field( );
58     clear_curve( 1 );
59   @}
60 
61   fsave( File_2, "% Start field     = # G\n", start_field );
62   fsave( File_2, "% End field       = # G\n", end_field );
63   fsave( File_2, "% Field step      = # G\n", field_step );
64   fsave( File_2, "% Number of runs  = #\n", Number_of_runs );
65   fsave( File_2, "% Time constant   = # ms\n", tc / 1 ms );
66   save( File_2, mean / Number_of_runs );
@end example

The new first four lines are for defining some special variables that
will be used by the program for the graphical user interface. Each of
the lines starts with three equal-signs in a row, followed by the
variable name. This variable name must be different from all names
already used in the @code{EDL} script and also may not be @code{EDL}
keywords. Directly after the name follows the type of the variable,
here we only use floating point and integer variables. The type is
followed by the allowed range of the variable, enclosed in square braces
and with the upper and lower limit separated by a colon, "@code{:}". As
you can see, you may leave out one (or even both) limits. Here we use
the field range that can be measured with the gaussmeter as the limits
for the start and end field . For the field step variable there's
only a lower limit, the smallest step size possible with the magnet
power supply. Also for the number of runs only a lower limit is given,
which is @code{1} for obvious reasons.

Following the ranges a default value may be given, also enclosed in
square braces, we use here the values we previously had hard-coded into
the script. Finally, two strings can be given to be shown on the left
and right side of the entry field in the graphical user interface.

With these declarations a program for the graphical user interface can
be created automatically which will show four entry fields for filling
in the parameters using the @code{fsc2_guify} tool. There will also be
another button that allows to create the above script with the user
supplied parameters filled in an to directly send it to @code{fsc2} for
execution.

Of course, for this tool to be able to fill in the user supplied
parameters into the right positions we also must change a few lines.
E.g.@: in the place where previously the start field was hard-coded into
the script we now have to fill in the variable for the start field,
@code{START_FIELD}, and the same hold for the end field, the field step
size and the number of runs.

There is already some security mechanism to keep the user from entering
bogus parameters, the possibility to restrict the values of the
variables to a certain range. This will keep the user from entering
e.g.@: too small a field step size (or even a negative one) or less than
one number of runs. But, unfortunately, it's still possible to enter an
end field that is lower than the start field. To catch this kind of
mistake, in the script above at line 11 it is checked that the value for
the start field is lower than the end field before assigning
@code{START_FIELD} and @code{END_FIELD} to the corresponding @code{EDL}
variables. But if @code{START_FIELD} is higher than @code{END_FIELD} in
line 14 ff.@: the assignment is reversed, so that the @code{EDL}
variable @code{start_field} is guaranteed to be lower than
@code{end_field} even when the user made a mistake while filling in the
form.

To finally create the program with the graphical user interface all we
now to do is save the above script, e.g.@: with the file name
@file{cw_epr.EDL} and, on the command line, apply the @code{fsc2_guify}
tool to get an immediately executable program called @code{cw_epr}:
@example
fsc2_guify cw_epr.EDL cw_epr
@end example
@noindent
From now on all an user has to do to start a @i{cw}-EPR experiment is to
execute the @code{cw_epr} program, enter the parameters and push the
button for starting the experiment.


@node cw-EPR monitor script, Hahn-echo detected EPR script, GUI-fying the script, Example EDL Scripts
@section cw-EPR monitor script

Before doing a real experiment one often needs to optimize the experimental
parameters like phase, amplification etc. In these cases it would be rather
inconvenient to have start an experiment in order to check e.g@: the signal
intensity, adjust the parameters and start another test experiment. One
rather would have a program where it's possible to adjust the parameters
while scanning the field region where the signal is to be expected. This
can be done easily with a another @code{EDL} script. Here we also will
make use of the built-in methods to create additional graphical elements
like buttons, input fields etc.

Before starting to write such a script let's collect the requirements:
@itemize @bullet
@item It should be possible to sweep up and down as well as to stop the
      sweep. Whenever the sweep direction is changed or the sweep is
      stopped a marker should be drawn.
@item We need two input fields to be able to set a new magnetic field
      value and sweep step size.
@item The current field should be displayed in an output field.
@item It should be possible to stop and restart acquiring new data from
      the lock-in amplifier.
@item We would like to be able to clear the display when the old data
      aren't needed anymore.
@item While running the test experiment the lock-in amplifiers keyboard
      should still be usable to allow adjustments of phase, sensitivity,
      time constant etc.
@end itemize

Now here is the complete @code{EDL} script:
@example
  1 DEVICES:
  2 
  3 er032m;       // Bruker field controller
  4 sr530;        // SR 530 lock-in amplifier
  5 
  6 
  7 VARIABLES:
  8 
  9 field;
 10 field_step = 0.5 G
 11 data[ 2 ];
 12 
 13 last_field;
 14 last_field_step = field_step;
 15 new_field, new_field_step;
 16 
 17 max_field = -50.0 G
 18 min_field = 23 kG;
 19 min_field_step = 1 mG;
 20 max_field_step = 100 G;
 21 
 22 I;
 23 
 24 Sweep_State = 0;   // 0: stopped, 1: up, -1: down
 25 Pause_State = 1;   // 0: running, 1: paused
 26 
 27 Sweep_Up, Sweep_Down, Sweep_Stop,
 28 Field_In, Field_Step_In, Field_Out,
 29 Pause, Clear;
 30 
 31 
 32 PREPARATIONS:
 33 
 34 init_1d( 2, "Points", "Signal [uV]" );
 35 
 36 
 37 EXPERIMENT:
 38 
 39 lockin_lock_keyboard( "OFF" );
 40 field = magnet_field( field );
 41 last_field = field;
 42 
 43 hide_toolbox( "ON" );
 44 Field_Out = output_create( "FLOAT_OUTPUT", field,
 45                            "Current field (in G)" );
 46 Sweep_Up   = button_create( "RADIO_BUTTON", "Sweep up" );
 47 Sweep_Stop = button_create( "RADIO_BUTTON", Sweep_Up, "Stop sweep" );
 48 Sweep_Down = button_create( "RADIO_BUTTON", Sweep_Up, "Sweep Down" );
 49 button_state( Sweep_Stop, "ON" );
 50 
 51 Field_In = input_create( "FLOAT_INPUT", field,
 52                          "Set a new field (in G)" );
 53 Field_Step_In = input_create( "FLOAT_INPUT", field_step,
 54                               "Set a new field step (in G)" );
 55 Pause = button_create( "PUSH_BUTTON", "Pause display" );
 56 button_state( Pause, Pause_State );
 57 Clear = button_create( "NORMAL_BUTTON", "Clear screen" );
 58 hide_toolbox( "OFF" );
 59 
 60 I = 1;
 61 
 62 FOREVER @{
 63 
 64   wait( lockin_time_constant( );
 65 
 66   IF Pause_State == 0
 67   @{
 68     data = lockin_get_data( 1, 2 );
 69     display_1d( I, data[ 1 ] / 1 uV, 1,
 70                 I, data[ 2 ] / 1 uV, 2 );
 71     I += 1;
 72   @} 
 73 
 74   IF button_state( Sweep_Up ) @{
 75     IF Sweep_State != 1 @{
 76       Sweep_State = 1;
 77       draw_marker( I, "RED" );
 78     @}
 79   @} ELSE IF button_state( Sweep_Down ) @{
 80     IF Sweep_State != -1 @{
 81       Sweep_State = -1;
 82       draw_marker( I, "GREEN" );
 83     @}
 84   @} ELSE @{
 85     IF Sweep_State != 0 @{
 86       Sweep_State = 0;
 87       draw_marker( I, "YELLOW" );
 88     @}
 89   @}
 90 
 91   IF Sweep_State == 1 @{
 92      IF field + field_step <= max_field @{
 93        field = magnet_field( field + field_step );
 94        output_value( Field_Out, field );
 95      @} ELSE @{
 96        Sweep_State = 0;
 97        button_state( Sweep_Stop, 1 );
 98        draw_marker( I, "YELLOW" );
 99      @}
100    @} ELSE IF Sweep_State == -1 @{
101      IF field - field_step >= min_field @{
102        field = magnet_field( field - field_step );
103        output_value( Field_Out, field );       
104      @} ELSE @{
105        Sweep_State = 0;
106        button_state( Sweep_Stop, 1 );
107        draw_marker( I, "YELLOW" );
108      @}
109   @}
110 
111   new_field = input_value( Field_In );
112   IF new_field != last_field @{
113     IF ( new_field >= min_field AND new_field <= max_field @{
114       field = magnet_field( new_field );
115       output_field( Field_Out, field );
116       last_field = new_field;
117     @} ELSE @{
118       input_field( Field_In, last_field );
119     @}
120   @}
121 
122   new_field_step = input_value( Field_Step_In );
123   IF new_field_step != last_field_step @{
124     IF new_field_step >= min_field_step AND
125        new_field_step <= max_field_step @{
126       field_step = new_field_step;
127       last_field_step = new_field_step;
128     @} ELSE @{
129       input_field( Field_Step_In, last_field_step );
130     @}
131   @}
132 
133   Pause_State = button_state( Pause );
134 
135   IF button_state( Clear ) @{
136     clear_curve( );
137     clear_marker( );
138     rescale( 64 );
139     I = 1;
140   @}
141 @}
@end example

I hope that this script doesn't look too daunting, but most of its
length is due to checking for and reacting to user input, the really
interesting content being rather small as you will see.

The @code{DEVICES} section again is very simple, we're just loading the
modules for the @code{Bruker} field controller and the @code{SR530}
lock-in amplifier. Since this lock-in has two channels we will be able to
display both the @i{x}- and the @i{y}-phase signal which might help to
set the correct phase for the real experiment.

The @code{VARIABLES} section has gotten rather long. But the most
important variables are just the first three for the current field, the
current field step size and an array with two elements for storing the
@i{x}- and @i{y}-phase signal.

The next four variables at line 13 to 15 are needed in the evaluation of
the input fields for setting a new field and field step size. We will
discuss their meaning later.

The variables defined on line 17 to 20 for the minimum and maximum field
and field step size are not strictly necessary. We also could have
hard-coded the values into the script (but at the cost of
readability). It's also going to be easier to adapt the script for
using a different field controller with a different set of limits when
such values can be found in just one place instead of having them
scattered all over the script.

The variable @code{I} is just a counter variable which will tell us at
which coordinate to draw the next measured data points.

@code{Sweep_State} and @code{Pause_State} (line 24 and 25) are for
remembering the current state the program is in. If @code{Sweep_State}
is set to @code{1} the program is currently sweeping the field to higher
values, if it's set to @code{0} the field sweep is stopped, and if it is
@code{-1} we're sweeping down. If @code{Pause_State} is set to @code{0}
we're supposed to measure and display new data, if it's @code{1} data
acquistion is disabled.

The final variables declared in the lines 27 to 29 are integer variables
for storing handles for the graphical elements like buttons and in- and
output fields. To e.g.@: determine if a button has been pressed we will
need its handle.

The @code{PREPARATIONS} section is very short, all which is done here is
the initialization of the display: we need two curves for the @i{x}- and
@i{y}-phase signal and we set the labels for the @i{x}- and @i{y}-axis.
We can't know in advance how many points we're going to have to display,
so the corresponding parameter in the function call has been left out.
Since it is rather likely that while running the script the field will
not be swept in just one direction (and in fixed-sized steps) but will
be swept up and down (or even stay at the same value for longer times)
in unpredictable ways it's not possible to draw a reasonable @i{x}-axis
scale, so also the parameters for defining the scale are omitted,
resulting in just point numbers getting displayed at the @i{x}-axis.

Now we're getting to the most interesting part, the @code{EXPERIMENT}
section. The first thing we do (line 39) is to re-enable the lock-in
amplifiers keyboard. Normally, all keys of devices get disabled when an
experiment starts, so we have to re-enable them if we want to manually
change the settings.

The second thing to be done is figuring out at which field the magnet
currently is and store it in both the variables @code{field} and
@code{last_field}. Because we didn't call the function
@code{magnet_setup()} (@pxref{magnet_setup()}) in the @code{PREPARATIONS}
section as in the previous example script the magnet will simply start
of at the field value it has been set to manually.

All the lines 43 to 58 are for setting up an additional window with
graphical elements, i.e.@: buttons and in- and output fields. The first
element is an output field, i.e.@: a box to just display values.  It is
created by calling the function @code{output_create()}
(@pxref{output_create()}) with three arguments. The first is the type of
the field where "FLOAT_OUTPUT" stands for a field for displaying
floating point values. The second is the value to display in the field
and the third is a label to appear below the field. Obviously, this
first field is for displaying the current magnetic field. The integer
value returned by the function is later going to used when we have to
refer to the field for updating the displayed value when the magnet gets
swept.

The following 4 lines (46-49) are for creating a set of radio buttons.
Radio buttons always appear in groups and the important property is that
only one of them can be switched on at a time. That's exactly what we
need to control if the magnet is to be swept up or down or stopped -- it
can only be in one of these states. To create a button we need to call
the function @code{button_create()} (@pxref{button_create()}). For the
first of group of radio buttons it takes just two arguments, the first
one indicating the type of the button, i.e.@: @code{"RADIO_BUTTON"}
(there are also other types of buttons as we will see soon) and a label
to be drawn to the right of the button.

For the other two radio buttons belonging to the group we need an
additional argument to state to which group they belong to. This extra
argument is simply the number of the first button of the group. It has
to be given between the buttons type and the label string.

After creating all three buttons we now select one of them as activated
with a call to @code{button_state()} (@pxref{button_state()}). When we
want to set the state of a button we have to pass the function two
arguments, the number associated with the button and the state, either
@code{"ON"} or @code{"OFF"} (but @code{1} and @code{0} will also do). If
we don't set one of the buttons of a group of radio buttons the first of
the group will be selected per default. But since we better start off
with the sweep being stopped we here have to manually set the
corresponding button.

Next we add two input fields where the user can enter a new field as
well as a new field step size. This is down by a call of the function
@code{input_create()} (@pxref{input_create()}). Since both values are
floating point numbers we use @code{"FLOAT_INPUT"} as the first
argument. As already in the case of the function for creating an output
field, the second argument is the value to be shown at first in the
input field and the third argument is a label string.

Finally two further buttons are created. The first one is for stopping
and restarting the acquisition of data. This button must be either
active or inactive, i.e.@: it's either pushed in or not. The natural
choice in this case is to use a button of type @code{"PUSH_BUTTON"}
which has exactly these properties. As we already have seen when
creating radio buttons, the function to create a button is
@code{button_create()} (@pxref{button_create()}) and the first argument
passed to it must be the type of the button. The second argument is just
the label string to be shown on its right side. Since push buttons start
of in the inactive state per default but it is probably better not to
start the experiment already acquiring data (the user probably first
will have to set a reasonable field value) we have to activate button
(indicating that the acquisition is stopped) by calling
@code{button_state()} (@pxref{button_state()}) with the buttons handle
and the new state to be set.

The last button for clearing the display is just a normal button, i.e.@:
a button that just can be clicked on. This is indicated by the button
type @code{"NORMAL_BUTTON"} as the first argument to
@code{button_create()} (@pxref{button_create()}).

The creation of all the buttons and in- and output fields is enclosed by
two calls of the function @code{hide_toolbox()} (@pxref{hide_toolbox()})
(line 43 and 58). Before we start creating the buttons etc.@: this
disables the immediate display of the newly created objects in a window
labled "Toolbox", redrawing the window for each object. When we're done
with adding new objects we "un-hide" the window and it willl now be
visible with all the new buttons etc.@: at once.  Actually, this isn't
necessary, it's just cosmetics to make the creation of the objects look
nicer. The script will also work when you leave out both the lines.

Just before entering the main loop for the experiment we set the counter
variable @code{I}, which will be used as the @i{x}-coordinate when
drawing new data points, to @code{1}, i.e.@: to represent the leftmost
point in the display area.

After all these preparations the real fun starts. Since we can't know in
advance how many points the user is going to measure be use a
@code{FOREVER} loop, i.e.@: a loop that will run until the user hits the
@code{Stop} button. All of the test experiment will happen within this
loop.

The first action within the loop is to wait for the lock-in amplifiers
time constant. In contrast to the previous script we don't determine the
lock-ins time constant once at the start of the experiment but ask the
lock-in each time we have to wait. This is necessary because the
keyboard of the lock-in is unlocked, so the user can change the time
constant whenever he likes, so we have to make sure that we always get
the correct time constant.

As you will notice, we also wait even when the acquisition is
stopped. This is reasonable because otherwise loop would be repeated
extremely fast in paused mode, uselessly eating up computer time.


Unless the acquistion hasn't been stopped (i.e.@: as long as
@code{Pause_State} is @code{0}) we now ask the lock-in amplifier for new
data. To be able to display both the @i{x}- and @i{y}-phase signal we
tell it to return data for both channel @code{1} and @code{2}. Of
course, it must return 2 values, which it stores in an array with two
elements, @code{data}. Please note that not all lock-in amplifiers have
two channels, for these we would have to change the script a bit to
fetch and display only one data point.

After having gotten both the new measured data points we draw them in
the display at @i{x}-coordinate @code{I} and afterwards we increment
@code{I} to be prepared for the next set of data points.

Before now also stepping the field up or down we first have to check the
state of the sweep buttons -- the user may have pushed one of them. This
is what happens in the lines 74 to 89. Checking the state of a button is
done using the same function that already was used to set the state of a
button, @code{button_state()} (@pxref{button_state()}), but without a
second argument, just with the button handle as the only argument. If a
radio or push button is active it returns a non-zero number, otherwise
@code{0}.

The first of a series of tests is for the sweep up button. If it is
active but we're not sweeping up (i.e.@: when @code{Sweep_State} isn't
@code{1}) we'll have to change the @code{Sweep_State} variable to in
accordance with the users request. To also give a visual indication that
the sweep directon changed we then draw a marker at the current
coordinate. This is one via the @code{draw_marker()} function
(@pxref{draw_marker()}). It takes two arguments, the @i{x}-coordinate and
a string for the color of the marker, and will draw a vertical dashed
line in the selected color.

Of course, if the sweep-up button isn't active we also have to check the
sweep-down and the stop-sweep buttons, in exactly the same way as we did
for the sweep-up button. When we're done we know into which direction
we have to sweep the field (or if we shouldn't do a field step at all).

This brings us to the lines 91 to 109. Here the field is swept (unless
the stop-sweep button is active). But we have to be a bit careful:
before stepping up or down the field we have to make sure that the new
field value is still within the allowed limits for the magnet. (If we
don't take care here the script might be stopped by the driver for the
magnet -- but most drivers will handle the situation more gracefully by
simply refusing to sweep the field out of the allowed limits, but you
shouldn't count on this.)

If the new field value is still within the allowed range we tell the
magnet to set the new field by calling the function @code{magnet_field()}
(@pxref{magnet_field()}) with the field to be set as the argument.  It
returns the value of the new field, which we store in the @code{field}
variable. When done with this we still have to update the output field
for displaying the current field by calling the @code{output_value()}
function (@pxref{output_value()}). It takes two arguments, the handle
of the output field we got when it was created and the new value to be
displayed.

But if the new field is not within the magnets limits we have to
automatically stop the sweep and give the user a visual feedback. This
is done by setting the @code{Sweep_State} variable to @code{0},
indicating a stopped sweep. By setting the variable we avoid that the
next time we run through the loop the program again will try to change
the field. And to notify the user about this we also activate the button
the user would push for stopping a sweep and draw a marker in the same
color that would be used in this case.

But we're not finished yet. In the mean time the user might have entered
a new field or field step value in one of the input fields. To be able
to figure this out the last known value in these entry fields had been
stored in the variables @code{last_field} and @code{last_field_step}.
To check if something has changed we need to figure out the current
values in the input fields and compare them to our stored version. If
something changed we need to take appropriate action. This is what
happens during lines 111 to 130.

For both the field and the field step size we fetch the current value by
calling @code{input_value()} (@pxref{input_value()}) with just one
argument, the entry fields handle, and store the returned value in a
variable, @code{new_field} and @code{new_field_step}, respectively. Now
we can compare the last recoded value to the current value of the input
field. If they are identical nothing neeeds to be done.

But if they should differ we shouldn't blindly set a new field or field
step size but instead first check if the user supplied value is
reasonable. So we have to compare it to the minimum and maximum field or
field step size. If e.g.@: the new field value is within the allowed
range we can tell the magnet to move to the requested field and store it
in both the variables @code{field} and @code{last_field}. Of course, we
also have the output field showing the current field. On the other hand,
if the value isn't acceptable we must notify the user which we do by
resetting the input field to its previous value, using again the
@code{input_value()} function (@pxref{input_value()}).

Now we're nearly done, there only remain two more buttons to be taken
care of. Handling the button for stopping the acquisition is simple --
we just have to get its state and set the @code{Pause_State} variable
accordingly, which is done in line 133.

Also dealing with the button for clearing the display isn't complicated.
First we must determine if it had been clicked on in the mean
time. Again, we can use the @code{button_state()} (@pxref{button_state()})
function. It will return a non-zero value if the button has been clicked
on since the last invocation of the function for this button, otherwise
@code{0}. (Actually, the value returned by the function is the number of
times the button was clicked on since the last call.)

If the user clicked onto the button we have to clear both the curves and
also remove the markers that might have been drawn, using the functions
@code{clear_curve()} (@pxref{clear_curve()}) and @code{clear_marker()}
(@pxref{clear_marker()}) (if invoked without an argument the functions
remove all curves and markers, otherwise you would have to supply a list
of curve numbers and marker handles).  But we also call the function
@code{rescale()} (@pxref{rescale()}) to reduce the @i{x}-scaling to some
reasonable value (here @code{64}) -- if we wouldn't do so and the number
of points displayed before removing the curves was very large, e.g.@:
10000, the @i{x}-scaling would remain set for displaying 10000 points,
which would probably be rather not what the user expects.

Finally, we also have to set the counter variable @code{I} to @code{1}
in order to have the next measured value drawn at the leftmost position
of the display (instead to the right of the deleted curve).


@node Hahn-echo detected EPR script, ESEEM script, cw-EPR monitor script, Example EDL Scripts
@section Hahn-echo detected EPR script

The following script is for an EPR experiment, measuring the area of a
simple (2-pulse) Hahn-echo as a function of the field. Thus it is
somewhat similar to the very first script of this chapter, but with the
additional complication of adding the creation of pulses and using a
digitizer instead of a lock-in amplifier to do the detection:
@example
 1 DEVICES:
 2
 3 dg2020_b;     // pulser
 4 tds754a;      // digitizer
 5 er032m;       // field controller
 6
 7
 8 VARIABLES:
 9 
10 start_field = 3400 G;
11 end_field   = 3480 G;
12 field_step  = 0.5 G;
13 
14 pi_half     = 40 ns;
15 tau         = 200 ns;
16 
17 field = start_field;
18 area[ 2 ];
19 W[ 2 ];
20 I = 1;
31 
32 
33 ASSIGNMENTS:
34 
35 TIMEBASE:     5 ns;
36 TRIGGER_MODE: INTERNAL, REPEAT_FREQUENCY = 100 Hz;
37 
38 MICROWAVE:     POD = 1, V_HIGH = 5 V, V_LOW = 0 V;
39 DETECTION:     POD = 3;
40 
41 
42 PREPARATIONS:
43 
44 PULSE_1: FUNCTION = MICROWAVE,
45          START    = 0 ns,
46          LENGTH   = pi_half;
47 
48 PULSE_2: FUNCTION = MICROWAVE,
49          START    = PULSE_1.START + PULSE_1.LENGTH + tau,
50          LENGTH   = 2 * pi_half;
51 
52 PULSE_3: FUNCTION = DETECTION,
53          START    = PULSE_2.START + PULSE_2.LENGTH / 2 + tau,
54          LENGTH   = 10 ns;
55 
56 magnet_setup( start_field, end_field );
57 init_1d( 1, 0, start_field, field_step,
58          "Field [G]", "Echo area [mV * ns]" );
59 
60 digitizer_num_averages( 100 );
61 digitizer_trigger_channel( AUX );
62 digitizer_trigger_position( 0.2 );
63 
64 W[ 1 ] = digitizer_define_window( -5 ns, 10 ns );
65 W[ 2 ] = digitizer_define_window( 200 ns, 10 ns );
66 
67 
68 EXPERIMENT:
69 
70 WHILE field <= end_field @{
71     digitizer_start_acquisition( );
72     area[ 1 ] = digitizer_get_area( CH1, W[ 1 ] );
73     area[ 2 ] = digitizer_get_area( CH1, W[ 2 ] );
74     display_1d( I, ( area[ 1 ] - area[ 2 ] ) * 1.0e12 );
75     I += 1;
76     fsave( "# # # #\n", field, area[ 1 ], area[ 2 ],
77                         area[ 1 ] - area[ 2 ] );
78     field = sweep_up( )
79 @}
@end example

As usual, the script starts with the @code{DEVICES} section, telling
@code{fsc2} that the Berlin version of the driver for the
@code{Sny/Tektronix DG2020} pulser, the @code{Tektronix TDS754A}
digitizer and the @code{Bruker ER032M} field controller are going to be
used in the experiment.

In the @code{VARIABLES} section we need variables for the field sweep,
i.e.@: the start and end field and the field sweep with. Then we declare
a variable with the length of a pi-half pulse and the edge-to-edge
distance of the two pulses we're going to use. 

Finally, we have a variable for storing the current field, an array with
two elements for the echo area and an area off-signal, another array for
digitizer window descriptors (to be explained later) and a counter
variable.

Then follows a section which we haven't had to deal with until now, the
@code{ASSIGNMENTS} section. It is for the basic set up of the pulser.

As the very first thing (line 35) we need to set the timebase the
pulser is going to be used with. It always has to be the first
instruction because all timings in later statements concerning the
pulser must be integer multiples of this timebase and the program can
only check this when it already knows about the timebase.

The next statment sets the trigger mode for the pulser. Here we tell
@code{fsc2} to use the internal trigger of the pulser and to take care
that the repetition frequency is @w{200 Hz}. If we wouldn't set a
repetition frequency (or time), the pulser would repeat the pulse
sequence with the highest possible rate. This wouldn't make to much
sense, not only because didgitizers usually can't sample data that fast,
but also because we need some time for the spin system to relax back to
Boltzmann distribution before applying the pulse sequence again.

The following lines are for setting up pulser functions. Each pulse is
supposed to have a function. Typical functions are @code{MICROWAVE},
@code{TWT}, @code{RADIO_FREQUENCY}, @code{DETECTION} and many more.
For this simple experiment we only need two functions, we need microwave
pulses and another pulse to trigger the digitizer at the right moment,
i.e.@: a detection pulse. For each of the used functions the output
channel(s) of the pulser must be defined, i.e.@: on which of its
connectors the pulse will appear. Here we tell @code{fsc2} to route
microwave pulses to the output pod @code{1} and the detection pulse to
pod @code{3}. Additionally, we also set the high voltage for the
microwave pulses to @w{+5 V} and the low voltage to @w{0 V}.

The declaration of the pulses happens in the @code{PREPARATIONS}
section, starting at line 44. Pulses always start with the word
@code{PULSE} (but which can be abbreviated to a simple @code{P}),
followed by an optional underscore and end in a unique number which must
be non-negative. @code{PULSE_7}, @code{PULSE7}, @code{P_7} and @code{P7}
are all legal names of the same pulse. For each pulse at least its
function and start position must be set. As long as its length isn't
set the pulse cannot be used (there is an exception for pulsers that can
generate trigger pulses of only a fixed length).

In line 44 the definition of pulse @code{PULSE_1} (which also could be
called @code{P1}) starts: its function is set to @code{MICROWAVE},
i.e.@: it will be output on the pulsers pod designated for microwave
pulses in the @code{ASSIGNMENTS} section, its starting position is
@w{0 ns} after the trigger and its length is set to the value stored
in the variable @code{pi_half}.

@code{PULSE_2} is also a microwave pulse, but is starts displaced by a
time @code{tau} after the falling edge of the first pulse,
@code{PULSE_1}. As you can see from the code you can use the properties
of already pulses by a combination of the pulse name, a dot, and the
name of the property.

Finally, @code{PULSE_3} is the trigger pulse for the digitizer. It is
supposed to appear exactly on top of the echo, i.e.@: after twice the
time between the middle of the first and the second pulse. Its length 
isn't really that important, a rather short pulse should do fine.

The next lines starting at line 56 should already be well known from the
first script for a normal @i{cw}-experiment: the magnet and the graphics
get initialized.

Because we use here a digitizer to measure the echo area we also should
set up the digitizer. Calling the function
@code{digitizer_num_averages()} (@pxref{digitizer_num_averages()}) we set
the digitizer to always accumulate the results of 100 repetitions of the
pulse sequence. @code{digitizer_trigger_channel()}
(@pxref{digitizer_trigger_channel()}) tells the digitizer to expect the
trigger signal on its @code{AUX} channel. The next call of
@code{digitizer_trigger_position()} (@pxref{digitizer_trigger_position()})
sets the position within the trace it records. By setting it to 0.2 the
digitzer will use a pretrigger a fifth (of 20%) of the measured trace.

Finally, we must define ranges for measuring the area, otherwise the
digitizer would return the area of the full trace. This is done by
calling the @code{digitizer_define_window()} function
(@pxref{digitizer_define_window()}), which expects up to two arguments,
the start position of the range (relative to the trigger position and
its length. It returns an integer number which in the following is used
in further function calls for the digitizer. Here we define two windows,
with the first on top of the echo and another one far of the echo to
allow background subtraction. The window handles returned by the
function calls are stored in the array @code{W}.

Now we are done with all preparations and can start with the
@code{EXPERIMENT} section. The whole experiment is done within a
@code{WHILE} loop, which is repeated until the field has reached the end
field.

Since the pulser is already running the first thing to be done in the
loop is to start an acquisition sequence of the digitizer by calling
@code{digitizer_start_acquisition()}
(@pxref{digitizer_start_acquisition()}). This function only returns when
the digitizer is finished accumulating the requested number of traces.
When it is done we first fetch the area where the echo is supposed to be
by calling @code{digitizer_get_area()} (@pxref{digitizer_get_area()}). The
function expects two arguments, the channel used for measuring (here
channel 1, @code{CH1}), and the handle for the window previously
defined. After storing the result in the first element of array
@code{area} we call the function again to also get the off-signal area.

The next thing to be done is to display the area, or to be precise, the
difference between the on-signal and the off-signal areas, multiplied by
1.0e12 because in the call of @code{init_1d()} we promised to display
the signal in units of mV times ns, but the digitizer returns the areas
always in Vs units. Afterwards we have to increment the counter @code{I}
to be prepared for displaying the next data point.

We also need to write the data to a file, which is done by the next call
of @code{fsave()} (@pxref{fsave()}). Here we write first the current
field, both areas and the difference between the areas to a file. Since
we didn't open a file explicitely by a call of e.g.@: @code{get_file()}
(@pxref{get_file()}) we don't have a file handle to pass to the function
as the first argument as we did in the first script. Instead we simply
leave out the file handle. In this case the first time the script needs
to write to the file a file selector box pops up.

All left to be done in the loop of the experiemnt is to sweep up the
field. The new field value as returned by @code{sweep_up()}
(@pxref{sweep_up()}) is stored in the @code{field} variable. which then is
used at the begin of the loop to figure out if the experiment has to
continue or if the end field has already been reached.


@node ESEEM script, Time-resolved EPR script, Hahn-echo detected EPR script, Example EDL Scripts
@section ESEEM script

The following script is for a 3-pulse (stimulated echo) ESEEM
experiment. It uses the Oxford magnet for the @w{275 GHz} spectrometer
at the Rijksuniversiteit Leiden, a special pulser used there and the
RB8509 ADC (which converts the voltage measured via a boxcar integrator,
that can't be connected directly to the computer). As you will see there
aren't too many differences to the previous script, the most interesting
part is probably how the pulses are moved during the experiment.

@example
 1DEVICES:
 2
 3 ips120_10;            // magnet power supply
 4 rb_pulser;            // pulser
 5 rb8509;               // ADC (connected to boxcar)
 6
 7 VARIABLES:
 8
 9 repeat_time = 50 ms;
10 p1_to_p2_dist = 400 ns;
11 p2_to_p3_dist = 400 ns;
12 p2_to_p3_incr = 20 ns;
13 p1_len = 100 ns;
14 p2_len = 200 ns;
15 p3_len = 200 ns;
16 field = 90000 G;
17 N_Avg  = 10;
18 I;
19 data;
20 File;
21 
22 ASSIGNMENTS:
23 
24 TRIGGER_MODE: INTERNAL, REPEAT_TIME = repeat_time;
25 
26 PREPARATIONS:
27 
28 P1:  FUNCTION    = MICROWAVE,
29      START       = 120 ns,
30      LENGTH      = p1_len;
31 
32 P2:  FUNCTION    = MICROWAVE,
33      START       = P1.START + p1_to_p2_dist + 0.5 * ( P1.LENGTH - p2_len ),
34      LENGTH      = p2_len;
35 
36 P3:  FUNCTION    = MICROWAVE,
37      START       = P2.START + p2_to_p3_dist + 0.5 * ( P2.LENGTH - p3_len ),
38      DELTA_START = p2_to_p3_incr,
39      LENGTH      = p3_len;
40 
41 P4:  FUNCTION    = DETECTION,
42      START       = P3.START + p1_to_p2_dist + 0.5 * P3.LENGTH,
43      DELTA_START = p2_to_p3_incr,
44      LENGTH      = 100 ns;
45 
46 init_1d( 1, 0, p2_to_p3_dist / 1 ns, p2_to_p3_incr / 1 ns,
47          "Pulse separation [ns]", "Echo amplitude [a.u.]" );
48 
49 EXPERIMENT:
50 
51 magnet_field( field );
52 
53 File = get_file( );
54 
55 I = 1;
56 pulser_state( "ON" );
57 daq_gain( 4 );
58 
59 FOREVER @{
60     wait( 1.1 * repeat_time * N_Avg );
61     data = daq_get_voltage( CH0 );
62     display( I, data );
63     fsave( File, "#,#\n",
64            ( p2_to_p3_dist + p2_to_p3_incr * ( I - 1 ) ) / 1 ns, data );
65     pulser_shift( );
66     pulser_update( );	
67     I += 1;
68 @}
69 
70 ON_STOP:
71 
72 save_comment( File, "%" );
@end example


In the @code{DEVICES} section three devices are needed, the magnet power
supply, the pulser and a device or measuring the data, here it's a
analog/digital converter which has it's input connected to a boxcar
integrator. The signal goes to the boxcar and integrates a number of
signals on each trigger it receives (the set-up of the boxcar is done
manually).

In the @code{VARIABLES} section we first have a variable for the
repetition time of the pulse sequence. The next two are the
center-to-center distances between the first and second and second
and third microwave pulse as well as the increment of the distance
between the second and third pulse. Then follow the lenghts of all
three pulses. Finally, we need the field at which the experiment is#
to be done and the number of averages to do for each pulse separation
step and, as usual, a counter, a value for storing a data point and
a file handle.

The @code{ASSIGNMENTS} section for the pulser used is rather simlple:
since the functions of the pulses can't be changed only the trigger
mode and, with te mode, the repetition time needs to be set.

In the @code{PREPARATIONS} section first the pulses must be defined.
The first microwave pulse can't start earlier then at @w{120 ns},
so that's used as the start time of the first pulse. The start
positions of both the other microwave pulses need a bit of
calculations since the values in the @code{VARIABLES} section
are center-to-center pulse separations, but here start positions
are needed. The fourth pulse is the detection pulse that triggers
the boxcar integrator - it's required position can be calculated
from the ones of the three microwave pulses.

The other thing to be done in the @code{PREPARATIONS} section is
the initialization of the graphics with @code{init_1d()}
(@pxref{init_1d()}) - we need an @code{x}-axis that shows the
distance between the second and third microwave pulse.

The first things to be done in the @code{EXPERIMENT} section are
telling the magnet power supply to go to the required field value
using the @code{magnet_field()} function (@pxref{magnet_field()}),
open a file for saving the data using @code{get_file()}
(@pxref{get_file()}), switch on the pulser by a call of
@code{pulser_state()} (@pxref{pulser_state()}) and set a gain factor
for the DAC with @code{daq_gain()} (@pxref{daq_gain()}). Then the
usual loop starts.

Within the loop we first need to wait long enough for the boxcar
to average over as many pulse sequences as required - we wait
for 10% longer than necessary to be on the safe side, that's what
the additional factor of @code{1.1} is meant for. Then the DAC is
told to convert the voltage from the boxcar using @code{daq_get_voltage()}
(@pxref{daq_get_voltage()}) and this value is displayed and,
together with the current pulse separation in nano-seconds, written
into the data file. All then left to be done is to shift the third
microwave and the detection pulse using @code{pulser_shift()}
(@pxref{pulser_shift()}) and asking the pulser to update the pulse
sequence with @code{pulser_update()} (@pxref{pulser_update()}).

Since one usually doesn't know at which pulse separation the signal
will have become undetectable the whole loop is an infinite loop,
i.e.@: the experiment only stops when the user presses the @code{STOP}
button.

Once the user has just done that it should still be possible to enter
some comments, e.g.@: which sample was used and other experimental
conditions. For this we need the @code{ON_STOP} pseudo-section: the
program will jump to this point when the @code{STOP} button gets
pressed and the remaining code following this label is executed
(while this happens the @code{STOP} button has no function anymore).
Calling the function @code{save_comment()} (@pxref{save_comment()})
opens up a new window where the user can input arbitrary text that
then will get appended to the data file.


@node Time-resolved EPR script, , ESEEM script, Example EDL Scripts
@section Time-resolved EPR script

The next script is one that has already been used extensively in
experiments, so it's not just an example but for real. The field is
swept over a certain field range and at each field point after a laser
flash a trace is fetched from the digitizer (or, to be precise, after a
certain number of traces has been averaged), which is then displayed and
written to a file.

@example
 1 DEVICES:
 2
 3 er035m_s;          // gaussmeter
 4 aeg_x_band;        // magnet
 5 tds754a;           // digitizer
 6
 7
 8 VARIABLES:
 9
10 start_field = 3300 G;
11 end_field   = 3500 G;
12 field_step  = 1 G;
13 Num_avg = 10;
14
15 field = start_field;
16 N = int( abs( ( end_field - start_field ) / field_step ) ) + 1;
17 I;
18 curve[ * ];
19 Rec_len;
20 trig_pos;
21 File;
22 Pretrigger;
23 background = 0.0;
24
25
26 PREPARATIONS:
27
28 init_2d( 2, 0, N, 0, 1, start_field, field_step, "Time [s]",
29          "Field [G]", "Signal [mV] " );
30 magnet_setup( start_field, field_step );
31 digitizer_num_averages( Num_avg );
32 digitizer_trigger_channel( AUX );
33
34
35 EXPERIMENT:
36
37 Rec_len   = digitizer_record_length( );
38 trig_pos  = digitizer_trigger_position( 0.1 );
39 time_res  = digitizer_time_per_point( );
40 Pretrigger = int( 0.9 * trig_pos * Rec_len );
41
42 change_scale( ( - trig_pos * Rec_len * time_res ) / 1 us,
43               digitizer_time_per_point( ) / 1 us );
44
45 File = get_file( );
46 fsave( File, "% Start field     = # G\n"
47              "% End field       = # G\n"
48              "% Field step size = # G\n"
49              "% Num. averages   = #\n"
50              "% Time resolution = # us\n"
51              "% Trigger pos.    = #\n"
52              "% Record length   = #\n",
53        start_field, end_field, field_step, Num_avg,
54        digitizer_time_per_point( ) / 1 us,
55        trig_pos * Rec_len, Rec_len );
56 save_program( File, "% " );
57 save_comment( File, "% " );
58
59
60 FOR I = 1 : N @{
61     digitizer_start_acquisition( );
62     curve = digitizer_get_curve( CH1 );
63
64     background = mean( curve, 1, Pretrigger );
65
66     display( 1, I, curve / 1 mV, 1,
67              1, I, ( curve - background ) / 1 mV, 2 );
68
69     fsave( File, "\n% #.: Field = # G\n\n", I, field );
70     save( File, curve );
71
72     field = sweep_up( );
73 @}
@end example

There aren't too many new things in this script. In the @code{DEVICES}
section the modules for the gaussmeter, the field controller and the
digitizer get loaded. In the @code{VARIABLES} section first the
variables that get often changed are listed, i.e.@: the start and end
field, the field step and the number of laser flashes to average over at
each field. Then several other variables used during the experiment are 
declared.

In the @code{PREPARATIONS} section the graphics get initialized, we will
display the averaged traces at each field point, so we need a 2D
display. We're going to display 2 curves, one with the raw data and one
where we try to do some background subtraction by taking some points
before the laser flash and subtracting their mean value from the
curve. This should take care of slow drifts of the base line.

We will display the time traces along the @i{i}-axis and have the
@i{y}-axis as the field axis. Since we don't know yet the length of a
trace we pass the @code{init_2d()} function a @code{0} as the number of
points in @i{x}-direction. On the other hand we already calculated how
many field points we're going to measure, so we can specify it. Also for
the scaling of the @i{x}-axis we still have to pass the function some
dummy values, because we know about them only after we have talked to
the digitizer. But since we know the start field and the field step we
can already set up the scaling for the @i{y}-axis.

The initialization of the magnet in line 30 is straight forward again.
After this we also set up the number of averages the digitizer is going
to do and that the digitizer is supposed to receive its trigger from
channel @code{AUX} (the trigger comes from a diode detecting the laser
flash).

Now the experiment already gets started. We ask the digitizer for the
length of the traces and then set it to a pretrigger of 10% of the total
curve length. Then we ask it again for the time resolution (i.e.@: the
time difference between two points in a trace. Finally we calculate the
number of points of the pretrigger phase (multiplied by 0.9 to avoid
getting too near to the point where the laser flash comes in). This
number is later used in the background subtraction.

Since we now know the exact timing we can set up the scaling for the
@i{x}-axis. We would like to have the laser flash at time 0, so we tell
the program that the first point is at a negative time, the time before
the laser flash.

Before we finally start the experiment alll relevant parameters of the
experiment get written to the output file. After obtaining a file via
the @code{get_file()} function the start and end field and the the field
step width, the number of averages, the time resolution, the trigger
position and the length of the traces get written into the file as well
as the text of the @code{EDL} script itself. Calling
@code{save_comment()} allows the user to enter some further text,
like the name of the sample, the temperature etc.@: into the file.

And now the experiment starts for real. Everything is done in a loop
over all field points. At each field point we ask the digitizer to start
an acquisistion (consisting of averaging over the number of traces
specified above in the call of @code{digitizer_num_averages()} and then
ask it for the curve it measured on channel @code{CH1}. For the
background subtraction we calculate in line 64 the mean value of the
first @code{Pretrigger} points of the measured curve, i.e.@: the
points before the laser flash.

Now we only have to display and store the new curve. In line 66 we
display both the raw curve and the curve after background subtraction
(in both cases divided by @code{1 mV} because we want to display
the measured voltage in units uf milli-volts). 

Before each new set of data we write the current field value into the
file in line 69.  Storing the whole set of points of the trace is done
by a simple call of @code{fsave()}, it will write all points one after
each other into the file.

Everything left to be done is sweeping the field to the next field
value and the loop can start with the fetching the next curve.
