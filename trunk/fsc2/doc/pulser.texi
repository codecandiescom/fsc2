@c $Id$
@c
@c Copyright (C) 2001 Jens Thoms Toerring
@c
@c This file is part of fsc2.
@c
@c Fsc2 is free software; you can redistribute it and/or modify
@c it under the terms of the GNU General Public License as published by
@c the Free Software Foundation; either version 2, or (at your option)
@c any later version.
@c
@c Fsc2 is distributed in the hope that it will be useful,
@c but WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with fsc2; see the file COPYING.  If not, write to
@c the Free Software Foundation, 59 Temple Place - Suite 330,
@c Boston, MA 02111-1307, USA.


@node Using Pulsers, Command Line Options, Device Functions, Top
@chapter Using Pulsers

@ifinfo
@menu
* Pulser Overview::        Introduction
* Setting up the Pulser::  @code{ASSIGNMENTS} and @code{PHASES} section
* Defining Pulses::        How to define pulses
* Using Pulses::           How to use pulses in the experiment
@end menu
@end ifinfo


@c ########################################################

@node Pulser Overview, Setting up the Pulser, Using Pulsers, Using Pulsers
@section Pulser Overview

Using the pulsers has its own chapter, covering the special methods to
handle the pulser setup, create pulses und do phase cycling. It also
describes how the way the pulser is to be used depends on the hardware
used in the spectrometer. Currently, there are three
pulsers/spectrometer combinations of implemented:
@itemize @bullet
@item Sony/Tektronix DG2020 with S-band spectrometer in Frankfurt/Main
@item Sony/Tektronix DG2020 with X-band spectrometer in Berlin
@item Tektronix HFS9003 with W-band spectrometer in Berlin
@end itemize
Because of the importance of the pulser for time-resolved experiments
there are even two additional types of sections in the @acronym{EDL}
program in order to set up the pulser. These
are@footnote{@code{ASSIGNMENTS:} can be abbreviated to
@code{ASSIGNMENT:} or @code{ASS:} and @code{PHASES:} to @code{PHA}.}
@example
ASSIGNMENTS:
PHASES:
@end example
The first section deals with the basic setup of the pulser, the second
is only needed when phase cycling is used.  Valid statements in these
sections differ slightly depending on the type of the pulser and the
spectrometer.

Beside these additional sections there are several other constructs for
the creation of pulses and their subsequent manipulation. These are
identical for all pulsers and are explained in in subsequent sections of
this chapter.


@c ########################################################

@node Setting up the Pulser, Defining Pulses, Pulser Overview, Using Pulsers
@section Setting up the Pulser

The basic setup of the pulser happens in the @code{ASSIGNMENTS} and the
@code{PHASES} section. The latter section will be missing if no phase
cycling is planned for the experinment.


@c ########################################################

@anchor{ASSIGNMENTS section}
@subsection @code{ASSIGNMENTS} section
@cindex @code{ASSIGNMENTS} section

Within the @code{ASSIGNMENTS} section the pulsers timebase and the
trigger mode is set. It also deals with the basic setup of the channels,
i.e. associating some or more output channels with certain functions and
setting the physical characteristics of the channels (e.g.@: voltages
etc.).

@c ########################################################

@anchor{Setting the TIMEBASE}
@subsubsection Setting the @code{TIMEBASE}
@cindex Setting the @code{TIMEBASE}
@cindex @code{TIMEBASE}


The first statement of the @code{ASSIGNMENTS} section has to be the
setting of the timebase of the pulser. All pulsers function similarly:
they have a certain number of time slices (65536, 2^16) and for each of
them the output of the pulser can be either set to a high or a low
voltage. By setting the output during one or more of these time slices
to a high voltage (and for the neighbouring slices to low) pulses are
created.  The timebase to be set first in the @code{ASSIGNMENT} section
is the length of one of these time slices. From the above it is clear,
that all pulses (as well as all the times between pulses) have to be
integer multiples of the length of this timebase.

The statement to set the timebase, i.e.@: the length of the individual
time slices is@footnote{Instead of @code{TIMEBASE} one may also write
@code{TB:}, @code{T_B}, @code{TBASE:}, @code{T_BASE:}, @code{TIMEB},
@code{TIME_B:} or @code{TIME_BASE:} instead of @code{TIMEBASE:}.}:
@example
TIMEBASE: 5 ns;
@end example

The minumum and maximum values for the timebase differ for both types of
pulsers:
@itemize @bullet
@item Sony/Tektronix DG2020: @w{5 ns} to @w{0.1 s}
@item Tektronix HFS9003: @w{1.6 ns} to @w{20 us}
@end itemize


@c ########################################################

@anchor{Setting the trigger mode}
@subsubsection Setting the trigger mode
@cindex Setting the trigger mode
@cindex @code{TRIGGER_MODE}
@cindex @code{REPEAT_FREQUENCY}
@cindex @code{REPEAT_TIME}
@cindex @code{INTERNAL}
@cindex @code{EXTERNAL}
@cindex @code{SLOPE}
@cindex @code{LEVEL}
@cindex @code{IMPEDANCE}


The next statement concerns the triggering of the pulser. A pulser
starts a new sequence of pulses either on receiving an external trigger
or it has to use an internal trigger. Which type of triggering to use
depends, of course, on the experiment. To set either internal or
external trigger use a statement like this@footnote{Instead of
@code{TRIGGER_MODE} also @code{TM:}, @code{T_M:}, @code{TRIGM:},
@code{TRIG_M:}, @code{TRIGMODE:}, @code{TRIG_MODE:}, @code{T_MODE:},
@code{TMODE:}, @code{TRIGGER_M:}, @code{TRIGGERM:} or
@code{TRIGGERMODE:} can be used. And the keywords @code{INTERNAL} and
@code{EXTERNAL} can be shortend to @code{INTERN} or @code{INT} and
@code{EXTERN} or @code{EXT}.}:
@example
TRIGGER_MODE: INTERNAL;
@end example
or
@example
TRIGGER_MODE: EXTERNAL;
@end example

When using the internal trigger it is useful to be able to set the rate
or the frequency with which the experiment is repeated. Thus, for
internal triggering, for the @strong{Sony/Tektronix DG2020} an
additional keyword can be specified, either @code{REPEAT_TIME} or
@code{REPEAT_FREQUENCY}@footnote{@code{REPEAT_TIME} and
@code{REPEAT_FREQUENCY} may also be abbreviated to @code{REPT},
@code{REP_T}, @code{REPTIME}, @code{REPEAT_TIME}, @code{REPEAT_T},
@code{REPEATT} or @code{REPEATTIME} and @code{REPF}, @code{REP_F},
@code{REPFREQ}, @code{REP_FREQ}, @code{REPFREQUENCY},
@code{REP_FREQUENCY}, @code{REPEATF}, @code{REPEAT_F},
@code{REPEATFREQ}, @code{REPEAT_FREQ} or @code{REPEATFREQUENCY}.}, i.e.@
one may use:
@example
TRIGGER_MODE: INTERNAL, REPEAT_TIME = 10 ms;
@end example
or
@example
TRIGGER_MODE: INTERNAL, REPEAT_FREQUENCY = 100 Hz;
@end example
to set the repetition rate of the the experiment to @w{100 Hz}. Please
note that the repeat time must be an integer multiple of the timebase of
the pulser.

Please note: Unfortunately, for the @strong{Tektronix HFS9000} no
frequency or rate can be set, so an external trigger has to be used to
determine the repetition rate of the experiment, otherwise the pulser
will repeat the pulse sequence at the highest possible rate.

On the other hand, when using an external trigger one may want to set
the trigger level, slope and, possibly, the trigger input
impedance. This done using a statement similar to one of
these@footnote{The keywords @code{LEVEL} can be shortend to @code{LEV},
@code{SLOPE} to @code{SL}, @code{POSITIVE} to @code{POS},
@code{NEGATIVE} to @code{NEG}, @code{IMPEDANCE} to @code{IMP} and,
finally, @code{HIGH} to @code{H} and @code{LOW} to @code{L}.}:
@example
TRIG_MODE: EXTERNAL, LEVEL = 3.5 V, SLOPE = NEGATIVE, IMPEDANCE = LOW;
@end example
or
@example
TM: EXTERNAL, LEVEL = -1.2 V, SLOPE = POSITIVE, IMPEDANCE = HIGH;
@end example
Please note: The trigger input impedance can only be set for the
@strong{Sony/Tektronix DG2020}.

For the @strong{Sony/Tektronix DG2020} the trigger level must be in the
range between @w{-5V} and @w{+5 V}, while for the @strong{Tektronix
HFS9003} the allowed trigger level range is @w{-4.7 V} to @w{+4.7 V}.


@c ########################################################

@anchor{Channel setup}
@subsubsection Channel setup
@cindex Channel setup
@cindex @code{MICROWAVE}
@cindex @code{TWT}
@cindex @code{TWT_GATE}
@cindex @code{DETECTION}
@cindex @code{DETECTION_GATE}
@cindex @code{DEFENSE}
@cindex @code{RADIO_FREQUENCY}
@cindex @code{RADIO_FREQUENCY_GATE}
@cindex @code{PULSE_SHAPER}
@cindex @code{OTHER_1}
@cindex @code{OTHER_2}
@cindex @code{OTHER_3}
@cindex @code{OTHER_4}
@cindex @code{CHANNEL}
@cindex @code{POD}
@cindex @code{TRIGGER_OUT}
@cindex @code{V_HIGH}
@cindex @code{V_LOW}
@cindex @code{INVERTED}
@cindex @code{DELAY}

The statements described in the following deal with setting up the
channels of the pulser. The basic idea is to abstract from the real
output connectors of the pulser and to use symbolic names for the
channels. Instead of telling the pulser to output a pulse from e.g.@:
connector @w{numbered 1} of the pulser in the experiment, in the
@code{ASSIGNMENTS} section symbolic names for the functions of the
channels are defined and these symbolic names are used when specifying
pulses. While this may be only a convenience in simple experiments (you
only have to do a change in one place when changing the output instead
of finding and changing it for all pulses concerned) it makes doing
phase cycling much simpler because here the same pulse may have to be
output on different channels, depending on the current phase. So,
instead of always specifying which output channel to use for a certain
phase for each phase, the program is told about which channels to use
for a function and then it's left to the program to do all the
bookkeeping when to use which output channel.

The following symbolic names for pulse functions are defined:
@itemize @bullet
@item @code{MICROWAVE} (or @code{MW} etc.@footnote{The function
@code{MICROWAVE} can also be abbreviated to @code{MICRO_WAVE}, @code{MICROW},
@code{MICRO_W}, @code{MWAVE}, @code{M_WAVE} or @code{M_W}})
@item @code{TRAVELING_WAVE_TUBE} (or @code{TWT} etc.@footnote{Instead of
@code{TRAVELING_WAVE_TUBE} all other combinations, where any of
constituting words is replaced by its initial character or one or all
underscore characters are missing can be used.})
@item @code{TRAVELING_WAVE_TUBE_GATE} (or @code{TWTG}
etc.@footnote{@code{TRAVELING_WAVE_TUBE_GATE} may also be abbreviated by
all combinations, where any of constituting words is replaced by its
initial character or one or all underscore characters are missing.})
@item @code{DETECTION} (or @code{DET})
@item @code{DETECTION_GATE} (or @code{DETG}
etc.@footnote{@code{DETECTION_GATE} can be also shortened to
@code{DET_G}, @code{DETECTIONGATE}, @code{DETECTION_G},
@code{DETECTIONG}, @code{DET_GATE} or @code{DETGATE}.})
@item @code{DEFENSE} (of @code{DEF})
@item @code{RADIO_FREQUENCY} (or @code{RF} etc.@footnote{Instead
@code{RADIO_FREQUENCY} also all combinations can be used where
@code{RADIO} is replaced by @code{R} or @code{FREQUENCY} by either
@code{FREQ} or @code{F}. The underscore can also be left out.})
@item @code{RADIO_FREQUENCY_GATE} (or @code{RFG}
etc.@footnote{For @code{RADIO_FREQUENCY_GATE} all combinations where
@code{RADIO} is replaced by @code{R}, @code{FREQUENCY} by either
@code{FREQ} or @code{F} or @code{GATE} by @code{G} may be used. As
usual, the underscore characters can be omitted.})
@item @code{PULSE_SHAPER} (or @code{PSH} etc.@footnote{You may
abbreviate @code{PULSE_SHAPER} to @code{PULSESH}, @code{PULSE_SH},
@code{PULSE_SHAPE}, @code{PULSESHAPE}, @code{PULSESHAPER}, @code{P_SH},
@code{P_SHAPE}, @code{PSHAPE}, @code{P_SHAPER}, @code{P_SHAPER}.})
@item @code{OTHER_1} (or @code{OTHER1}, @code{O_1}, @code{O1},
      @code{OTHER} or @code{O})
@item @code{OTHER_2} (or @code{OTHER2}, @code{O_2} or @code{O2})
@item @code{OTHER_3} (or @code{OTHER3}, @code{O_3} or @code{O3})
@item @code{OTHER_4} (or @code{OTHER4}, @code{O_4} or @code{O4})
@end itemize
The names of the functions do not enforce what the channels that will
become associated with them are really going to be used for, but it is
probably a good idea not to use e.g.@: the @code{MICROWAVE} channel for
something completely different (other people will have major problems
understanding what your @acronym{EDL} program is supposed to do and
there's no Obfuscated EDL Contest yet;-).

The functions @code{OTHER_1} to @code{OTHER_4} should be used in cases
where none of the function names seem to fit the special purpose you
have in mind.

Before giving an example it is important to point out that there are
some major differences between the @strong{Sony/Tektronix DG2020} and
the @strong{Tektronix HFS9003}. The @strong{Tektronix HFS9003} is quite
simple in that it has just a number of output channels. In contrast, the
@strong{Sony/Tektronix DG2020} has 36 internal channels that have to be
mapped to what is called the POD, that in both cases (Frankfurt S-band
and Berlin X-band spectrometer) has 12 real output channels. 

For the @strong{Tektronix HFS9003} simply a channel is associated with a
function by statements like
@example
MICROWAVE: CHANNEL = 1;
RF:        CHANNEL = 2;
RF_GATE:   CH = 3;
DETECTION: CHANNEL = TRIGGER_OUT;
@end example
Please note, that usually the output channels are numbered as printed on
the device, the only exception for the @strong{Tektronix HFS9003} is the
trigger-out channel, that is called @code{TRIGGER_OUT}, and has some
special properties, e.g. allowing only one pulse of a fixed length.
The keyword @code{CHANNEL} can be replaced by @code{CH} and
@code{TRIGGER_OUT} by either @code{TRIGGEROUT}, @code{TRIG_OUT} or
@code{TRIGOUT}.

For the @strong{Sony/Tektronix DG2020} the function gets associated with
one (or more pods, see below why sometimes more than one is needed):
@example
MICROWAVE: POD = 1, 2, 3, 4;
RF:        POD = 6;
RF_GATE:   POD = 7;
DETECTION: POD = 11;
@end example
Instead of @code{POD} you can also simply write @code{P}.


Optionally, for the @strong{Sony/Tektronix DG2020} you can also set
which of the internal channels should be used. If you don't the channel
the program will automatically grab as many of the internal channels as
it needs (using always the ones with the lowest numbers first). You can
tell the program which of the internal channels it should use via a
statement like this:
@example
MICROWAVE: POD = 1, 2, 3, 4  CHANNEL = 31, 32, 33, 34;
RF:        POD = 6           CHANNEL = 35;
RF_GATE:   POD = 7           CHANNEL = 17;
DETECTION: POD = 11;   // leave it to the program to select the channel
@end example


Beside defining at wich of the output connectors the pulses for a
function will appear you can also set other properties for the pulses of
a POD or channel. As far as the hardware allows it you may set the high
and the low voltage for all pulses of a function by using the keywords
@code{V_HIGH} and @code{V_LOW}@footnote{Instead of @code{V_HIGH} you can
also write @code{VHIGH}, @code{V_H} or @code{VH} and for @code{V_LOW}
you may use @code{VLOW}, @code{V_L} or @code{VL}.}:
@example
MICROWAVE: POD = 1, 2, 3, 4  V_HIGH = 4.3 V, V_LOW = -0.5 V;
RF:        POD = 6           V_HIGH = 2.6 V, V_LOW = 0 V;
RF_GATE:   POD = 7           V_HIGH = 5 V,   V_LOW = 0 V;
@end example
Please note that the high voltage must always be larger than the low
voltage.

For the @strong{Sony/Tektronix DG2020} the high voltage can be adjusted
to values between @w{-2 V} and @w{+7 V} and the low voltage can be in
the range between @w{-3 V} and @w{+6 V}. The difference between the
voltages must be between @w{0.5 V} and @w{9 V} and can be set in
increments of @w{0.1 V}.

For the @strong{Tektronix HFS9003} the high voltage can be adjusted to
values between @w{-1.5 V} and @w{+5.5 V}, the low voltage has to be in
the range from @w{-2 V} to @w{+5 V}. Rhe minimum and maximum voltage
swing is @w{0.5 V} and @w{5.5 V}, respectively, and the voltage
resolution is @w{10 mV}.

If a function requires the output levels to be inverted (i.e.@: that the
voltage is high while there are no pulses and low on pulses) use the
@code{INVERTED} keyword@footnote{The keyword @code{INVERTED} can be
shortened to @code{INVERT} or @code{INV}.}:
@example
RF:        POD = 6   V_HIGH = 2.6 V, V_LOW = 0 V, INVERTED;
@end example


Finally, in order to take care of different cable lengths a delay for a
function can be set. This delay will be automatically added to the start
position of each pulse of this function:
@example
MICROWAVE: POD = 1, 2, 3, 4  DELAY = 50 ns;
@end example
For obvious reasons setting negative delays is only possible when using
internal trigger mode@footnote{The obvious reason is, of course,
causality - the pulser can't know when the external trigger is going to
happen, so starting before the trigger is detected would be a bit
difficult. By the way, the keyword @code{DELAY} can be abbreviated to
@code{DEL}.}.


@c ########################################################

@anchor{Phase channel setup}
@subsubsection Phase channel setup
@cindex Phase channel setup
@cindex @code{PHASE_SETUP}
@cindex @code{PHASE_SWITCH_DELAY}
@cindex @code{GRACE_PERIOD}

Please note that a phase channel setup can only be done with the
@strong{Sony/Tektronix DG2020} pulsers and that there are several
differences between the Frankfurt S-band and the Berlin X-band
spectrometer. And all the following is only relevant if phase
cycling is to be used.

@strong{Berlin X-band spectrometer}:

The Berlin bridge setup is rather simple in that it expects pulses with
different phases to appear on different input channels of the microwave
bridge. The bridge has 5 different inputs (one for each phase
@code{+X}, @code{-X}, @code{+Y} and @code{-Y} and one to be used for
@i{cw} experiments) and the phase of the pulse coming fom the bridge
and going to the TWT amplifier depends on which input channel was used
for the pulse.

Now all you have to do is to tell the program once which pulser pod
channel is connected to which phase input of the bridge (and, to allow
for some sanity checks, which functions is to be phase cycled). This is
done via the following statement in the @code{ASSIGNMENTS} section:
@example
PHASE_SETUP:  MICROWAVE,
               X: POD = 1,
              +Y: POD = 2,
              -X: POD = 4,
              -Y: 2,
              CW: 3;
@end example
In this example you obviously want to phase cycle the microwave pulses
and the @code{+X} input of the bridge is connected to pod channel 1 of
the pulser etc.@footnote{As usual, the keyword @code{PHASE_SETUP} can be
abbreviated, either to @code{PH_SETUP}, @code{PHASE_S}, or @code{PHS}.}
Since you actually can have 2 phase cycled function, you may append
either @code{1} or @code{_1} and @code{2} or @code{_2} to distinguish
between the two phase setups, i.e.@: @code{PHASE_SETUP_1}.


@strong{Frankurt S-band spectrometer}:

The Frankfurt spectrometer is somewhat more complicated. The bridge has
one microwave pulse input and two further input channels that cotrol the
setting of the bridge's phase switch. So, while a microwave pulse is sent
to the bridge, further phase pulses have to be present to control the
phase switch. Two pulse inputs are enough to differentiate between the 4
phases @code{+X}, @code{-X}, @code{+Y} and @code{-Y}.

In order to create the phase pulses an extra function is needed for
these pulses, which is called @code{PHASE} (or, abbreviated @code{PH}).
For being able to feed both the bridge's phase inputs, for this function
two of the pod channels of the pulser are needed. The definition of this
function looks nearly identical to the other functions, the only
exception is that also the name of the function to be phase cycled using the
phase function needs to be specified:
@example
PHASE:        MICROWAVE, POD = 8, 9, V_HIGH = 5 V, V_LOW = 0 V;
@end example
In this example the phase function is used to phase cycle the microwave
pulses and the pod channels assigned to it are the ones numbered 8 and 9.

The second thing that is needed is which voltages have to be present at
the outputs to set a certain phase. Here's an example:
@example
PHASE_SETUP:   X: POD_1 = OFF, POD2 = OFF,
              +Y: POD1 = ON, POD_2 = 0,
              -X: 0, 1,
              -Y: 1, 1;
@end example
This phase setup command tells the program that to set the @code{+X} phase
the voltage at both pod outputs of the phase function have to be in the
low state, while for the @code{-Y} phase the first pod output (set to pod
channel 8 by the @code{PHASE} command, see above) has to be in the high
state, while the other output (pod channel 9) has to be low. @code{POD_1}
stands here for the first pod channel of the phase function,
@code{POD_2} for the second one. @code{ON} and @code{1} can both be used
to indicate a high output state, @code{OFF} and @code{0} stand for a low
state.

With these informations the program is able (or nearly is) to create the
phase pulses (i.e.@: the pulses that control the phase switch) without
the user having to deal with it. So, all that needs to be done later
is to create the microwave pulses and define the sequence of phases for
the pulse. The program will automatically create the pulses necessary to
set the phases of the microwave pulses.

One further information that is needed is the time the phase switch has
to be set to a new phase before the microwave pulses (or other phase
cycled pulses) start (the phase switch needs some small amount of time
to settle). This time can be set via a statement like
@example
PHASE_SWITCH_DELAY: 40ns;
@end example
This will lead to the phase pulse being switched at least @w{40 ns}
before the real pulse starts. When this statement is missing a default
value of @w{20 ns} is used. If there are tweo different phase functions
(e.g.@: if two different pulse functions need phase cycling) the phase
switch delay can be set individually for each of them by using
@code{PHASE_SWITCH_DELAY_1} and @code{PHASE_SWITCH_DELAY_2} (setting the
phase switch delay for the phase pulses created for phase function 1 and
2).

And, finally, one may specify how long the phase pulse should remain
switched on after the end of a pulse. This is called the grace period
and is set via
@example
GRACE_PERIOD: 20ns;
@end example
Without this statement a default grace period of @w{10 ns} will be
used.

Here's a diagram that shows the phase switch delay and the grace period:
@example
                   ____________________________
                  |                            |
Phase pulse       |                            |
             _____|                            |_________
                           _________________
                          |                 |
Microwave pulse           |                 |
             _____________|                 |____________
         
                ->|       |<-             ->|  |<-
               phase switch delay        grace period
@end example


When the program does its tests it will always check if the distances
between the pulses is large enough to allow setting the phase pulses. If
the pulse distances get very small it may drop the grace period but the
phase switch delay will always be there (or the program will abort with
an error message).


@c ########################################################

@anchor{Maximum pulse pattern length}
@subsubsection Maximum pulse pattern length
@cindex Maximum pulse pattern length
@cindex @code{MAXIMUM_PATTERN_LENGTH}

In most cases the program will be able to figure out automatically how
long the length of the longest pulse pattern in the experiment is going
to be when doing the test run. The longest pulse pattern length is
needed to set up the pulser correctly. Unfortunately, there are certain
syntax constructs that make it difficult or even impossible to find out
this maximum pattern length. These constructs are @code{FOREVER} loops
and sometimes cases, where changes of pulse positions or lengths are
done within @code{IF-ELSE} or @code{UNLESS-ELSE} constructs (please also
see the discussion of the problems introduced by @code{FOREVER} loops
and @code{IF} and @code{ELSE} constructs, @pxref{Control structures}).

Whenever there is a reason to suspect that these problems may occur one
can set the maximum pulse pattern length manually (i.e.@: the end point
of the last pulse when it has been set to its latest position in the
experiment. This is done by a statement in the @code{ASSIGMENTS} section
starting with the @code{MAXIMUM_PATTERN_LENGTH} keyword@footnote{In
@code{MAXIMUM_PATTERN_LENGTH} @code{MAXIMUM} can be abbreviated to
@code{MAX}, @code{PATTERN} to @code{PATT} and @code{LENGTH} to
@code{LEN}. The intermediate underscore characters are also optional.}:
@example
MAXIMUM_PATTERN_LENGTH: 1.2 us
@end example
This will tell the program to expect a maximum pattern length of 1.2
micro-seconds. Unless in the test run a longer pattern length is found,
this value is used. It is not a problem to specify too long a maximum
pattern length, so a conservative guess will do. The only penality
incurred is a slightly longer time needed to set up the pulser at the
start of the experiment. On the other hand, too short a pattern length
will lead to the experiment being stopped with an error message when the
actual pattern length becomes larger than the one specified.


@c ########################################################

@anchor{Keeping unused pulses}
@subsubsection Keeping unused pulses
@cindex Keeping unused pulses
@cindex @code{KEEP_ALL_PULSES}

Usually, pulses that in the test run are found to be unused in the
experiment are deleted and a warning message is printed. Any further
reference to or use of these deleted pulses would lead to the immediate
termination of the experiment. But there are a few situations where it
can't be detected in the test run that a pulse is actually needed
(e.g.@: if it is only used in an untestable @code{IF} construct) and it
gets deleted eventhough it is needed. In this case it is possible to force
the program to keep all pulses, even if they seem to be unused. This is
done by specifying the keyword @code{KEEP_ALL_PULSES} in the
@code{ASSIGNMENTS} section, i.e.@: just write
@example
KEEP_ALL_PULSES;
@end example
and pulses will not be deleted even if they seem to be unused.


@c ########################################################

@anchor{PHASES section}
@subsection @code{PHASES} section
@cindex @code{PHASES} section
@cindex @code{PHASE_SEQUENCE}
@cindex @code{ACQUSISTION_SEQUENCE}


The @code{PHASES} section is for defining phase sequences and,
optionally, acquisition sequences. As the word says a phase sequence
defines for one (or more) pulses the sequence of phases the pulse is
switched between in the experiment. For example, in a phase cycled
stimulated echo experiment the first microwave pulse usually is set
first to a @code{+X} phase, then to @code{-X}, again to @code{+X} and
finally to @code{-X}. The second pulse will run at the same time through
the sequence @code{+X}, @code{+X}, @code{-X} and @code{-X}. The third
pulse has alway the same @code{+X} phase. Because a constant phase of
@code{+X} is the default, only two phase sequences have to be defined:
@example
PHASE_SEQUENCE_1: +x, -x, +x, -x;  // for 1st pulse
PHASE_SEQUENCE_2: +x, +x, -x, -x;  // for 2nd pulse
@end example
As can be seen from this example the keyword is
@code{PHASE_SEQUENCE}@footnote{@code{PHASE_SEQUENCE}can be shortened to
@code{PHASESEQUENCE}, @code{PH_SEQUENCE}, @code{PHSEQUENCE},
@code{PHASE_SEQ}, @code{PHASESEQ}, @code{PHASEA_S}, @code{PHASES},
@code{PH_SEQ}, @code{PHSEQ}, @code{PH_S}, @code{PHS}.}, followed by an
optional underscore and the number of the phase sequence (if there is
only one phase sequence no number is needed). For the phase number any
number between 0 and 2147483647 @w{(2^32 - 1)} can be choosen. Of course
the lengths of all phase sequences have to be identical.

In one of the following sections it is explained how the phase sequences
become associated with certain pulses.

Beside the phase sequences also acquisition sequences can be defined.
These are used by some @acronym{EDL} functions to determine how the
results of the experiments with different phases have to be added up in
order to give the final result for a complete phase cycling sequence. In
the example of a phase cycled stimulated echo experiment the area of the
echo measured for the second phase setting has to be subtracted from the
area of the first phase, the area of the third also has to be subtracted, and
for the fourth the area has to be added. Thus the acquisition sequence
would be defined as:
@example
ACQUSISTION_SEQUENCE: +, -, -, +;
@end example

When one has a setup with a quadrature mixer one also can define in the
acqusition sequence which of the signals from the two digitizer channels
has to be used. The first channel is named @code{A} and the second
@code{B}. In this case one usually also needs two acquisition sequences,
one for the real part and one for the imaginary part of the signal. To
distinguish between the sequences append either @code{1} or @code{2} to
the keyword (optionally with an underscore in between. As an example
here the phase and acquisition sequence definitions for an inversion
revocery experiment with FID detection and phase cycling:
@example
PHASE_SEQUENCE_1       = +x, +x, +x, +x, -x, -x, -x, -x;
PHASE_SEQUENCE_2       = +x, -x, +y, -y, +x, -x, +y, -y;
ACQUISITION_SEQUENCE_1 = +A, -A, +B, -B, +A, -A, +B, -B;
ACQUISITION_SEQUENCE_2 = +B, -B, -A, +A, +B, -B, -A, +A;
@end example

The definition of acquisition sequences is optional and only needed if
the function @code{get_phase_cycled_area()} (see below) is going to be
used. If defined their lengths have to be identical to the lengths of
the phase sequences.



@c ########################################################


@node Defining Pulses, Using Pulses, Setting up the Pulser, Using Pulsers
@section Defining Pulses

@cindex @code{PULSE_}x
@cindex @code{FUNCTION}
@cindex @code{START}
@cindex @code{LENGTH}
@cindex @code{DELTA_START}
@cindex @code{DELTA_LENGTH}
@cindex @code{PHASE_CYCLE}


While the basic setup of the pulse happens in the @code{ASSIGNMENTS}
and, possibly, in the @code{PHASES} section, the definition of the
pulses is done in the @code{PREPARATIONS} section.

Each pulse has at least three properties: a unique number, a function
and a start position. Actually, pulses also need a length, but as long
as the length is not set (or is 0) the pulse stays switched off. Here is
an example of how to create a pulse, numbered @code{1}, that is a
microwave pulse, starts @w{100 ns} after the trigger) and has a length
of @w{250 ns}:
@example
PULSE_1:    FUNCTION = MICROWAVE,
            START    = 100 ns,
            LENGTH   = 250 ns;
@end example
As usual, most of the keywords can be abbreviated, @code{PULSE_1:} to
@code{PULSE1:}, @code{P_1:} or @code{P1:}, @code{FUNCTION} to either
@code{FUNC} or @code{F}, @code{START} to @code{S}, and finally,
@code{LENGTH} to @code{LEN} or @code{L}. And, of course, for numerical
values like pulse positions and times variables, complex expressions and
functions can be used.

Pulse numbers can be choosen randomly - the only requirement is that the
numbers are positive (including 0) and not larger than 2147483647
@w{(2^32 - 1)}. Positions and lengths of pulses have to be positive
(including 0). A pulse of zero length is invisible.

There are three additional properties a pulse can have. The first one is
the amount of time the start position of the pulse will be changed by
during the experiment, the corresponding keyword is
@code{DELTA_START}@footnote{@code{DELTA_START} can be abbreviated to
@code{DELTASTART}, @code{DELTA_S}, @code{DELTAS}, @code{DEL_START},
@code{DELSTART}, @code{DEL_S}, @code{DELS}, @code{D_START},
@code{DSTART}, @code{D_S} or @code{DS}.}. Second, there is the length
change of the pulse, @code{DELTA_LENGTH}@footnote{@code{DELTA_LENGTH}
can be shortened to @code{DELTALENGTH}, @code{DELTA_L}, @code{DELTAL},
@code{DEL_LENGTH}, @code{DELLENGTH}., @code{DEL_L}. @code{DELL},
@code{D_LENGTH}, @code{DLENGTH}, @code{DEL_L}, @code{DELL},
@code{D_LENGTH}, @code{DLENGTH}, @code{D_L} or @code{DL}.}. And finally,
there is the phase sequence to be used for phase cycling of the pulse -
here the keyword is @code{PHASE_CYCLE}@footnote{@code{PHASE_CYCLE} can
also be written as @code{PHASECYCLE}, @code{PHASE_C}, @code{PHASEC},
@code{PH_CYCLE}, @code{PHCYCLE}, @code{PH_C} or @code{PHC}.}.

With these additional properties (using, for phase cycling of the pulse,
the first phase sequence defined in the @code{PHASES} section, see
above) the definition of the pulse would look like this:
@example
PULSE_1:    FUNCTION     = MICROWAVE,
            START        = 100 ns,
            LENGTH       = 250 ns,
            DELTA_START  = 20 ns,
            DELTA_LENGTH = 35 ns,
            PHASE_CYCLE  = PHASE_SEQUENCE_1;
@end example

When setting the properties of further pulses the properties of pulses
already defined can be used. This is done by specifying the name of the
pulse (e.g.@: @code{PULSE_1}), followed by a dot and the property of the
referenced pulse to be used. For example, if you want to create a second
pulse that is also a microwave pulse, starts @w{300 ns} after the end
of the first pulse and is twice as long, you could write:
@example
PULSE_2:    FUNCTION     = PULSE_1.FUNCTION,
            START        = PULSE_1.START + PULSE_1.LENGTH + 300 ns,
            LENGTH       = 2 * PULSE_1.LENGTH;
@end example


@c ########################################################

@node Using Pulses, , Defining Pulses, Using Pulsers
@section Using Pulses


When pulses have been defined and the experiment is started (indicated by
the begin of the @code{EXPERIMENT} section) all pulses get set (as long as
their lengths are defined and non-zero) and all channels or PODs that
have been assigned pulses (that are really used in the experiment) are
switched on.

There are two methods to change the properties of pulses. TZhe first one
works by calling a dedicated function. To change the start position of,
for example, pulse 1 by the start position change time
(@code{DELTA_START}) as defined in the properties of the pulse the
function @code{pulser_shift()} (see also @ref{Pulser Functions}) can be
used:
@example
pulser_shift( P1 );      // or  pulser_shift( 1 );
@end example
Also the start position of several pulses at once can be changed because
this function also accepts a (comma separated) list of pulses. If the
function is called with no arguments at all the start positions of all
pulses that have the @code{DELTA_START} property defined are changed.

There is a similar function for changing the length of pulses by their
@code{DELTA_LENGTH}, called @code{pulser_increment()} (see also
@ref{Pulser Functions}):
@example
pulser_increment( P3 );  // or  pulser_increment( 3 );
@end example
As for the @code{pulser_shift()} function also this functions accepts a
comma separated list of pulses, and calling it with no arguments
automatically lengthens all pulses that have the @code{DELTA_LENGTH}
property defined.

The second method allows to you to change the start position or length
of a pulse directly and in increments differing from @code{DELTA_START}
or @code{DELTA_LENGTH}. If, for example, the position of pulse 4 has to
be changed to @w{500 ns} and its length to @w{120 ns}, one may simply
write
@example
P4.START  = 500 ns;
P4.LENGTH = 120 ns;
@end example
This method can also be used to switch off a pulse completely by
assigning 0 to the pulse length.

Of course, as in the definition of the pulses in the @code{PREPARATION}
section the properties of the pulse itself and other pulses can be used
in setting the new values, e.g.:
@example
P4.START  = P3.START + 200 ns;
P4.LENGTH = 2 * P4.LENGTH + 20 ns;
@end example
As you see, these properties (i.e.@: start positions and lengths and the
corresponding delta start positions and lengths) of pulses can be treated
nearly as if they are just normal variables.

Also the values for @code{DELTA_START} and @code{DELTA_LENGTH} can be
changed in this way at any time during the experiment:
@example
P4.DELTA_START  = 20 ns;
P4.DELTA_LENGTH = 10 ns;
@end example
This holds even if these properties haven't been defined in the
@code{PREPARATION} section at all.

The only pulse properties that may not be changed during the experiment
are the function and the phase sequence associated with the pulse.

There is only one point that needs to be taken care of: Just calling one
of these methods to change pulse properties does not change the real
pulses immediately. Instead, all these changes are stored internally in
the program. The changes get only send to the pulser when the function
@code{pulser_update()} (see also @ref{Pulser Functions}) is
called. Therefor, the normal way to change the pulse pattern is to
change all necessary pulse properties and when everything is done
@code{pulser_update()} is called to commit the changes. In this moment
the program will also do all its usual checks, e.g.@: it will test that
no pulses overlap.

There is a further function that resets all pulses to their intial
state, @code{pulser_pulse_reset()}. This function can, for example, be
used for repeating the same experiment several times without having to
reset each pulse individually. As in the other functions the argument
can be either one pulse, a list of pulses or no argument, in which case
all pulses are reset to their initial positions and lengths (i.e.@: as
set in the initial definition of the pulse in the @code{PREPARAIONS}
section.

Here is now a somewhat shortened example of a 2 pulse Hahn-echo
experiment. Two microwave pulses are needed, a pi-half and a pi pulse,
plus a pulse to trigger the digitizer. The trigger pulse must move twice
as fast as the second microwave pulse because the distance of the echo
from the second pulse is always as large as the distance between both
the microwave pulses.
@example
DEVICES:

dg2020_b;    // Berlin X-band spectrometer pulser
tds520c;     // digitzer

VARIABLES:

tau_0     = 200 ns;
delta_tau =  50 ns;
pi_pulse  = 100 ns;

I, J;
data[ 20, 1024];
Window;

ASSIGNMENTS:

TIMEBASE:     5 ns;
TRIGGER_MODE: INTERNAL, REPEAT_TIME = 20 ms;
MICROWAVE:    POD = 8,  V_HIGH = 5 V, V_LOW = 0 V;
DETECTION:    POD = 5,  V_HIGH = 3 V, V_LOW = 0 V;

PREPARATIONS:

P0:   FUNCTION    = MICROWAVE,       // 1st microwave pulse
      START       = 0 ns,
      LENGTH      = pi_pulse / 2;

P1:   FUNCTION    = MICROWAVE,       // 2nd microwave pulse
      LENGTH      = pi_pulse,
      START       = P0.START + P0.LENGTH / 2 + tau_0 - P1.LENGTH / 2,
      DELTA_START = delta_tau;

P2:   FUNCTION    = DETECTION,       // trigger pulse
      LENGTH      = 5 ns,
      START       = P1.START + P1.LENGTH / 2 + tau_0,
      DELTA_START = 2 * delta_tau;

Window = digitizer_define_window( P2.START + 250 ns, 100 ns );

EXPERIMENT:

FOR J = 1 : 20 @{          // repeat experiment 20 times
    FOR I = 1 : 1024 @{
        digitizer_start_acquisition( );
        data[ J, I ] = digitizer_get_area( CH1, Window );
        pulser_shift( );             // move all pulses
        pulser_update( );            // commit the changes
    @}
    pulser_pulse_reset( );           // reset all pulses
@}
@end example


Beside the functions for changing the positions and lengths of pulses
there are also functions to adjust the phases of pulses, needed for
for phase cycled experiments. When the experiment starts the phase of
a pulse is set to the first phase of its associated phase sequence
(defined in the @code{PHASES} section). To switch to the next phase the
function @code{pulser_next_phase()} (see also @ref{Pulser Functions})
has to be used. In contrast to the functions @code{pulser_shift()} and
@code{pulser_increment()} this function can not be used for phase
changes of individual pulses but alway applies to all pulses that have
been assigned a phase sequence. Thus this function does not accepts any
arguments.

Again, the necessary changes are only send to the pulser when the
function @code{pulser_update()} is called afterwards. By repeatedly
invoking @code{pulser_next_phase()} one can run through the complete
phase sequence. To reset all pulses to their start phase (i.e.@: the
first phase of the associated phase sequence) the function
@code{pulser_phase_reset()} (see also @ref{Pulser Functions}) can be
used.

The next (rather simplified) example is the program for a phase cycled
(1-dimensional) stimulated echo experiment. We need three microwave
pulses and a detection trigger pulse. During the experiment the first
two microwave pulses have to be phase cycled.
@example
DEVICES:

dg2020_b;    // Berlin X-band spectrometer pulser
tds520c;     // digitzer

VARIABLES:

tau_0     = 250 ns;   // start distance between 1st & 2nd pulse
delta_tau =  25 ns;   // and the change of this distance
t_0       = 400 ns;   // start distance between 2nd & 3rd pulse
delta_t   =  50 ns;   // and the change of this distance

area, data;
I, J;

ASSIGNMENTS:

TIMEBASE:      5 ns;
TRIGGER_MODE:  INTERNAL, REP_FREQ = 200 Hz;

MW:            POD = 1, 2, 3, 4, 5, INVERTED, V_HIGH = 5 V, V_LOW = 0 V;
DETECTION:     POD = 0,                       V_HIGH = 5 V, V_LOW = 0 V;;
      
       
PHASE_SETUP:   MW,           // cycle microwave channel
               +X: POD = 1,  // POD 1 on for +X
               -X: POD = 2,  // POD 2 on for -X
               +Y: POD = 3,  // POD 3 on for +Y
               -Y: POD = 4,  // POD 4 on for -Y
               CW: POD = 5;  // POD 5 on for CW

PHASES:

PHASE_SEQUENCE_0 = +x, -x, +x, -x;  // for 1st pulse
PHASE_SEQUENCE_1 = +x, +x, -x, -x;  // for 2nd pulse

PREPARATIONS:

P0:  FUNCTION    = MW,
     START       = 0 ns,
     LENGTH      = pi_half_pulse_length,
     PHASE_CYCLE = PHASE_SEQUENCE_0;
     
P1:  FUNCTION    = MW,
     START       = P0.START + P0.LENGTH  + tau0,
     LENGTH      = pi_half_pulse_length,
     PHASE_CYCLE = PHASE_SEQUENCE_1;

P2:  FUNCTION    = MW,
     START       = P1.START + P1.LENGTH + t0,
     LENGTH      = pi_half_pulse_length,
     DELTA_START = delta_t;

P3:  FUNCTION    = DETECTION,
     START       = P2.START + P2.LENGTH,
     LENGTH      = 10 ns,
     DELTA_START = delta_t;

init_1d( );

Window = digitizer_define_window( P3.START + 250 ns, 100 ns );

EXPERIMENT:

FOR I = 1: 128 @{
    data = 0.0;
    FOR J = 1 : 4 @{
        digitizer_start_acquisition( );
        area = digitizer_get_area( CH1, Window );

        IF J == 1 | J == 4 @{
            data += area;     // add 1st & 4th area
        @} ELSE @{
            data -= area;     // subtract 2nd & 3rd area
        @}

        pulser_next_phase( );
        pulser_update( );
    @}

    display( I, data );
    pulser_shift( );
    pulser_update( );
@}
@end example


@anchor{ Simplified pulse cycling }
@subsection Simplified pulse cycling
@cindex Simplified pulse cycling


The inner loop in the previous example runs through the 4 different
phase settings, adding up the areas with the correct sign. Instead of
writing out this loop one could also define an acquisition sequence and
use the @acronym{EDL} function @code{get_phase_cycled_area()}. This
function does everything automatically that had to be spelled out
explicitely in the loop in the previous example and thus makes the
program much simpler. The only changes needed are in the @code{PHASES}
and @code{EXPERIMENT} section: first, an acquistion sequence must be
defined and, second, the whole inner loop can be replaced by a single
function call.
@example
PHASES:

PHASE_SEQUENCE_0     = +x, -x, +x, -x;  // for 1st pulse
PHASE_SEQUENCE_1     = +x, +x, -x, -x;  // for 2nd pulse
ACQUISITION_SEQUENCE =  +,  -,  -,  +;

...

Window = digitizer_define_window( P3.START + 250 ns, 100 ns );

EXPERIMENT:

FOR I = 1: 128 @{
    data = get_phase_cycled_area( CH1, Window );
    display( I, data );
    pulser_shift( );
    pulser_update( );
@}
@end example
As can be seen from this example @code{get_phase_cycled_area()} not only
sets the pulse phases but also starts the digitizer acquisition, fetches
the measured areas from the digitizer and adds up the areas according to
the acquisition sequence.

@code{get_phase_cycled_area()} can handle one as well as two acquisition
sequences, see below. But also a single acquisistion sequence may need
data from two different digitizer channels, for example an acquisistion
sequence like this:
@example
ACQUISITION_SEQUENCE =  +A, -B, -A, +B;
@end example
which means that the value for the first phase setting has to be fetched
from the first digitizer channel (associated with @code{A}) and that for
the second phase setting the value from the second digitizer channel
(associated with @code{B}) has to be subtracted, etc. In this case
@code{get_phase_cycled_area()} expects its second argument to be the
second digitizer channel, i.e.@: it must be called like this:
@example
data = get_phase_cycled_area( CH1, CH2, Window );
@end example

In some cases one might be interested not only in the value from just
one digitizer window but from two or more. Thus you may specify,
following the digitizer channel(s) to be used for fetching data as many
windows as you need. For each of the windows the phase cycled area is
measured.  Of course, in these cases not just one data value will be
returned but an array of data values with as many elements as there are
digitizer windows passed to the function. It is the responsibility of
the writer of the @acronym{EDL} program to supply an array long enough
to hold exactly as many data as returned by the function. Here's an
example:
@example
VARIABLES:

Window_1, Window_2;
I;
data[ 2 ];

PHASES:

PHASE_SEQUENCE_0     = +x, -x, +x, -x;  // for 1st pulse
PHASE_SEQUENCE_1     = +x, +x, -x, -x;  // for 2nd pulse
ACQUISITION_SEQUENCE = +A, -B, -A, +B;

...

Window_1 = digitizer_define_window( P3.START + 250 ns, 100 ns );
Window_2 = digitizer_define_window( P3.START + 650 ns );

EXPERIMENT:

FOR I = 1: 128 @{
    data = get_phase_cycled_area( CH1, CH2, Window_1, Window_2 );
    display( I, data[ 1 ], 1, I, data[ 2 ], 2 );
    pulser_shift( );
    pulser_update( );
@}
@end example

Finally, if there are two acquisition sequences
@code{get_phase_cycled_area()} will return 2 values for each
digitizer window. Thus it will returns an array of values, where the
first two values are the data from both the acquisition sequences of the
first window, the next two from the second window etc.
