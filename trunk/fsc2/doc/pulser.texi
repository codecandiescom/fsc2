@c  $Id$
@c
@c  Copyright (C) 1999-2009 Jens Thoms Toerring
@c
@c  This file is part of fsc2.
@c
@c  Fsc2 is free software; you can redistribute it and/or modify
@c  it under the terms of the GNU General Public License as published by
@c  the Free Software Foundation; either version 2, or (at your option)
@c  any later version.
@c
@c  Fsc2 is distributed in the hope that it will be useful,
@c  but WITHOUT ANY WARRANTY; without even the implied warranty of
@c  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c  GNU General Public License for more details.
@c
@c  You should have received a copy of the GNU General Public License
@c  along with fsc2; see the file COPYING.  If not, write to
@c  the Free Software Foundation, 59 Temple Place - Suite 330,
@c  Boston, MA 02111-1307, USA.


@node Using Pulsers, Example EDL Scripts, Device Functions, fsc2
@chapter Using Pulsers


Using the pulsers has its own chapter covering the special methods to
handle the pulser setup, create pulses and do phase cycling. It also
describes how the way the pulsers are to be used depends on the hardware
used in the spectrometer. The following pulsers/spectrometer
combinations
of implemented:
@itemize @bullet
@item Sony/Tektronix DG2020 (S-band spectrometer, Frankfurt/Main)
@item Sony/Tektronix DG2020 (X-band spectrometer, Berlin)
@item Tektronix HFS9003 (W-band spectrometer, Berlin)
@item Bruker EP385 Pulse Programmer (X-band spectrometer, Berlin)
@item Interface Technology RS690 Word Generator (360 GHz and X-band
spectrometer, Berlin)
@item J-band configuration for Rulbus pulser (275 GHz spectrometer, Leiden)
@item W-band configuration for Rulbus pulser (95 GHz spectrometer, Leiden)
@item TEGAM 2714A Arbitrary Waveform generator (used as single channel
pulser)
@end itemize
All pulsers can be used everywhere when no special requirements for
phase-cycling exist, see the discussion below about the differences
between the Frankfurt S-band and the Berlin X-band spectrometer.


Please note that the Rubus pulsers are a bit different form the rest
in that it they aren't stand-alone devices but are made up from a set
of delay and clock cards connected to the Rulbus (Rijksuniversiteit
Leiden BUS) which results in a few restrictions.


Because of the importance of the pulser for time-resolved experiments
there are even two additional types of sections in the @code{EDL}
script in order to set up the pulser. These
are@footnote{@code{ASSIGNMENTS:} can be abbreviated to
@code{ASSIGNMENT:} or @code{ASS:} and @code{PHASES:} to @code{PHA}.}
@example
ASSIGNMENTS:
PHASES:
@end example
@noindent
The first section deals with the basic setup of the pulsers, the second
is only needed when phase cycling is used.  Valid statements in these
sections differ slightly depending on the type of the pulsers and the
spectrometer.


Beside these additional sections there are several other constructs for
the creation of pulses and their subsequent manipulation. These are
identical for all pulsers and are explained in in subsequent sections of
this chapter.

@ifnottex

@menu
* Setting up the Pulser::  @code{ASSIGNMENTS} and @code{PHASES} section
* Defining Pulses::        How to define pulses
* Using Pulses::           How to use pulses in the experiment
@end menu

@end ifnottex



@c ########################################################


@node Setting up the Pulser, Defining Pulses, Using Pulsers, Using Pulsers
@section Setting up the Pulser


The basic setup of a pulser happens in the @code{ASSIGNMENTS} and the
@code{PHASES} section. The latter section will be missing if no phase
cycling is to be done during the experiment.

@ifnottex

@menu
* ASSIGNMENTS section::
* PHASES section::
@end menu

@end ifnottex


@c ########################################################

@node ASSIGNMENTS section, PHASES section, , Setting up the Pulser
@subsection ASSIGNMENTS section
@cindex @code{ASSIGNMENTS} section


Within the @code{ASSIGNMENTS} section the pulsers timebases and trigger
modes are set. It also deals with the basic setup of the channels,
i.e.@: associating some or more output connectors with pulse functions
and setting the physical characteristics of the output (e.g.@: voltage
levels, inverting the output etc.).

@ifnottex

@menu
* Setting the TIMEBASE::
* Setting the trigger mode::
* Channel setup::
* Phase channel setup::
@end menu

@end ifnottex


@c ########################################################


@node Setting the TIMEBASE, Setting the trigger mode, , ASSIGNMENTS section
@subsubsection Setting the TIMEBASE
@cindex Setting the @code{TIMEBASE}
@cindex @code{TIMEBASE}


For most pulsers the first statement of the @code{ASSIGNMENTS} section
has to be the setting of the timebase of the pulser. Most of the
pulsers function similarly: the output is divided into a certain number
of time slices (usually 65536, 2^16) and for each of them the output can
be either set to a high or a low voltage. By setting the output during
one or more of these time slices to a high voltage (and for the
neighboring slices to low) pulses are created.  The timebase set in the
@code{ASSIGNMENT} section is the length of these time slices. From the
above it is clear that all pulses (as well as all the times between
pulses) have to be integer multiples of the length of the timebase.


An exception is the @strong{Bruker EP385} pulse programmer. This pulser
has a fixed built-in timebase of @w{8 ns}. In this case a
@code{TIMEBASE} statement (see below) may only be given if an external
clock input is used, in which case you need to specify the inverse of
the frequency of the external clock.


In case of the @strong{Interface Technology RS690} the internal clock is
automatically used for timebases of @w{4 ns}, @w{8 ns} and @w{16 ns},
all other timebases require an external clock. To distinguish between
the @code{TTL} and @code{ECL} level input connectors for the external
clock the additional keywords @code{TTL} and @code{ECL} can be given
together with the timebase value. When one of these keywords is given
the external clock will be used, even if the timebase value is one of
the three values that can be realized using the internal clock. When
neither of the two keywords is given and the specified timebase
requires an external clock the @code{TTL} level clock input connector is
used per default.


In the currently used configuration the timebase for the J-band version
of the @strong{Rulbus pulsers} is fixed to @w{10 ns}. But this is a
compilation option that can be changed via the configuration files. After
this change and a recompilation of the modules variable timebases. In
contrast, for the W-band version the timebase in the current configuration
must be set, where possible settings are either @w{10 ns}, @w{100 ns},
@w{1 us}, @w{10 us}, @w{100 us}, @w{1 ms} or @w{10 ms}.


The statement to set the timebase, i.e.@: the length of the individual
time slices is@footnote{Instead of @code{TIMEBASE} one may also write
@code{TB:}, @code{T_B}, @code{TBASE:}, @code{T_BASE:}, @code{TIMEB},
@code{TIME_B:} or @code{TIME_BASE:}.}:
@example
TIMEBASE: 5 ns;
@end example
@noindent
or, for the @strong{Interface Technology RS690}, when using an external
clock at the @code{TTL} level input connector:
@example
TIMEBASE: 25 ns, TTL;
@end example


The minimum and maximum values for the timebase differ for the different
pulsers:
@itemize @bullet
@item Sony/Tektronix DG2020: @w{5 ns} to @w{0.1 s}
@item Tektronix HFS9003: @w{1.6 ns} to @w{20 us}
@item Bruker EP385: internal clock @w{8 ns} only (no @code{TIMBASE}
statement allowed), external clock @w{8 ns} and larger
@item Interface Technology R690: @w{4 ns}, @w{8 ns} and @w{16 ns}
for the internal clock, @w{4 ns} and larger with an external clock
@item TEGAM 2174A Arbitrary Waveform Generator: between @w{50 ns} and
@w{10 s}
@end itemize


If you're using two or more pulsers simultaneously you need as many
@code{TIMEBASE} statements in your @code{EDL} script as you have
pulsers. In this case you need to append a @code{#} character plus the
number of the pulser to indicate for which of the pulsers the statement
is to be used. E.g.@: if you have two pulsers you normally will need two
@code{TIMEBASE} statements:
@example
TIMEBASE#1:  5 ns;
TIMEBASE#2: 25 ns;
@end example
@noindent
The additional @code{#1} in the statement for the first pulser is optional.


@c ########################################################


@node Setting the trigger mode, Channel setup, Setting the TIMEBASE, ASSIGNMENTS section
@subsubsection Setting the trigger mode
@cindex Setting the trigger mode
@cindex @code{TRIGGER_MODE}
@cindex @code{REPEAT_FREQUENCY}
@cindex @code{REPEAT_TIME}
@cindex @code{INTERNAL}
@cindex @code{EXTERNAL}
@cindex @code{SLOPE}
@cindex @code{LEVEL}
@cindex @code{IMPEDANCE}


The next statement concerns the triggering of the pulser. A pulser
starts a new sequence of pulses either on receiving an external trigger
or it uses an internal trigger. Which type of triggering to use depends,
of course, on the experiment. To set either internal or external trigger
mode use a statement like this@footnote{Instead of @code{TRIGGER_MODE}
also @code{TM:}, @code{T_M:}, @code{TRIGM:}, @code{TRIG_M:},
@code{TRIGMODE:}, @code{TRIG_MODE:}, @code{T_MODE:}, @code{TMODE:},
@code{TRIGGER_M:}, @code{TRIGGERM:} or @code{TRIGGERMODE:} can be
used. And the keywords @code{INTERNAL} and @code{EXTERNAL} can be
shortened to @code{INTERN} or @code{INT} and @code{EXTERN} or
@code{EXT}.}:
@example
TRIGGER_MODE: INTERNAL;
@end example
@noindent
or
@example
TRIGGER_MODE: EXTERNAL;
@end example


Especially when using the internal trigger it is useful to be able to
set the rate or the frequency with which the experiment is to be
repeated. Thus for the @strong{Sony/Tektronix DG2020}, the @strong{Bruker
EP385}, the @strong{Interface Technology RS690} as well as the @strong{Rulbus
pulsers} an additional keyword can be specified, either @code{REPEAT_TIME} or
@code{REPEAT_FREQUENCY}@footnote{@code{REPEAT_TIME} and
@code{REPEAT_FREQUENCY} may also be abbreviated to @code{REPT},
@code{REP_T}, @code{REPTIME}, @code{REPEAT_TIME}, @code{REPEAT_T},
@code{REPEATT} or @code{REPEATTIME} and @code{REPF}, @code{REP_F},
@code{REPFREQ}, @code{REP_FREQ}, @code{REPFREQUENCY},
@code{REP_FREQUENCY}, @code{REPEATF}, @code{REPEAT_F},
@code{REPEATFREQ}, @code{REPEAT_FREQ} or @code{REPEATFREQUENCY}.}, i.e.@
one may use:
@example
TRIGGER_MODE: INTERNAL, REPEAT_TIME = 10 ms;
@end example
@noindent
or
@example
TRIGGER_MODE: INTERNAL, REPEAT_FREQUENCY = 100 Hz;
@end example
@noindent
to set the repetition rate of the experiment to @w{100 Hz}. The repeat
time must be an integer multiple of the timebase of the pulser.


When using an external trigger a repetition time or frequency can't be
enforced for obvious reasons. It can only be guaranteed that the pulse
sequence is as long as the repetition time, thus keeping the pulser from
getting restarted by a stray trigger event before the end of the repetition
time.


For the @strong{Tektronix HFS9003} no repetition frequency or rate can
be set, so an external trigger has to be used to determine the
repetition rate of the experiment, otherwise the pulser will repeat the
pulse sequence at the highest possible rate.


For the @strong{Bruker EP385} pulse programmer the highest repetition
frequency is about @w{976.56 Hz} (when using the internal clock,
otherwise multiply the external clocks oscillation period by 160768 to
compute the exact length of the minimum repeat time). Repetition times
can be only set to multiples of @w{102.4 us} (or in increments of 12800
times the external clocks oscillation period). If necessary, repetition
frequencies are adjusted automatically to the next lower allowed value.


For the @strong{Interface Technology RS690} it might happen that for
certain pulse settings the repetition time must be lengthened slightly,
but never more than three times the timebase.


For the @strong{TEGAM 2714A} no repetition time or frequency can be set
(you can use the function @ref{pulser_maximum_pattern_length()} instead
to adjust the pattern length if necessary).


On the other hand, when using an external trigger one may want to set
the trigger level, slope and, possibly, the trigger input impedance. For
pulsers allowing this it is done using a statement similar to one of
these@footnote{The keywords @code{LEVEL} can be shortens to @code{LEV},
@code{SLOPE} to @code{SL}, @code{POSITIVE} to @code{POS},
@code{NEGATIVE} to @code{NEG}, @code{IMPEDANCE} to @code{IMP} and,
finally, @code{HIGH} to @code{H} and @code{LOW} to @code{L}.}:
@example
TRIG_MODE: EXTERNAL, LEVEL = 3.5 V, SLOPE = NEGATIVE, IMPEDANCE = LOW;
@end example
@noindent
or
@example
TM: EXTERNAL, LEVEL = -1.2 V, SLOPE = POSITIVE, IMPEDANCE = HIGH;
@end example


The @strong{Bruker EP385} does not allow the setting of any of these
parameters.


The trigger input impedance can only be set for the
@strong{Sony/Tektronix DG2020}.


For the @strong{Sony/Tektronix DG2020} the trigger level must be in the
range between @w{-5V} and @w{+5 V}, while for the @strong{Tektronix
HFS9003} the allowed trigger level range is @w{-4.7 V} to @w{+4.7 V}.


For the @strong{Interface Technology RS690} no input trigger level nor
input impedance can be set, but it has two trigger input connectors, one
for @code{TTL} and one for @code{ECL} level trigger input. To
distinguish between the two trigger input ports the additional keywords
@code{TTL} and @code{ECL} may be used. If none is given the @code{TTL}
level input port is used per default.


The @strong{Rulbus pulsers} only allow to set the trigger slope.


For the @strong{TEGAM 2714A} neither impedance, level or slope of the
input trigger can be set.


If you need to control more than one pulser you must have a
@code{TRIGGER_MODE} statement for each of the pulsers. In this case you
need to append a @code{#} and the number of the pulser to tell
@code{fsc2} for which pulser the trigger mode setting is to be used.


@c ########################################################


@node Channel setup, Phase channel setup, Setting the trigger mode, ASSIGNMENTS section
@subsubsection Channel setup
@cindex Channel setup
@cindex @code{MICROWAVE}
@cindex @code{TWT}
@cindex @code{TWT_GATE}
@cindex @code{DETECTION}
@cindex @code{DETECTION_GATE}
@cindex @code{DEFENSE}
@cindex @code{RADIO_FREQUENCY}
@cindex @code{RADIO_FREQUENCY_GATE}
@cindex @code{LASER}
@cindex @code{PULSE_SHAPE}
@cindex @code{PHASE_1}
@cindex @code{PHASE_2}
@cindex @code{OTHER_1}
@cindex @code{OTHER_2}
@cindex @code{OTHER_3}
@cindex @code{OTHER_4}
@cindex @code{CHANNEL}
@cindex @code{POD}
@cindex @code{TRIGGER_OUT}
@cindex @code{V_HIGH}
@cindex @code{V_LOW}
@cindex @code{INVERTED}
@cindex @code{DELAY}


The statements described in the following deal with setting up the
output channels of the pulser. The basic idea is to abstract from the
real output connectors of the pulser and to use symbolic names for them.
So, instead of telling the pulser to output a pulse at e.g.@: the output
connector @w{numbered 1} during the experiment, in the
@code{ASSIGNMENTS} section output connectors get associated with
symbolic names for their functions and these symbolic names are used
when specifying pulses. While this may be only a convenience in simple
experiments (you only have to apply changes in one place when changing
the output connectors instead of finding and changing it for all pulses
concerned) it makes doing phase cycling much simpler because here the
same pulse may have to be output at different output connectors,
depending on the current phase. Instead of always specifying which
output connector to use for a certain phase for each pulse, the program
is told which connectors to use for a function (and which phase) and
then it's left to the program to figure out when to use which of the
output connectors.


The following symbolic names for pulse functions are defined:
@itemize @bullet
@item @code{MICROWAVE} (or @code{MW} etc.@footnote{The function
@code{MICROWAVE} can also be abbreviated to @code{MICRO_WAVE}, @code{MICROW},
@code{MICRO_W}, @code{MWAVE}, @code{M_WAVE} or @code{M_W}})
@item @code{TRAVELING_WAVE_TUBE} (or @code{TWT} etc.@footnote{Instead of
@code{TRAVELING_WAVE_TUBE} all other combinations, where any of
constituting words is replaced by its initial character or one or all
underscore characters are missing can be used.})
@item @code{TRAVELING_WAVE_TUBE_GATE} (or @code{TWTG}
etc.@footnote{@code{TRAVELING_WAVE_TUBE_GATE} may also be abbreviated by
all combinations, where any of constituting words is replaced by its
initial character or one or all underscore characters are missing.})
@item @code{DETECTION} (or @code{DET})
@item @code{DETECTION_GATE} (or @code{DETG}
etc.@footnote{@code{DETECTION_GATE} can be also shortened to
@code{DET_G}, @code{DETECTIONGATE}, @code{DETECTION_G},
@code{DETECTIONG}, @code{DET_GATE} or @code{DETGATE}.})
@item @code{DEFENSE} (of @code{DEF})
@item @code{RADIO_FREQUENCY} (or @code{RF} etc.@footnote{Instead
@code{RADIO_FREQUENCY} also all combinations can be used where
@code{RADIO} is replaced by @code{R} or @code{FREQUENCY} by either
@code{FREQ} or @code{F}. The underscore can also be left out.})
@item @code{RADIO_FREQUENCY_GATE} (or @code{RFG}
etc.@footnote{For @code{RADIO_FREQUENCY_GATE} all combinations where
@code{RADIO} is replaced by @code{R}, @code{FREQUENCY} by either
@code{FREQ} or @code{F} or @code{GATE} by @code{G} may be used. As
usual, the underscore characters can be omitted.})
@item @code{LASER}  (or @code{L})
@item @code{PULSE_SHAPE} (or @code{PSH} etc.@footnote{You may
abbreviate @code{PULSE_SHAPE} to @code{PULSESH}, @code{PULSE_SH},
@code{PULSE_SHAPE}, @code{PULSESHAPE}, @code{PULSESHAPE}, @code{P_SH},
@code{P_SHAPE}, @code{PSHAPE}, @code{P_SHAPE}, @code{P_SHAPE}.})
@item @code{OTHER_1} (or @code{OTHER1}, @code{O_1}, @code{O1},
      @code{OTHER} or @code{O})
@item @code{OTHER_2} (or @code{OTHER2}, @code{O_2} or @code{O2})
@item @code{OTHER_3} (or @code{OTHER3}, @code{O_3} or @code{O3})
@item @code{OTHER_4} (or @code{OTHER4}, @code{O_4} or @code{O4})
@item @code{PHASE_1} (or @code{PHASE1}, @code{PH_1} or @code{PH1})
@item @code{PHASE_2} (or @code{PHASE2}, @code{PH_2} or @code{PH2})
@end itemize
The names of the functions of course do not enforce what the connectors
are really going to be used for, but it is probably a good idea not to
use e.g.@: the @code{MICROWAVE} function for something completely different
(or other people will have major problems understanding what your @code{EDL}
script is supposed to do and there's no obfuscated EDL contest yet;-).
Besides, some of the pulser modules also define special functions (e.g.@:
for automatically setting TWT pulses) that only work for some of these
functions.


The functions @code{PHASE_1} and @code{PHASE_2} are special in that they
can only be used with the Frankfurt version of the driver for the
@strong{Sony/Tektronix DG2020}, @code{dg2020_f}, and are used for
controlling the phase switches, i.e.@: it's pulses are created
automatically.


The functions @code{OTHER_1} to @code{OTHER_4} should be used in cases
where none of the other function names seem to fit the special purpose
you have in mind for the pulses of this function.


Before showing some examples it is important to point out that there are
some differences between the different devices.


The simplest one is the @strong{Bruker EP385}. It has 8 output
connectors, which are named in the @code{EDL} script as @code{CH0} ti
@code{CH7}. 


The @strong{Tektronix HFS9003} can has at least one and up to three
channel boards, each with 4 channels. The channels of the first board
are named @code{A1} to @code{A4} for the first, @code{B1} to @code{B4}
for the second and @code{C1} to @code{C4} for the thrid channel
board. Additionally, the @strong{Tektronix HFS9003} has a trigger output
channel that can produce a single pulse of @w{5 ns} duration. This
special channel can also be associated with a function (e.g.@: for
generating a @code{DETECTION} trigger pulse) and is named
@code{TRIG_OUT} (or @code{TRIGOUT}, @code{TRIGGER_OUT} or
@code{TRIGGEROUT}).


The @strong{Interface Technology RS690} has 4 sets of output connectors
(or even 8, if a second HSM card is installed), each with 16 output
channels. Each output channel can be addressed by a letter between
@code{A} and @code{D} (or @code{H}, if two HSM cards are installed) for
the connector, followed by a number between @code{0} and @code{15},
specifying the channel on the connector to use. Valid channel
designators are e.g.@: @code{A3}, @code{C13} etc. Moreover, the number
of channels of a connector that can be used depends on the timebase
setting: for a timebase of @w{4 ns} only the lowest 4 channels of each
connector can be used, for a timebase of @w{8 ns} only the lower 8
channels.


The @strong{Sony/Tektronix DG2020} is quite a bit different. It has 36
internal channels (named @code{CH0} to @code{CH35}) that have to be
mapped to pod channels (named @code{P0} to @code{P11}. The pod is the
additional box, conected to the pulser by a cable and having (for both
the Frankfurt S-band and and the Berlin X-band spectrometer) 12 output
connectors, numbered from @code{0} to @code{11}. Instead of associating
one of the (internal) channels for this device a pod channel has to be
associated with a function. Optionally, it is also possible to tell
@code{fsc2} which of the internal channels are to be used for a
function.


For the @strong{Tektronix HFS9003} simply a channel is associated with a
function by statements like (the keyword @code{CHANNEL} can be replaced
by @code{CH})
@example
MICROWAVE: CHANNEL = A1;          /* board A, channel 1 */
RF:        CHANNEL = A2;          /* board A, channel 2 */
RF_GATE:   CH = B3;               /* board B, channel 3 */
DETECTION: CHANNEL = TRIG_OUT;    /* TRIG_OUT connector */
@end example
@noindent
(where the @code{A} in the channel specifier stands for the first
channel card and @code{B} for the second card) or, for the
@strong{Interface Technology RS690},
@example
MICROWAVE: CHANNEL = A3;          /* connector A, channel 3 */
RF:        CHANNEL = B7;          /* connector B, channel 7 */
RF_GATE:   CH = C5;               /* connector C, channel 5 */
DETECTION: CHANNEL = D15;         /* connector D, channel 15 */
@end example
@noindent


For the @strong{Sony/Tektronix DG2020} the function gets associated with
a pod (or several pods, see below why sometimes more than one is
needed), with the pods named @code{P0} to @code{P11}:
@example
MICROWAVE: POD = P1, P2, P3, P4;
RF:        POD = P6;
RF_GATE:   POD = P7;
DETECTION: POD = P11;
@end example
@noindent


Optionally, for the @strong{Sony/Tektronix DG2020} you can also tell the
program which of the 36 internal channels (numbered @code{CH0} to
@code{CH35}) should be used for a function. If you don't the program
will automatically grab as many of the internal channels as it needs,
always using the lowest numbered ones first. To declare which of the
internal channels are to be associated with the output connectors (PODs)
use a statement like this:
@example
MICROWAVE: POD = P1, P2, P3, P4  CHANNEL = CH31, CH32, CH33, CH34;
RF:        POD = P6              CHANNEL = CH35;
RF_GATE:   POD = P7              CHANNEL = CH17;
DETECTION: POD = P11;   // leave it to the program to select the channel
@end example


Please note: the @strong{Tektronix HFS9003} does not allow assignment of
more than one channel to a single function.


Here a list of the pod and/or channel numbers that can be used for the
pulsers:
@itemize @bullet
@item Sony/Tektronix DG2020: POD = P0..P11, CH = CH0..CH35
@item Tektronix HFS9003: CH = A1..A4, B1..B4, C1..C4, TRIG_OUT
@item Bruker EP385: CH = CH0..CH7
@item Interface Technology RS690: CH = X0..15 with X standing for A..D
(or A..H when two HSM cards are installed)
@item TEGAM 2714A: CH = 0..99 (default is 99)
@end itemize


For the @strong{TEGAM 2714A} the channel determines the number of the user
waveform to be used to create the pulse sequence. If no such assignment
is done channel @code{99} is used pr default and the function of the
single channel the pulser has is determined from the setting of the
first pulse to be defined.


Beside defining at which of the output connectors the pulses for a
function will appear at you can also set other properties for the pulses
of a POD or channel. As far as the hardware allows it you may set the
high and the low voltage for all pulses of a function by using the
keywords @code{V_HIGH} and @code{V_LOW}@footnote{Instead of
@code{V_HIGH} you can also write @code{VHIGH}, @code{V_H} or @code{VH}
and for @code{V_LOW} you may use @code{VLOW}, @code{V_L} or @code{VL}.}:
@example
MICROWAVE: POD = P1, P2, P3, P4  V_HIGH = 4.3 V, V_LOW = -0.5 V;
RF:        POD = P6              V_HIGH = 2.6 V, V_LOW = 0 V;
RF_GATE:   POD = P7              V_HIGH = 5 V,   V_LOW = 0 V;
@end example
@noindent
The high voltage must always be larger than the low voltage, to get
inverted pulses use the @code{INVERTED} keyword, see below.


For the @strong{Sony/Tektronix DG2020} the high voltage can be adjusted
to values between @w{-2 V} and @w{+7 V} and the low voltage can be in
the range between @w{-3 V} and @w{+6 V}. The difference between the
voltages must be between @w{0.5 V} and @w{9 V} and can be set in
increments of @w{0.1 V}.


For the @strong{Tektronix HFS9003} the high voltage can be adjusted to
values between @w{-1.5 V} and @w{+5.5 V}, the low voltage has to be in
the range from @w{-2 V} to @w{+5 V}. The minimum and maximum voltage
swing is @w{0.5 V} and @w{5.5 V}, respectively, and the voltage
resolution is @w{10 mV}.


For the @strong{TEGAM 2714A} pulse levels can be set in the range between
@w{-10.2 V} and @w{+10.2 V}, with the maximum difference being @w{10.2 V}.
If the level difference is below @w{1 V} the levels must be in the @w{+/-1 V}
range and for level differences below @w{100 mV} within @w{+/-100 mV}.


If a function requires the output levels to be inverted (i.e.@: that the
voltage is high while there are no pulses and low during pulses) use the
@code{INVERTED} keyword@footnote{The keyword @code{INVERTED} can be
shortened to @code{INVERT} or @code{INV}.}:
@example
RF:        POD = P6   V_HIGH = 2.6 V, V_LOW = 0 V, INVERTED;
@end example


For both the @strong{Bruker EP385} and @strong{Interface Technology
RS690} pulser pulse levels can't be specified. For the @strong{Bruker
EP385} also the @code{INVERTED} keyword cannot be used, use the inverted
output connectors instead.


Finally, in order to take care of different cable lengths a delay for a
function can be set. This delay will be automatically added to the start
position of each pulse of this function:
@example
MICROWAVE: POD = P1, P2, P3, P4  DELAY = 50 ns;
@end example
@noindent
For obvious reasons setting negative delays is only possible when
internal trigger mode is used@footnote{The obvious reason is, of course,
causality - the pulser can't know when the external trigger is going to
happen, so starting before the trigger is detected would be a bit
difficult. By the way, the keyword @code{DELAY} can be abbreviated to
@code{DEL}.}.


If you are dealing with two or more pulsers simultaneously you will have
to append a @code{#} character plus the pulser number to each of the
channel function setup statements, i.e.@: use
@example
MICROWAVE#1: POD = P3;
TWT#2:       CH  = A7;
@end example
@noindent
to create microwave pulses with the first pulser and TWT pulses with the
second one.


For the @strong{Rulbus pulsers} in the J-band configuration(module
@code{rb_pulser_j}) only allows for three function, @code{MICROWAVE}
(restricted to creating three pulses), @code{RADIO_FREQUENCY}
(restricted to creating a single pulse) and @code{DETECTION} (also
restricted to creating a single pulse). In the W-band configuration
(module @code{rb_pulser_w} allows additionally the function @code{LASER}
(restricted to creating a single pulse) and @code{DEFENSE} (restricted to
creating a single pulse starting at the very start of the pulse pattern,
so only its length can be changed - normally the defense pulse is created
automatically). Moreover, in the W-band configuration the lenght of the 
detection pulse can only be varied between @w{0 s} and the timebase of the
pulser. For both configurations the functions are fixed to certain delay
cards of the pulsers, so assigning a function to a "channel" isn't possible
- there are no channels. All that can be set for a certain function is the
delay to be used with this function.



@c ########################################################


@node Phase channel setup, , Channel setup, ASSIGNMENTS section
@subsubsection Phase channel setup
@cindex Phase channel setup
@cindex @code{PHASE_SETUP}


Please note that a phase channel setup can only be done with the
@strong{Sony/Tektronix DG2020} and the @strong{Bruker EP385}. Moerover,
there are several differences between the Frankfurt S-band and the
Berlin X-band spectrometer. And all the following is only relevant if
phase cycling is to be used.


@strong{Berlin X-band spectrometer} (@strong{Sony/Tektronix DG2020},
@strong{Bruker EP385} and @strong{Interface Technology RS690}):


The Berlin bridge setup is rather simple in that it expects pulses with
different phases to appear on different input connectors of the
microwave bridge. The bridge has 4 different inputs, one for each phase
@code{+X}, @code{-X}, @code{+Y} and @code{-Y}, and the phase of the
pulse coming from the bridge and going to the TWT amplifier depends on
which input connector was used for the pulse.


Now all you have to do is to tell the program once which pulser pod
channel is connected to which phase input of the bridge (and, to allow
for some sanity checks, which functions is to be phase cycled). This is
done via a statement in the @code{ASSIGNMENTS} section like the following:
@example
PHASE_SETUP:  MICROWAVE,
              +X: POD = P1,
              +Y: POD = P2,
              -X: POD = P4,
              -Y: P5;
@end example
@noindent
or
@example
PHASE_SETUP:  MICROWAVE,
              +X: CH = C1,
              +Y: CH = C2,
              -X: CH = C4,
              -Y: C5,
@end example
@noindent
(depending on the pulser you use).  In this example you obviously want
to phase cycle the microwave pulses and the @code{+X} input connector of
the bridge is connected to pod channel 1 (or output connector C1) of the
pulser etc.@footnote{As usual, the keyword @code{PHASE_SETUP} can be
abbreviated, either to @code{PH_SETUP}, @code{PHASE_S}, or @code{PHS}.}
Since you actually can have 2 phase cycled function, you may append
either @code{1} or @code{_1} and @code{2} or @code{_2} to distinguish
between the two phase setups, i.e.@: @code{PHASE_SETUP_1}.


Please note that you only have to supply settings for phases that are
really needed during the experiment, e.g.@: if during the experiment only
the @code{+X} and @code{-X} phases are needed only channels for both these
phases have to be specified.


@strong{Frankurt S-band spectrometer} (@strong{Sony/Tektronix DG2020}
only):


The Frankfurt spectrometer is somewhat more complicated. The bridge has
one microwave pulse input and two further input channels that control the
setting of the bridges phase switch. So, while a microwave pulse is sent
to the bridge, further phase pulses have to be present to control the
phase switch. Two phase inputs are enough to differentiate between the 4
phases @code{+X}, @code{-X}, @code{+Y} and @code{-Y}.


In order to create the phase pulses an extra function is needed for
these pulses, which is called @code{PHASE} (or, abbreviated @code{PH}).
For being able to feed both the bridges phase inputs, for this function
two of the pod channels of the pulser are needed. The definition of this
function looks nearly identical to the other functions, the only
exception is that also the name of the function to be phase cycled using the
phase function needs to be specified:
@example
PHASE:        MICROWAVE, POD = P8, P9, V_HIGH = 5 V, V_LOW = 0 V;
@end example
@noindent
In this example the phase function is used to phase cycle the microwave
pulses and the pod channels assigned to it are the ones numbered 8 and 9.


The second thing that is needed is which voltages have to be present at
the outputs to set a certain phase. Here's an example:
@example
PHASE_SETUP:  +X: POD_1 = OFF, POD2 = OFF,
              +Y: POD1  = ON,  POD_2 = 0,
              -X: 0, 1,
              -Y: 1, 1;
@end example
@noindent
This phase setup command tells the program that to set the @code{+X} phase
the voltage at both pod outputs of the phase function have to be in the
low state, while for the @code{-Y} phase the first pod output (set to pod
channel 8 by the @code{PHASE} command, see above) has to be in the high
state, while the other output (pod channel 9) has to be low. @code{POD_1}
stands here for the first pod channel of the phase function,
@code{POD_2} for the second one. @code{ON} and @code{1} can both be used
to indicate a high output state, @code{OFF} and @code{0} stand for a low
state.


With these informations the program is able (or nearly is) to create the
the additional "phase" pulses (i.e.@: the pulses that control the phase
switch) without the user having to deal with it. So, all that needs to
be done later is to create the microwave pulses and define the sequence
of phases for the pulses. The program will automatically create the
pulses necessary to set the phases of the microwave pulses.


You can also specify how long phase pulses start before the pulse
they are made for and how much longer they are supposed to last by using
the functions @ref{pulser_phase_switch_delay()} and
@ref{pulser_grace_period()} (these functions replace the deprectated
but still supported keywords @code{PHASE_SWITCH_DELAY} and
@code{GRACE_PERIOD} in the @code{ASSIGNMENTS} section).


@c ########################################################


@node PHASES section, , ASSIGNMENTS section, Setting up the Pulser
@subsection PHASES section
@cindex @code{PHASES} section
@cindex @code{PHASE_SEQUENCE}
@cindex @code{ACQUISITION_SEQUENCE}


The @code{PHASES} section is for defining with phase sequences and,
optionally, acquisition sequences. As the word says a phase sequence
defines for one (or more) pulses the sequence of phases a pulse is
switched between during the experiment. For example, in a phase cycled
stimulated echo experiment the first microwave pulse usually is set
first to a @code{+X} phase, then to @code{-X}, again to @code{+X} and
finally to @code{-X}. The second pulse will run at the same time through
the sequence @code{+X}, @code{+X}, @code{-X} and @code{-X}. The third
pulse has alway the same @code{+X} phase. Because a constant phase of
@code{+X} is the default, only two phase sequences have to be defined:
@example
PHASE_SEQUENCE_1: +x, -x, +x, -x;  // for 1st pulse
PHASE_SEQUENCE_2: +x, +x, -x, -x;  // for 2nd pulse
@end example
@noindent
As can be seen from this example the keyword is
@code{PHASE_SEQUENCE}@footnote{@code{PHASE_SEQUENCE}can be shortened to
@code{PHASESEQUENCE}, @code{PH_SEQUENCE}, @code{PHSEQUENCE},
@code{PHASE_SEQ}, @code{PHASESEQ}, @code{PHASEA_S}, @code{PHASES},
@code{PH_SEQ}, @code{PHSEQ}, @code{PH_S}, @code{PHS}.}, followed by an
optional underscore and the number of the phase sequence (if there is
only one phase sequence no number is needed). For the phase number any
number between 0 and 2147483647 @w{(2^32 - 1)} can be chosen. Of course
the lengths of all phase sequences have to be identical.


Please note that due to hardware limitations for the W-band configuration
of the @strong{Rulbus pulser} the phase @code{-Y} can't be used.


The following sections explain how the phase sequences become
associated with certain pulses.


Beside the phase sequences also acquisition sequences can be defined.
These are used by some @code{EDL} functions to determine how the
results of the experiments with different phases have to be added up in
order to give the final result for a complete phase cycling sequence. In
the example of a phase cycled stimulated echo experiment the area of the
echo measured for the second phase setting has to be subtracted from the
area of the first phase, the area of the third also has to be subtracted, and
for the fourth the area has to be added. Thus the acquisition sequence
would be defined as:
@example
ACQUISITION_SEQUENCE: +, -, -, +;
@end example


When one has an experiment with a quadrature mixer one also can define
in the acquisition sequence which of the signals from the two digitizer
channels have to be used. The first channel is named @code{A} and the
second @code{B}. In this case one usually also needs two acquisition
sequences, one for the real part and one for the imaginary part of the
signal. To distinguish between the sequences append either @code{1} or
@code{2} to the keyword (optionally with an underscore in between. As an
example here the phase and acquisition sequence definitions for an
inversion recovery experiment with FID detection and phase cycling:
@example
PHASE_SEQUENCE_1       = +x, +x, +x, +x, -x, -x, -x, -x;
PHASE_SEQUENCE_2       = +x, -x, +y, -y, +x, -x, +y, -y;
ACQUISITION_SEQUENCE_1 = +A, -A, +B, -B, +A, -A, +B, -B;
ACQUISITION_SEQUENCE_2 = +B, -B, -A, +A, +B, -B, -A, +A;
@end example


The definition of acquisition sequences is optional and only needed if
the function @code{@ref{get_phase_cycled_area()}} (see below) is going
to be used. If defined their lengths have to be identical to the
lengths of the phase sequences.


@c ########################################################


@node Defining Pulses, Using Pulses, Setting up the Pulser, Using Pulsers
@section Defining Pulses

@cindex @code{PULSE_}
@cindex @code{FUNCTION}
@cindex @code{START}
@cindex @code{LENGTH}
@cindex @code{DELTA_START}
@cindex @code{DELTA_LENGTH}
@cindex @code{PHASE_CYCLE}


While the basic setup of the pulse happens in the @code{ASSIGNMENTS}
and, possibly, in the @code{PHASES} section, the definition of the
pulses is done in the @code{PREPARATIONS} section.


Each pulse has at least three properties: a unique number, a function
and a start position. Actually, pulses also need a length, so as long
as the length is not set (or is 0) the pulse stays switched off. Here is
an example of how to create a pulse, numbered @code{1}, that is a
microwave pulse, starts @w{100 ns} after the trigger) and has a length
of @w{250 ns}:
@example
PULSE_1:    FUNCTION = MICROWAVE,
            START    = 100 ns,
            LENGTH   = 250 ns;
@end example
@noindent
As usual, most of the keywords can be abbreviated, @code{PULSE_1:} to
@code{PULSE1:}, @code{P_1:} or @code{P1:}, @code{FUNCTION} to either
@code{FUNC} or @code{F}, @code{START} to @code{S}, and finally,
@code{LENGTH} to @code{LEN} or @code{L}. And, of course, for numerical
values like pulse positions and times variables, complex expressions and
functions can be used.


Pulse numbers can be chosen randomly - the only requirement is that the
numbers are positive (including 0) and not larger than 2147483647
@w{(2^32 - 1)} (of course there always is some limitation by the device
that won't allow to create that many pulses). Positions and lengths of
pulses have to be positive (including 0). A pulse of zero length is
invisible.


Each pulse must be assigned to a certain function (this is used to
determine on wich output of the pulser the pulse will appear). The
only exception is the @strong{TEGAM 2714A}. if a channel number is
assigned to a certain function than this function is automatically
the function of each pulse (since this device only has a single
channel).


If more than one pulser is used it must also be indicated which pulser
is supposed to create the pulse. This is done by appending the @code{#}
character, followed by the pulser number, to the @code{PULSE}
keyword. Thus, if e.g.@: the pulse numbered 3 has to be created by the
second pulser it must be created by a command like the following:
@example
PULSE_3#2:   FUNCTION = RADIO_FREQUENCY,
             START    = 2 ms,
             LENGTH   = 8 ms;
@end example
@noindent
Please note that in this case a @code{RADIO_FREQUENCY} function must
have been defined for the @strong{second} pulser.


Even when using more than one pulser the pulse numbers still have to be
unique. If e.g.@: a pulse numbered @code{1} has been created for the
first pulser it is @strong{not} allowed to create a second pulse with
the same number even when it is assigned to another pulser.


There are three additional properties a pulse can have. The first one is
a constant amount of time the start position of the pulse will be
changed by during the experiment, the corresponding keyword is
@code{DELTA_START}@footnote{@code{DELTA_START} can be abbreviated to
@code{DELTASTART}, @code{DELTA_S}, @code{DELTAS}, @code{DEL_START},
@code{DELSTART}, @code{DEL_S}, @code{DELS}, @code{D_START},
@code{DSTART}, @code{D_S} or @code{DS}.}. Second, there is a constant
length change of the pulse,
@code{DELTA_LENGTH}@footnote{@code{DELTA_LENGTH} can be shortened to
@code{DELTALENGTH}, @code{DELTA_L}, @code{DELTAL}, @code{DEL_LENGTH},
@code{DELLENGTH}, @code{DEL_L}, @code{DELL}, @code{D_LENGTH},
@code{DLENGTH}, @code{DEL_L}, @code{DELL}, @code{D_LENGTH},
@code{DLENGTH}, @code{D_L} or @code{DL}.}. And finally, there is the
phase sequence to be used for phase cycling of the pulse -- here the
keyword is @code{PHASE_CYCLE}@footnote{@code{PHASE_CYCLE} can also be
written as @code{PHASECYCLE}, @code{PHASE_C}, @code{PHASEC},
@code{PH_CYCLE}, @code{PHCYCLE}, @code{PH_C} or @code{PHC}.}.



With these additional properties (using, for phase cycling of the pulse,
the first phase sequence defined in the @code{PHASES} section, see
above) the definition of the pulse would look like this:
@example
PULSE_1:    FUNCTION     = MICROWAVE,
            START        = 100 ns,
            LENGTH       = 250 ns,
            DELTA_START  = 20 ns,
            DELTA_LENGTH = 35 ns,
            PHASE_CYCLE  = PHASE_SEQUENCE_1;
@end example


When setting the properties of further pulses the properties of pulses
already defined can be used. This is done by specifying the name of the
pulse (e.g.@: @code{PULSE_1}), followed by a dot and the property of the
referenced pulse to be used. For example, if you want to create a second
pulse that is also a microwave pulse, starts @w{300 ns} after the end
of the first pulse and is twice as long, you could write:
@example
PULSE_2:    FUNCTION     = PULSE_1.FUNCTION,
            START        = PULSE_1.START + PULSE_1.LENGTH + 300 ns,
            LENGTH       = 2 * PULSE_1.LENGTH;
@end example


For the @strong{Rulbus pulsers} there are several restrictions for the
number of pulses that can be used. The @code{MICROWAVE} function can
have a maximum of three active pulses at a moment while both the
@code{RADIO_FREQUENCY}, the @code{LASER} (W-band configuration only)
and the  @code{DETECTION} function allow only a single active pulse.
Moreover, for the J-band configuration (module @code{rb_pulser_j}) the
@code{RADIO_FREQUENCY} and @code{DETECTION} can't start before the first
@code{MICROWAVE} pulse. In the W-band configuration the @code{DETECTION}
pulse only can have a length of @w{0 s} or the length of the timebase
(which is the default value if no pulse length has been set) and the
@code{DEFNSE} pulse must always start at the very beginning of the pulse
pattern (moreover, unless the function @ref{pulser_defense_pulse_mode()}
with the appropriate argument before the definition of the @code{DETECTION}
pulse it is created automatically). Pulses can have a maximum length of
about @w{167 ms} and also delays between pulses (and before the start of
a pulse) are restricted to this range of value. Finally, a
@code{RADIO_FREQUENCY} pulse can only be created if the pulser is
connected to the @strong{Rhode & Schwarz SML01} synthesizer (with SML-B3
option), which has a built-in pulse unit.


@c ########################################################


@node Using Pulses, , Defining Pulses, Using Pulsers
@section Using Pulses


When pulses have been defined and the experiment is started (indicated by
the begin of the @code{EXPERIMENT} section) all pulses get set (as long as
their lengths are defined and non-zero) and all channels or PODs that
have been assigned pulses (that are really used during the experiment) are
switched on.


There are two methods to change the properties of pulses. The first one
works by calling a dedicated function. To change the start position of,
for example, pulse 1 by the start position change time
(@code{DELTA_START}) as defined in the properties of the pulse the
function @ref{pulser_shift()} can be used:
@example
pulser_shift( P1 );      // or  pulser_shift( 1 );
@end example
@noindent
Also the start position of several pulses at once can be changed because
this function also accepts a (comma separated) list of pulses. If the
function is called with no arguments at all the start positions of all
pulses that have the @code{DELTA_START} property defined are changed.


There is a similar function for changing the length of pulses by their
@code{DELTA_LENGTH}, called @ref{pulser_increment()}:
@example
pulser_increment( P3 );  // or  pulser_increment( 3 );
@end example
@noindent
As for the @ref{pulser_shift()} function also this functions accepts a
comma separated list of pulses, and calling it with no arguments
automatically lengthens all pulses that have the @code{DELTA_LENGTH}
property defined.


The second method allows to you to change the start position or length
of a pulse directly and in increments differing from @code{DELTA_START}
or @code{DELTA_LENGTH}. If, for example, the position of pulse 4 has to
be changed to @w{500 ns} and its length to @w{120 ns}, one may simply
write
@example
P4.START  = 500 ns;
P4.LENGTH = 120 ns;
@end example
@noindent
This method can also be used to switch off a pulse completely by
assigning 0 to the pulse length.


Of course, as in the definition of the pulses in the @code{PREPARATION}
section the properties of the pulse itself and other pulses can be used
in setting the new values, e.g.:
@example
P4.START  = P3.START + 200 ns;
P4.LENGTH = 2 * P4.LENGTH + 20 ns;
@end example
@noindent
As you see, these properties (i.e.@: start positions and lengths and the
corresponding delta start positions and lengths) of pulses can be treated
nearly as if they are just normal variables.


Also the values for @code{DELTA_START} and @code{DELTA_LENGTH} can be
changed in this way at any time during the experiment:
@example
P4.DELTA_START  = 20 ns;
P4.DELTA_LENGTH = 10 ns;
@end example
@noindent
This holds even if these properties haven't been defined in the
@code{PREPARATION} section at all.


The only pulse properties that may not be changed during the experiment
are the function and the phase sequence associated with the pulse.


There is only one point that needs to be taken care of: Just calling one
of these methods to change pulse properties does not change the real
pulses immediately. Instead, all these changes are stored internally in
the program. The changes only get send to the pulser when the function
@ref{pulser_update()} is called. Therefor, the normal way to change the
pulse pattern is to change all necessary pulse properties and when
everything is done to call @ref{pulser_update()} in order to commit the
changes. In this moment the program will also do all its usual checks,
e.g.@: it will test that no pulses overlap.


There is a further function that resets all pulses to their initial
state, @ref{pulser_pulse_reset()}. This function can, for example, be
used for repeating the same experiment several times without having to
reset each pulse individually. As in the other functions the argument
can be either one pulse, a list of pulses or no argument, in which case
all pulses are reset to their initial positions and lengths (i.e.@: as
set in the initial definition of the pulse in the @code{PREPARATIONS}
section.


Here is now a somewhat shortened example of a 2 pulse Hahn-echo
experiment. Two microwave pulses are needed, a pi-half and a pi pulse,
plus a detection pulse to trigger the digitizer. This trigger pulse must
move twice as fast as the second microwave pulse because the distance of
the echo from the second pulse is always as large as the distance
between both the microwave pulses.
@example
DEVICES:

dg2020_b;    // Berlin X-band spectrometer pulser
tds520c;     // digitizer

VARIABLES:

tau_0     = 200 ns;
delta_tau =  50 ns;
pi_pulse  = 100 ns;

I, J;
data[ 20, 1024];
Window;

ASSIGNMENTS:

TIMEBASE:     5 ns;
TRIGGER_MODE: INTERNAL, REPEAT_TIME = 20 ms;
MICROWAVE:    POD = P8,  V_HIGH = 5 V, V_LOW = 0 V;
DETECTION:    POD = P5,  V_HIGH = 3 V, V_LOW = 0 V;

PREPARATIONS:

P0:   FUNCTION    = MICROWAVE,       // 1st microwave pulse
      START       = 0 ns,
      LENGTH      = pi_pulse / 2;

P1:   FUNCTION    = MICROWAVE,       // 2nd microwave pulse
      LENGTH      = pi_pulse,
      START       = P0.START + P0.LENGTH / 2 + tau_0 - P1.LENGTH / 2,
      DELTA_START = delta_tau;

P2:   FUNCTION    = DETECTION,       // trigger pulse
      LENGTH      = 5 ns,
      START       = P1.START + P1.LENGTH / 2 + tau_0,
      DELTA_START = 2 * delta_tau;

Window = digitizer_define_window( P2.START + 250 ns, 100 ns );

EXPERIMENT:

FOR J = 1 : 20 @{          // repeat experiment 20 times
    FOR I = 1 : 1024 @{
        digitizer_start_acquisition( );
        data[ J, I ] = digitizer_get_area( CH1, Window );
        pulser_shift( );             // move all pulses
        pulser_update( );            // commit the changes
    @}
    pulser_pulse_reset( );           // reset all pulses
@}
@end example


Beside the functions for changing the positions and lengths of pulses
there are also functions to adjust the phases of pulses, needed for
for phase cycled experiments. When the experiment starts the phase of
a pulse is set to the first phase of its associated phase sequence
(defined in the @code{PHASES} section). To switch to the next phase the
function @ref{pulser_next_phase()} has to be used. In contrast to the
functions @ref{pulser_shift()} and @ref{pulser_increment()} this function
can not be used for phase changes of individual pulses but alway applies
to all pulses that have been assigned a phase sequence. Thus this function
does not accepts any arguments.


Again, the necessary changes are only send to the pulser when the
function @ref{pulser_update()} is called afterwards. By repeatedly
invoking @ref{pulser_next_phase()} one can run through the complete
phase sequence. To reset all pulses to their start phase (i.e.@: the
first phase of the associated phase sequence) the function
@ref{pulser_phase_reset()} can be used.


The next (rather simplified) example is a script for a phase cycled
(1-dimensional) stimulated echo experiment. We need three microwave
pulses and a further detection pulse that triggers the digitizer at the
right moment. During the experiment the first two microwave pulses have
to be phase cycled.
@example
DEVICES:

dg2020_b;             // Berlin X-band spectrometer pulser
tds520c;              // digitizer

VARIABLES:

tau_0     = 250 ns;   // start distance between 1st & 2nd pulse
delta_tau =  25 ns;   // and the change of this distance
t_0       = 400 ns;   // start distance between 2nd & 3rd pulse
delta_t   =  50 ns;   // and the change of this distance

Curve_length = 128;   // number of points of curve

area, data;
I, J;

ASSIGNMENTS:

TIMEBASE:     5 ns;
TRIGGER_MODE: INTERNAL, REP_FREQ = 200 Hz;

MW:           POD = P1, P2, P3, P4, INVERTED, V_HIGH = 5 V, V_LOW = 0 V;
DETECTION:    POD = P0,                       V_HIGH = 5 V, V_LOW = 0 V;
      
       
PHASE_SETUP:  MW,            // cycle microwave channel
              +X: POD = P1,  // POD 1 on for +X
              -X: POD = P2,  // POD 2 on for -X
              +Y: POD = P3,  // POD 3 on for +Y
              -Y: POD = P4;  // POD 4 on for -Y

PHASES:

PHASE_SEQUENCE_0 = +x, -x, +x, -x;  // for 1st pulse
PHASE_SEQUENCE_1 = +x, +x, -x, -x;  // for 2nd pulse

PREPARATIONS:

P0:  FUNCTION    = MW,                        // 1st microwave pulse
     START       = 0 ns,
     LENGTH      = pi_half_pulse_length,
     PHASE_CYCLE = PHASE_SEQUENCE_0;
     
P1:  FUNCTION    = MW,                        // 2nd microwave pulse
     START       = P0.START + P0.LENGTH  + tau0,
     LENGTH      = pi_half_pulse_length,
     PHASE_CYCLE = PHASE_SEQUENCE_1;

P2:  FUNCTION    = MW,                        // 3rd microwave pulse
     START       = P1.START + P1.LENGTH + t0,
     LENGTH      = pi_half_pulse_length,
     DELTA_START = delta_t;

P3:  FUNCTION    = DETECTION,                 // digitizer trigger pulse
     START       = P2.START + P2.LENGTH,
     LENGTH      = 10 ns,
     DELTA_START = delta_t;

Window = digitizer_define_window( P3.START + 250 ns, 100 ns );
init_1d( );


EXPERIMENT:

FOR I = 1: Curve_length @{
    data = 0.0;
    FOR J = 1 : 4 @{
        digitizer_start_acquisition( );
        area = digitizer_get_area( CH1, Window );

        IF J == 1 OR J == 4 @{
            data += area;     // add 1st & 4th area
        @} ELSE @{
            data -= area;     // subtract 2nd & 3rd area
        @}

        pulser_next_phase( );
        pulser_update( );
    @}

    display( I, data );
    pulser_shift( );
    pulser_update( );
@}
@end example


@ifnottex

@menu
* Simplified pulse cycling::
@end menu

@end ifnottex


@node Simplified pulse cycling, , , Using Pulses
@subsection Simplified pulse cycling
@cindex Simplified pulse cycling


The inner loop in the previous example runs through the 4 different
phase settings, adding up the areas with the correct sign. Instead of
writing out this loop one could also define an acquisition sequence
and use the @code{EDL} function @code{@ref{get_phase_cycled_area()}}.
This function does everything automatically that had to be spelled out
explicitely in the loop in the previous example and thus makes the
script much simpler. The only changes needed are in the @code{PHASES}
and @code{EXPERIMENT} section: first, an acquisition sequence must be
defined and, second, the whole inner loop can be replaced by a single
function call.
@example
PHASES:

PHASE_SEQUENCE_0     = +x, -x, +x, -x;  // for 1st pulse
PHASE_SEQUENCE_1     = +x, +x, -x, -x;  // for 2nd pulse
ACQUISITION_SEQUENCE =  +,  -,  -,  +;

...

Window = digitizer_define_window( P3.START + 250 ns, 100 ns );

EXPERIMENT:

FOR I = 1: 128 @{
    data = get_phase_cycled_area( CH1, Window );
    display( I, data );
    pulser_shift( );
    pulser_update( );
@}
@end example
@noindent
As can be seen from this example @code{@ref{get_phase_cycled_area()}}
not only sets the pulse phases but also starts the digitizer
acquisition, fetches the measured areas from the digitizer and adds up
the areas according to the acquisition sequence.


@code{@ref{get_phase_cycled_area()}} can handle one as well as two
acquisition sequences, see below. But also a single acquisition
sequence may need data from two different digitizer channels, for
example an acquisition sequence like this:
@example
ACQUISITION_SEQUENCE =  +A, -B, -A, +B;
@end example
@noindent
which means that the value for the first phase setting has to be
fetched from the first digitizer channel (associated with @code{A})
and that for the second phase setting the value from the second
digitizer channel (associated with @code{B}) has to be subtracted,
etc. In this case @code{@ref{get_phase_cycled_area()}} expects its
second argument to be the second digitizer channel, i.e.@: it must be
called like this:
@example
data = get_phase_cycled_area( CH1, CH2, Window );
@end example


In some cases one might be interested not only in the value from just
one digitizer window but from two or more. Thus you may specify,
following the digitizer channel(s) to be used for fetching data as many
windows as you need. For each of the windows the phase cycled area is
measured.  Of course, in these cases not just one data value will be
returned but an array of data values with as many elements as there are
digitizer windows passed to the function. It is the responsibility of
the writer of the @code{EDL} script to supply an array long enough
to hold exactly as many data as returned by the function. Here's an
example:
@example
VARIABLES:

Window_1, Window_2;
I;
data[ 2 ];

PHASES:

PHASE_SEQUENCE_0     = +x, -x, +x, -x;  // for 1st pulse
PHASE_SEQUENCE_1     = +x, +x, -x, -x;  // for 2nd pulse
ACQUISITION_SEQUENCE = +A, -B, -A, +B;

...

Window_1 = digitizer_define_window( P3.START + 250 ns, 100 ns );
Window_2 = digitizer_define_window( P3.START + 650 ns );

EXPERIMENT:

FOR I = 1: 128 @{
    data = get_phase_cycled_area( CH1, CH2, Window_1, Window_2 );
    display( I, data[ 1 ], 1, I, data[ 2 ], 2 );
    pulser_shift( );
    pulser_update( );
@}
@end example


Finally, if there are two acquisition sequences
@code{@ref{get_phase_cycled_area()}} will return 2 values for each
digitizer window. Thus it will returns an array of values, where the
first two values are the data from both the acquisition sequences of
the first window, the next two from the second window etc.
