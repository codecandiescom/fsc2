@c $Id$
@c
@c Copyright (C) 1999-2003 Jens Thoms Toerring
@c
@c This file is part of fsc2.
@c
@c Fsc2 is free software; you can redistribute it and/or modify
@c it under the terms of the GNU General Public License as published by
@c the Free Software Foundation; either version 2, or (at your option)
@c any later version.
@c
@c Fsc2 is distributed in the hope that it will be useful,
@c but WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with fsc2; see the file COPYING.  If not, write to
@c the Free Software Foundation, 59 Temple Place - Suite 330,
@c Boston, MA 02111-1307, USA.


@node Using Pulsers, Example EDL Scripts, Device Functions, Top
@chapter Using Pulsers

@ifinfo
@menu
* Setting up the Pulser::  @code{ASSIGNMENTS} and @code{PHASES} section
* Defining Pulses::        How to define pulses
* Using Pulses::           How to use pulses in the experiment
@end menu
@end ifinfo


Using the pulsers has its own chapter covering the special methods to
handle the pulser setup, create pulses and do phase cycling. It also
describes how the way the pulsers are to be used depends on the hardware
used in the spectrometer. The following pulsers/spectrometer
combinations
of implemented:
@itemize @bullet
@item Sony/Tektronix DG2020 (S-band spectrometer, Frankfurt/Main)
@item Sony/Tektronix DG2020 (X-band spectrometer, Berlin)
@item Tektronix HFS9003 (W-band spectrometer, Berlin)
@item Bruker EP385 Pulse Programmer (X-band spectrometer, Berlin)
@item Interface Technology RS690 Word Generator (360 GHz and X-band
spectrometer, Berlin)
@end itemize
All pulsers can be used everywhere when no special requirements for
phase-cycling exist, see the discussion below about the differences
between the Frankfurt S-band and the Berlin X-band spectrometer.

Because of the importance of the pulser for time-resolved experiments
there are even two additional types of sections in the @code{EDL}
script in order to set up the pulser. These
are@footnote{@code{ASSIGNMENTS:} can be abbreviated to
@code{ASSIGNMENT:} or @code{ASS:} and @code{PHASES:} to @code{PHA}.}
@example
ASSIGNMENTS:
PHASES:
@end example
@noindent
The first section deals with the basic setup of the pulsers, the second
is only needed when phase cycling is used.  Valid statements in these
sections differ slightly depending on the type of the pulsers and the
spectrometer.

Beside these additional sections there are several other constructs for
the creation of pulses and their subsequent manipulation. These are
identical for all pulsers and are explained in in subsequent sections of
this chapter.


@c ########################################################

@node Setting up the Pulser, Defining Pulses, Using Pulsers, Using Pulsers
@section Setting up the Pulser

The basic setup of a pulser happens in the @code{ASSIGNMENTS} and the
@code{PHASES} section. The latter section will be missing if no phase
cycling is to be done in the experiment.


@c ########################################################

@anchor{ASSIGNMENTS section}
@subsection @code{ASSIGNMENTS} section
@cindex @code{ASSIGNMENTS} section

Within the @code{ASSIGNMENTS} section the pulsers time bases and trigger
modes are set. It also deals with the basic setup of the channels,
i.e.@: associating some or more output connectors with pulse functions
and setting the physical characteristics of the output (e.g.@: voltage
levels, inverting the output etc.).

@c ########################################################

@anchor{Setting the time base}
@subsubsection Setting the @code{TIMEBASE}
@cindex Setting the @code{TIMEBASE}
@cindex @code{TIMEBASE}


For most pulsers the first statement of the @code{ASSIGNMENTS} section
has to be the setting of the time base of the pulser. Most of the
pulsers function similarly: the output is divided into a certain number
of time slices (usually 65536, 2^16) and for each of them the output can
be either set to a high or a low voltage. By setting the output during
one or more of these time slices to a high voltage (and for the
neighboring slices to low) pulses are created.  The time base set in the
@code{ASSIGNMENT} section is the length of these time slices. From the
above it is clear that all pulses (as well as all the times between
pulses) have to be integer multiples of the length of the time base.

An exception is the @strong{Bruker EP385} pulse programmer. This pulser
has a fixed built-in time base of @w{8 ns}. In this case a
@code{TIMEBASE} statement (see below) may only be given if an external
clock input is used, in which case you need to specify the inverse of
the frequency of the external clock.

In case of the @strong{Interface Technology RS690} the internal clock is
automatically used for time bases of @w{4 ns}, @w{8 ns} and @w{16 ns},
all other time bases require an external clock. To distinguish between
the @code{TTL} and @code{ECL} level input connectors for the external
clock the additional keywords @code{TTL} and @code{ECL} can be given
together with the time base value. When one of these keywords is given
the external clock will be used, even if the time base value is one of
the three values that can be realized using the internal clock. When
neither of the two keywords is given and the specified time base
requires an external clock the @code{TTL} level clock input connector is
used per default.


The statement to set the time base, i.e.@: the length of the individual
time slices is@footnote{Instead of @code{TIMEBASE} one may also write
@code{TB:}, @code{T_B}, @code{TBASE:}, @code{T_BASE:}, @code{TIMEB},
@code{TIME_B:} or @code{TIME_BASE:} instead of @code{TIMEBASE:}.}:
@example
TIMEBASE: 5 ns;
@end example
@noindent
or, for the @strong{Interface Technology RS690}, when using an external
clock at the @code{TTL} level input connector:
@example
TIMEBASE: 25 ns, TTL;
@end example

The minimum and maximum values for the time base differ for the different
pulsers:
@itemize @bullet
@item Sony/Tektronix DG2020: @w{5 ns} to @w{0.1 s}
@item Tektronix HFS9003: @w{1.6 ns} to @w{20 us}
@item Bruker EP385: internal clock @w{8 ns} only (no @code{TIMBASE}
statement allowed), external clock @w{8 ns} and larger
@item Interface Technology R690: @w{4 ns}, @w{8 ns} and @w{16 ns}
for the internal clock, @w{4 ns} and larger with an external clock
@end itemize

If you're using two or more pulsers simultaneously you need as many
@code{TIMEBASE} statements in your @code{EDL} script as you have
pulsers. In this case you need to append a @code{#} character plus the
number of the pulser to indicate for which of the pulsers the statement
is to be used. E.g.@: if you have two pulsers you normally will need two
@code{TIMEBASE} statements:
@example
TIMEBASE#1:  5 ns;
TIMEBASE#2: 25 ns;
@end example
@noindent
The additional @code{#1} in the statement for the first pulser is optional.


@c ########################################################

@anchor{Setting the trigger mode}
@subsubsection Setting the trigger mode
@cindex Setting the trigger mode
@cindex @code{TRIGGER_MODE}
@cindex @code{REPEAT_FREQUENCY}
@cindex @code{REPEAT_TIME}
@cindex @code{INTERNAL}
@cindex @code{EXTERNAL}
@cindex @code{SLOPE}
@cindex @code{LEVEL}
@cindex @code{IMPEDANCE}


The next statement concerns the triggering of the pulser. A pulser
starts a new sequence of pulses either on receiving an external trigger
or it uses an internal trigger. Which type of triggering to use depends,
of course, on the experiment. To set either internal or external trigger
mode use a statement like this@footnote{Instead of @code{TRIGGER_MODE}
also @code{TM:}, @code{T_M:}, @code{TRIGM:}, @code{TRIG_M:},
@code{TRIGMODE:}, @code{TRIG_MODE:}, @code{T_MODE:}, @code{TMODE:},
@code{TRIGGER_M:}, @code{TRIGGERM:} or @code{TRIGGERMODE:} can be
used. And the keywords @code{INTERNAL} and @code{EXTERNAL} can be
shortened to @code{INTERN} or @code{INT} and @code{EXTERN} or
@code{EXT}.}:
@example
TRIGGER_MODE: INTERNAL;
@end example
@noindent
or
@example
TRIGGER_MODE: EXTERNAL;
@end example

Especially when using the internal trigger it is useful to be able to
set the rate or the frequency with which the experiment is to be
repeated. Thus for the @strong{Sony/Tektronix DG2020}, the @code{Bruker
EP385} and @strong{Interface Technology RS690} an additional keyword can
be specified, either @code{REPEAT_TIME} or
@code{REPEAT_FREQUENCY}@footnote{@code{REPEAT_TIME} and
@code{REPEAT_FREQUENCY} may also be abbreviated to @code{REPT},
@code{REP_T}, @code{REPTIME}, @code{REPEAT_TIME}, @code{REPEAT_T},
@code{REPEATT} or @code{REPEATTIME} and @code{REPF}, @code{REP_F},
@code{REPFREQ}, @code{REP_FREQ}, @code{REPFREQUENCY},
@code{REP_FREQUENCY}, @code{REPEATF}, @code{REPEAT_F},
@code{REPEATFREQ}, @code{REPEAT_FREQ} or @code{REPEATFREQUENCY}.}, i.e.@
one may use:
@example
TRIGGER_MODE: INTERNAL, REPEAT_TIME = 10 ms;
@end example
@noindent
or
@example
TRIGGER_MODE: INTERNAL, REPEAT_FREQUENCY = 100 Hz;
@end example
@noindent
to set the repetition rate of the experiment to @w{100 Hz}. The repeat
time must be an integer multiple of the time base of the pulser.

if a repetition time is specified when using an external trigger a
repetition time or frequency obviously can't be enforced. It can only be
guaranteed that the pulse sequence is as long as the repetition time,
thus keeping the pulser from getting restarted before the end of the
repetition time.

For the @strong{Tektronix HFS9000} no repetition frequency or rate can
be set, so an external trigger has to be used to determine the
repetition rate of the experiment, otherwise the pulser will repeat the
pulse sequence at the highest possible rate.

For the @strong{Bruker EP385} pulser the highest repetition frequency is
about @w{976.56 Hz} (when using the internal clock, otherwise multiply
the external clocks oscillation period by 160768 to compute the exact
length of the minimum repeat time). Repetition times can be only set to
multiples of @w{102.4 us} (or in increments of 12800 times the external
clocks oscillation period). If necessary, repetition frequencies are set
to the next lower allowed value.

For the @strong{Interface Technology RS690} it might happen that for
certain pulse settings the repetition time must be lengthened slightly,
but never more than three times the time base.

On the other hand, when using an external trigger one may want to set
the trigger level, slope and, possibly, the trigger input impedance. For
pulsers allowing this it is done using a statement similar to one of
these@footnote{The keywords @code{LEVEL} can be shortens to @code{LEV},
@code{SLOPE} to @code{SL}, @code{POSITIVE} to @code{POS},
@code{NEGATIVE} to @code{NEG}, @code{IMPEDANCE} to @code{IMP} and,
finally, @code{HIGH} to @code{H} and @code{LOW} to @code{L}.}:
@example
TRIG_MODE: EXTERNAL, LEVEL = 3.5 V, SLOPE = NEGATIVE, IMPEDANCE = LOW;
@end example
@noindent
or
@example
TM: EXTERNAL, LEVEL = -1.2 V, SLOPE = POSITIVE, IMPEDANCE = HIGH;
@end example

The @strong{Bruker EP385} does not allow the setting of any of these
parameters.

The trigger input impedance can only be set for the
@strong{Sony/Tektronix DG2020}.

For the @strong{Sony/Tektronix DG2020} the trigger level must be in the
range between @w{-5V} and @w{+5 V}, while for the @strong{Tektronix
HFS9003} the allowed trigger level range is @w{-4.7 V} to @w{+4.7 V}.

For the @strong{Interface Technology RS690} no input trigger level nor
input impedance can be set, but it has two trigger input connectors, one
for @code{TTL} and one for @code{ECL} level trigger input. To
distinguish between both the input ports the additional keywords
@code{TTL} and @code{ECL} may be used. If none is given the @code{TTL}
level input port is used per default.

If you need to control more than one pulser you must have a
@code{TRIGGER_MODE} statement for each of the pulsers. In this case you
need to append a @code{#} and the number of the pulser to tell the
@code{fsc2} for which pulser the trigger mode is to be used.


@c ########################################################

@anchor{Channel setup}
@subsubsection Channel setup
@cindex Channel setup
@cindex @code{MICROWAVE}
@cindex @code{TWT}
@cindex @code{TWT_GATE}
@cindex @code{DETECTION}
@cindex @code{DETECTION_GATE}
@cindex @code{DEFENSE}
@cindex @code{RADIO_FREQUENCY}
@cindex @code{RADIO_FREQUENCY_GATE}
@cindex @code{PULSE_SHAPER}
@cindex @code{PHASE_1}
@cindex @code{PHASE_2}
@cindex @code{OTHER_1}
@cindex @code{OTHER_2}
@cindex @code{OTHER_3}
@cindex @code{OTHER_4}
@cindex @code{CHANNEL}
@cindex @code{POD}
@cindex @code{TRIGGER_OUT}
@cindex @code{V_HIGH}
@cindex @code{V_LOW}
@cindex @code{INVERTED}
@cindex @code{DELAY}

The statements described in the following deal with setting up the
output channels of the pulser. The basic idea is to abstract from the
real output connectors of the pulser and to use symbolic names for them.
So, instead of telling the pulser to output a pulse at e.g.@: the output
connector @w{numbered 1} during the experiment, in the
@code{ASSIGNMENTS} section output connectors are associated with
symbolic names for the functions and these symbolic names are used when
specifying pulses. While this may be only a convenience in simple
experiments (you only have to apply changes in one place when changing
the output connectors instead of finding and changing it for all pulses
concerned) it makes doing phase cycling much simpler because here the
same pulse may have to be output at different output connectors,
depending on the current phase. Instead of always specifying which
output connector to use for a certain phase for each pulse, the program
is told about which connectors to use for a function (and which phase)
and then it's left to the program to do all the bookkeeping about when
to use which output connector.

The following symbolic names for pulse functions are defined:
@itemize @bullet
@item @code{MICROWAVE} (or @code{MW} etc.@footnote{The function
@code{MICROWAVE} can also be abbreviated to @code{MICRO_WAVE}, @code{MICROW},
@code{MICRO_W}, @code{MWAVE}, @code{M_WAVE} or @code{M_W}})
@item @code{TRAVELING_WAVE_TUBE} (or @code{TWT} etc.@footnote{Instead of
@code{TRAVELING_WAVE_TUBE} all other combinations, where any of
constituting words is replaced by its initial character or one or all
underscore characters are missing can be used.})
@item @code{TRAVELING_WAVE_TUBE_GATE} (or @code{TWTG}
etc.@footnote{@code{TRAVELING_WAVE_TUBE_GATE} may also be abbreviated by
all combinations, where any of constituting words is replaced by its
initial character or one or all underscore characters are missing.})
@item @code{DETECTION} (or @code{DET})
@item @code{DETECTION_GATE} (or @code{DETG}
etc.@footnote{@code{DETECTION_GATE} can be also shortened to
@code{DET_G}, @code{DETECTIONGATE}, @code{DETECTION_G},
@code{DETECTIONG}, @code{DET_GATE} or @code{DETGATE}.})
@item @code{DEFENSE} (of @code{DEF})
@item @code{RADIO_FREQUENCY} (or @code{RF} etc.@footnote{Instead
@code{RADIO_FREQUENCY} also all combinations can be used where
@code{RADIO} is replaced by @code{R} or @code{FREQUENCY} by either
@code{FREQ} or @code{F}. The underscore can also be left out.})
@item @code{RADIO_FREQUENCY_GATE} (or @code{RFG}
etc.@footnote{For @code{RADIO_FREQUENCY_GATE} all combinations where
@code{RADIO} is replaced by @code{R}, @code{FREQUENCY} by either
@code{FREQ} or @code{F} or @code{GATE} by @code{G} may be used. As
usual, the underscore characters can be omitted.})
@item @code{PULSE_SHAPER} (or @code{PSH} etc.@footnote{You may
abbreviate @code{PULSE_SHAPER} to @code{PULSESH}, @code{PULSE_SH},
@code{PULSE_SHAPE}, @code{PULSESHAPE}, @code{PULSESHAPER}, @code{P_SH},
@code{P_SHAPE}, @code{PSHAPE}, @code{P_SHAPER}, @code{P_SHAPER}.})
@item @code{PHASE_1} (or @code{PHASE1}, @code{PH_1} or @code{PH1})
@item @code{PHASE_2} (or @code{PHASE2}, @code{PH_2} or @code{PH2})
@item @code{OTHER_1} (or @code{OTHER1}, @code{O_1}, @code{O1},
      @code{OTHER} or @code{O})
@item @code{OTHER_2} (or @code{OTHER2}, @code{O_2} or @code{O2})
@item @code{OTHER_3} (or @code{OTHER3}, @code{O_3} or @code{O3})
@item @code{OTHER_4} (or @code{OTHER4}, @code{O_4} or @code{O4})
@end itemize
The names of the functions do not enforce what the connectors that will
become associated with them are really going to be used for, but it is
probably a good idea not to use e.g.@: the @code{MICROWAVE} function for
something completely different (or other people will have major problems
understanding what your @code{EDL} script is supposed to do and there's
no obfuscated EDL contest yet;-). Besides, some of the pulser modules
also define special functions (e.g.@: for automatically setting TWT
pulses) that only work for some of these functions.

The functions @code{PHASE_1} and @code{PHASE_2} are special in that they
can only be used with the Frankfurt version of the driver for the
@strong{Sony/Tektronix DG2020}, @code{dg2020_f}, and are used for
controlling the phase switches, i.e.@: it's pulses are created
automatically.

The functions @code{OTHER_1} to @code{OTHER_4} should be used in cases
where none of the function names seem to fit the special purpose you
have in mind for the pulses of this function.

Before giving an example it is important to point out that there are
some major differences between the @strong{Sony/Tektronix DG2020} on the
one hand and the @strong{Tektronix HFS9003} and the @strong{Bruker
EP385} on the other. The latter pulsers are quite simple in that they
have just a number of output connectors. In the @strong{Bruker EP385}
they are simply called @code{CH0} to @code{CH7}, while for the
@strong{Tektronix HFS9003} they are divided into sets of channels
belonging to the different channel boards in the device (at least one
board and a maximum of three), so channels are named @code{A1} to
@code{A4}, @code{B1} to @code{B4} and @code{C1} to @code{C4}. 

In contrast, the @strong{Sony/Tektronix DG2020} has 36 internal channels
(named @code{CH0} to @code{CH35}) that have to be mapped to what is
called a POD, that in both cases (Frankfurt S-band and Berlin X-band
spectrometer) has 12 real output connectors, named @code{P0} to
@code{P11}.

Finally, the @strong{Interface Technology RS690} has 4 sets of output
connectors (or even 8, if a second HSM card is installed), each with 16
output channels. Each output channel can be addressed by a letter
between @code{A} and @code{D} (or @code{H}, if two HSM cards are
installed) for the connector, followed by a number between @code{0} and
@code{15}, specifying the channel on the connector to use. Valid channel
designators are e.g.@: @code{A3}, @code{C13} etc. Moreover, the number
of channels of a connector that can be used depends on the time base
setting: for a time base of @w{4 ns} only the lowest 4 channels of each
connector can be used, for a time base of @w{8 ns} only the lower 8
channels.

For the @strong{Tektronix HFS9003} simply a channel is associated with a
function by statements like (the keyword @code{CHANNEL} can be replaced
by @code{CH})
@example
MICROWAVE: CHANNEL = A1;
RF:        CHANNEL = A2;
RF_GATE:   CH = B3;
DETECTION: CHANNEL = TRIG_OUT;
@end example
@noindent
(where the @code{A} in the channel specifier stands for the first
channel card and @code{B} for the second card) or, for the
@strong{Interface Technology RS690},
@example
MICROWAVE: CHANNEL = A3;
RF:        CHANNEL = B7;
RF_GATE:   CH = C5;
DETECTION: CHANNEL = D15;
@end example
@noindent
The output channels usually are numbered as printed on the device, one
exception is the trigger-out channel of the @strong{Tektronix HFS9003},
that is called @code{TRIG_OUT}, and has some special properties, e.g.@:
allowing only one pulse of fixed length.  The keyword @code{TRIG_OUT} by
either @code{TRIGOUT}, @code{TRIGGER_OUT} or
@code{TRIGGEROUT}. 


Please note: the @strong{Tektronix HFS9003} has only 4 channels and does
not allow assignment of more than one channel to a single function.

For the @strong{Sony/Tektronix DG2020} the function gets associated with
one (or more pods, see below why sometimes more than one is needed):
@example
MICROWAVE: POD = P1, P2, P3, P4;
RF:        POD = P6;
RF_GATE:   POD = P7;
DETECTION: POD = P11;
@end example
@noindent
Instead of @code{POD} you can also write @code{P}.

Optionally, for the @strong{Sony/Tektronix DG2020} you can also tell the
program which of its 36 internal channels (numbered 0 to 35) should be
used. If you don't the program will automatically grab as many of the
internal channels as it needs, always using the ones with the lowest
numbers first. To declare which of the internal channels are to be
associated with the output connectors (PODs) use a statement like this:
@example
MICROWAVE: POD = P1, P2, P3, P4  CHANNEL = 31, 32, 33, 34;
RF:        POD = P6              CHANNEL = 35;
RF_GATE:   POD = P7              CHANNEL = 17;
DETECTION: POD = P11;   // leave it to the program to select the channel
@end example

Here a list of the pod and/or channel numbers that can be used for the
pulsers:
@itemize @bullet
@item Sony/Tektronix DG2020: POD = P0..P11, CH = CH0..CH35
@item Tektronix HFS9003: CH = A1..A4, B1..B4, C1..C4, TRIG_OUT
@item Bruker EP385: CH = CH0..CH7
@item Interface Technology RS690: CH = X0..15 with X standing for A..D
(or A..H when two HSM cards are installed)
@end itemize

Beside defining at which of the output connectors the pulses for a
function will appear at you can also set other properties for the pulses
of a POD or channel. As far as the hardware allows it you may set the
high and the low voltage for all pulses of a function by using the
keywords @code{V_HIGH} and @code{V_LOW}@footnote{Instead of
@code{V_HIGH} you can also write @code{VHIGH}, @code{V_H} or @code{VH}
and for @code{V_LOW} you may use @code{VLOW}, @code{V_L} or @code{VL}.}:
@example
MICROWAVE: POD = P1, P2, P3, P4  V_HIGH = 4.3 V, V_LOW = -0.5 V;
RF:        POD = P6              V_HIGH = 2.6 V, V_LOW = 0 V;
RF_GATE:   POD = P7              V_HIGH = 5 V,   V_LOW = 0 V;
@end example
@noindent
The high voltage must always be larger than the low voltage, to get
inverted pulses use the @code{INVERTED} keyword, see below.

For the @strong{Sony/Tektronix DG2020} the high voltage can be adjusted
to values between @w{-2 V} and @w{+7 V} and the low voltage can be in
the range between @w{-3 V} and @w{+6 V}. The difference between the
voltages must be between @w{0.5 V} and @w{9 V} and can be set in
increments of @w{0.1 V}.

For the @strong{Tektronix HFS9003} the high voltage can be adjusted to
values between @w{-1.5 V} and @w{+5.5 V}, the low voltage has to be in
the range from @w{-2 V} to @w{+5 V}. The minimum and maximum voltage
swing is @w{0.5 V} and @w{5.5 V}, respectively, and the voltage
resolution is @w{10 mV}.

If a function requires the output levels to be inverted (i.e.@: that the
voltage is high while there are no pulses and low during pulses) use the
@code{INVERTED} keyword@footnote{The keyword @code{INVERTED} can be
shortened to @code{INVERT} or @code{INV}.}:
@example
RF:        POD = P6   V_HIGH = 2.6 V, V_LOW = 0 V, INVERTED;
@end example


For both the @strong{Bruker EP385} and @strong{Interface Technology
RS690} pulser pulse levels can't be specified. For the @strong{Bruker
EP385} also the @code{INVERTED} keyword cannot be used, use the inverted
output connectors instead.


Finally, in order to take care of different cable lengths a delay for a
function can be set. This delay will be automatically added to the start
position of each pulse of this function:
@example
MICROWAVE: POD = P1, P2, P3, P4  DELAY = 50 ns;
@end example
@noindent
For obvious reasons setting negative delays are only possible when in
internal trigger mode@footnote{The obvious reason is, of course,
causality - the pulser can't know when the external trigger is going to
happen, so starting before the trigger is detected would be a bit
difficult. By the way, the keyword @code{DELAY} can be abbreviated to
@code{DEL}.}.


If you are dealing with two or more pulsers simultaneously you will have
to append a @code{#} character plus the pulser number to each of the
channel function setup statements, i.e.@: use
@example
MICROWAVE#1: POD = P3;
TWT#2:       CH  = A7;
@end example
@noindent
to create microwave pulses with the first pulser and TWT pulses with the
second one.


@c ########################################################

@anchor{Phase channel setup}
@subsubsection Phase channel setup
@cindex Phase channel setup
@cindex @code{PHASE_SETUP}

Please note that a phase channel setup can only be done with the
@strong{Sony/Tektronix DG2020} and the @strong{Bruker EP385} pulsers and
that there are several differences between the Frankfurt S-band and the
Berlin X-band spectrometer. And all the following is only relevant if
phase cycling is to be used.

@strong{Berlin X-band spectrometer} (@strong{Sony/Tektronix DG2020},
@strong{Bruker EP385} and @strong{Interface Technology RS690}):

The Berlin bridge setup is rather simple in that it expects pulses with
different phases to appear on different input connectors of the
microwave bridge. The bridge has 4 different inputs, one for each phase
@code{+X}, @code{-X}, @code{+Y} and @code{-Y}, and the phase of the
pulse coming from the bridge and going to the TWT amplifier depends on
which input connector was used for the pulse.

Now all you have to do is to tell the program once which pulser pod
channel is connected to which phase input of the bridge (and, to allow
for some sanity checks, which functions is to be phase cycled). This is
done via a statement in the @code{ASSIGNMENTS} section like the following:
@example
PHASE_SETUP:  MICROWAVE,
               X: POD = P1,
              +Y: POD = P2,
              -X: POD = P4,
              -Y: P5;
@end example
@noindent
or
@example
PHASE_SETUP:  MICROWAVE,
               X: CH = C1,
              +Y: CH = C2,
              -X: CH = C4,
              -Y: C5,
@end example
@noindent
(depending on the pulser you use).  In this example you obviously want
to phase cycle the microwave pulses and the @code{+X} input connector of
the bridge is connected to pod channel 1 (or output connector C1) of the
pulser etc.@footnote{As usual, the keyword @code{PHASE_SETUP} can be
abbreviated, either to @code{PH_SETUP}, @code{PHASE_S}, or @code{PHS}.}
Since you actually can have 2 phase cycled function, you may append
either @code{1} or @code{_1} and @code{2} or @code{_2} to distinguish
between the two phase setups, i.e.@: @code{PHASE_SETUP_1}.

Please note that you only have to supply settings for phases that are
really needed in the experiment, e.g.@: if in the experiment only the
@code{+x} and @code{-x} phases are needed only channels for both these
phases have to be specified.


@strong{Frankurt S-band spectrometer} (@strong{Sony/Tektronix DG2020}
only):

The Frankfurt spectrometer is somewhat more complicated. The bridge has
one microwave pulse input and two further input channels that control the
setting of the bridges phase switch. So, while a microwave pulse is sent
to the bridge, further phase pulses have to be present to control the
phase switch. Two phase inputs are enough to differentiate between the 4
phases @code{+X}, @code{-X}, @code{+Y} and @code{-Y}.

In order to create the phase pulses an extra function is needed for
these pulses, which is called @code{PHASE} (or, abbreviated @code{PH}).
For being able to feed both the bridges phase inputs, for this function
two of the pod channels of the pulser are needed. The definition of this
function looks nearly identical to the other functions, the only
exception is that also the name of the function to be phase cycled using the
phase function needs to be specified:
@example
PHASE:        MICROWAVE, POD = P8, P9, V_HIGH = 5 V, V_LOW = 0 V;
@end example
@noindent
In this example the phase function is used to phase cycle the microwave
pulses and the pod channels assigned to it are the ones numbered 8 and 9.

The second thing that is needed is which voltages have to be present at
the outputs to set a certain phase. Here's an example:
@example
PHASE_SETUP:   X: POD_1 = OFF, POD2 = OFF,
              +Y: POD1  = ON,  POD_2 = 0,
              -X: 0, 1,
              -Y: 1, 1;
@end example
@noindent
This phase setup command tells the program that to set the @code{+X} phase
the voltage at both pod outputs of the phase function have to be in the
low state, while for the @code{-Y} phase the first pod output (set to pod
channel 8 by the @code{PHASE} command, see above) has to be in the high
state, while the other output (pod channel 9) has to be low. @code{POD_1}
stands here for the first pod channel of the phase function,
@code{POD_2} for the second one. @code{ON} and @code{1} can both be used
to indicate a high output state, @code{OFF} and @code{0} stand for a low
state.

With these informations the program is able (or nearly is) to create the
the additional "phase" pulses (i.e.@: the pulses that control the phase
switch) without the user having to deal with it. So, all that needs to
be done later is to create the microwave pulses and define the sequence
of phases for the pulses. The program will automatically create the
pulses necessary to set the phases of the microwave pulses.

You can also specify how long phase pulses start before the pulse
they are made for and how much longer they are supposed to last by using
the functions @code{pulser_phase_switch_delay()} and
@code{pulser_grace_period()} (these functions replace the deprectated
but still supported keywords @code{PHASE_SWITCH_DELAY} and
@code{GRACE_PERIOD} in the @code{ASSIGNMENTS} section).



@c ########################################################

@anchor{PHASES section}
@subsection @code{PHASES} section
@cindex @code{PHASES} section
@cindex @code{PHASE_SEQUENCE}
@cindex @code{ACQUISITION_SEQUENCE}


The @code{PHASES} section is for defining with phase sequences and,
optionally, acquisition sequences. As the word says a phase sequence
defines for one (or more) pulses the sequence of phases a pulse is
switched between in the experiment. For example, in a phase cycled
stimulated echo experiment the first microwave pulse usually is set
first to a @code{+X} phase, then to @code{-X}, again to @code{+X} and
finally to @code{-X}. The second pulse will run at the same time through
the sequence @code{+X}, @code{+X}, @code{-X} and @code{-X}. The third
pulse has alway the same @code{+X} phase. Because a constant phase of
@code{+X} is the default, only two phase sequences have to be defined:
@example
PHASE_SEQUENCE_1: +x, -x, +x, -x;  // for 1st pulse
PHASE_SEQUENCE_2: +x, +x, -x, -x;  // for 2nd pulse
@end example
@noindent
As can be seen from this example the keyword is
@code{PHASE_SEQUENCE}@footnote{@code{PHASE_SEQUENCE}can be shortened to
@code{PHASESEQUENCE}, @code{PH_SEQUENCE}, @code{PHSEQUENCE},
@code{PHASE_SEQ}, @code{PHASESEQ}, @code{PHASEA_S}, @code{PHASES},
@code{PH_SEQ}, @code{PHSEQ}, @code{PH_S}, @code{PHS}.}, followed by an
optional underscore and the number of the phase sequence (if there is
only one phase sequence no number is needed). For the phase number any
number between 0 and 2147483647 @w{(2^32 - 1)} can be chosen. Of course
the lengths of all phase sequences have to be identical.

The following sections explain how the phase sequences become
associated with certain pulses.

Beside the phase sequences also acquisition sequences can be defined.
These are used by some @code{EDL} functions to determine how the
results of the experiments with different phases have to be added up in
order to give the final result for a complete phase cycling sequence. In
the example of a phase cycled stimulated echo experiment the area of the
echo measured for the second phase setting has to be subtracted from the
area of the first phase, the area of the third also has to be subtracted, and
for the fourth the area has to be added. Thus the acquisition sequence
would be defined as:
@example
ACQUISITION_SEQUENCE: +, -, -, +;
@end example

When one has an experiment with a quadrature mixer one also can define
in the acquisition sequence which of the signals from the two digitizer
channels have to be used. The first channel is named @code{A} and the
second @code{B}. In this case one usually also needs two acquisition
sequences, one for the real part and one for the imaginary part of the
signal. To distinguish between the sequences append either @code{1} or
@code{2} to the keyword (optionally with an underscore in between. As an
example here the phase and acquisition sequence definitions for an
inversion recovery experiment with FID detection and phase cycling:
@example
PHASE_SEQUENCE_1       = +x, +x, +x, +x, -x, -x, -x, -x;
PHASE_SEQUENCE_2       = +x, -x, +y, -y, +x, -x, +y, -y;
ACQUISITION_SEQUENCE_1 = +A, -A, +B, -B, +A, -A, +B, -B;
ACQUISITION_SEQUENCE_2 = +B, -B, -A, +A, +B, -B, -A, +A;
@end example

The definition of acquisition sequences is optional and only needed if
the function @code{get_phase_cycled_area()} (see below) is going to be
used. If defined their lengths have to be identical to the lengths of
the phase sequences.



@c ########################################################


@node Defining Pulses, Using Pulses, Setting up the Pulser, Using Pulsers
@section Defining Pulses

@cindex @code{PULSE_}
@cindex @code{FUNCTION}
@cindex @code{START}
@cindex @code{LENGTH}
@cindex @code{DELTA_START}
@cindex @code{DELTA_LENGTH}
@cindex @code{PHASE_CYCLE}


While the basic setup of the pulse happens in the @code{ASSIGNMENTS}
and, possibly, in the @code{PHASES} section, the definition of the
pulses is done in the @code{PREPARATIONS} section.

Each pulse has at least three properties: a unique number, a function
and a start position. Actually, pulses also need a length, so as long
as the length is not set (or is 0) the pulse stays switched off. Here is
an example of how to create a pulse, numbered @code{1}, that is a
microwave pulse, starts @w{100 ns} after the trigger) and has a length
of @w{250 ns}:
@example
PULSE_1:    FUNCTION = MICROWAVE,
            START    = 100 ns,
            LENGTH   = 250 ns;
@end example
@noindent
As usual, most of the keywords can be abbreviated, @code{PULSE_1:} to
@code{PULSE1:}, @code{P_1:} or @code{P1:}, @code{FUNCTION} to either
@code{FUNC} or @code{F}, @code{START} to @code{S}, and finally,
@code{LENGTH} to @code{LEN} or @code{L}. And, of course, for numerical
values like pulse positions and times variables, complex expressions and
functions can be used.

Pulse numbers can be chosen randomly - the only requirement is that the
numbers are positive (including 0) and not larger than 2147483647
@w{(2^32 - 1)} (of course there always is some limitation by the device
that won't allow to create that many pulses). Positions and lengths of
pulses have to be positive (including 0). A pulse of zero length is
invisible.

If more than one pulser is used it must also be indicated which pulser
is supposed to create the pulse. This is done by appending the @code{#}
character, followed by the pulser number, to the @code{PULSE}
keyword. Thus, if e.g.@: the pulse numbered 3 has to be created by the
second pulser it must be created by a command like the following:
@example
PULSE_3#2:   FUNCTION = RADIO_FREQUENCY,
             START    = 2 ms,
             LENGTH   = 8 ms;
@end example
@noindent
Please note that in this case a @code{RADIO_FREQUENCY} function must
have been defined for the @strong{second} pulser.

Even when using more than one pulser the pulse numbers still have to be
unique. If e.g.@: a pulse numbered @code{1} has been created for the
first pulser it is @strong{not} allowed to create a second pulse with
the same number even when it is assigned to another pulser.


There are three additional properties a pulse can have. The first one is
a constant amount of time the start position of the pulse will be
changed by during the experiment, the corresponding keyword is
@code{DELTA_START}@footnote{@code{DELTA_START} can be abbreviated to
@code{DELTASTART}, @code{DELTA_S}, @code{DELTAS}, @code{DEL_START},
@code{DELSTART}, @code{DEL_S}, @code{DELS}, @code{D_START},
@code{DSTART}, @code{D_S} or @code{DS}.}. Second, there is a constant
length change of the pulse,
@code{DELTA_LENGTH}@footnote{@code{DELTA_LENGTH} can be shortened to
@code{DELTALENGTH}, @code{DELTA_L}, @code{DELTAL}, @code{DEL_LENGTH},
@code{DELLENGTH}, @code{DEL_L}, @code{DELL}, @code{D_LENGTH},
@code{DLENGTH}, @code{DEL_L}, @code{DELL}, @code{D_LENGTH},
@code{DLENGTH}, @code{D_L} or @code{DL}.}. And finally, there is the
phase sequence to be used for phase cycling of the pulse -- here the
keyword is @code{PHASE_CYCLE}@footnote{@code{PHASE_CYCLE} can also be
written as @code{PHASECYCLE}, @code{PHASE_C}, @code{PHASEC},
@code{PH_CYCLE}, @code{PHCYCLE}, @code{PH_C} or @code{PHC}.}.

With these additional properties (using, for phase cycling of the pulse,
the first phase sequence defined in the @code{PHASES} section, see
above) the definition of the pulse would look like this:
@example
PULSE_1:    FUNCTION     = MICROWAVE,
            START        = 100 ns,
            LENGTH       = 250 ns,
            DELTA_START  = 20 ns,
            DELTA_LENGTH = 35 ns,
            PHASE_CYCLE  = PHASE_SEQUENCE_1;
@end example

When setting the properties of further pulses the properties of pulses
already defined can be used. This is done by specifying the name of the
pulse (e.g.@: @code{PULSE_1}), followed by a dot and the property of the
referenced pulse to be used. For example, if you want to create a second
pulse that is also a microwave pulse, starts @w{300 ns} after the end
of the first pulse and is twice as long, you could write:
@example
PULSE_2:    FUNCTION     = PULSE_1.FUNCTION,
            START        = PULSE_1.START + PULSE_1.LENGTH + 300 ns,
            LENGTH       = 2 * PULSE_1.LENGTH;
@end example


@c ########################################################

@node Using Pulses, , Defining Pulses, Using Pulsers
@section Using Pulses


When pulses have been defined and the experiment is started (indicated by
the begin of the @code{EXPERIMENT} section) all pulses get set (as long as
their lengths are defined and non-zero) and all channels or PODs that
have been assigned pulses (that are really used in the experiment) are
switched on.

There are two methods to change the properties of pulses. The first one
works by calling a dedicated function. To change the start position of,
for example, pulse 1 by the start position change time
(@code{DELTA_START}) as defined in the properties of the pulse the
function @code{pulser_shift()} (see also @ref{Pulser Functions}) can be
used:
@example
pulser_shift( P1 );      // or  pulser_shift( 1 );
@end example
@noindent
Also the start position of several pulses at once can be changed because
this function also accepts a (comma separated) list of pulses. If the
function is called with no arguments at all the start positions of all
pulses that have the @code{DELTA_START} property defined are changed.

There is a similar function for changing the length of pulses by their
@code{DELTA_LENGTH}, called @code{pulser_increment()} (see also
@ref{Pulser Functions}):
@example
pulser_increment( P3 );  // or  pulser_increment( 3 );
@end example
@noindent
As for the @code{pulser_shift()} function also this functions accepts a
comma separated list of pulses, and calling it with no arguments
automatically lengthens all pulses that have the @code{DELTA_LENGTH}
property defined.

The second method allows to you to change the start position or length
of a pulse directly and in increments differing from @code{DELTA_START}
or @code{DELTA_LENGTH}. If, for example, the position of pulse 4 has to
be changed to @w{500 ns} and its length to @w{120 ns}, one may simply
write
@example
P4.START  = 500 ns;
P4.LENGTH = 120 ns;
@end example
@noindent
This method can also be used to switch off a pulse completely by
assigning 0 to the pulse length.

Of course, as in the definition of the pulses in the @code{PREPARATION}
section the properties of the pulse itself and other pulses can be used
in setting the new values, e.g.:
@example
P4.START  = P3.START + 200 ns;
P4.LENGTH = 2 * P4.LENGTH + 20 ns;
@end example
@noindent
As you see, these properties (i.e.@: start positions and lengths and the
corresponding delta start positions and lengths) of pulses can be treated
nearly as if they are just normal variables.

Also the values for @code{DELTA_START} and @code{DELTA_LENGTH} can be
changed in this way at any time during the experiment:
@example
P4.DELTA_START  = 20 ns;
P4.DELTA_LENGTH = 10 ns;
@end example
@noindent
This holds even if these properties haven't been defined in the
@code{PREPARATION} section at all.

The only pulse properties that may not be changed during the experiment
are the function and the phase sequence associated with the pulse.

There is only one point that needs to be taken care of: Just calling one
of these methods to change pulse properties does not change the real
pulses immediately. Instead, all these changes are stored internally in
the program. The changes get only send to the pulser when the function
@code{pulser_update()} (see also @ref{Pulser Functions}) is
called. Therefor, the normal way to change the pulse pattern is to
change all necessary pulse properties and when everything is done
@code{pulser_update()} is called to commit the changes. In this moment
the program will also do all its usual checks, e.g.@: it will test that
no pulses overlap.

There is a further function that resets all pulses to their initial
state, @code{pulser_pulse_reset()}. This function can, for example, be
used for repeating the same experiment several times without having to
reset each pulse individually. As in the other functions the argument
can be either one pulse, a list of pulses or no argument, in which case
all pulses are reset to their initial positions and lengths (i.e.@: as
set in the initial definition of the pulse in the @code{PREPARATIONS}
section.

Here is now a somewhat shortened example of a 2 pulse Hahn-echo
experiment. Two microwave pulses are needed, a pi-half and a pi pulse,
plus a detection pulse to trigger the digitizer. This trigger pulse must
move twice as fast as the second microwave pulse because the distance of
the echo from the second pulse is always as large as the distance
between both the microwave pulses.
@example
DEVICES:

dg2020_b;    // Berlin X-band spectrometer pulser
tds520c;     // digitizer

VARIABLES:

tau_0     = 200 ns;
delta_tau =  50 ns;
pi_pulse  = 100 ns;

I, J;
data[ 20, 1024];
Window;

ASSIGNMENTS:

TIMEBASE:     5 ns;
TRIGGER_MODE: INTERNAL, REPEAT_TIME = 20 ms;
MICROWAVE:    POD = P8,  V_HIGH = 5 V, V_LOW = 0 V;
DETECTION:    POD = P5,  V_HIGH = 3 V, V_LOW = 0 V;

PREPARATIONS:

P0:   FUNCTION    = MICROWAVE,       // 1st microwave pulse
      START       = 0 ns,
      LENGTH      = pi_pulse / 2;

P1:   FUNCTION    = MICROWAVE,       // 2nd microwave pulse
      LENGTH      = pi_pulse,
      START       = P0.START + P0.LENGTH / 2 + tau_0 - P1.LENGTH / 2,
      DELTA_START = delta_tau;

P2:   FUNCTION    = DETECTION,       // trigger pulse
      LENGTH      = 5 ns,
      START       = P1.START + P1.LENGTH / 2 + tau_0,
      DELTA_START = 2 * delta_tau;

Window = digitizer_define_window( P2.START + 250 ns, 100 ns );

EXPERIMENT:

FOR J = 1 : 20 @{          // repeat experiment 20 times
    FOR I = 1 : 1024 @{
        digitizer_start_acquisition( );
        data[ J, I ] = digitizer_get_area( CH1, Window );
        pulser_shift( );             // move all pulses
        pulser_update( );            // commit the changes
    @}
    pulser_pulse_reset( );           // reset all pulses
@}
@end example


Beside the functions for changing the positions and lengths of pulses
there are also functions to adjust the phases of pulses, needed for
for phase cycled experiments. When the experiment starts the phase of
a pulse is set to the first phase of its associated phase sequence
(defined in the @code{PHASES} section). To switch to the next phase the
function @code{pulser_next_phase()} (see also @ref{Pulser Functions})
has to be used. In contrast to the functions @code{pulser_shift()} and
@code{pulser_increment()} this function can not be used for phase
changes of individual pulses but alway applies to all pulses that have
been assigned a phase sequence. Thus this function does not accepts any
arguments.

Again, the necessary changes are only send to the pulser when the
function @code{pulser_update()} is called afterwards. By repeatedly
invoking @code{pulser_next_phase()} one can run through the complete
phase sequence. To reset all pulses to their start phase (i.e.@: the
first phase of the associated phase sequence) the function
@code{pulser_phase_reset()} (see also @ref{Pulser Functions}) can be
used.

The next (rather simplified) example is a script for a phase cycled
(1-dimensional) stimulated echo experiment. We need three microwave
pulses and a further detection pulse that triggers the digitizer at the
right moment. During the experiment the first two microwave pulses have
to be phase cycled.
@example
DEVICES:

dg2020_b;             // Berlin X-band spectrometer pulser
tds520c;              // digitizer

VARIABLES:

tau_0     = 250 ns;   // start distance between 1st & 2nd pulse
delta_tau =  25 ns;   // and the change of this distance
t_0       = 400 ns;   // start distance between 2nd & 3rd pulse
delta_t   =  50 ns;   // and the change of this distance

Curve_length = 128;   // number of points of curve

area, data;
I, J;

ASSIGNMENTS:

TIMEBASE:     5 ns;
TRIGGER_MODE: INTERNAL, REP_FREQ = 200 Hz;

MW:           POD = P1, P2, P3, P4, INVERTED, V_HIGH = 5 V, V_LOW = 0 V;
DETECTION:    POD = P0,                       V_HIGH = 5 V, V_LOW = 0 V;
      
       
PHASE_SETUP:  MW,           // cycle microwave channel
              +X: POD = P1,  // POD 1 on for +X
              -X: POD = P2,  // POD 2 on for -X
              +Y: POD = P3,  // POD 3 on for +Y
              -Y: POD = P4;  // POD 4 on for -Y

PHASES:

PHASE_SEQUENCE_0 = +x, -x, +x, -x;  // for 1st pulse
PHASE_SEQUENCE_1 = +x, +x, -x, -x;  // for 2nd pulse

PREPARATIONS:

P0:  FUNCTION    = MW,                        // 1st microwave pulse
     START       = 0 ns,
     LENGTH      = pi_half_pulse_length,
     PHASE_CYCLE = PHASE_SEQUENCE_0;
     
P1:  FUNCTION    = MW,                        // 2nd microwave pulse
     START       = P0.START + P0.LENGTH  + tau0,
     LENGTH      = pi_half_pulse_length,
     PHASE_CYCLE = PHASE_SEQUENCE_1;

P2:  FUNCTION    = MW,                        // 3rd microwave pulse
     START       = P1.START + P1.LENGTH + t0,
     LENGTH      = pi_half_pulse_length,
     DELTA_START = delta_t;

P3:  FUNCTION    = DETECTION,                 // digitizer trigger pulse
     START       = P2.START + P2.LENGTH,
     LENGTH      = 10 ns,
     DELTA_START = delta_t;

Window = digitizer_define_window( P3.START + 250 ns, 100 ns );
init_1d( );


EXPERIMENT:

FOR I = 1: Curve_length @{
    data = 0.0;
    FOR J = 1 : 4 @{
        digitizer_start_acquisition( );
        area = digitizer_get_area( CH1, Window );

        IF J == 1 | J == 4 @{
            data += area;     // add 1st & 4th area
        @} ELSE @{
            data -= area;     // subtract 2nd & 3rd area
        @}

        pulser_next_phase( );
        pulser_update( );
    @}

    display( I, data );
    pulser_shift( );
    pulser_update( );
@}
@end example


@anchor{ Simplified pulse cycling }
@subsection Simplified pulse cycling
@cindex Simplified pulse cycling


The inner loop in the previous example runs through the 4 different
phase settings, adding up the areas with the correct sign. Instead of
writing out this loop one could also define an acquisition sequence and
use the @code{EDL} function @code{get_phase_cycled_area()}. This
function does everything automatically that had to be spelled out
explicitely in the loop in the previous example and thus makes the
script much simpler. The only changes needed are in the @code{PHASES}
and @code{EXPERIMENT} section: first, an acquisition sequence must be
defined and, second, the whole inner loop can be replaced by a single
function call.
@example
PHASES:

PHASE_SEQUENCE_0     = +x, -x, +x, -x;  // for 1st pulse
PHASE_SEQUENCE_1     = +x, +x, -x, -x;  // for 2nd pulse
ACQUISITION_SEQUENCE =  +,  -,  -,  +;

...

Window = digitizer_define_window( P3.START + 250 ns, 100 ns );

EXPERIMENT:

FOR I = 1: 128 @{
    data = get_phase_cycled_area( CH1, Window );
    display( I, data );
    pulser_shift( );
    pulser_update( );
@}
@end example
@noindent
As can be seen from this example @code{get_phase_cycled_area()} not only
sets the pulse phases but also starts the digitizer acquisition, fetches
the measured areas from the digitizer and adds up the areas according to
the acquisition sequence.

@code{get_phase_cycled_area()} can handle one as well as two acquisition
sequences, see below. But also a single acquisition sequence may need
data from two different digitizer channels, for example an acquisition
sequence like this:
@example
ACQUISITION_SEQUENCE =  +A, -B, -A, +B;
@end example
@noindent
which means that the value for the first phase setting has to be fetched
from the first digitizer channel (associated with @code{A}) and that for
the second phase setting the value from the second digitizer channel
(associated with @code{B}) has to be subtracted, etc. In this case
@code{get_phase_cycled_area()} expects its second argument to be the
second digitizer channel, i.e.@: it must be called like this:
@example
data = get_phase_cycled_area( CH1, CH2, Window );
@end example

In some cases one might be interested not only in the value from just
one digitizer window but from two or more. Thus you may specify,
following the digitizer channel(s) to be used for fetching data as many
windows as you need. For each of the windows the phase cycled area is
measured.  Of course, in these cases not just one data value will be
returned but an array of data values with as many elements as there are
digitizer windows passed to the function. It is the responsibility of
the writer of the @code{EDL} script to supply an array long enough
to hold exactly as many data as returned by the function. Here's an
example:
@example
VARIABLES:

Window_1, Window_2;
I;
data[ 2 ];

PHASES:

PHASE_SEQUENCE_0     = +x, -x, +x, -x;  // for 1st pulse
PHASE_SEQUENCE_1     = +x, +x, -x, -x;  // for 2nd pulse
ACQUISITION_SEQUENCE = +A, -B, -A, +B;

...

Window_1 = digitizer_define_window( P3.START + 250 ns, 100 ns );
Window_2 = digitizer_define_window( P3.START + 650 ns );

EXPERIMENT:

FOR I = 1: 128 @{
    data = get_phase_cycled_area( CH1, CH2, Window_1, Window_2 );
    display( I, data[ 1 ], 1, I, data[ 2 ], 2 );
    pulser_shift( );
    pulser_update( );
@}
@end example

Finally, if there are two acquisition sequences
@code{get_phase_cycled_area()} will return 2 values for each
digitizer window. Thus it will returns an array of values, where the
first two values are the data from both the acquisition sequences of the
first window, the next two from the second window etc.
