@c  $Id$
@c
@c  Copyright (C) 1999-2007 Jens Thoms Toerring
@c
@c  This file is part of fsc2.
@c
@c  Fsc2 is free software; you can redistribute it and/or modify
@c  it under the terms of the GNU General Public License as published by
@c  the Free Software Foundation; either version 2, or (at your option)
@c  any later version.
@c
@c  Fsc2 is distributed in the hope that it will be useful,
@c  but WITHOUT ANY WARRANTY; without even the implied warranty of
@c  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c  GNU General Public License for more details.
@c
@c  You should have received a copy of the GNU General Public License
@c  along with fsc2; see the file COPYING.  If not, write to
@c  the Free Software Foundation, 59 Temple Place - Suite 330,
@c  Boston, MA 02111-1307, USA.


@node Modules, Installation, Internals, Top
@chapter Modules
@cindex modules

This chapter tries to describe how to write new modules for use with
@code{fsc2}.

@ifinfo
@menu
* Module Overview::       What modules are good for.
* fsc2s Variables::       How to use fsc2's variables.
* New Modules::           How to write new modules.
* Programming Utils::     Functions that help in programming modules
* Pulser Modules::        Writing modules for pulsers
@end menu
@end ifinfo

@node Module Overview, fsc2s Variables, Modules, Modules
@section What modules are good for


Modules allow to extend the set of commands that can be used in an
@code{EDL} script. This is especially important if a new device needs to
be integrated into @code{fsc2}. You don't have to change @code{fsc2}
itself but just write a new module for the device. To do so you don't
have to understand in all details how @code{fsc2} works. You only must have
a working knowledge of the @code{C} programming language and understand a
few basics about @code{fsc2}'s variables (and, of course, you must know how
your device works and how to communicate with it). But modules may also be
used for other purposes beside handling devices, one could also write modules
that supply new mathematical functions or other functionalities. But the
following discussion will concentrate on modules for new devices, writing
other kinds of modules is even simpler.

I want to start with a short summary of what a module usually consists of and
how to make @code{fsc2} aware of its existence. The most important things
are, of course, the functions that are going to be invoked from @code{EDL}
script. Their names (in the @code{C} code) are identical to the ones
that are used as @code{EDL} function names. Thus, while you are in
principle free to chose whatever names you fancy, it is probably
reasonable to use names that fit the convention to pick names that start
with the type of the device (not its name), followed by an underscore
and a descriptive name. If there are already devices similar to the one
you're writing the module for it's best to use names identical to the
ones in these other modules and also to try to use the same arguments if
possible. This reduces the problems for users when they have to switch
devices, they simply can exchange the device name in the @code{DEVICES}
section and don't have to check each and every function call for the
device. So, if you're writing a driver for a lock-in amplifier stick for
example with the name @code{lockin_get_data()} and don't make up new
ones like @code{lockin_fetch_data()} when the functionality is the same.

Of course, a module will usually also contain other utility functions.
Here you're free to use whatever name you like. To avoid trouble I
always prepend the name of the device to the names of all function not
exported by the module and define them, as far as possible, as @code{static}.
Moreover, I use so-called version scripts (see the files with the exension
@file{.map}) for complete control over which symbols get exported from a
module.

There usually are a few functions in a module beside the ones that are
going to be invoked from @code{EDL} scripts that get called from
@code{fsc2}. These are the so-called hook functions that (if they exist)
get invoked at certain stages of the execution of an @code{EDL} script,
i.e.@: after loading the module, before and after the test run, at the
start and the end of an experiment and, finally, just before the module
is unloaded. From within these functions you can initialize the internal
data of the module, initialize the device you're controlling and finally
bring it back into a well defined state when the experiment is done.

Once you have written the module you must make @code{fsc2} aware of the
new device it's supposed to control and inform it of the additional @code{EDL}
functions that can be used with the device. For this purpose there are
two files in the @file{config} directory, called @file{Devices} and
@file{Functions} where you have to enter the name of the device and
append the new functions to the list of the already known functions.

All these subjects are discussed in detail in the following. But before 
I do so I want to start with an explanation of the special type of
variables used within @code{fsc2}.



@node fsc2s Variables, New Modules, Module Overview, Modules
@section How fsc2's variables work and how to use them

All functions in a module that are going to be invoked from @code{EDL}
scripts get their input parameters in the form of a special type of
variable and @code{fsc2} also expects that each function returns a
value in this form.

Let's start with a look at the way @code{fsc2} internally stores
variables. Here is the (actually somewhat simplified) @code{typedef} of
the structure for variables:
@example
typedef struct Var
@{
    Var_Type_T type;           /* type of the variable */
    union
    @{
        long          lval;   /* value of integer values */
        double        dval;   /* value of float values */
        long   *      lpnt;   /* pointer to integer arrays */
        double *      dpnt;   /* pointer to floating point arrays */
        char   *      sptr;   /* for string constants */
        struct Var ** vptr;   /* for array references, used for
                                multi-dimensional arrays */
    @} val;
    int dim;                  /* dimension of array */
    ssize_t len;              /* length of array */
    struct Var * next;        /* next variable on stack */
@} Var_T;
@end example

There are only six types of variables (defined by an enumeration with
type @code{Var_Type_T}) you have to know about:
@multitable {FLOAT_ARR} {a one-dimensional array of floating point values}
@item @code{INT_VAR} @tab a variable for integer values
@item @code{FLOAT_VAR} @tab a variable for floating point values
@item @code{INT_ARR} @tab a one-dimensional array of integer values
@item @code{FLOAT_ARR} @tab a one-dimensional array of floating point values
@item @code{INT_REF} @tab a 2- or more-dimensional array of integer values
@item @code{FLOAT_REF} @tab a 2- or more-dimensional array of floating point values
@end multitable
@noindent
Actually, there are a few more, but they are only used by @code{fsc2}
internally. If you test for variable types in an @code{switch} you may
get compiler warnings because @code{Var_Type_T} is an @code{enum}. To
avoid the warning simply add a @code{default} for all the other types,
you should never receive a variable of such a type and if you do just
throw an exception (see below) - that happening would be an obvious big
in @code{fsc2}.

To give you a better idea what these variables are good for let's assume
that you want to write a function that returns the curve between the two
cursor bars of your shiny new LeCronix digitizer. For that you may want to
write a function that has the two positions of the cursor bars as input
arguments and which returns the data of the curve between the cursor bars.
Let's call this function
@example
get_curve_between_cursors( cursor_1, cursor_2 )
@end example
@noindent
A typical C declaration for this function is
@example
Var_T * get_curve_between_cursors( Var_T * var );
@end example
@noindent
Surprisingly, there seems to be only a single argument! And how to return
an array of data?

Actually, it's not too complicated. The pointer to the variable
structure @code{var} points to the first of the two parameters. And if
you look back at the typedef for @code{fsc2}'s variables, there is a
@code{next} pointer. This is the key to accessing the further function
argument -- @code{var->next} points to next of the input parameters. If
the function expects even more arguments, @code{var->next->next} etc.@:
let's you get them, i.e.@: the input variables are organized as a linked
list:
@example
  var                               pointer passed to function
   |                                  |
   V                                  |
  ---------------                     V
 |        | next |                  first input parameter
  ---------------                         |
              |                           |
              V                           |
             ---------------              V
            |        | next |       second input parameter
             ---------------                  |
                         |                    |
                         V                    V
                        NULL        no more parameters...
@end example
@noindent
This method allows to pass the function an arbitrary number of arguments
and you can check how many you got by simply counting while following
the pointers until the @code{next} pointer of a parameter is @code{NULL}.

When you later tell @code{fsc2} about the function (by adding it to the
@file{Functions} file, see below) you can explicitely state if the
functions allows a variable number of arguments or only a certain fixed
number. A function that only accepts e.g.@: 3 arguments will always get
3 -- when the @code{EDL} function is called with less arguments an error
message is printed and executing the @code{EDL} script is stopped; if it
is called with too many arguments the superfluous ones are discarded and
an error message is printed before your function gets invoked with the
correct number of arguments.

In case you defined the function to accept a variable number of
arguments you probably better check in your function that there aren't
too many and if necessary print out a warning.

One word of warning: @strong{Never ever change the variables you get
passed to your functions in any way, especially the
@code{next}-pointer!} Even though the variables get thrown away
automatically when you return from the function changing something
within the variables may break the mechanism for clearing up the
variables and lead to all kinds of weird errors.

What @code{fsc2} can't check is if the arguments it passes to your
function have the type you expect. Let's assume that you expect two
integer values. What you should do first is to check if the parameters
you got are really integers. There is a function that can do this for
you, @code{vars_check()}.
@findex vars_check()
All you have to do is to call @code{vars_check()}
with the pointer to the variable and the type you expect it to have,
e.g.@:
@example
vars_check( var, INT_VAR );
vars_check( var->next, FLOAT_VAR );
@end example
@noindent
If @code{vars_check()} finds that everything is ok it simply returns,
otherwise an error message will be printed (telling the user that a
variable of an unexpected type was detected in the function call) and
the program stops, so you don't have to take care of error handling.
If you're prepared to accept integers as well as floating point data,
call @code{vars_check()} instead with
@example
vars_check( var, INT_VAR | FLOAT_VAR );
@end example
@noindent
i.e.@: just logically or the types of variables you're prepared to
accept in your function. 

You can also check if the argument is a string by testing a type
of @code{STR_VAR}, i.e.@:
@example
vars_check( var, STR_VAR );
@end example

@code{vars_check()} not only checks that the variables has the correct
type but also does some internal consistency checks to make sure that
the variable actually exists and has been assigned a value.

A function that expects just integer arguments could start like the
following example, just running through the linked list of parameters:
@example
Var_T * my_function( Var_T * var )
@{
    Var_T * current;

    for ( current = var; current != NULL; current = current->next )
        vars_check( current, INT_VAR );

    ....
@}
@end example

The next question is how to access the value of the variable. As you can
see the typedef for variables above the value is stored in the union
@code{val}.  If the variable has integer type, you can access it as
@quotation
    @code{var->INT}@ @ @ @ (which is a macro standing for @code{var->val.lval})
@end quotation
@noindent
and what you get is a value of type @code{long int} -- @code{fsc2}
is using long integers internally. On the other hand, if the type of the
variable is @code{FLOAT_VAR} you get at the data with
@quotation
    @code{var->FLOAT}@ @ @ @ (i.e.@: a macro for @code{var->val.dval})
@end quotation
@noindent
in which case you get a value of type @code{double}. Finally you may use
@quotation
    @code{var->STRING}@ @ @ @ (a macro standing for @code{var->val.sptr})
@end quotation
to get the address of the start of a string variable.


@subsection Utility functions to determine variables values

There are some utility functions that make it even easier to evaluate
the parameters your function receives (and, if you use those, you don't
need to check them with the @code{var_check()} function). The first one
is for the case that you expect an integer variable but would also be
prepared to deal with a floating point number after it has been rounded
to the nearest integer. This is the function @code{get_long()}, declared
as
@example
long get_long( Var_T *      var,
               const char * snippet );
@end example
@noindent
The first argument is a pointer to the variable you want to
evaluate. The second parameter is used to create a warning message when
the variable isn't an integer variable but a float value. This message
always starts with the name of the currently interpreted @code{EDL}
file, followed by the line number in the @code{EDL} script your function
was invoked from and the device name. The second parameter is a string
that gets embedded into the message. For example, if the currently
interpreted @code{EDL} file is @file{foo.edl}, the line where your
function is called is line 17 and the device name is @code{LECRONIX},
your function (that expects an integer but got a floating point number)
is named @code{abc()} and the string you pass to the function
@code{get_long()} as the second argument is @code{"channel number"}, i.e.
@example
get_long( var, "channel number" );
@end example
@noindent
the following warning message will be printed:
@example
foo.edl:17: LECRONIX: abc(): Floating point number used as channel number.
@end example

If, on the other hand, you expect a floating point number but are also
prepared to accept an integer, you can use the function
@example
long get_double( Var_T *     var,
                const char * snippet );
@end example
@noindent
The arguments of this function are the same you would pass to the
previous function and the only difference is that it will return a
@code{double} and print a warning message if the variable is an
integer variable instead of the expected floating point variable.

If your function can accept an integer variable only there's a third
function:
@example
long get_strict_long( Var_T *      var,
                      const char * snippet );
@end example
@noindent
This function has the same arguments as the two other functions but it
will throw an exception (see below what this means) when getting passed
a floating point number, stopping the interpretation of the @code{EDL}
script. Only while doing the experiment only a warning message is
printed and the floating point number is converted to the nearest
integer, which is then returned, thus avoiding the termination of a
running experiment. But usually the wrong parameter should already have
been found during the test run, forcing the user to correct the script.

There's no function for requirung a double variable only because basically
all functions should accept an integer in place of a double and the
@code{get_double()} function always returns a double, if necessary
after converting the integer value.

Then there is a function for the case where you want a boolean
variable, i.e.@: a variable that can be either true or false. This
function is declared as
@example
bool get_boolean( Var_T * var );
@end example
This function will return true (i.e.@: a value of @code{1}) when the
variable passed to it is either an integer variable with a non-zero
value or a string variable with the string @code{"ON"} (it is
case-insensitive, so @code{"on"}, @code{"On"} or even @code{"oN"} will
also do). False (i.e.@: @code{0} is returned when it receives an integer
variable with a value of @code{0} or a string with the text @code{"OFF"}
(again this is checked in a case-insensitive manner).

If the variable passed to the function is a floating point variable
normally an error message like
@example
foo.edl:17: LECRONIX: abc(): Floating point number found where
                             boolean value was expected.
@end example
@noindent
is printed and an exception is thrown. Should @code{fsc2} already be
running the experiment (instead of just doing the test run) a warning
message is printed and instead of terminating the experiment the
floating point value is converted to the nearest integer value and the
truth value of this number (i.e.@: if it's non-zero) is returned to
avoid stopping the experiment.

Finally, if the @code{get_boolean()} function receives a string variable
that is neither @code{"ON"} nor @code{"OFF"} (including variations of
the case of the characters) an error message is printed:
@example
foo.edl:17: LECRONIX: abc(): Invalid boolean argument ("bla").
@end example
@noindent
(assuming that the string passed to the function was @code{"bla"}) and
an exception is thrown in all cases, even during the experiment, since
there is no obvious way how to determine the truth value of some string.


@subsection Getting at the data of one-dimensional arrays

When a complete one-dimensional array gets passed to your function the
type of the variable is either @code{INT_ARR} or @code{FLOAT_ARR}. As
for single value variables you can check these variables by calling
@code{vars_check()}.

You can find the length of the array by checking the @code{len} part of
the variable structure. Dynamically sized arrays can have a still
undefined length, in which case the @code{len} field has a value of
@code{0}, make sure you check for this possibility in your code.

The actual data of the array can be accessed via the @code{lpnt} or the
@code{dpnt} elements of the @code{val} union in the variables structure.
When you have to deal with an array of integer values (i.e.@: a variable
named @code{var} of type @code{INT_ARR}) the values (of type
@w{@code{long int}}) are in @w{@code{var->val.lpnt[0]}} to
@w{@code{var->val.lpnt[var->len - 1]}}. For an array of floating point
numbers the values (of type @code{double}) are stored in
@w{@code{val->var.dpnt[0]}} to @w{@code{var->val.dpnt[var->len - 1]}}.


@subsection More-dimensional arrays

For arrays of 2 or more dimensions (i.e.@: variables of type
@code{INT_REF} and @code{FLOAT_REF}) the dimension of the array is
stored in the @code{dim} field of the variables structure (i.e.@:
@code{fsc2} doesn't have real more-dimensional arrays but fakes
them in a similar way like e.g.@: Perl by using arrays of pointers).
For the data of such arrays the @code{vptr} field in the @code{val}
union of the variable structure is relevant. @code{vptr} then points
to an array of variable pointers, each pointing to the next
lower-dimension sub-arrays. How many of such sub-arrays exist can
be determined from the @code{len} field of the variable structure.
As already for the one-dimensional arrays care has to be taken to
check that @code{len} isn't @code{0} in case none of the sub-arrays
have been defined yet for variable sized arrays.

If the dimension of a variable is 2 all the sub-arrays are
one-dimensional arrays (i.e.@: have a type of @code{INT_ARR} or
@code{FLOAT_ARR} and one can the values of these sub-arrays as described
in the previous section.

For arrays of higher dimensions the pointers in the @code{val.vptr}
array point to variables that also have a type of @code{INT_REF} or
@code{FLOAT_REF}.

Thus to find out the element @code{[3][2][5]} of variable @code{var}
pointing a three-dimensional floating point array one would have to use
@example
  var->val.vptr[ 3 ]->val.vptr[ 2 ]->val.dpnt[ 5 ]
@end example
Of course, before one tries to access the element one always should check
that @code{var->len} is at least @code{4}, @code{var->val.vptr[3]->len}
is at least @code{3} and @code{var->val.vptr[3]->val.vptr[2]->len} is
at least @code{6}.


But there's also a function that does all the required checks
automatically and returns an element. It is called @code{get_element()}
and is declared as
@example
   Var_T * get_element( Var_T * v, int len, ... );
@end example
@noindent
It takes a variable number of arguments, but at least three. The
first one is a pointer to the array or matrix from which you want an
element and the second is the number of arguments to follow. This number
may not be larger than the dimension of the array or matrix. All the
remaining arguments are indices into the array.

The function returns on success a variable that is either an integer or
float value or a pointer to an array or matrix. On failure (e.g.@:
because the accessed element does not exist) an exception is thrown.

If you have a 1-dimensional array of integers named @code{i_arr_1d} and
you want to determine its fourth element you can call this function like
this
@example
    elem = get_element( i_arr_1d, 1, 3 );
@end example
@noindent
and the returned variable @code{elem} will be of type @code{INT_VAR},
having the value of the fourth element of the array (please remember
that array indices start at @code{0}, so the fourth element has the
index @code{3}).

If, in contrast, you want the element @code{[3][2][5]} of the variable
@code{f_arr_3d}, pointing to a three-dimensional floating point matrix,
you would call the function as
@example
    elem = get_element( f_arr_3d, 3, 3, 2, 5 );
@end example

You can also call the function with less indices than the matrix has
dimensions. In this case the function returns a variable pointing to
the indexed array or sub-matrix.


@subsection Returning data from EDL functions

If your function just wants to return an integer or a float, things are
very easy: just call the function @code{vars_push()} with the type of
the return value as the first and the value itself as the second
argument, e.g.@:
@example
return vars_push( INT_VAR, i_value );
@end example
@noindent
or
@example
return vars_push( FLOAT_VAR, f_value );
@end example
@noindent
where @code{i_value} is a @code{long int} and @code{f_value} must be a
value of type @code{double} (take care not to get this wrong). Of
course, you don't have to use @code{vars_push()} in return statements
only, it simply returns a pointer to the new variable holding the value.

For arrays @code{vars_push()} the first argument is either
@code{INT_ARRAY} or @code{FLOAT_ARRAY}, The second argument is a pointer
to the array (i.e.@: its first argument). For creation of an array
variable also third argument is needed, the length of the array (a
@code{long} integer). If you want to return an array with two integer
arguments you would use for example
@example
data[ 0 ] = 1;
data[ 1 ] = 2;
return vars_push( INT_ARRAY, data, 2 );
@end example
@noindent
assuming that @code{data} is an array of @code{long int}s.

As a complete example here is a rather simple but working function named
@code{square()} that returns the square of the value it got passed:
@example
Var_T * square( Var_T * var )
@{
    long int_square;
    double float_square;
    Var_T * ret_val;

    vars_check( var, INT_VAR | FLOAT_VAR );   /* is it a number ? */ 

    if ( var->type == INT_VAR )
    @{
        int_square = var->INT * var->INT;
        ret_val = vars_push( INT_VAR, int_square );
    @}
    else
    @{
        float_square = var->FLOAT * var->FLOAT;
        ret_val = vars_push( FLOAT_VAR, float_square );
    @}

    return ret_val;
@}
@end example
@noindent
As you see it's checked first that the variable passed to the function
has the correct type - both integer and floating point values are ok
(otherwise the interpretation of the @code{EDL} script would stop).
Next we distinguish between the possibilities that the value is an
integer or a floating point number by testing the @code{type} field of
the variable. Then we create either a new integer variable by calling
@code{vars_push()} with the square of the integer value or a new
floating point variable. Finally, we return the variable pointer
@code{vars_push()} had delivered.

Of course, we could also have written the function in a more compact way:
@example
Var_T * square( Var_T * var )
@{
    vars_check( var, INT_VAR | FLOAT_VAR );

    if ( var->type == INT_VAR )
        return vars_push( INT_VAR, var->INT * var->INT );
    else
        return vars_push( FLOAT_VAR, var->FLOAT * var->FLOAT );
@}
@end example


If your function does not have to return a value at all just return
the integer value @code{1}, which can be interpreted as success.


What if you want to write to function that returns more than one value?
Again we use a function for a digitizer that has to return a curve
stored in an array as an example. Let's assume the data you got from the
digitizer are stored in an array of integers called @code{data} which
has @code{len} elements (where @code{len} is a @code{long}). Now all
you've got to do is call the function @code{vars_push()} as
@example
Var_T * ret_var;

...
ret = vars_push( INT_ARR, data, len );
...
return ret_var;
@end example
@noindent
Actually, at some point of your function you may have allocated memory
for storing the data. It is your responsibility to free this memory
before you return from your function, @code{fsc2} just uses a copy of
the data you pass to it using @code{vars_push()}. As you probably already
guessed, if you want to return a float array, you will have to use
@code{FLOAT_ARR} instead of @code{INT_ARR} in the call to
@code{vars_push()}.

The same method may be used if your function has to return two different
values and both have the same type. Again an array can be returned
@example
VARIABLES:

V1; V2;         // results of call to my_function()
Dummy[ * ];     // variable sized array for values returned by my_function()

...             // lots of stuff left out

Dummy = my_function( );      // automagically sets the dimension 
                             // of array Dummy to 2
V1 = Dummy[ 1 ];
V2 = Dummy[ 2 ];
@end example
@noindent
and the C code for function @code{my_function()} would look like
@example
Var_T * my_function( Var_T * var )
@{
    long v[ 2 ];

    v[ 0 ] = ...;    /* just fill in all the stuff you */
    v[ 1 ] = ...;    /* need to calculate both data    */

    return vars_push( INT_ARR, v, 2 );
@}
@end example


An alternative (e.g.@: if the type of the variables you need to return
differs) is two write two functions where the first one does the
calculations needed and stores the second value in a global
variable. All the second function has to do is just to return the value
of the global variable. This way, the @code{EDL} file might look like
@example
V1 = my_function_1( );
v2 = my_function_2( );
@end example
@noindent
while the C code would define both functions as

@example
static double v2;   /* global variable used by my_function_1() 
                       and my_function_2() */
Var_T * my_function_1( Var_T * v )
@{
    long V1;

    V1 = ...;       /* just fill in all the stuff you */
    v2 = ...;       /* need to calculate both data    */

    return vars_push( INT_VAR, V1 );
@}

Var_T * my_function_2( Var_T * v )
@{
    return vars_push( FLOAT_VAR, v2 );
@}
@end example


Alternatively, you also could write the function in a way that it counts the
number of times it has been called and returns values accordingly, e.g.@: 
@example
V1 = my_function( );
v2 = my_function( );
@end example
@noindent
with the corresponding C code
@example
Var_T * my_function( Var_T * v )
@{
    long V1;
    static double v2;
    static int call_count = 0;


    if ( call_count > 0 )    /* on second call return second value */
    @{
        call_count = 0;      /* don't forget to reset the call counter! */
        return vars_push( FLOAT_VAR, v2 );
    @}
        
    V1 = ...                 /* just fill in all the stuff you */
    v2 = ...                 /* need to calculate both data    */

    return vars_push( INT_VAR, V1 );
@}
@end example
@noindent
Of course, in both cases one has to be careful to call the function(s) in the
correct sequence, so it's not completely foolproof.



@node New Modules, Programming Utils, fsc2s Variables, Modules
@section How to write a new module

@subsection EDL Functions

Each module has its own unique name, usually you will pick name of the
device. Beside, a device usually belongs to a certain group, i.e.@:
lock-in-amplifiers, digitizers, gaussmeters etc. As you will already
have understood, the names of the @code{EDL} functions should be chosen
to start with the type of the device, followed by an underscore and a
name, describing what the function is supposed to do. Typical examples
are @code{lockin_get_data()} or @code{digitzer_time_constant()}.

Please note that there aren't two separate function, one for setting the
digitizers time constant and one for asking the digitizer for the
currently set time constant. Instead there is a single function that can
be used for both purposes. What it's supposed to do gets recognized from
the number of arguments: if there's no argument it returns the
currently set time constant, otherwise it sets the time constant to the
value passed to the function (at least if the value is reasonable). You
should try to follow this convention if possible.

Another convention I am following when inventing function names is that
if one can only either set a certain value for a device or get some data
from a device I always use either @code{set} or @code{get} in the
function name. E.g.@: its not possible to send data values to a
lockin-amplifier, thus I use the name @code{lockin_get_data()} (and not
e.g.@: @code{lockin_data()}). In names for functions that can be used
for setting as well as getting data I try to avoid these words.

All functions to be invoked via an @code{EDL} script take their arguments
in the form of the variables as described above and return a pointer to
such a variable.


@subsection Files to be included

First of all, each module has to include the header file
@file{fsc2_module.h} -- otherwise it will not be able to use
@code{fsc2}'s variables. It should @strong{not} include
@file{fsc2.h}, this header file is for @code{fsc2} itself.
@file{fsc2_module.h} already includes all definitions and declarations
of macros, variables and functions of @code{fsc2} that can be used
within modules.

The module may also have to include a header file for a library dealing
with the interface used for connecting the device to the computer. If
you're using a device on the GPIB bus you need to include @file{gpib_if.h},
if it's connected to one of the serial ports @file{serial.h} or, if the
device is controlled via the LAN, the file @file{lan.h} (all these files
are in the source directory of @code{fsc2}, so just put the file name
into double quotes and it will be found automatically). For other devices
some other include file may be required, e.g.@: @file{rulbus.h} for the
RULBUS, that usually reside in some of the standard include directories and
thus the file name will have to be enclosed in angle braces.

Finally, each module must put its basic configuration information into
a special file which should be commented well enough to allow even
people without much programming experience to adapt the behavior of the
module to his/her needs. A good example are modules for devices that are
accessed via the serial port. Because you probably won't know which
serial port the user is going to use you shouldn't hide this information
somewhere deep down in the innards of your module but put it in a
prominent place where it is easy to find. Thus this is one of the items
that should go into the configuration file.

All configuration files are in the @file{config} directory. For obvious
reasons the names of the configuration files should make it clear for
which module they are used for. Currently, all of them have the extension
@code{.conf}. Each configuration file must contain at least
two items: first a string with the device name should be defined, e.g.
@example
#define DEVICE_NAME     "TDS754A"
@end example
@noindent
This device name should be used in all places where the module has to
print out error messages or warnings. For devices connected via the GPIB
bus this device name should be identical to the one it is advertised as
in the GPIB configuration file (usually @file{/etc/gpib.conf}).

It is probably a good idea to select a name for a device that is
identical to the name of the module in order to avoid confusion for the
users.

For each module also a second string needs to be defined which describes
the device type, e.g.
@example
#define DEVICE_TYPE     "digitizer"
@end example
@noindent
The device type string is used by @code{fsc2} when more than one device
with the same functionality is being used by an @code{EDL} script. You
probably already have read that when you have two such devices you can
access the second one by appending a '@code{#2}' when calling an
@code{EDL}-function. But, obviously, for this to work @code{fsc2} must
know which devices have similar capabilities and which don't. This it
finds out from the device type string. Thus if you decide which device
type string you're going to use please first check the device types of
other devices as defined in their configuration files. If your device
is similar enough to one of the existing devices pick the same device
type string, otherwise pick a new and descriptive name.


@subsection Variables a module must define

In the previous section the meanings of the device name and type strings
have already been discussed. While the definitions of the strings should
go into the configuration file for the device, no memory has been allocated
for these strings yet. This should be done as one of the first things after
the include files have been included. Each and every device module should 
define two constant character arrays called @code{device_name} and
@code{generic_type}, that contain the device name and type strings, i.e.@:
one of the first lines should always be
@example
const char device_name[ ]  = DEVICE_NAME;
const char generic_type[ ] = DEVICE_TYPE;
@end example
or
@example
const char * device_name  = DEVICE_NAME;
const char * generic_type = DEVICE_TYPE;
@end example
@noindent
@code{fsc2} will use the first variable with the device name while printing
warnings and error messages. The second string is needed to find out
about the type of the device. If this variable does not exist
@code{fsc2} won't have any information about the device type and
recognizing another device of the same type automatically will fail (in
which case e.g.@: using more than one device of a certain type won't work)-

Another important point is that if in two modules (with different
@code{generic_type} settings) define the same function name only one of
these modules can be used at the same time. If the user tries to load
both modules in the @code{DEVICES} section an error message will be
printed and interpretation of the @code{EDL} script stopped. Thus it
must be avoided to use identical @code{EDL} function names in modules
for devices of different types.


@subsection Global variables

First, there is a global variable@footnote{Actually, @code{FSC2_MODE}
isn't a real variable. While you can obtain its value you can't assign
values to it, and if your try the compiler will complain about an error
like '@code{invalid lvalue in assignment}'.}, called @code{FSC2_MODE},
which tells you in which context your module function is called. There
are three different contexts: the program can be either interpreting the
@code{VARIABLES} or @code{PREPARATIONS} section, do a test run, or do
the experiment. While the program interprets the @code{VARIABLES} or
@code{PREPARATIONS} section @code{FSC2_MODE} is set to the predefined
value @code{PREPARATION}. At this stage the devices are not initialized
yet and can't be accessed.

Before the real experiment is started a test run of the
@code{EXPERIMENT} section must is done. In this context your module
function still can't access the devices but must try to return
reasonable dummy data. That means that the module functions should at
least return data of the same type as they will do in the actual
experiment. E.g., if a function will return an array during the
experiment it should do the same during the a test run, even though the
data in the array probably are going to be completely bogus. During the
the test run the variable @code{FSC2_MODE} is set to @code{TEST}.

Finally the experiment gets started. Now your module can talk to the
devices and can return 'real' values. During this stage the
@code{FSC2_MODE} variable is set to the value @code{EXPERIMENT} (it's
already set to this value when the @code{exp_hook} functions (see below)
are run).

Thus you will probably often have constructs like the following in your
module functions:
@example
switch ( FSC2_MODE )
@{
    case PREPARATION :
        /* print an error message that this functionality is */
        /* only available from within the EXPERIMENT section */
        break;

    case TEST :
        /* return some reasonable dummy value */
        break;

    case EXPERIMENT :
        /* do something only allowed when you can talk to the */
        /* device, i.e. from within the EXPERIMENT section    */
        break;
@}
@end example


The second important global variable, @code{Need_GPIB}, is of type
@code{bool} and has to be set in the init hook function if the device is
controlled via the GPIB bus. Thus, if the GPIB bus is needed, include a
line in the init hook function similar to
@example
Need_GPIB = SET;
@end example
@noindent
If you forget to set this variable chances are high that the program
will stop with an error message, complaining that it can't access the
GPIB bus.

For devices that use the Rulbus another global variable, @code{Need_RULBUS}
and also of type @code{bool}, has to be set in the init hook function.

Finally, for devices where the LAN is used for communicaation the variable
@code{Need_LAN} (again of type @code{bool}) need to be set in the init hook
function.


@subsection Handling GPIB devices

To make dealing with the GPIB bus simpler there are several routines
that can be used when writing a module, which then call the needed
functions from the GPIB library you choose when installing
@code{fsc2}. To be able to use that functions you must include the
appropriate header file for tge GPIB interface, i.e.@. you need
@example
#include "gpib_if.h"
@end example
@noindent
Please note that these function can't be invoked before
the @code{exp_hook} function.

As already pointed out above, to be able to use the GPIB bus our module
must set the boolean variable @code{need_GPIB}.

The first other thing to do is to announce the device to the library
dealing with the GPIB bus. This should be done in the @code{exp_hook}
function (see below) via a call of the function
@example
int gpib_init_device( const char * name,
                      int *        device );
@end example
@noindent
This function expects the name of the device (which will be used to look
it up in the GPIB configuration file) and the address of an integer,
which, on successful return, will contain a number now associated with
the device and to be used in all further calls of GPIB functions for
this device. The function returns either either @code{SUCCESS} or
@code{FAILURE} (with obvious meaning). All of the functions described in
rest of this section return these values.

The next two most important functions are
@example
int gpib_write( int          device,
                const char * buffer,
                long         length );

int gpib_read( int    device,
               char * buffer,
               long * length );
@end example
@noindent
The first functions sends @code{length} data contained in @code{buffer}
to the device designated by @code{device} (which you got from a call of
@code{gpib_init_device()}). The second function reads a maximum of
@code{length} byte from the device @code{device} and stores them in
@code{buffer}. Before @code{gpib_read()} is called @code{length} must
have been set to the maximum number of data that should be read and
after a successful call @code{length} contains the number of bytes that
really have been read.

When you're done dealing with a device you should call
@example
int gpib_local( int device );
@end example
@noindent
to bring it back into the local state. This function should be called
in the @code{end_of_exp_hook} function (see below).

Using the function
@example
int gpib_timeout( int device,
                  int period );
@end example
@noindent
a new timeout value can be set for the device. The value of
@code{period} depends on the values that the GPIB library you are using
expect. Please check the manual for the library.

The function
@example
int gpib_clear_device( int device );
@end example
@noindent
clears the device by sending it the Selected Device Clear (SDC) message.

@example
int gpib_trigger( int device );
@end example
@noindent
triggers the device by sending it a Device Trigger Command.

@findex gpib_log_message()
Finally, there is an additional function to let you directly write to
the log file that stores information about the details of the
communication on the GPIB bus:
@example
void gpib_log_message( const char * fmt, ... );
@end example
@noindent
It expects a format string as you would use in the @code{C printf()}
function plus arguments corresponding to the conversion specifiers in
the format string.


@subsection Serial port handling

To be able use @code{fsc2}'s interface to the serial ports you must
include the appropriate header file, i.e.@: you need
@example
#include "serial.h"
@end example
@noindent
For serial ports things are handled a bit differently from GPIB devices.
You don't need to set a special variable to advertise your intention
of using one of them. Instead, in the init hook function you must try to
request the serial port you need by calling the function
@example
fsc2_request_serial_port( SERIAL_PORT, DEVICE_NAME );
@end example
@noindent
with the number of the serial port (0 stands for the device file
@file{/dev/ttyS0}, which is what is called @code{COM1} in DOS-speak, 1
for @file{/dev/ttyS1} or for @code{COM2} etc.@:) as the first and the
device name as the second argument. If the requested serial port has
already been claimed by a different device the function will print an
error message and stop the @code{EDL} script, so you don't have to
deal with error handling.

All the other function may not be called before the @code{exp_hook}
function.

For all functions that deal directly with file descriptors for the
serial port device files there are replacements functions. The following
table lists all functions that are used with respect to serial ports
with their replacements:
@table @samp
@item open()
@code{fsc2_serial_open()}
@findex fsc2_serial_open()
@item close()
@code{fsc2_serial_close()}
@findex fsc2_serial_close()
@item write()
@code{fsc2_serial_write()}
@findex fsc2_serial_write()
@item read()
@code{fsc2_serial_read()}
@findex fsc2_serial_read()
@item tcgetattr()
@code{fsc2_tcgetattr()}
@findex fsc2_tcgetattr()
@item tcsetattr()
@code{fsc2_tcsetattr()}
@findex fsc2_tcsetattr()
@item tcsendbreak()
@code{fsc2_tcsendbreak()}
@findex fsc2_tcsendbreak()
@item tcdrain()
@code{fsc2_tcdrain()}
@findex fsc2_tcdrain()
@item tcflush()
@code{fsc2_tcflush()}
@findex fsc2_tcflush()
@item tcflow()
@code{fsc2_tcflow()}
@findex fsc2_tcflow()
@end table

The only functions that are different from their normal counterparts are
@code{fsc2_serial_open()}, @code{fsc2_serial_write()},
@code{fsc2_serial_read()} and
@code{fsc2_serial_close()}:

@code{fsc2_serial_open()} is defined as
@example
struct termios * fsc2_serial_open( int          sn,
                                   const char * devname,
                                   int          flags )
@end example
@noindent
where @code{sn} is the number of the serial port as already used in
@code{fsc2_request_serial_port()}, @code{devname} has to be the same
device name as used in the call of @code{fsc2_request_serial_port()} and
@code{flags} are the same flags you would pass to a normal @code{open()}
call. The function not only opens the file but also creates the
necessary lock file and determines the current communication parameter
settings for the serial port. These are returned via a pointer to a
@code{termios} structure, that can be freely changed within the
module. If the function returns a @code{NULL} pointer opening the device
file failed and you can determine the reasons by checking @code{errno}.

@code{fsc2_serial_write()} and @code{fsc2_serial_read()} are defined as
@example
ssize_t fsc2_serial_write( int    sn,
                           void * buf,
                           size_t count,
                           long   us_timeout,
                           bool   quit_on_signal );

ssize_t fsc2_serial_read( int    sn,
                          void * buf,
                          size_t count,
                          long   us_timeout,
                          bool   quit_on_signal );
@end example
@noindent
where @code{sn} is the number of the serial port as already used in
@code{fsc2_request_serial_port()}, @code{buf} is a buffer of length
@code{count} for the data to be written or read. @code{us_timeout} is the
time in microseconds you are prepared to wait the serial port becoming
ready for writing or reading the data. Specifying a negative value is
interpreted to mean that you want to wait indefinitely for data, while a
value of @code{0} for @code{us_timeout} means not to wait at all. Finally,
@code{quit_on_signal} determines if the function returns immediately
when a signal has been received before any data could be read. This
might for example happen when the user pressed the @code{Stop} button
while the function was waiting for data.  The function returns on
success the number of bytes written or read, @code{0} if no data could
be written or read (e.g.@: because the maximum time to wait was exceeded
or a signal was received before the data could be written or read), and
@code{-1} on any other form of error.

@code{fsc2_serial_close()} expects just one argument, the serial port
number. Before closing the serial port device file it flushes it and
resets the communication parameters to their initial state. It also
deletes lock files. (If you don't close the serial ports device files
explicitely they will be automatically closed at the end of the
experiment.)

All remaining functions are identical to their usual form (see the
@code{termios(3)} man page for all details) except that the first
argument is always the serial port number instead of a file
descriptor. If the function gets passed an invalid serial port number
@code{errno} is set to @code{EBADF}.

@findex fsc2_serial_log_message()
The only other additional function that can be called is
@code{fsc2_serial_log_message()} and lets you directly write to
the log file that stores information about the details of the
communication over the serial port:
@example
void fsc2_serial_log_message( const char * fmt, ... );
@end example
@noindent
It expects a format string as you would use in the @code{C printf()}
function plus arguments corresponding to the conversion specifiers in
the format string.


@subsection Handling devices connected via the LAN

There are some functions for the communication with devices connected
via the LAN (@code{TCP} only, there's no support for @code{UDP} yet)
provided by @code{fsc2}. They allow you to connect to a device, send
and receive data and finally close the connection. To be able to use
these functions you need to include the appropriate header file, i.e.@:
you need
@example
#include "lan.h"
@end example

Naturally the functions aren't written with a certain protocol in mind
-- writing that is your business -- but just provide a set of fundamental
routines on top of which you can write your own functions. You can even
forego using them at all and write your own code for talking with the
devices directly, they only exist for your convenience. But if you use
them make sure they don't get invoked before the @code{exp_hook} function.

The advantage of using them is that you don't have to care about basic
operations (including dealing with timeouts etc.@:) and that the
functions automatically log whatever gets send between the computer
and the devices. How much is written to the log file (and where this
log file is and is named) can be set as a compilation option, see the
main @file{Makefile} or the settings for your machine in the 
@file{machines} subdirectory (if you created such a file).

Here is a complete list of these convenience functions:
@table @samp
@item @code{fsc2_lan_open()}
Opens a connection to a device
@item @code{fsc2_lan_write()}
Sends data to the device
@item @code{fsc2_lan_read()}
Reads data from the device
@item @code{fsc2_lan_close()}
Closes the connection to the device
@end table
@noindent
While they are similar to the @code{open()}, @code{write()}, @code{read()}
and @code{close()} function for dealing with normal file descriptors the
all need several extra arguments.

@findex fsc2_lan_open()
The function for opening a connection, @code{fsc2_lan_open()}, is declared
as
@example
int fsc2_lan_open( const char * dev_name,
                   const char * address,
                   int          port,
                   long         us_timeout,
                   bool         quit_on_signal )
@end example
@noindent
The first argument, @code{dev_name}, is a string with the name of the
device to be used when writing to the log file. The second argument,
@code{address} is a string with the IP address of the device. This can
be either the numerical IP address in dotted-quad format (e.g.@:
@code{"123.97.243.12"}) or a symbolic host name
(e.g.@: @code{"hex.discworld.unseen.edu"}), for which the IP address
then is determined via a DNS request. The third argument, @code{port},
is the port the device is accepting connections on, i.e.@: a number
between @code{0} and @code{65535}. The fourth argument, @code{us_timeout},
is the maximum time (in micro-seconds) to wait for a connection to be
achieved. If set to @code{0} (or a negative value) the connection will
only time out after a system dependent delay (typically in the order of
a minute). Finally, the last argument @code{quit_on_signal} tells the
function if it is supposed to return immediately if a signal is received
while the function is trying to connect to the device.

The function returns a positive integer on success that can be used as
a handle for the device in all the following function calls, and @code{-1}
on errors. The handle returned by the function is the file descriptor
for the socket connected to the device. You are free to use this file
descriptor for whatever you want, but please call the function
@code{fsc2_lan_close()} to close it. The only two option set for the
socket are @code{SO_KEEPALIVE} and @code{TCP_NODELAY} (but you can unset
them if you want). Later on the options @code{SO_SNDTIMEO} and
@code{SO_RCVTIMEO} may be set for timeouts for read and write
operations (if the system supports setting these options), so you better
leave them alone if you plan to use the functions @code{fsc2_lan_write()}
and @code{fsc2_lan_read()}.

@findex fsc2_lan_write()
The function for writing, @code{fsc2_lan_write()}, is declared as
@example
ssize_t fsc2_lan_write( int          handle,
                        const char * message,
                        long         length,
                        long         us_timeout,
                        bool         quit_on_signal )
@end example
@noindent
The first argument is the handle returned by @code{fsc2_lan_open()},
identifying the device. The second argument, @code{message}, is a
buffer with the data to be send to the device. The third, @code{length},
is the length of the data buffer. The fourth argument, @code{us_timeout},
is the amount of time to wait for data to be written to the device
before timing out. If this is set to @code{0} (or a negative value)
no timeout is used, i.e.@: the write function will wait indefinitely if
necessary. The last argument, @code{quit_on_signal}, again indicates i
the function must return immediately if a signal is received.

Please note that (as always with writing to the network) the function
may return before as many bytes as requested have been send. The return
value will tell you how many actually were sent or, if @code{-1} is
returned, that the write operation failed.

@findex fsc2_lan_read()
The function for reading, @code{fsc2_lan_read()}, is declared as
@example
ssize_t fsc2_lan_read( int    handle,
                       char * buffer,
                       long   length,
                       long   us_timeout,
                       bool   quit_on_signal )
@end example
@noindent
The arguments are identical to the ones of @code{fsc2_lan_write()},
with the only difference that the second, @code{buffer}, is a buffer
large enough to hold at least @code{length} bytes (make sure that
this is the case!).

As for @code{fsc2_lan_write()} it isn't guaranteed that has many bytes
as requested get read. The return value tells you how many actually
got read - if this should be @code{-1} reading failed.

@findex fsc2_lan_close()
Finally, the function @code{fsc2_lan_close()} for closing the connection
is declared as
@example
int fsc2_lan_close( int handle )
@end example
It only expects a single argument, the handle of for the connection to
close. It normally returns @code{0}, but when you try to close a connection
with an invalid handle (possibly because the connection had already been
closed), @code{-1} gets returned.


@findex fsc2_lan_log_message()
The only other additional function that can be called is
@code{fsc2_lan_log_message()} and lets you directly write to
the log file that stores information about the details of the
communication over the LAN:
@example
void fsc2_lan_log_message( const char * fmt, ... );
@end example
@noindent
It expects a format string as you would use in the @code{C printf()}
function plus arguments corresponding to the conversion specifiers in
the format string.


@subsection Hook functions
@cindex hook functions
@findex init_hook()
@findex test_hook()
@findex end_of_test_hook
@findex exp_hook()
@findex end_of_exp_hook
@findex exit_hook()


As you already know the interpretation of an @code{EDL} file consists of
several steps. When the file is tested and a @code{DEVICES} section is
found all modules for the devices listed are loaded. When in the test
the @code{EXPERIMENT} section is found the test run is started in which
the script is tested as far as possible. When the test was successful
the experiment may be run repeatedly. To allow initialization of the
modules internal parameters, initialization of the devices etc.@: for
each of these stages hook functions can be defined in the modules that
will be executed automatically at appropriate times (if they exist).

Thus, each module may contain up to six pre-defined hook functions that
don't have to be declared in the function data base file,
@file{Functions}. They all start with the name of the module followed by
@code{_init_hook}, @code{_test_hook}, @code{_end_of_test_hook},
@code{_exp_hook}, @code{_end_of_exp_hook} and @code{_exit_hook}. Thus,
if the new device is named `SR510' (as the lock-in amplifier mentioned
at the start and thus the module is `sr510') these functions are
(together with the parameters):
@example
int sr510_init_hook( void );
int sr510_test_hook( void );
int sr510_end_of_test_hook( void );
int sr510_exp_hook( void );
int sr510_end_of_exp_hook( void );
void sr510_exit_hook( void );
@end example


If it exists, the first function, i.e.@: @code{sr510_init_hook()} is
called immediately after the functions defined in all modules are
loaded. That means that the internal loader loads the module libraries and
when done runs the init hook functions of the modules in the order the
modules did appear in the devices section. The main purpose of the init
hook functions is to allow the modules to get all kinds of initialization
done. Since all other modules are already loaded, they also may be used to
test for the existence of other modules by calling a function called
@code{exist_device()}. But you should not call functions from other
modules at this stage because the other modules may still be
uninitialized. If the initialization completes successfully, the
function must return a non-zero value. If there are problems that don't
make the module unusable it may return a zero value -- in this case a
warning message will be printed. If the initialization fails in a
non-recoverable way the function should throw an exception -- in this
case also the @code{exit_hook()} won't get run.

The second function, @code{sr510_test_hook()}, is called at the start
of the test run of the @code{EXPERIMENT} section of the @code{EDL}
input file. Again, it can be used for initializations. But it should be
noted that changes to the variables defined in the @code{EDL} file
will remain only visible for the test run, after the test is completed
they will revert to their former values, i.e.@: the ones they had before
the test run started! The return code of the function is the same as for
the init hook function (i.e.@: always return a non-zero value on success).

The third function, @code{sr510_end_of_test_hook()} is called when the
test hook functions of the modules have been run. This hook function
might be used to reset internal variables of the module that got changed
during the test run. The return code of the function is the same as for
the init hook and test hook function (i.e.@: always return a non-zero
value on success).

The fourth function, @code{sr510_exp_hook()}, is run when the actual
experiment is started. Initialization of devices should be done
here. Return codes are again identical to the ones of the former
functions.

The fifth function, @code{sr510_end_of_exp_hook()} is run after the
experiment has been stopped. This hook function should be used to get
the device back into a usable state with local control and must close
any existing connections to the device.

Finally, the sixth and final function, @code{sr510_exit_hook()}, is run
just before the module is unloaded except for the case that an exception
had been thrown while the @code{init_hook()} was run. Please take care:
you can't talk to the device anymore when this hook is called. It should
only be used to e.g.@: get rid of memory allocated withing the module
before the it becomes unloaded (and thus any memory not deallocated
properly would result in a memory leak). The exit hook can be run
immediately after the init hook, so write your module in a way that it
can handle this case!

Please note that the first three functions, i.e.@:
@code{sr510_init_hook}, @code{sr510_test_hook} and
@code{sr510_end_of_test_hook} as well as the last function,
@code{sr510_exit_hook()}, will be run only once, while both the
remaining functions, @code{sr510_exp_hook()} and
@code{sr510_end_of_exp_hook()} will be run each time the experiment is
started.


@subsection Caveats for the test run

There is one rather nasty problem with the test run. In the test run the
@code{EDL} script is checked extensively and, as far as possible,
everything is done as in the real experiment. But this leads to the
problem that the functions in the module must return data even though
they can't talk to the devices yet. If the script asks for the measured
value from a device reasonable data most be returned.  This can be quite
tricky, because it sometimes may be not completely clear what will be
reasonable data in all imaginable situations.

I don't have a failsafe method to select data to return during the test
run and I also fear that there isn't one. But after some experimenting
the values now used in the modules didn't lead to too many problems. To
make them stand out they are always defined as macros at some prominent
place at the start of the module. If necessary the users must be made
aware of possible problems, i.e.@: if they test values returned from
within the @code{EDL} file they must be prepared to write the @code{EDL}
script to accept some unexpected values.


@subsection How to compile a module

A module is a shareable library (with an extension of @file{.fsc2_so})
that gets loaded while @code{fsc2} is running if the name of the module
is listed in the @code{DEVICES} section of an @code{EDL} file. Probably
the simplest way to make such a shareable library from the source files
you have written is to include it in the existing @file{Makefile} in the
@file{modules} subdirectory of the packages. But, of course, it's also
possible to use other methods.


If you want to include your module into the existing Makefile you have
to distinguish between two cases:
@enumerate
@item The new module consists of just one @code{C} file with the same
      name as the module and the @code{config} file (residing in the
      @file{config} directory)
@item The new module consists of several source files, one header file
      (with the same name as the module and the extension @code{.h}) and
      and the @code{config} file
@end enumerate

In both cases all you have to do is to edit the @file{Makefile} in the
@file{modules} directory. In the first case look for the variable
@code{simp_modules}, defined near the start of the file. The line
defining this variable is at the moment (while I'm writing this):
@example
simp_modules  := User_Functions sr510 sr530 sr810 sr830 aeg_s_band        \
                 aeg_x_band er035m er035m_s hp5340a er035m_sa er035m_sas  \
                 bh15 keithley228a egg4402 kontron4060 lakeshore330       \
                 pt2025 er032m ips20_4 $(s_band_list) ni6601 me6000       \
                 thurlby330 hjs_daadc gg_chopper itc503
@end example
@noindent
(The @code{\} characters at the ends of the lines tell make that the
line continues on the next line.) All you've got to do to include your
new module is to append the name of the single @code{C} file you have
written to this list but without the @code{.c} extension, i.e.@: if it
is called @file{abc.c} just change the last line to
@example
simp_modules  := User_Functions sr510 sr530 sr810 sr830 aeg_s_band        \
                 aeg_x_band er035m er035m_s hp5340a er035m_sa er035m_sas  \
                 bh15 keithley228a egg4402 kontron4060 lakeshore330       \
                 pt2025 er032m ips20_4 $(s_band_list) ni6601 me6000       \
                 thurlby330 hjs_daadc gg_chopper itc503 abc
@end example
@noindent
If you now re-compile it will also be compiled, a shareable library will
be created from it and when you do @code{make install} it will be copied
to the appropriate place where @code{fsc2} will find it (but don't
forget that you also have to declare it in the devices data base file
@file{config/Devices} and the functions it exports in the functions data
base file @file{config/Functions}).

If you wrote a larger module that consists of more than just one source
file you will have to apply two changes to the @file{Makefile}. Directly
beneath the definition of the make variable @code{simp_modules} another
variable, @code{comp_modules}, is defined, which (at the moment) is set to:
@example
comp_modules  := dg2020_f dg2020_b hfs9000 ep385 rs690 er023m lecroy9400  \
                 hp8672a $(hp864_list) $(tds_list) spectrapro_300i        \
                 hjs_attenuator hjs_sfc lecroy9400_s spex_cd2a rs_sml01
@end example
@noindent
Here you have to append the name of your own module (just the name with
no extension). Next you have to create a second variable that has the
same name as your module (again without extension, i.e.@: identical to
what you just appended to @code{comp_modules}) and which has to be set
to the list of the all the names of your @code{C} source files. As an
example have a look at the definition of the variable @code{lecroy9400}:
@example
lecroy9400    := lecroy9400.c lecroy9400_gpib.c lecroy9400_util.c
@end example
@noindent
The module @code{lecroy9400} consists of the three @code{C} source files
listed here. You have to create a similar entry for your own
module. That's all that's need done and you can now re-compile to create
the new module and re-install to make it available to @code{fsc2}.

If you should want to compile a module 'by hand' you'll have to make sure
that the @file{src} and the @file{config} directory are in the include
paths and that both the flags @code{-shared} and @code{-fpic} are set
both for compiling as well as linking. If you have a @code{C} source
called @code{abc123.c} in the @file{modules} directory and you want to
make a shareable library out of it you should compile it with at least
@example
  gcc -I../src -I../config -shared -fpic -o abc.o abc.c
@end example
@noindent
To create a shareable library from it you need
@example
  ld -shared -fpic -o abc.fsc2_so abc.c
@end example
@noindent
(assuming you're using GNU's @code{gcc} and @code{ld}). If this succeeds
you will still have to copy the library to the place where
@code{fsc2} expects it, i.e.@: usually @file{/usr/local/lib/fsc2},
or need to set the environment variable @code{LD_LIBRARY_PATH} to
point to the place where the library can be found.


@subsection Linker scripts

As you may have noticed, for every of the modules made of more than a
single source file there exists a file with the extension @code{map}.
This file is a linker script which restricts the number of symbols
exported by the shared library representing the module to the smallest
possible subset.

The reason for the existence of these linker scripts is to avoid name
space polution, unfortunately not too uncommon a problem with @code{C}.
For the modules made from single source files this isn't much of a
problem. As you will notice in these files each and every function and
global variable that does not need to be visible outside of the scope of
the file is declared static, thus already reducing the number of visible
symbols of the library to the bare minimum. It's different for libraries
that get made from several files, here usually at least some of the
functions and global variables need a scope that isn't restricted to
just the file where they are defined in. To restrict the visibility of
these symbols to the library (so that they are not "picked up" by the
@code{fsc2} program when the module gets loaded) the linker scripts are
used. Within a linker script it's possible to declare which of the
functions and global variables of the library are to be exported and
which ones not.

Of course, using linker scripts isn't required, modules might work
perfectly well without one. They are only meant to help keep things
cleanly separated, thereby reducing the probability of making some
difficult to trace errors. But if you feel you don't need them you can
just as well skip the rest of this subsection.

To be able to write a linker script one needs to know which symbols must
be exported by a module. And there are only three classes of symbols.
First, there are the two global variables that need to be exported by
each and every module, @code{generic_type} and @code{device_name}. Both
of them have been discussed in detail above. Then there are the hook
functions.  And finally we have the @code{EDL} functions, i.e.@: the
functions that get invoked when an function call for the module is found
in an @code{EDL} script. And, luckily, both the hook functions as well
as the @code{EDL} functions have to have simply structured names. The
names of hook functions have to start with the name of the module they
belong to and to end in the word @code{_hook}. @code{EDL} functions
always start with the name of the type of the device the module
controls, e.g.@: all @code{EDL} functions for a pulser start with
@code{pulser_}.

With taking just a bit of care when writing a module the simple pattern
used for both hook and @code{EDL} functions makes writing a linker
script extremely simple. The only thing to keep in mind is to avoid to
use names for other types of functions or global variables that would
fit these patterns (which isn't really difficult). Already for the
purpose of self-documentation it seems to be advisable to avoid function
names that start with the generic type of the device -- functions with
these names should stand out to be easily recognizable as @code{EDL}
function. And having functions that start of with the module name and
end in the string @code{_hook} usually makes not much sense anyway
(except for hook functions of course).

Under these conditions a linker script (i.e.@: the file ending with the
extension @code{map}) for e.g.@: a pulser with module name @code{abcd}
may look like this:
@example
ABCD @{
    global:    generic_type;
               device_name;
               abcd_*_hook;
               pulser_*;
    local:     *;
@};
@end example

All the interesting things are enclosed in curly braces. You have two
sections, one for @code{global} symbols (i.e.@: functions and global
variables exported by the module) and another one for @code{local}
symbols. Into the section for @code{global} symbols belong the two
variables that every module needs to export, @code{generic_type} and
@code{device_name}. Then there are the hook functions -- and as you can
see things are much simplified by the fact that the @code{*} can be used
as a wildcard character. Finally, all functions starting with the
generic type of the device, the @code{EDL} functions also belong to this
set. The section for @code{local} symbols is even simpler, a simple
@code{*} stands for all the remaining symbols of the module that
otherwise would get also exported even though they aren't needed.

Both these sections for global and local symbols are enclosed by curly
braces and at the very start you have just e.g.@: the name of the
module. This is no magic but due to the fact that these kinds of linker
scripts are usually used to control what symbols different versions of a
library do export. Here we don't care at all about versions of the
modules, you should always use the ones compiled for the version of
@code{fsc2} you're using anyway, but we have to start of with the
version command, so I picked the name of the module as the version name,
this being as good as any other value.

If you create such a linker script for a module just name it like the
name of the module and append the @code{map} extension. Then it will be
automatically used by the @code{Makefile} that takes care of creating
the shared library for the module. But if it does not exist creating the
module will also work without pronblems.


@subsection Making @code{fsc2} aware of the module

@code{fsc2} must be made aware of the existence of a new module and of
the @code{EDL} functions supplied by the module. Thus a new device
driver has to be included into the device name data base called
@file{Devices}
@cindex @code{Devices} file
, which is a simple ASCII file consisting of the names of all the
supported devices. It can be found in the @file{config} subdirectory of
the source tree and usually gets installed in the directory
@file{/usr/local/lib/fsc2}. The entries in this file are
case-insensitive, so you might add `SR510', `sr510' or `Sr510'
etc. Within the file C and C++ style comments can be used. By adding the
device name to this file you tell @code{fsc2} that there is now a module
called `sr510' (take care - all modules are spelled with @strong{lower}
case characters!). Actually, the file compiled from the C file defining
the functions has to be @file{sr510.fsc2_so} - that means it is a shared
library that can be used as a plugin for @code{fsc2} (how to create one
from the C file is described later). Here is a short snippet from the
@file{Devices} file with the entries for the lock-in amplifiers:
@example
sr510         // Stanford Research lock-in amplifier, model 510
sr530         // Stanford Research lock-in amplifier, model 530
sr810         // Stanford Research lock-in amplifier, model 810
sr830         // Stanford Research lock-in amplifier, model 830
er023m        // Bruker Signal Channel, model ER 023 M
@end example

The next thing is to append the function(s) exported by the module (in
the sense that they can be used from @code{EDL} scripts) to the function
data base file called @file{Functions}
@cindex @code{Functions} file
. Also this file is located in the @file{config} subdirectory of the
source tree and also will usually be installed under
@file{/usr/local/lib/fsc2}. Here one adds lines consisting of two
or three entries, separated by commas and ending with a
semicolon. Please note that you can't use function names that contain a
@code{#} character.
@enumerate
@item Each line must start with the names of the exported function, i.e.@:
      @code{lockin_get_data}.
@item This has to be followed by the number of arguments the function takes 
      - if the function accepts a variable number of arguments specify an
      arbitrary negative number or just a minus sign (@code{-}).
@item Optionally, you can add the keywords @code{ALL},
@cindex @code{ALL} (in @code{Functions} file)
      @code{EXP}
@cindex @code{EXP} (in @code{Functions} file)
      or @code{PREP},
@cindex @code{PREP} (in @code{Functions} file)
      where @code{ALL} means that the function can be used in all parts of the
      @code{EDL} file, while @code{EXP} tells @code{fsc2} to use this
      functions only during an experiment and, finally, @code{PREP} restricts
      the use of the function to the @code{PREPARATION} section of the
      @code{EDL} file.
@end enumerate
As in the file with the device list, C and C++ style comments can be
used. Here are a few lines from a valid @file{Functions} file with the
entries for lock-in amplifier functions:
@example
/* Functions exported by the lock-in amplifier modules
   (SR510, SR530, SR810, SR830) */

lockin_name,           0, ALL;  // return the device name
lockin_get_data,      -1, EXP;  // return the lock-in voltage 
lockin_get_adc_data,   1, EXP;  // return a ADC voltage
lockin_dac_voltage,   -1, ALL;  // get/set DAC voltage
lockin_sensitivity,   -1, ALL;  // get/set the sensitivity
lockin_time_constant, -1, ALL;  // get/set the time constant
lockin_phase,         -1, ALL;  // get/set the phase
lockin_ref_freq,      -1, ALL;  // Get/set mod. frequency (SR8x0 only)
lockin_ref_mode,       0, EXP;  // Get mod. mode (SR8x0 only)
lockin_ref_level,     -1, EXP;  // Get/set mod. level (SR8x0 only)
lockin_lock_keyboard, -1, EXP;  // Lock/unlock the keyboard
@end example
@noindent
For example, @code{lockin_get_adc_data} (a function that allows you to
read the voltage at one of the lock-ins ADCs) expects 1 argument (the
number of the ADC) and can only be used in the @code{EXPERIMENT}
section. In contrast, @code{lockin_sensitivity} can be called with a
variable number of arguments (if called without an argument it returns
the sensitivity setting of the lock-in, if called with an argument the
function treats this as the new sensitivity to be set). This function
can be used in all parts of the @code{EDL} script - but because
querying the lock-in for its sensitivity won't work as long as the
program can't talk with the lock-in, i.e.@: while not in the
@code{EXPERIMENT} section the function must test for this case and emit
an appropriate error message all by itself.

@subsection Calling EDL functions from a modules

Calling an @code{EDL} function (built-in as well as @code{EDL}
functions defined in modules) consists of three to four steps:

@enumerate
@item
You may first want to check if the function you're planning to call
exists at all. To do so call @code{func_exists()}
@findex func_exists()
with the name of the function as the argument. It will return @code{0}
if the function does not exist and can not be used, otherwise a non-zero
value.
@item
Call @code{func_get()}
@findex func_get()
with the name of the function you want to call as the first argument and
the address of an integer variable for returning the access flags (you
may specify also @code{NULL} instead if you're not interested in the
access flag) -- this will return a variable with a pointer to the
function which you have to store. If the returned pointer is @code{NULL}
the function does not exist or isn't loaded.  The variable pointed to by
the second argument will be set to either @code{ALL}, @code{PREP} or
@code{EXP}.
@item
Now call @code{vars_push()} for each of the arguments of the function -
see the description of @code{vars_push()} in the section about
@code{fsc2}'s built in variable types.
@item
Finally, call @code{func_call()} with the pointer returned by the call
to @code{func_get()}
@findex func_get()
as the argument. This will return a pointer to the variable with the result.
@end enumerate

As an example let's assume there is an @code{EDL} function named
@code{foo()} you want to call from your module, that takes two
arguments, an integer and a floating point value. Then a typical piece
of C code to call the function would be
@example
Var_T * my_function( Var_T * var )
@{
    Var_T * func_ptr;
    Var_T * ret_value;
    int access;

    if ( ! func_exists( "foo" ) )              /* test if function exists */
    @{
        /* do your error handling here */ 
    @}
    else                                  
    @{                                    
        func_ptr = func_get( "foo", &access ); /* get pointer to function */
        vars_push( INT_VAR, 5 );               /* push first argument */
        vars_push( FLOAT_VAR, 3.1415 );        /* push second argument */
        ret_value = func_call( func_ptr );     /* call the function */
    @}

    ...
@}
@end example


There is one point that needs attention: After the call to
@code{func_call()} the variable @code{func_ptr} with the pointer to the
function returned by @code{func_get()}
@findex func_get()
will disappear automatically. Thus, when you need to call the function
again  you will have to go through this procedure, since the value
stored in @code{func_ptr} after the call to @code{func_call()} is
completely useless and even dangerous to use for any purpose whatsoever!
So, don't assume that the value of @code{func_prtr} you got from
@code{func_get()}
@findex func_get()
will have any meaning later on. Not only will the value be invalid but,
even worse, there is a high probability that hard to trace bugs will
result if you try to use it.


If you should be wondering what happens if you call an @code{EDL}
function defined in your own module from within the module you can be
sure that you will always get the function from this module even if
there are other modules with the same generic type and thus supplying a
function of the same name. I.e.@: if there are e.g.@: two lock-in
amplifier modules loaded, both having a @code{lockin_get_data()}
function, and within one of the lock-in modules this function is called
it is guaranteed that the function of this name from the same module
gets called and not the one from the other module. So you don't have to
care about appending a @code{#} and a device number to the function name
-- @code{fsc2} will do this automatically when necessary.


@node Programming Utils, Pulser Modules, New Modules, Modules
@section Additional utilities provided by fsc2

When writing a module some of the following information might be useful:
first a special function for printing out messages to the user is
discussed, second a function that simulates @code{usleep()} but does not
share some of its shortcomings.

The third topic, exceptions, is a well-known concept implemented for
example in @code{C++}. Unfortunately, @code{C} does not have this kind
of mechanism, but when being a bit careful one can implement something
very similar also in @code{C} using a few macros. 

When writing the program I had to deal with my share of memory leaks,
segmentation faults etc.@: and hacked together a few routines for
allocation and deallocation of memory that have some build in code to
help me with debugging (and which throw exceptions when an allocation
fails). You might find it useful to also use these routines for your
modules.

A boolean type is something that was missing until the new C99
standard (which only a few compilers support yet), so there's already a
@code{typedef} for this type included in @code{fsc2} that you can
use. It's also documented here in order to avoid confusion should you
accidentally try to redefine it.

Finally, there exist some utility function for rounding of double values
to the different integer types as well as converting integers to types
of smaller width.


@subsection Printing out messages
@cindex print()
@findex print()

When writing a module one often has to print out messages to inform the
user e.g.@: about invalid arguments etc.  For this purpose there's the
@code{print()} function in @code{fsc2} (not to be mistaken for the
built-in @code{EDL} function with the same name) that helps to deal
with this and prints messages to the lower browser in the main
form. Except for the first argument the function is identical to the
@code{printf()} function in @code{C}, i.e.@: the second parameter is a
format string of exactly the same format as @code{printf()} expects,
followed by as many values as there are conversion specifiers in the
format string.

The first parameter is an integer describing the severity of the problem.
There are four levels:
@itemize
@item @code{NO_ERROR} Just an informational message (in black)
@item @code{WARN} A warning message (in green)
@item @code{SEVERE} A severe warning, which the user really should
      think about (printed in blue)
@item @code{FATAL} A fatal error message (printed in red) - to stay consistent
      with the usual way this type of error message is used you should
      now throw an exception (see next subsection) to make the program stop.
@end itemize

To the output the @code{EDL} file name and line number (if
appropriate) as well as the device and function name is prepended.

The full @code{C} declaration of this function is:
@example
void print( int          severity,
            const char * fmt,
            ... );
@end example
@noindent


@subsection Determining the time
@cindex experiment_time()
@findex experiment_time()

To find out how much time has been spent since the start of the
experiment the function @code{experiment_time()} may be used. It returns
the time in seconds since the start of the experiment (to be precise
since the start of the first exp_hook function). The time resolution
should not be taken to be better than about @w{10 ms}.

The function also can be used during the test run but in this case only
a very rough estimate will be returned that easily could be off by more
than an order of magnitude.

The full @code{C} declaration of this function is:
@example
double experiment_time( void );
@end example
@noindent


@subsection Waiting for short times
@cindex fsc2_usleep()
@findex fsc2_usleep()

When writing code that deals with real devices one often needs to wait
for times with a resolution of less than a second. The usual way to do
this is to call either @code{usleep()} or @code{nanosleep()}. The second
function, @code{nanosleep()}, may look like a bit of overkill since both
functions real time resolution is usually in the @w{10 ms} range, at
least on Intel machines. On the other hand, @code{usleep()} is marked as
obsolete in the IEEE Standard 1003.1-2001 (Single UNIX Specification,
Version 3) for several reasons (mainly for it's undefined interaction
with the @code{SIGALRM} signal and other similar functions) and thus
should not be used anymore.

As a replacement for @code{usleep()} (which you shouldn't use in a
module) there is a function
@example
int fsc2_usleep( unsigned long us_duration,
                 bool          quit_on_signal );
@end example
@noindent
It takes two parameters, an @code{unsigned long}, which is the duration
(in milliseconds) to wait (just like @code{usleep()}), and a boolean
value that indicates if the function is supposed to return immediately
if a signal gets caught or if it should wait for the specified time even
on signals.  The function is actually nothing else than a wrapper around
@code{nanosleep()}, so you can @code{nanosleep()} yourself if you prefer.


@subsection Assertions
@cindex assertions
@findex @code{fsc2_assert()}
@findex @code{fsc2_impossible()}

At least during development it usually is helpful to also test for
conditions that should never happen but may anyway due to bugs. In
this case often the standard C macro @code{assert()} is used.
@code{fsc2} comes with two variants of this macro, @code{fsc2_assert()}
and @code{fsc2_impossible()}. The first one is basically identical to
@code{assert()}, the only difference being that in case the assertions
tests true not only a text, showing the the file and line number, gets
printed to the standard error channel but also an email is sent
(including the text of the currently running @code{EDL} script and some
more relevant information) to whatever email address has been set
during the installation as the one for receiving such mails about
crashes and other fatal states of the program. The macro
@code{fsc2_impossible()} is for the same purpose but doesn't take an
expression as its argument, it is meant for situations in the code
where one would end up in in a branch that (at least theoretically)
can never be reached - e.g. if you test in a switch all possible cases
you could add a @code{default:} case to catch a situation where you
actually forgot about a possible case.

If, as in the case of the @code{assert()} macro, the macro @code{NDEBUG}
is defined (before you include @file{fsc2_module.h}) both functions don't
do anything at all. You don't have to worry about cases where one of
these macros is used as the only statement following for example an
@code{else} like in
@example
    if ( x == 1 )
        do_something_1( );
    else if ( x == 2 )
        do_something_2( );
    else
        fsc2_impossible( );
@end example
@noindent
The macros are written in a way that they form an (empty)  block also when
@code{NDEBUG} is defined.

The only thing you've got to worry about with @code{fsc2_assert()} is the
same thing you have to with the @code{assert()} macro: if the expression
has side effects then the programs behaviour may differ depending on
whether @code{NDBUG} is defined and you thus may have intoduced a Heisenbug.


@subsection Error handling with exceptions
@cindex exceptions

One of the most important but also most tedious things in programming is
rigorous error handling. In order to make a program failsafe in every
place where there is even the remotest chance something may go wrong
one has to include error handling code everywhere. This is especially
annoying when an error can happen with deeply nested function calls
where the type of the error may have to "bubble up" several levels
before it is finally can be dealt with.

In order to alleviate this problem several newer programming languages
like @code{C++} introduced a concept called "exceptions". Unfortunately,
@code{C} doesn't have them but in @code{fsc2} I use a method to "fake"
exceptions@footnote{The basic ideas for the exceptions code came from an
article by Peter Simons in the iX magazine (@uref{http://www.heise.de/ix/}),
No. 5, 1998, pp. 160-162, but also several other people implemented similar
solutions. My version has benefited a lot from the very constructive
criticism by Chris Torek (@email{nospam@@elf.eng.bsdi.com}) on
@uref{news:comp.lang.c} (which isn't meant to say that he would be
responsible for its shortcomings in any way).}. An exception can be seen
as a kind of flag that can be raised at any instance in the program and
leads to the flow of control being immediately transfered to a place were
the error can be dealt with (another way to see it is as a non-local
@code{goto} which knows all by itself were to go to).

There's one restriction with @code{fsc2}'s exceptions: you may @strong{not}
use them from within code that might get called asynchronously, like signal
handlers. But this is probably not an important restriction when writing a
module.

As far as raising exceptions in a module is concerned it's usually very
simple. If you run into an error that you can't handle within the module
just use
@example
if ( non_recoverable_error )
    THROW( EXCEPTION );
@end example
@findex THROW()
@findex EXCEPTION
@noindent
and @code{fsc2} will take care of all error handling and the stop the
running experiment (or the test run). That's all you need to know about
exceptions for nearly all cases that have to be dealt within modules.


@subsubsection More on programming with exceptions

Of course, when an exception is 'thrown', there must be a place where it
gets 'caught', otherwise the exception will simply kill the program. You
don't have to care about catching exceptions, @code{fsc2} will do this
for you. But in some situations you might prefer to do it yourself. So
lets assume that you have a function @code{foo()} that might run into a
non-recoverable error that can't be handled within the module itself.
However you may still need to do some cleaning-up before you pass it up to
@code{fsc2}. The following example demonstrates how to catch an exception
in the calling function:
@example
TRY
@{
    foo( );
    TRY_SUCCESS;         /* never forget this ! */
@}
CATCH( EXCEPTION )
@{
    ...                  /* the error handling code goes here */
@}
OTHERWISE
    RETHROW( );
@end example

@findex TRY
@findex TRY_SUCCESS
@findex CATCH()
@findex OTHERWISE
@findex RETHROW()
With @code{TRY} the program is told that the following code might throw
an exception. If everything works out well and no exception is thrown
the @code{CATCH()} and @code{OTHERWISE} blocks are never executed and in
this case @code{TRY_SUCCESS} must be called to do some cleaning up (this
is different from e.g.@: @code{C++} where the programmer does not have
to care about this case). But if an error happens and an exception (of
whatever type, there are more than the simply named @code{EXCEPTION}
exception) gets thrown the flow of control is changed immediately from
the function the exception is thrown in to the @code{CATCH()} line.

The @code{CATCH} section can be used to catch a specific exception and
you can have several of them for different types of exceptions listed
one after the other. But because flow of control will be transferred to
the @code{CATCH()} line on every possible type of exception, not only
the one specified as the arguments of the @code{CATCH()} calls, a
@code{CATCH()} should always followed finally by an @code{OTHERWISE}
(unless you are absolutely sure no other exceptions than the one you're
catching could happen). The block following @code{OTHERWISE} will deal
with all other exceptions not dealt by @code{CATCH()}.  Normally, you
just will rethrow the exception you're not interested in or which you
are unable to handle yourself by calling @code{RETHROW()}.

In cases where you aren't interested in a special type of exception but
want to catch every exception, e.g.@: to just do some cleaning up before
bailing out to pass the problem on to some higher level routines, you
can use just an @code{OTHERWISE} block without a @code{CATCH()}. Here's
another example:
@example
TRY
@{
    do_something_error_prone();
    TRY_SUCCESS;
@}
OTHERWISE
@{
    do_local_cleanup();       /* e.g. deallocate memory */
    RETHROW();
@}
@end example


There are three types of exceptions that may be relevant when writing
a module:
@example
EXCEPTION
OUT_OF_MEMORY_EXCEPTION
USER_BREAK_EXCEPTION
@end example
@noindent
@code{EXCEPTION} is a kind of catch-all exceptions not covered by the
other two types. @code{OUT_OF_MEMORY_EXCEPTION} gets only thrown by
@code{fsc2}s special functions for memory allocation (see next section),
so don't throw it yourself without a very good reason. A
@code{USER_BREAK_EXCEPTION} can be thrown from within a module when the
module is doing something rather time consuming (e.g.@: waiting for a
device to become ready or doing some calibration) and the user has
pressed the @code{STOP} button. In many cases it's probably simpler not
to throw the @code{USER_BREAK_EXCEPTION} directly but use the function
@example
void stop_on_user_request( void );
@end example
@noindent
It will detect if the user has pressed the @code{STOP} button and, if
she did, will throw an @code{USER_BREAK_EXCEPTION} all by itself. This
works from all parts of the module except when running the
@code{end_of_exp_hook} and @code{exit_hook} functions because these
need to run without the user intervening.  Thus you must make sure
that these clean-up functions don't call other functions that may rely
on user intervention.


But if you don't want to use @code{stop_on_user_request()} but need to
do some cleanup within the module when the @code{STOP} button has been
pressed you can check if the button has been pressed by calling the
function
@example
void check_user_request( void );
@end example
@noindent
It will return @code{true} if the @code{STOP} button has been pressed.
You then should do your cleanup and immediately afterwards throw a
@code{USER_BREAK_EXCEPTION} yourself.


Here's some code taken from the module for a digitizer. It waits
indefinitely in a loop for the digitizer to become finished with a
measurement. To allow the user to get out of this loop (when, for
example, he realizes that he forgot to connect the trigger input to the
digitizer, so the function never returns) @code{stop_on_user_request()}
is called each time the loop is repeated.  When the user presses the
@code{STOP} button the function will break out of the loop by throwing
an @code{USER_BREAK_EXCEPTION}.
@example
while ( 1 )                   /* loop forever */
@{
    stop_on_user_request( );
    fsc2_sleep( 100000, UNSET );   /* give the device a bit of time */

    length = 40;
    if ( gpib_write( tds754a.device, "BUSY?\n", 6 ) == FAILURE ||
         gpib_read_w( tds754a.device, reply, &length ) == FAILURE )
        THROW( EXCEPTION );

    if ( length > 0 && reply[ 0 ] == '1' )  /* break when digitizer is ready */
        break;
@}
@end example


@subsubsection Problems with exceptions

There is a caveat when using exceptions. The exception mechanism is
using the standard C functions @code{setjmp()} and @code{longjmp()} to
realize @code{TRY} and @code{CATCH}. These functions have some problems:
when an exception is thrown the data stored in CPU registers are not
necessarily saved, but an optimizing compiler usually stores the values
of often used variables in CPU registers, i.e.@: the value of a variable
in memory is not necessarily identical to its 'real' value (or variables
might even not exist in memory, they may have gotten optimized out.).
When the program now reaches the @code{CATCH()} part the values of these
variables can be completely bogus and if you would try to use their values
extremely hard to find errors might result.

Fortunately, when the compiler gets invoked with its warning level set
to a suitable level it will recognize such potential problems and utter
a warning message message like the following (this example is taken from
@code{gcc}):
@example
module.c:123: warning: variable `i' might be clobbered by
                       `longjmp' or `vfork'
@end example

You might get this warning for code like this:
@example
long ** foo( size_t count,
             size_t len )
@{
    long ** buffer;
    size_t  i;


    TRY
    @{
        for ( i = 0; i < count; i++ )
            buffer[ i ] = T_malloc( len * sizeof ** buffer );
        buffer[ 0 ] = 123;
        TRY_SUCCESS;
    @}
    CATCH( OUT_OF_MEMORY_EXECPTION )
    @{
        for ( i -= 1; i >= 0; i-- )
            T_free( i )
        RETHROW( );
    @}

    return buffer;
@}
@end example
@noindent
Chances are high that the compiler will use a register for the variable
@code{i} to speed up execution. But when an exception happens the value
@code{i} had in the loop of the @code{TRY} block might hav gotten discarded
in the process, even though it is still needed.

But there's a way to get rid of this problem. All you need is to add an
additional statement before @code{TRY} is invoked:
@example
CLOBBER_PROTECT( i );
@end example
@noindent
Just insert this line after the definitions of the variables and you're
save from all these problems. So better be careful when the compiler
emits warnings like the one above and add a @code{CLOBBER_PROTECT()}
call for such variables.

If you want to find out more about this problem, have a look at the code
in @file{exceptions.h} and @file{exceptions.c} and read the
documentation for the standard C functions @code{setjmp()} and
@code{longjmp()}.


@subsection Functions for memory allocation
@cindex memory allocation
@findex T_malloc()
@findex T_calloc()
@findex T_realloc()
@findex T_free()
@findex T_strdup()

There are special function for @code{fsc2} for allocating memory.
These functions not only allocate memory but also check that the
allocation really returned as much memory as you asked for (on failure
the program is stopped and an appropriate error message is
printed). That means that you don't have to care for error handling --
if these memory allocation functions return everything is ok, otherwise
they won't return at all. The first of these functions called
@code{T_malloc()} (think about it as @i{tested malloc}). And, of course,
there is also a replacement for @code{realloc()} and @code{calloc()},
called @code{T_realloc()} and @code{T_calloc()}. For the duplication of
strings you should use @code{T_strdup()} instead of the normal
@code{strdup()}. And, to make things complete, the replacement for
@code{free()} is called @code{T_free()}. All five functions accept the
same input and return values as their normal counterparts, i.e.@ they
have the prototypes:
@example
void * T_malloc( size_t size );

void * T_calloc( size_t nmemb,
                 size_t size );

void * T_realloc( void * ptr,
                  size_t size );

char * T_strdup( const char * string );

void * T_free( void * ptr );
@end example
@noindent
For @code{T_free()} there's is small deviation from the behavior of
the normal @code{free()} function. @code{T_free()} returns a @code{void}
pointer, which is always @code{NULL}.

There might be cases where you need a call of one of the functions for
allocation of memory to return even if it fails. In this case you have
to call the function from within a @code{TRY} block and be prepared to
catch the @code{OUT_OF_MEMORY_EXCEPTION} exception that gets thrown when
the memory allocation fails. Here's some example code:
@example
TRY
@{
    array = T_malloc( length );
    TRY_SUCCESS;
@}
CATCH( OUT_OF_MEMORY_EXCEPTION )
@{
    ...                  /* your error handling code goes here */
@}
@end example


@subsection The @code{bool} type
@cindex bool type

@code{fsc2} already has a @code{typedef} for the @code{bool} type,
i.e.@: for variables that can have only two values, either @code{1} or
@code{0}. It is declared as
@example
typedef enum
@{
    false = 0,
    true  = 1
@} bool;
@end example


You can use either the macros @code{SET}, @code{OK} or @code{TRUE}
instead of @code{1} and @code{UNSET}, @code{FAIL} or @code{FALSE}
instead of @code{1}. Use this type to do things like
@example
bool is_flag;

flag = SET;
...
if ( ! flag )
@{
    do_something( );
    flag = UNSET;
@}
...
if ( flag == SET )
    do_something_else( );
@end example


@subsection Numerical conversions and comparisons
@cindex numerical conversions and comparisons

It's a rather common task to round floating point numbers to some type
of integer (signed or unsigned). Therefore, a set of utility functions
exists for the more common of these tasks. They are:
@example
short int srnd( double a );
unsigned short usrnd( double a );
int irnd( double x );
unsigned int uirnd( double x );
long lrnd( double x );
unsigned long ulrnd( double x );
@end example
@noindent
@code{srnd()}, @code{usrnd()}, @code{irnd()}, @code{uirnd()}, @code{lrnd()}
and @code{ulrnd()} round a double value to the next @code{short int},
@code{unsigned short int}, @code{int}, @code{unsigned int}, @code{long int}
or @code{unsigned long int} value, respectively. If the double value is
smaller than the smallest value of the target range (0 for conversion to an
unsigned integer type) the turn value is the smallest value in the target
range and @code{errno} is set to @code{ERANGE}. If the value is too large
to fit into the traget range the return value is the largest possible value
in the target range and @code{errno} is also set to @code{ERANGE} (if the
conversion does not result in an out-of-range value @code{errno} is not
modified). If you plan to check for an out-of-range error you thus have to
zero-out errno before calling the functions.


@node Pulser Modules, , Programming Utils, Modules
@section Writing modules for pulsers

Modules for pulsers are a bit more difficult to write than drivers for
other devices. The reason is that pulsers play a rather important role
in modern spectrometers and thus setting the pulses should be made as
easy as possible for the user. Of course, it would be possible to deal
with pulsers in exactly the same way as normal devices, i.e.@: to define
just a set of functions for setting different pulse properties etc.@:
but this would make the programs much harder to write and understand.
Instead many aspects of dealing with pulses and pulsers are integrated
directly into the @code{EDL} language. While this makes it easier for
the user writing @code{EDL} scripts it requires more work by the
writer of the module for a pulsers.

If, for example, the user defines a new pulse in the @code{PREPARATIONS}
section the relevant part of the @code{EDL} file will similar look to
this:
@example
P3: FUNCTION = MW,
    START    = P1.START + 200 ns,
    LENGTH   = 140 ns;
@end example
@noindent
When @code{fsc2} finds these lines it will have to call several
functions that must be defined within the module. First it needs to call
a function that allows it to inform the module that there is a new pulse
numbered 3. Next it will inform the module that the pulse function the
new pulse 3 is associated with is the function for microwave pulses.
Next it detects that the start position of the new pulse is defined in
terms of the values that (hopefully) have been already set for the pulse
1 and must ask the module for the start position of pulse 1. Using the
returned value @code{fsc2} now can calculate the start position of
the new pulse 3 and must then call another function in the module to
tell the module about this position. Finally, another function in the
module must exist so that @code{fsc2} can inform it about the length
of the new pulse. Using these (and a lot more) functions the module will
be able to set up an internal representation of the pulser state and to
bring the pulser into this state at the start of the experiment.

To make it possible to integrate handling of pulsers in this way
directly into @code{EDL} the module for a pulser must obviously
define quite a lot of non-@code{EDL} functions and some additional
variables. Pointers to all of these needed functions are collected in one
structure, @code{Pulser_Struct}:
@example
struct @{
    const char * name;
    bool needs_phase_pulses;
    bool has_pods;

    bool ( * assign_channel_to_function )( int function, long channel );
    bool ( * assign_function )( int function, long connector );
    bool ( * set_function_high_level )( int function, double high_voltage );
    bool ( * set_function_low_level )( int function, double low_voltage );
    bool ( * invert_function )( int function );
    bool ( * set_function_delay )( int function, double delay );

    bool ( * set_timebase )( double timebase );
    bool ( * set_timebase_level )( int level );

    bool ( * set_trigger_mode )( int mode );
    bool ( * set_repeat_time )( double rep_time );
    bool ( * set_trig_in_level )( double voltage );
    bool ( * set_trig_in_slope )( int slope );
    bool ( * set_trig_in_impedance )( int state );

    bool ( * set_phase_reference )( int phase, int function );

    bool ( * phase_setup_prep )( int func, int type, int pod, long val );
    bool ( * phase_setup )( int func );

    bool ( * new_pulse )( long pulse_number );
    bool ( * set_pulse_function )( long pulse_number, int function );
    bool ( * set_pulse_position )( long pulse_number, double ptime );
    bool ( * set_pulse_length )( long pulse_number, double ptime );
    bool ( * set_pulse_position_change )( long pulse_number, double ptime );
    bool ( * set_pulse_length_change )( long pulse_number, double ptime );
    bool ( * set_pulse_phase_cycle )( long pulse_number, long cycle );

    bool ( * get_pulse_function )( long pulse_number, int * function );
    bool ( * get_pulse_position )( long pulse_number, double * ptime );
    bool ( * get_pulse_length )( long pulse_number, double * ptime );
    bool ( * get_pulse_position_change )( long pulse_number, double * ptime );
    bool ( * get_pulse_length_change )( long pulse_number, double * ptime );
    bool ( * get_pulse_phase_cycle )( long pulse_number, long * cycle );

    long ( * ch_to_num )( long channel );

    /* The following entries are deprecated and exist for backward
       compatibility only */

    bool ( * set_max_seq_len )( double seq_len );
    bool ( * keep_all_pulses )( void );
    bool ( * set_phase_switch_delay )( int function, double del_time );
    bool ( * set_grace_period )( double gp_time );
@} Pulser_Struct;
@end example
@noindent
At the start all the pointers in this structure are set to @code{NULL}
(@code{fsc2} has still no idea which functions it actually has to
call), @code{name} is also a @code{NULL} pointer and the boolean
variable @code{needs_phase_pulses} is set to false. Now, when the
@code{init_hook} of the pulser module gets run it has to fill in values
for all the function pointers it supplies functions for - only this will
allow @code{fsc2} to figure out where the relevant functions to call
are. When the module does not define a function it must leave the
corresponding entry in the structure unchanged, i.e.@: leave it a
@code{NULL} pointer. Most of the following text will try to explain in
detail what the different functions are supposed to do and the meaning
of the arguments of the functions.

But first the three variables to be set will be discussed. The first
variable, @code{name}, is simply the name of the pulser that will be
used in error messages etc. When setting this variable within the
@code{init_hook} function it should first be checked if it is still a
@code{NULL} pointer. If not the module should print an error message and
quit immediately - when @code{name} is not @code{NULL} a different
pulser module has already been loaded and currently it is not possible
to deal with more than one pulser.

The second variable, @code{needs_phase_pulses}, must be set to a true
value only if the experiment the pulser is connected to has phase
switches that need their own pulses and if the module is prepared to
create these phase pulses automatically. Currently, this is only the
case for the Frankfurt S-band spectrometer.

The third variable, @code{has_pods}, must be set when the pulser has
internal channels for storing pulse sequences which get mapped to
certain output connectors (pods), like the @code{Sony/Tektronix DG2020}.
Per default the variable is set to false.


@subsection Pulse functions


Now follows a list of all functions that can be defined within a pulser
module and advertised to @code{fsc2} by assigning a pointer to the
function in the pulsers structure. All functions are supposed to return
a boolean value. Please remember that not all functions must exist, if
they don't exist and you don't supply a pointer for some of the
functions in the pulser structure @code{fsc2} will tell the user
automatically that the ability associated with the function is not
available with the driver. You can be sure that all time values that
these function receive are integer multiples of one nanosecond.


With the exception of the functions for setting pulse properties
@example
set_pulse_position()
set_pulse_length()
set_pulse_position_change()
set_pulse_length_change()
@end example
@noindent
and the functions for asking pulse properties, i.e.@: the functions with
names starting with @code{get_pulse_}, all functions will only be called
before the experiment is started, i.e.@: in the time between the calls of
the init_hook() and the test_hook() function.


During the test run. i.e.@: between the @code{test_hook()} and the
@code{exp_hook()} function call (while the global variable
@code{TEST_RUN} is set) functions to change pulse positions and lengths
will be called. In this functions the internal representation of the
pulser state has to be updated and the consistency of the state has to
be checked (i.e.@: do the pulses stay separated, don't they overtake
each other, do the lengths remain larger than zero, do the positions
stay larger than zero and don't exceed the maximum channel length,
etc.@:). The driver also might choose to store the longest duration of a
pulse sequence during the test run to be used later in the calculation
of the padding needed to set a fixed repeat time for the experiment.


@table @samp

@item bool assign_channel_to_function(int function, long channel)
This function is called when in the @code{ASSIGNMENTS} section in the
description of a pulse function the @code{CHANNEL} (or @code{CH})
keyword is found, i.e.@:
@example
ASSIGNMENTS:
MW: CH = 1, ....
@end example
@noindent
There are two types of pulsers, pulsers (like the @strong{Sony/Tektronix
DG2020} that have some internal channels, that can be freely assigned to
output connector (and for which the variable @code{needs_phase_pulses}
in the pulser structure must be set), and pulsers (like the
@strong{Tektronix HFS9000} that just have output channels. For the first
type of pulsers this function is called to assign a pulse function to
one of the internal channels (and @strong{not} the output connector,
this is what the next function is for, see below), while for the second
type of pulsers th function is for assigning a pulse function to one of
the output connectors.

As discussed in the chapter about pulsers (@pxref{Channel setup}) there
are currently 15 different types of pulse functions. To avoid having to
change your module in case the numbering of the functions changes you
should only use symbolic names for functions. These symbolic names are
defined in @file{src/global.h}:
@example
enum @{
    PULSER_CHANNEL_MW = 0,
    PULSER_CHANNEL_TWT,
    PULSER_CHANNEL_TWT_GATE,
    PULSER_CHANNEL_DET,
    PULSER_CHANNEL_DET_GATE,
    PULSER_CHANNEL_DEFENSE,
    PULSER_CHANNEL_RF,
    PULSER_CHANNEL_RF_GATE,
    PULSER_CHANNEL_PULSE_SHAPE,
    PULSER_CHANNEL_PHASE_1,
    PULSER_CHANNEL_PHASE_2,
    PULSER_CHANNEL_OTHER_1,
    PULSER_CHANNEL_OTHER_2,
    PULSER_CHANNEL_OTHER_3,
    PULSER_CHANNEL_OTHER_4
@};
@end example
@noindent
You also better don't rely on the number of pulse functions, instead of
using a hardcoded value of 15 use instead the
@code{PULSER_CHANNEL_NUM_FUNC}.

Beside the definition of pulse function numbers there is also an array
with the full names for the functions (to be used in error messages).
@example
const char * Function_Names[ ] = @{
    "MW", "TWT", "TWT_GATE","DETECTION", "DETECTION_GATE",
    "DEFENSE", "RF", "RF_GATE", "PULSE_SHAPE", "PHASE_1",
    "PHASE_2", "OTHER_1", "OTHER_2", "OTHER_3", "OTHER_4" @};
@end example

The functions @w{@code{PULSER_CHANNEL_PHASE_1}} and
@w{@code{PULSER_CHANNEL_PHASE_2}} are a bit different from the rest
because these functions are reserved for automatically created phase
pulses, so the user should never be able to create pulses with both
these functions.

The second argument of @code{assign_channel_to_function()} obviously is
either the number of channel (for pulsers with no pods) or the output
connector (for pulsers with pods). Please note that for pulsers of the
first type several channels may be assigned to one function (e.g.@: when
automatically created phase pulses are used, i.e.@: the variable
@code{needs_phase_pulses} is set).


@item bool assign_function(int function, long connector)
For pulsers of the second type, i.e.@: pulsers that have internal
channels and independent output pods this function is used to associate
a pulse function to one of the output functions, i.e.@: if in the
function description the @code{POD} keyword is found:
@example
ASSIGNMENTS:
  MW: POD = 3, ...
@end example
@noindent
Only one function should be assignable to an output connector.


@item bool set_function_high_level(int function, double high_voltage)
This function is called to set the high voltage level to be output for a
certain pulse function, i.e.@: when the @code{V_HIGH} keyword is found
in the function description. Obviously, @code{high_voltage} is the
voltage to be used for the high voltage level in Volts.


@item bool set_function_low_level(int function, double low_voltage)
This function is called to set the low voltage level to be output for a
certain pulse function, i.e.@: when the @code{V_LOW} keyword is found in
the function description. To stay compatible with other pulser modules I
would recommend not to accept low voltage levels that are actually
higher than the high voltage level and to tell the user to use the
function @code{invert_function()} instead.


@item bool invert_function(int function)
This function is called to tell the pulser module that the output for a
certain pulse function has to be reversed polarity, i.e.@: that a high
voltage is to be output for a pulse off state while a high voltage has
to be output while a pulse with this function is switched on. The
function is automatically called for the @code{INV} or @code{INVERT}
keyword in the pulse function description.


@item bool set_function_delay(int function, double delay)
This function is called to tell the pulser to use a delay for one of the
pulse function, i.e.@: when the @code{DELAY} keyword is found in the
description of a function. When possible you should be prepared also
to accept negative delays (which of course requires that the pulser is
triggered internally).


@item bool set_timebase(double timebase)
This function gets called when the @code{TIMEBASE} keyword is found in
the @code{ASSIGNMENTS} section, i.e.@:
@example
ASSIGNMENTS:
  TIMEBASE: 10 ns;
@end example
@noindent
You will have to check that this is an acceptable timebase value and
you will also have to check later that all pulse positions, lengths
etc.@: are integer multiples of this timebase.


@item bool set_timebase_level(int level)
This function gets called when the @code{TIMEBASE} keyword is found in 
the @code{ASSIGNMENTS} section, followed by either @code{TTL} or
@code{ECL}, i.e.
@example
ASSIGNMENTS:
  TIMEBASE: 16 ns, TTL;
@end example
@noindent
This indicates that the timebase is derived from external input with
either TTL or ECL levels. The argument the function gets passed is an
integer, either @code{TTL_LEVEL} or @code{ECL_LEVEL}.


@item bool set_trigger_mode(int mode)
This function gets called when a trigger mode description is found in
the assignments section, i.e.@:
@example
ASSIGNMENTS:
  TRIGGER_MODE: EXTERNAL;
@end example
@noindent
There are two possible values for the trigger mode, either external or
internal. In @file{src/global.h} an enumeration is already defined for
the values of @code{mode} with @code{EXTERNAL} (set to @code{1}) and
@code{INTERNAL} (set to @code{0}). In order to avoid problems if the
values should ever get changed you should use these predefined values.


@item bool set_repeat_time(double rep_time)
The function gets called for setting the repetition time or frequency of
an pulsed experiment, i.e.@: when either the @w{@code{REPETITION_TIME}}
or @w{@code{REPETITION_FREQUENCY}} keyword is found in the trigger mode
description in the @code{ASSIGNMENTS} section.  Obviously, to be able to
set a repetition time or frequency the trigger mode must be internal and
the module has to check that this is the case.


@item bool set_trig_in_level(double voltage)
This function is called when the @code{LEVEL} keyword is found in the
trigger mode description in the @code{ASSIGNMENTS} section to set the
trigger level for external trigger mode. The module should tell the user
that setting a trigger level doesn't make sense in the case that the
user specified internal trigger mode.


@item bool set_trig_in_slope(int slope)
This function is called when the @code{SLOPE} keyword is found in the
trigger mode description in the @code{ASSIGNMENTS} section to set the
trigger slope for external trigger mode.  In @file{src/global.h} an
enumeration is already defined for the values of @code{slope} with
@code{POSITIVE} (for triggering on the trigger input signal crossing the
trigger level coming from a lower voltage and set to @code{1}) and
@code{NEGATIVE} (set to @code{0}). In order to avoid problems if the
values should ever get changed you should use these predefined
values. The module should tell the user that setting a trigger slope
doesn't make sense in the case that the user specified internal trigger
mode.


@item bool set_trig_in_impedance(int state)
This function gets called to set the input impedance of the trigger
input channel when the @code{IMPEDANCE} keyword is found in the trigger
mode description in the @code{ASSIGNMENTS} section. In
@file{src/global.h} an enumeration is already defined for the values of
@code{state} with @code{HIGH} (set to @code{1}) and @code{LOW} (set to
@code{0}). In order to avoid problems if the values should ever get
changed you should use these predefined values -- this could be the case
when a pulser has to be integrated that has more than two different
trigger input impedances. The module should tell the user that setting a
trigger input impedance doesn't make sense in the case that the user
specified internal trigger mode.


@item bool set_phase_reference(int phase, int function)
This again a function that gets called under somewhat different
circumstances, depending on how the pulser module is supposed to work.
If you are writing a module that has to create phase pulses
automatically (and thus you have set the variable
@code{needs_phase_pulses} in the pulser structure), this function will
be called when in the definition of a phase function the function the
phase pulses will be used with is set. That means if the @code{EDL}
script contains a line like
@example
ASSIGNMENTS:
  PHASE_2: MICROWAVE, POD = 2, 3, ....
@end example
@noindent
Obviously, this is meant for a pulser module that automatically creates
phase pulses (otherwise the use of a phase function would not be
allowed) and this statement is intended to tell the module that the
function @code{PHASE_2} (with its pulses appearing on the output
connectors 2 and) is to be used to create phase pulses for the microwave
pulses. To tell the module the function @code{set_phase_reference()}
gets called with the number of the phase function (i.e.@:
@w{@code{PULSER_CHANNEL_PHASE_1}} or @w{@code{PULSER_CHANNEL_PHASE_1}})
as the first argument and the number of the pulse function (in the
example the @code{MICROWAVE} phase function) as the second argument.

In contrast, for modules that don't have to create phase pulses this
function is called from within the @code{ASSIGNMENTS} section when
lines of the form
@example
ASSIGNMENTS:
  PHASE_SETUP_2:  MICROWAVE, ...
@end example
@noindent
are found. In this case @code{MICROWAVE} is again the function that is
to be phase cycled and is passed to the function as the second
argument. The first argument is either @code{0} or @code{1}, depending
on if this pertains to the first phase cycled function (i.e.@: when the
command in @code{EDL} script starts with either @code{PHASE_SETUP} or
@code{PASE_SETUP_1}) or the second phase cycled function (i.e.@: for
@code{PHASE_SETUP_2}).


@item bool phase_setup_prep(int func, int type, int pod, long val)
Again this function is called under slightly different circumstances,
i.e.@: depending on if you have set the variable
@code{needs_phase_pulses} in the pulser structure (meaning that phase
pulses have to be created) or not. In the first case a syntax of
@example
PHASE_1:  MICROWAVE, POD = 2, 3;

PHASE_SETUP_1:  +X: POD_1 = ON, POD2 = OFF,
                +Y: POD1  = ON, POD_2 = 1,
                -X: POD2 = 0, 0,
                -Y: 1, 1;
@end example
@noindent
is expected in the @code{EDL} script. The first line indicates that
the phase function 1 is to be used to control phase pulses for microwave
pulses and the output pods to be used are the pods 2 and 3. The
following lines are supposed to tell the module that in order to create
a @code{+X} phase pulse the first output pod set in the definition of
the first phase function (@code{PHASE_1}) (i.e.@: pod 2) must be in the
high state, while the second pod (i.e.@: pod 3) must be low.

For this kind of phase setup the function @code{phase_setup_prep()} will
be called exactly 8 times in a row, 2 times for each phase type (i.e.@:
@code{+X}, @code{+Y}, @code{-X} and @code{-Y}). It will be called always
with the first argument set to @code{0} to indicate that
@code{PHASE_SETUP_1} is currently done (where @code{PHASE_SETUP} without
a number is just a short form for this), in for @code{PHASE_SETUP_2} the
first parameter would be @code{1}.

The second argument is type of phase, in @file{src/global.h} an
enumeration defining @code{PHASE_PLUS_X} for a phase of @code{+X},
@code{PHASE_PLUS_Y} for @code{+Y}, @code{PHASE_MINUS_X} for @code{-X} and
@code{PHASE_MINUS_Y} for @code{-Y} is defined and should be used in your
module. There is also a @code{PHASE_CW} pseudo phase type defined in
case your module has to support a special cw-mode configuration.

The third argument is the output pod to use, where @code{0} stands for
the first pod defined previously for the phase function, i.e.@: in our
example a @code{0} would represent the pod numbered 2. In contrast, an
argument of @code{1} indicates the second output pod, i.e.@: in our
example the pod numbered 3. Finally, you also have to expect an argument
of @code{-1}, meaning "the first of the two pods" if none of both the
pods has been set yet for this phase type or "the other one" if already
one one the two pods has been set.

The fourth and final argument is the state of the output for the put
when the pulse is output. In our example this means that it will be
@code{1} when a @code{1} or @code{ON} is found in the @code{EDL}
script and @code{0} for @code{OFF} or @code{0}.

Accordingly, the @code{EDL} code for the phase setup given above will
lead to the following sequence of calls of the function
@code{phase_setup_prep()}:
@example
/* PHASE_SETUP_1:  +X: POD_1 = ON, POD2 = OFF, */

phase_setup_prep( 0, PHASE_PLUS_X, 0, 1 );   
phase_setup_prep( 0, PHASE_PLUS_X, 1, 0 );

/* +Y: POD1  = ON, POD_2 = 1, */

phase_setup_prep( 0, PHASE_PLUS_Y, 0, 1 );   
phase_setup_prep( 0, PHASE_PLUS_Y, 1, 1 );

/* -X: POD2 = 0, 0, */

phase_setup_prep( 0, PHASE_MINUS_X, 1, 0 );   
phase_setup_prep( 0, PHASE_MINUS_X, -1, 0 );

/* -Y: 1, 1; */

phase_setup_prep( 0, PHASE_MINUS_Y, -1, 1 );   
phase_setup_prep( 0, PHASE_MINUS_Y, -1, 1 );
@end example

If you are writing a module that does not create phase pulses (and you
accordingly set the variable @code{needs_phase_pulses} in the pulser
structure to false) the phase setup command looks a bit different:
@example
PHASE_SETUP_1:  MICROWAVE,
              +X: POD = 1,
              +Y: POD = 2,
              -X: POD = 4,
              -Y: 5,
              CW: 3;
@end example
@noindent
For these @code{EDL} code the function @code{phase_setup_prep()} gets
called five times in a row. Again the first and second parameter the
function will receive is the phase setup number (i.e.@: either @code{0}
or @code{1}, for our example it would be @code{0} because we're dealing
with the first phase setup), and the second is the phase type (i.e.@:
@code{PHASE_PLUS_X}, @code{PHASE_PLUS_Y}, @code{PHASE_MINUS_X},
@code{PHASE_MINUS_Y} and @code{PHASE_CW}). The third parameter has in
this case no meaning at all and its value should be discarded. The
fourth and final is the output pod or channel to be used for a pulse
with the current phase. Thus, the function would be called in the
following sequence (without any other intervening calls except possibly
@code{set_phase_reference()}):
@example
phase_setup_prep( 0, PHASE_PLUS_X, (discard), 1 );   
phase_setup_prep( 0, PHASE_PLUS_Y, (discard), 2 );
phase_setup_prep( 0, PHASE_MINUS_X, (discard), 1 );   
phase_setup_prep( 0, PHASE_MINUS_Y, (discard), 2 );
phase_setup_prep( 0, PHASE_CW, (discard), 1 );   
@end example
@noindent
Here @code{(discard)} stands for an arbitrary value that has to be discarded.


@item bool phase_setup(int func)
This function is called to tell the module that a phase setup sequence
is finished and no further commands of @code{phase_setup_prep()} for the
phase setup with number @code{function} (i.e.@: either @code{0} for the
first phase setup or @code{1} for the second) should happen. The module can
now do some sanity checks on the data it received from the previous
@code{phase_setup_prep()} calls or whatever else it needs to do.


@item bool new_pulse(long pulse_number)
This function is called when a new pulse definition is found in the
@code{PREPARATIONS} section, i.e.@: for lines starting like this
@example
  PULSE_13: ...
@end example
@noindent
For this the function will called (with @code{13} as the
@code{pulse_number} argument) to tell the module that there's a new
pulse to be dealt with. Pulse numbers are always non-negative, so
negative pulse numbers can be used for pulses generated internally by
the module.


@item bool set_pulse_function(long pulse_number, int function)
This function is called when the function of a new pulse is set in the
@code{PREPARATIONS} section, i.e.@: for
@example
  PULSE_13:   FUNCTION = MICROWAVE, ...
@end example
@noindent
The first argument is the pulse number (you can be sure that the
function @code{new_pulse()} will have been called before with this pulse
number as argument) and the pulse function number as the second argument
(see the discussion of pulse function numbers above in the description
of the function @w{@code{assign_channel_to_function()}}). If you don't
have a god reason to do otherwise I would recommend to allow neither
@w{@code{PULSER_CHANNEL_PHASE_1}} nor @w{@code{PULSER_CHANNEL_PHASE_2}}
as pulse functions because these functions are usually reserved for
internally generated phase pulses.


@item bool set_pulse_position(long pulse_number, double ptime)
This is the function that gets called to tell the module about the
start position of a pulse, i.e.@: for lines like
@example
  PULSE_13: START = 100 ns, ...
@end example
@noindent
within the @code{PREPARATIONS} section or when during the experiment the
position of a pulse is changed directly by assigning a new start
position i.e.@: for lines like
@example
  P13.START = 260 ns;
@end example
@noindent
If you need different handling of both situations you can assign a new
function pointer to the corresponding structure entry at the start of
the @code{EXPERIMENT} section, for example in the @code{exp_hook}
function (or at any other time it is convenient).

As in the case of the @code{set_pulse_function()} function the first
argument is the pulse number, the second the start position of the pulse
in seconds (but guaranteed to be an integer multiple of @w{1 ns}, you
still will have to check if it's not negative and also that it isn't an
integer multiple of the pulsers timebase).


@item bool set_pulse_length(long pulse_number, double ptime)
The function gets called when the length of a pulse is set in the
@code{EDL} file, i.e.@: for lines like
@example
  PULSE_13: ...
            LENGTH = 2 us, ...
@end example
@noindent
within the @code{PREPARATIONS} section or, within the @code{EXPERIMENT}
section, to directly change the length of a pulse, e.g.@:
@example
  P13_LENGTH = 2.1 us;
@end example
@noindent
If you need different handling of both situations you can assign a new
function pointer to the corresponding structure entry whenever you want.

Obviously, the first argument to the function is the pulse number, the
second is the new length of the pulse in seconds. You will have to check
yourself within the module that the pulse length hasn't an invalid
value. If the length of the pulse is zero you must treat the pulse as
switched off for the time being.


@item bool set_pulse_position_change(long pulse_number, double ptime)
This function is used to tell the module about the start position change
of a pulse (i.e.@: when a pulse definition line containing the
@code{DELTA_START} keyword is found in the @code{PREPARATIONS} section
or a new value is assigned to the @code{DELTA_START} value of a pulse during
the experiment), with the first argument being the pulse number, the
second the start position change for the pulse (which might be
negative).


@item bool set_pulse_length_change(long pulse_number, double ptime)
This function is used to tell the module about the length change of a
pulse (i.e.@: when a pulse definition line containing the
@code{DELTA_LENGTH} keyword is found in the @code{PREPARATIONS} section
or a new value is assigned to the @code{DELTA_LENGTH} value of a pulse
during the experiment), with the first argument being the pulse number,
the second the length change for the pulse.


@item bool set_pulse_phase_cycle(long pulse_number, long cycle)
This function is called to set the phase sequence to be used for phase
cycling the pulse indexed by the first argument, i.e.@: when commands
like
@example
  PULSE_13: PHASE_CYCLE = PHASE_SEQUENCE_1, ...
@end example
@noindent
are found in the @code{PREPARATIONS} section of the @code{EDL} file.
The second argument is either the number @code{1} or @code{2},
indicating one of the currently allowed two phase sequences. But to
avoid the necessity of changes of the module it is probably a good idea
to test this value within the function.


@item bool get_pulse_function(long pulse_number, int * function)
This function is called by @code{fsc2} to find out about the function of
a pulse from the module. If a pulse with the number passed to the
function exists (if it doesn't the module should print out an error
message and throw an exception), it should set the variable pointed to
by the second argument to the number of the pulses function and return a
true value. If no function has been set for the pulse an error message
should be printed out and an exception has to be thrown.


@item bool get_pulse_position(long pulse_number, double * ptime)
This function is called by @code{fsc2} to find out about the current
position of a pulse (@strong{not} including function delays) from the
module. If a pulse with the number passed to the function exists
(otherwise the module should print out an error message and throw an
exception), it should set the variable pointed to by the second argument
to the start position (in seconds) of the pulse. If no start position
has been set for the pulse an error message should be printed out and an
exception has to be thrown.


@item bool get_pulse_length(long pulse_number, double * ptime)
This function in the module is called to determine the current length of
a pulse. If a pulse with the number passed as the first argument exists
the variable the second argument points to has to be set to the length
of the pulse (in seconds).  If no length has been set for the pulse an
error message should be printed out and an exception has to be thrown.


@item bool get_pulse_position_change(long pulse_number, double * ptime)
This function should return the current setting of the position change
setting for the pulse indexed by the argument in the variable pointed to
by the second argument. If no start position change vale has been set
for the pulse an error message should be printed out and an exception
has to be thrown.


@item bool get_pulse_length_change(long pulse_number, double * ptime)
This function should return the current setting of the length change
setting for the pulse indexed by the argument in the variable pointed to
by the second argument. If no length change value has been set for the
pulse an error message should be printed out and an exception has to be
thrown.


@item bool get_pulse_phase_cycle(long pulse_number, long * cycle)
The function should return the number of the phase sequence (i.e.@:
@code{1} or @code{2}) associated with the pulse associated with pulse
with the number passed to the function as the first argument. If a phase
sequence has been set for the pulse the number has to be written into
the variable pointed to by @code{cycle}, otherwise (or if no pulse with
the number of the first argument exists) an error message has to be
printed out and an exception should be thrown.


@item long ch_to_num(long channel)
Different pulser modules have different internal numbering schemes for
their channels. On the other hand, @code{fsc2} does only know about all
the possible names of channels (as defined in @file{global.h} and
@file{global.c}). So for @code{fsc2} being able to pass channel numbers
to the pulser module with the channel numbers the module expects the
pulser module must support this function. It gets a channel number in
the "global" numbering system according to the definitions in
@file{global.h} and @file{global.c} and has to translate this number
into the internally used channel number. If no translation is possible
the module should throw an exception and print out an error message,
stating that it has no channel of the name @code{Channel_Names[channel]}.


@item bool set_max_seq_len(double seq_len)
This function is called when the @code{MAXIMUM_SEQUENCE_LENGTH} is found
in the  @code{ASSIGNMENTS} section, i.e.@:
@example
ASSIGNMENTS:
  MAXIMUM_SEQUENCE_LENGTH: 10 us;
@end example
@noindent
If you determine the maximum length of the pulser pattern in your module
during the test run the value you get can be plain wrong if the
@code{EDL} script contains e.g.@: @code{FOREVER} loops,
@code{IF}/@code{ELSE} constructs etc.@: because it is not possible to
determine during the test run which branches of the @code{EDL} script
will be run in the real experiment. The @code{MAXIMUM_SEQUENCE_LENGTH}
command should allow the user to correct the possible wrong value when
necessary.

The obvious question is why bother at all to determine the maximum
length of the pulse pattern and not use instead the maximum pattern
length all the time? The reason is that clearing the whole pattern at
the start of the experiment for some pulsers can take a rather long
time. E.g.@: for the @strong{Sony/Tektronix DG2020} for each of the
internal channels that are going to be used more than @w{64 kB} of data
would have to be send to the pulser, probably taking several minutes,
while in most experiments only a small fraction of the maximum pattern
length is really needed.

@quotation
@cartouche
The use of the keyword @code{MAXIMUM_SEQUENCE_LENGTH} is deprecated.
Instead, the pulser module should supply, if necessary, a function
@code{pulser_maximum_sequence_length()} that can be used in the
@code{PREPARATIONS} section and has the same effect. Assigning anything
else then @code{NULL} to the @code{set_max_seq_len} member of the pulser
structure is only for backward compatibility.
@end cartouche
@end quotation


@item bool bool keep_all_pulses(void)
This function is called when the @w{@code{KEEP_ALL_PULSES}} keyword is
found in the @code{ASSIGNMENTS} section. If this function is called your
module may not delete pulses that it found during the test run never to
be used.

The question, of course, is why delete pulses at all that are never used
and not keep them? The reason is that when doing phase cycling it can
happen that for each additional pulse lots of channels in the digitizer
are needed, even to the point that the number of channels is exceeded.
Therefor, as a default, pulses that are found to be never used during
the test run are removed (after printing out a message to the user).

@quotation
@cartouche
The use of the keyword @code{KEEP_ALL_PULSES} is deprecated.  Instead,
the pulser module should supply, if necessary, a function
@code{pulser_keep_all_pulses()} that can be used in the
@code{PREPARATIONS} section and has the same effect. Assigning anything
else then @code{NULL} to the @code{keep_all_pulses} member of the pulser
structure is only for backward compatibility.
@end cartouche
@end quotation


@item bool set_phase_switch_delay(int function, double del_time)
This function is called when in the @code{ASSIGNMENTS} section a line like
@example
  PHASE_SWITCH_DELAY: 40 ns;
@end example
@noindent
is found. The module must use the value of the second argument
@code{del_time} as the time that pulses of the phase function indicated
by the first argument (which currently can be only either @code{1} or
@code{2}) start before the 'real' pulses of the pulse function the phase
function is associated with. Of course, if the module is not prepared to
create phase pulses at all, this function does not need to exist and the
corresponding entry in the pulsers structure should be left a @code{NULL}
pointer. If no phase switch delay is set for a phase-cycled function it
should (but that's not a necessity but just a recommendation) use a
default value of @w{20 ns}.

@quotation
@cartouche
The use of the keyword @code{PHASE_SWITCH_DELAY} is deprecated.
Instead, the pulser module should supply, if necessary, a function
@code{pulser_phase_switch_delay()} that can be used in the
@code{PREPARATIONS} section and has the same effect. Assigning anything
else then @code{NULL} to the @code{set_phase_switch_delay} member of the
pulser structure is only for backward compatibility.
@end cartouche
@end quotation


@item bool set_grace_period(double gp_time)
This function is called when in the @code{ASSIGNMENTS} section a line like
@example
  GRACE_PERIOD: 20 ns;
@end example
@noindent
is found. The module must use the value of the second argument
@code{gp_time} as the time that pulses of the phase function indicated
by the first argument remain switched on after the 'real' pulses of the
pulse function the phase function is associated with already ended. If
these 'real' pulses get to near to each other to allow having both a
phase switch delay as well as the 'grace period' the later may be
reduced below the value set by the user. If the module is not prepared
to create phase pulses at all, this function does not need to exist and
the corresponding function pointer entry in the pulsers structure should
remain a @code{NULL} pointer.

@quotation
@cartouche
The use of the keyword @code{GRACE_PERIOD} is deprecated.  Instead, the
pulser module should supply, if necessary, a function
@code{pulser_grace_period()} that can be used in the @code{PREPARATIONS}
section and has the same effect. Assigning anything else then
@code{NULL} to the @code{set_grace_period} member of the pulser
structure is only for backward compatibility.
@end cartouche
@end quotation


@end table
