@c $Id$
@c
@c Copyright (C) 2001 Jens Thoms Toerring
@c
@c This file is part of fsc2.
@c
@c Fsc2 is free software; you can redistribute it and/or modify
@c it under the terms of the GNU General Public License as published by
@c the Free Software Foundation; either version 2, or (at your option)
@c any later version.
@c
@c Fsc2 is distributed in the hope that it will be useful,
@c but WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with fsc2; see the file COPYING.  If not, write to
@c the Free Software Foundation, 59 Temple Place - Suite 330,
@c Boston, MA 02111-1307, USA.


@node Modules, Interfacing, Command Line Options, Top
@chapter Modules
@cindex modules

This chapter tries to describe how to write new modules for use with
@acronym{fsc2}.

@ifinfo
@menu
* Module Overview::       What modules are good for.
* fsc2s Variables::       How to use fsc2's variables.
* New Modules::           How to write new modules.
* Programming Utils::     Functions that help in programming modules
* Pulser Modules::        Writing modules for pulsers
@end menu
@end ifinfo

@node Module Overview, fsc2s Variables, Modules, Modules
@section What modules are good for


Modules allow extending the set of commands to be used in an
@acronym{EDL} file. This is especially important if a new device needs
to be integrated into @acronym{fsc2}. You don't have to change
@acronym{fsc2} itself but write a new module for the new devices without
having to understand completely how the @acronym{fsc2} works. It's only
necessary to be able to write functions in C for the communication with
the new device. The only exception is some basic knowledge about
@acronym{fsc2}'s variables. They are explained in one of the following
sections. But modules may also be used for other purposes beside handling
new devices - one might also write modules that supply new mathematical
functions or other useful functionalities. But the following the
discussion will mainly concentrate on modules for new devices, writing
other modules is even simpler.

Let's start with a short summary of the things a module for a device has
to do. Usually, a module contains just a few functions that talk to the
device via an hardware interface, e.g.@: the GPIB bus or a serial port
(or whatever else there might be). As an example for the following a
lock-in amplifier will be used. Probably the most basic operation is to
get data from the amplifier. So one will have to create a function
called for example @code{lockin_get_data()}. This name will be used in
the module written in C as well as in the @acronym{EDL} file.

Before starting to write a new module you have to decide about the name
for the device, which will also be the name of the module. E.g.@: for the
@i{Stanford Research 510} lock-in amplifier I picked the name SR510
because that's what's written on the front panel.

A new device has to be included into the device name data base called
@file{Devices}
@cindex @code{Devices} file
, which is a simple ASCII file consisting of the names of all the
supported devices. It can be found in the @file{config} subdirectory of
the source tree and usually gets installed in
@file{/usr/local/lib/fsc2}. The entries in this file are
case-insensitive, so you might add `SR510', `sr510' or `Sr510'
etc. Within the file C and C++ style comments can be used. By adding
the device name to this file you tell @acronym{fsc2} that there is now a
module called `sr510' (take care - all modules are spelled with
@strong{lower} case characters!). Actually, the file compiled from the C
file defining the functions has to be @file{sr510.so} - that means it is
a shareable library, how to create it from the C file is described
later. Here is a short snippet from the @file{Devices} file with the
entries for the lock-in amplifiers:
@example
sr510         // Stanford Research lock-in amplifier, model 510
sr530         // Stanford Research lock-in amplifier, model 530
sr810         // Stanford Research lock-in amplifier, model 810
sr830         // Stanford Research lock-in amplifier, model 830
er023m        // Bruker Signal Channel, model ER 023 M
@end example

The next thing is to append the function(s) exported (in the sense that
they can be used from @acronym{EDL} programs) by the module to the
function data base file called @file{Functions}
@cindex @code{Functions} file
. Also this file is located in the @file{config} subdirectory of the
source tree and will usually be installed in
@file{/usr/local/lib/fsc2}. Here one would add lines consisting of two
or three entries, separated by commas and ending with a
semicolon. Please note that you can't use function names that contain
a @code{#} character.
@enumerate
@item Each line must start with the names of the exported function, i.e.@:
      @code{lockin_get_data}.
@item This has to be followed by the number of arguments the function takes 
      - if the function accepts a variable number of arguments specify an
      arbitrary negative number or just a minus sign (@code{-}).
@item Optionally, you can add the keywords @code{ALL},
@cindex @code{ALL} (in @code{Functions} file)
      @code{EXP}
@cindex @code{EXP} (in @code{Functions} file)
      or @code{PREP},
@cindex @code{PREP} (in @code{Functions} file)
      where @code{ALL} means that the function can be used in all parts of the
      @acronym{EDL} file, while @code{EXP} tells @acronym{fsc2} to use this
      functions only during an experiment and, finally, @code{PREP} restricts
      the use of the function to the @code{PREPARATION} section of the
      @acronym{EDL} file.
@end enumerate
As in the device data base, C and C++ style comments can be used. Here
are a few lines from a valid @file{Functions} file with the entries for
lock-in amplifier functions:
@example
/* Functions exported by the lock-in amplifier modules
   (SR510, SR530, SR810, SR830) */

lockin_name,           0, ALL;  // return the device name
lockin_get_data,      -6, EXP;  // return the lock-in voltage 
lockin_get_adc_data,   1, EXP;  // return a ADC voltage
lockin_dac_voltage,   -2, ALL;  // get/set DAC voltage
lockin_sensitivity,   -1, ALL;  // get/set the sensitivity
lockin_time_constant, -1, ALL;  // get/set the time constant
lockin_phase,         -1, ALL;  // get/set the phase
lockin_ref_freq,      -1, ALL;  // Get/set mod. frequency (SR8x0 only)
lockin_ref_mode,       0, EXP;  // Get mod. mode (SR8x0 only)
lockin_ref_level,     -1, EXP;  // Get/set mod. level (SR8x0 only)
lockin_lock_keyboard, -1, EXP;  // Lock/unlock the keyboard
@end example
@noindent
For example, @code{lockin_get_adc_data} (a function that allows you to
read the voltage at one of the lock-ins ADCs) expects 1 argument (the
number of the ADC) and can only be used in the @code{EXPERIMENT}
section. In contrast, @code{lockin_sensitivity} can be called with a
variable number of arguments with an upper limit of 1 argument (if
called without an argument it returns the sensitivity setting of the
lock-in, if called with an argument the function treats this as the new
sensitivity to be set). This function can be used in all parts of the
@acronym{EDL} program - but because querying the lock-in for its
sensitivity won't work as long as the program can't talk with the
lock-in, i.e.@: while not in the @code{EXPERIMENT} section the function
must test for this case and emit an appropriate error message all by
itself.


Writing the C file(s) with these functions, compiling it to create a
shareable library file from it and extending the device and function
data base is all there is to be done. If in the devices sections of the
@acronym{EDL} file the new device is found (and it's also listed in the
devices data base file @file{Devices}) the new module will be loaded by
@acronym{fsc2} and the functions defined in the module can be used in
the @acronym{EDL} file.



@node fsc2s Variables, New Modules, Module Overview, Modules
@section How fsc2's variables work and how to use them


Of course, the first question is: Why do I have to know about this at
all?  The answer is that all functions to be used in an @acronym{EDL}
file get their input parameters in form of this kind of variables and
@acronym{fsc2} expects that you return values also in the form of
@acronym{fsc2}'s variables.

Now let's have a look at the way @acronym{fsc2} internally stores
variables. Here is the (actually somewhat simplified) @code{typedef} of the
structure for variables:

@example
typedef struct Var_
@{
    int type;                /* type of the variable */
    union
    @{
        long    lval;        /* value of integer values */
        double  dval;        /* value of float values */
        long   *lpnt;        /* pointer to integer arrays */
        double *dpnt;        /* pointer to floating point arrays */
        char   *sptr;        /* for string constants */
    @} val;
    size_t len;              /* length of array */
    struct Var_ *next;       /* next variable on stack */
@} Var;
@end example
@noindent
There are only four types of variables you have to know about:

@multitable {FLOAT_ARR} {a one-dimensional array of floating point values}
@item @code{INT_VAR} @tab a variable for integer values
@item @code{FLOAT_VAR} @tab a variable for floating point values
@item @code{INT_ARR} @tab a one-dimensional array of integer values
@item @code{FLOAT_ARR} @tab a one-dimensional array of floating
point values
@end multitable

To give you a better idea what these variables are good for let's assume
that you want to write a function that returns the curve between the two
cursor bars of your shiny new LeCronix digitizer. So, you may want to
write a function that has the two positions of the cursor bars as input
parameters and returns the data of the curve between the cursor
bars. Let's call this function
@example
get_curve_between_cursors( cursor_1, cursor_2 )
@end example
@noindent
This hypothetical function expects two values, the positions of two
cursors, and is expected to return the data between these two cursors it
fetched from the digitizer. Now, a typical C declaration for this
function is

@example
Var *get_curve_between_cursors( Var *var );
@end example
@noindent
Surprisingly, there seems to be only one input variable! And how to return an
array of data?

Actually, it's not too complicated. The pointer to the variable
structure @code{var} points to the first of the two parameters. And if
you look back at the typedef for @acronym{fsc2}'s variables, there is a
@code{next} pointer. This is the key to access the next parameter --
@code{var->next} points to next of the input parameters. If the function
expects even more arguments, @code{var->next->next} etc. let's you get
them, i.e.@: the input variables are organized as a linked list:
@example
  var                               pointer passed to function
   |                                  |
   V                                  |
  ---------------                     V
 |        | next |                  first input parameter
  ---------------                         |
              |                           |
              V                           |
             ---------------              V
            |        | next |       second input parameter
             ---------------                  |
                         |                    |
                         V                    V
                        NULL        no more parameters...
@end example
@noindent
If you declared your function in the function data base file
@file{Functions} to accept exactly two input parameters the function will
always get exactly two. The @code{next}-pointer of the very last
parameter will always be @code{NULL}. If the function gets called in the
@acronym{EDL} file with more variables than you declared it to have a
warning will be printed, the superfluous variables discarded
automatically and not passed to the function. If, on the other hand,
there are not enough parameters the program will just print an error
message and then stop (and not call your function).

Having the parameters organized as a linked list also makes it easy to a
handle variable numbers of arguments: as long as the @code{next}-pointer
of an argument isn't @code{NULL} there is at least another one. You
probably should check in your function if there aren't too many
arguments and if necessary print out a warning.


One word of warning: @strong{Never ever try to change the variables you
get passed to your functions in any way, especially the
@code{next}-pointer!}


What @acronym{fsc2} won't do is check if the arguments it passes to your
function have the type you expect. Let's assume that you expect two
integer values. What you should do first is to check if the parameters
you got are really integers. There is a function that can do this for you,
@code{vars_check()}.
@findex vars_check()
All you have to do is to call @code{vars_check()}
with the pointer to the variable and the type you expect it to have,
e.g.@:
@example
vars_check( var, INT_VAR );
vars_check( var->next, FLOAT_VAR );
@end example
@noindent
If @code{vars_check()} finds that everything is ok it simply returns,
otherwise an error message will be printed and the the program stops, so
you don't have to take care of error handling. If you're prepared to accept
integers as well as floating point data, call @code{vars_check()} instead
with
@example
vars_check( var, INT_VAR | FLOAT_VAR );
@end example
@noindent
As you probably already guessed from this the different types of
variables are coded into the bits of the the integer @code{type} in the
variable's structure, so you have to use the bitwise inclusive OR
operator @code{|} to test alternatives.


You can also check if the argument is a string by testing a type
of @code{STR_VAR}, i.e.@:
@example
vars_check( var, STR_VAR );
@end example


@code{vars_check()} not only checks that the variables has the correct
type but also some internal consistency checks to make sure that the
variable actually exists and has been assigned a value.

A function that expects just integer arguments would probably start
like the following example, just running through the linked list of
parameters:
@example
Var *my_function( Var *var )
@{
    Var *current;

    for ( current = var; current != NULL; current = current->next )
        vars_check( current, INT_VAR );

    ....
@}
@end example


The next question is how to access the value of the variable. As you can
see the typedef for variables above the value is stored in the union
@code{val}.  If the variable has integer type, you can access it as

@quotation
    @code{var->INT}@ @ @ @ (which is a macro standing for @code{var->val.lval})
@end quotation
@noindent
and what you get is a value of type @code{long int} -- @acronym{fsc2}
is using long integers internally. On the other hand, if the type of the
variable is @code{FLOAT_VAR} you get at the data with
@quotation
    @code{var->FLOAT}@ @ @ @ (i.e.@: a macro for @code{var->val.dval})
@end quotation
@noindent
in which case you get a value of type @code{double}. Of course, you may
also access the contents of the union directly. Finally you may use
@quotation
    @code{var->STRING}@ @ @ @ (a macro standing for @code{var->val.sptr})
@end quotation
to get the address of the start of a string variable.


But there are some functions that make it even easier for you to
evaluate the parameters your function receives. The first one is for the
case that you expect an integer variable but would be prepared also to
deal with a floating number (after it has been rounded to the nearest
integer. This is the function @code{get_long()}, defined as
@example
long get_long( Var *var, const char *snippet )
@end example
@noindent
The first argument is a pointer to the variable you want to
evaluate. The second parameter is used to setup a warning message when
the variable isn't an integer variable but a float value. This message
always starts with the name of the currently interpreted @acronym{EDL}
file, followed by the line number and the device name. The second
parameter is a string that gets embedded into the message. For example
if the currently interpreted @acronym{EDL} file is @file{foo.edl}, the
line where your function is called is line 17 and the device name is
@code{XYZ}, your function (that expects an integer but got a floating
point number) is @code{abc()} and the string you pass to the function
@code{get_long()} as the second argument is @code{"bar"}, i.e.
@example
get_long( var, "baz" );
@end example
@noindent
the following warning message will be printed:
@example
foo.edl:17: XYZ: Floating point number used as bar in abc().
@end example

If, on the other hand, you expect a floating point number but are
prepared to also accept an integer, you can use the function
@example
long get_double( Var *var, const char *snippet )
@end example
@noindent
The arguments of this function are the same you would pass to the
previous function and the only difference is that it will return a
@code{double} and print a warning message if the variable is an
integer variable instead of the expected floating point variable. The
warning message is
@example
foo.edl:17: XYZ: Integer number used as bar in abc().
@end example
@noindent
assuming that everything else is identical to the above example.

If your function can accept integer variables only there's a third
function:
@example
long get_strict_long( Var *var, const char *snippet )
@end example
@noindent
This function has the same arguments as the two other functions but it
will usually throw an exception to stop the interpretation of the
@acronym{EDL} program (see below) except while doing the experiment, in
which case a warning message is printed and the floating point number is
converted to the nearest integer, which is then returned (thus avoiding
the termination of the running experiment). But usually the wrong
parameter should already have been found during the test run, thus
forcing the user to correct her/his program.

Finally, there is a function for the case that you want a boolean
variable, i.e.@: a variable that can be either true or false. This
function is declared as
@example
bool get_boolean( Var *var )
@end example
This function will return true (i.e.@: a value of @code{1}) when the
variable passed to it is either an integer variable with a non-zero
value or a string variable with the string @code{"ON"} (it is
case-insensitive, so @code{"on"}, @code{"On"} or even @code{"oN"} will
also do). False (i.e.@: code{0}= is returned when it receives an integer
variable with a value of @code{0} or a string with the text @code{"OFF"}
(again this checked ion a case-insensitive manner). If the variable
passed to the function is a floating point variable normally an error
message like
@example
foo.edl:17: XYZ: Floating point number found where boolean
                 value was expected in abc().
@end example
@noindent
Only when @acronym{fsc2} is running the experiment only a similar
warning message is printed but instead the floating point value is
copnverted to the next integer value and the truth value of this number
is returned to avoid stopping the experiment.

Finally, if the function receives a string variable that is neither
@code{"ON"} nor @code{"OFF"} (including variations of the case the
characters) an error message is printed:
@example
foo.edl:17: XYZ: Invalid boolean argument ("bla") in abc().
@end example
@noindent
(assuming that the string was @code{"bla"}) and an execption is thrown
in all cases, even dring the experiment.


@subsection Returning data from EDL functions

If your function just wants to return an integer or a float, things are
very easy: just call the function @code{vars_push()} with the type of
the return value as the first and the value itself as the second
argument, e.g.@:
@example
return vars_push( INT_VAR, i_value );
@end example
@noindent
or
@example
return vars_push( FLOAT_VAR, f_value );
@end example
@noindent
where @code{i_value} is a @code{long int} and @code{f_value} is supposed
to be a @code{double} value. Of course, you don't have to use
@code{vars_push()} in return statements only, it simply returns a
pointer to the new variable holding the value.

For arrays @code{vars_push()} the first argument is either
@code{INT_ARRAY} or @code{FLOAT_ARRAY}, The second argument is a pointer
to the array (i.e.@: its first argument). For creation of an array
variable also third argument is needed, the length of the array (a
@code{long} integer). If you want to return an array with two integer
arguments you would use for example
@example
data[ 0 ] = 1;
data[ 1 ] = 2;
return vars_push( INT_ARRAY, data, 2 );
@end example
@noindent
assuming that @code{data} is an array of @code{long int}s.

As a complete example here is a rather simple but working function named
@code{square()} that returns the square of the value it got passed:
@example
Var *square( Var *var )
@{
    long int_square;
    double float_square;
    Var *ret_val;

    vars_check( var, INT_VAR | FLOAT_VAR );   /* is it a number ? */ 

    if ( var->type == INT_VAR )
    @{
        int_square = var->INT * var->INT;
        ret_val = vars_push( INT_VAR, int_square );
    @}
    else
    @{
        float_square = var->FLOAT * var->FLOAT;
        ret_val = vars_push( FLOAT_VAR, float_square );
    @}

    return ret_val;
@}
@end example
@noindent
As you see it is checked first that the variable passed to the function
has the correct type - both integer and floating point values are ok.
Next we distinguish between the possibilities that the value is
either an integer or a floating point number by testing the @code{type}
field of the variable. Then we create either a new integer variable by
calling @code{vars_push()} with the square of the integer value or a new
floating point variable. Finally, we return the variable pointer
@code{vars_push()} had delivered.

Of course, we could also have written the function in a more compact way:
@example
Var *square( Var *var )
@{
    vars_check( var, INT_VAR | FLOAT_VAR );

    if ( var->type == INT_VAR )
        return vars_push( INT_VAR, var->INT * var->INT );
    else
        return vars_push( FLOAT_VAR, var->FLOAT * var->FLOAT );
@}
@end example


If your function does not has to return a value at all there are two ways to
handle this situation. Either return a pointer to a variable with an arbitrary
value. e.g.@: write
@example
return vars_push( INT_VAR, 0 );
@end example
@noindent
or simply return a @code{NULL} pointer, i.e.@:
@example
return NULL;
@end example


What if you want to write to function that returns more than one value?
Again we use a function for a digitizer that has to return a curve as
an array as an example. Let's assume the data you got from the digitizer
are stored in an array of integers called @code{data} which has
@code{len} elements (where @code{len} is a @code{long}). Now all you've
got to do is call the function @code{vars_push()} as
@example
Var *ret_var;

...
ret = vars_push( INT_ARR, data, len );
...
return ret_var;
@end example
@noindent
Actually, at some point of your function you may have allocated memory
for storing the data. It is your responsibility to free this memory
before you return from your function, @acronym{fsc2} just uses a copy of
the data you pass to it using @code{vars_push()}. As you probably already
guessed, if you want to return a float array, you will have to use
@code{FLOAT_ARR} instead of @code{INT_ARR} in the call to
@code{vars_push()}.

The same method may be used if your function has to return two different
values and both have the same type. Again an array can be returned
@example
VARIABLES:

V1; V2;         // results of call to my_function()
Dummy[ * ];     // variable sized array for values returned by my_function()

...             // lots of stuff left out

Dummy[ ] = my_function( );   // auto-magically sets dimension 
                             // of Dummy to 2
V1 = Dummy[ 1 ];
V2 = Dummy[ 2 ];
@end example
@noindent
and the C code for function @code{my_function()} would look like
@example
Var *my_function( Var *var )
@{
    long v[ 2 ];

    v[ 0 ] = ...;    /* just fill in all the stuff you */
    v[ 1 ] = ...;    /* need to calculate both data    */

    return vars_push( INT_ARR, v, 2 );
@}
@end example


An alternative (e.g.@: if the type of the variables you need to return
differs) is two write two functions where the first one does the
calculations needed and stores the second value in a global
variable. All the second function has to do is just to return the value
of the global variable. This way, the @acronym{EDL} file might look like
@example
V1 = my_function_1( );
v2 = my_function_2( );
@end example
@noindent
while the C code would define both functions as

@example
static double v2;   /* global variable used by my_function_1() 
                       and my_function_2() */
Var *my_function_1( Var *v )
@{
    long V1;

    V1 = ...;       /* just fill in all the stuff you */
    v2 = ...;       /* need to calculate both data    */

    return vars_push( INT_VAR, V1 );
@}

Var *my_function_2( Var *v )
@{
    return vars_push( FLOAT_VAR, v2 );
@}
@end example


Alternatively, you also could write the function in a way that it counts the
number of times it has been called and returns values accordingly, e.g.@: 
@example
V1 = my_function( );
v2 = my_function( );
@end example
@noindent
with the corresponding C code
@example
Var *my_function( Var *v )
@{
    long V1;
    static double v2;
    static int call_count = 0;


    if ( call_count > 0 )    /* on second call return second value */
    @{
        call_count = 0;      /* don't forget to reset the call counter! */
        return vars_push( FLOAT_VAR, v2 );
    @}
        
    V1 = ...                 /* just fill in all the stuff you */
    v2 = ...                 /* need to calculate both data    */

    return vars_push( INT_VAR, V1 );
@}
@end example
@noindent
Of course, in both cases one has to be careful to call the function(s) in the
correct sequence, so it's not completely foolproof.



@node New Modules, Programming Utils, fsc2s Variables, Modules
@section How to write a new module

@subsection Files to be included

First of all, each module has to include the header file
@file{fsc2_module.h} -- otherwise it will not be able to use
@acronym{fsc2}'s variables. It should @strong{not} include
@file{fsc2.h}, this header file is for @acronym{fsc2} itself.
@file{fsc2_module.h} already includes all definitions and declarations
of macros, variables and functions for GPIB functions.

Second, each module should put its basic configuration information into
a special file which should be commented well enough to allow even
people without much programming experience to adapt the behavior of the
module to his/her needs. A good example are modules for devices that are
accessed via the serial port. Because you probably won't know which
serial port the user is going to use you shouldn't hide this information
somewhere deep down in the innards of your module but put it in a
prominent place where it's easy to find. Thus this is one of the items
that should go into the configuration file.

All configuration files are in the @file{config} directory. For obvious
reasons the names of the configuration files should make it clear for
which module they are supposed to be. Currently, all of them have the
extension @code{.conf}. Each configuration file should contain at least
to items. First a string with the device name should be defined, e.g.
@example
#define DEVICE_NAME     "TDS754A"
@end example
@noindent
This device name should be used in all places where the module has to
print out error messages or warnings. For devices connected via the GPIB
bus this device name should be identical to the one it is advertised as
in the GPIB configuration file (usually @file{/etc/gpib.conf}).

It is probably a good idea to select a name for a device that is
identical to the name of the module in order to avoid confusion for the
users.

For each module also a second string needs to be defined which describes
the device type, e.g.
@example
#define DEVICE_TYPE     "digitizer"
@end example
@noindent
The device type string is used by @acronym{fsc2} to figure out if more
than one device with the same functionality is being used by an
@acronym{EDL} program. You probably already have read that when you have
two such devices you can access the second device by appending a
'@code{#2}' when calling an @acronym{EDL}-function. But, obviously, for
this to work @acronym{fsc2} must know which devices have similar
capabilities and which don't. This it finds out from the device type
string. Thus if you decide which device type string you're going to use
please first check the device types of other devices as defined in their
configuration files.  If your device is similar enough to one of the
exiting devices pick the same device type string, otherwise pick a
new and descriptive name. Please also see the next section.


@subsection Variables a module should define

In the previous section the meaning of the device name and type type
strings has already been discussed. While the definition of the strings
should go into the configuration file for the device, no memory has been
allocated for these strings yet. This should be done as one of the first
things after the include files having been included. Each and every
device module should define two constant character arrays called
@code{device_name} and @code{generic_type}, that contain the device name
and type strings, i.e.@: one of the first lines should always be
@example
const char device_name[ ]  = DEVICE_NAME;
const char generic_type[ ] = DEVICE_TYPE;
@end example
or
@example
const char *device_name  = DEVICE_NAME;
const char *generic_type = DEVICE_TYPE;
@end example
@acronym{fsc2} will use the first variable with the name for printing of
@noindent
warnings and error messages. Tes second string is needed to find out
about the type of the device. If this variable does not exist it won't
have any information about the device type and having another device of
the same type recognized automatically will not work.

Another important point is that if in two modules with different
@code{generic_type} settings the same function name is used only one of
this modules can be used at the same time. If the user tries to list
both modules simultaneously in the @code{DEVICES} section an error
message will be printed and interpretation of the program will be
stopped. Thus it must be avoided to use identical @acronym{EDL} function
names in modules for devices of different types.


@subsection Global variables

First there is a global variable@footnote{Actually, @code{FSC2_MODE}
isn't a real variable. While you can obtain its value you can't assign
values to it, and if your try the compiler will complain about an error
like '@code{invalid lvalue in assignment}'.}, called @code{FSC2_MODE},
which tells you in which context your module function is called. There
are three different contexts: First you have to distinguish between the
program interpreting the @code{VARIABLES} or @code{PREPARATIONS} section
and, on the other hand, when interpreting the @code{EXPERIMENT}
section. During the handling of the @code{VARIABLES} or
@code{PREPARATIONS} section the devices are not initialized and can't be
accessed and the @acronym{EDL} program interpretation @code{FSC2_MODE}
is set to the predefined value @code{PREPARATION}.

But before the real experiment is started a test run of the
@code{EXPERIMENT} section must be done. While in this context your
module function still can't access the devices but must try to return
reasonable dummy data. That means that the module functions should at
least return data of the same type as it will do in the actual
experiment. E.g., if a function will return an array during the
experiment it should do the same during the a test run, even though the
data in the array probably are going to be completely bogus. During the
the test run the variable @code{FSC2_MODE} is set to @code{TEST}.

Finally the experiment gets started. Now your module can talk to the
devices and can return 'real' values. To indicate this @code{FSC2_MODE}
is set to the value @code{EXPERIMENT} (it's already set to this value
when the @code{exp_hook} functions (see below) are run).

Thus you will probably often have constructs like the following in your
module functions:
@example
switch ( FSC2_MODE )
@{
    case PREPARATION :
        /* print an error message that this functionality is */
        /* only available from within the EXPERIMENT section */
        break;

    case TEST :
        /* return some reasonable dummy value */
        break;

    case EXPERIMENT :
        /* do something only allowed when you can talk to the */
        /* device, i.e. from within the EXPERIMENT section    */
        break;
@}
@end example


The second important global variable, @code{need_GPIB}, is of type
@code{bool} and has to be set in the init hook function if the device is
controlled via the GPIB bus. Thus, if the GPIB bus is needed, include a
line in the init hook function similar to
@example
need_GPIB = SET;
@end example
@noindent
If you forget to set this variable chances are high that the program
will stop with an error message, complaining that it can't access the
GPIB bus.


@subsection Handling GPIB devices

To make dealing with the GPIB bus simpler there are several routines
that can be used when writing a module, which then call the needed
functions from the GPIB library you choose when installing
@acronym{fsc2}.

As already pointed out above, to be able to use the GPIB bus our module
must set the boolean variable @code{need_GPIB}.

The first other thing to do is to announce the device to the set of
functions dealing with the GPIB bus. This should be done in the
@code{exp_hook} function (see below) via a call of the function
@example
int gpib_init_device( const char *name, int *device );
@end example
@noindent
This function expects the name of the device (which will be used to look
it up in the GPIB configuration file) and the address of an integer,
which, on successful return, will contain a number now associated with
the device and to be used in all further calls of GPIB functions for
this device. The function returns either either @code{SUCCESS} or
@code{FAILURE} (with obvious meaning). All of the functions described in
rest of this section return these values.

The next two most important functions are
@example
int gpib_write( int device, const char *buffer, long length );
int gpib_read( int device, char *buffer, long *length );
@end example
@noindent
The first functions sends @code{length} data contained in @code{buffer}
to the device designated by @code{device} (which you got from a call of
@code{gpib_init_device()}). The second function reads a maximum of
@code{length} byte from the device @code{device} and stores them in
@code{buffer}. Before @code{gpib_read()} is called @code{length} must
have been set to the maximum number of data that should be read and
after a successful call @code{length} contains the number of bytes that
really have been read.

When you're done dealing with a device you should call
@example
int gpib_local( int device );
@end example
@noindent
to bring it back into the local state. This function should be called
in the @code{end_of_exp_hook} function (see below).

Using the function
@example
int gpib_timeout( int device, int period );
@end example
@noindent
a new timeout value can be set for the device. The value of
@code{period} depends on the values that the GPIB library you are using
expect. Please check the manual for the library.

The function
@example
int gpib_clear_device( int device );
@end example
@noindent
clears the device by sending it the Selected Device Clear (SDC) message.

@example
int gpib_trigger( int device );
@end example
@noindent
triggers the device by sending it a Device Trigger Command.


Finally, there is an additional function to let you directly write to
the log file that stores information about the details of the
communication on the GPIB bus:
@example
void gpib_log_message( const char *fmt, ... );
@end example
@noindent
It expects a format string as you would use in the @code{C printf()}
function plus arguments corresponding to the conversion specifiers in
the format string.


@subsection Serial port handling

For serial ports things are handled a bit differently from GPIB
devices. In the init hook function you must try to request the serial
port you need by calling the function @code{fsc2_request_serial_port()}
@example
fsc2_request_serial_port( SERIAL_PORT, DEVICE_NAME );
@end example
@noindent
with the number of the serial port (0 stands for the device file
@file{/dev/ttyS0}, which is what is called @code{COM1} in DOS-speak, 1
for @file{/dev/ttyS1} or for @code{COM2} etc.@.) as the first and the
device name as the second argument. If the requested serial port has
already been claimed by a different device the function will print an
error message and stop the @acronym{EDL} program, so you don't have to
deal with error handling.

For all functions that deal directly with file descriptors for the
serial port device files there are replacements functions. The following
table lists all functions that are used with respect to serial ports
with their replacements:
@table @samp
@item open()
@code{fsc2_serial_open()}
@findex fsc2_serial_open()
@item close()
@code{fsc2_serial_close()}
@findex fsc2_serial_close()
@item write()
@code{fsc2_serial_write()}
@findex fsc2_serial_write()
@item read()
@code{fsc2_serial_read()}
@findex fsc2_serial_read()
@item tcgetattr()
@code{fsc2_tcgetattr()}
@findex fsc2_tcgetattr()
@item tcsetattr()
@code{fsc2_tcsetattr()}
@findex fsc2_tcsetattr()
@item tcsendbreak()
@code{fsc2_tcsendbreak()}
@findex fsc2_tcsendbreak()
@item tcdrain()
@code{fsc2_tcdrain()}
@findex fsc2_tcdrain()
@item tcflush()
@code{fsc2_tcflush()}
@findex fsc2_tcflush()
@item tcflow()
@code{fsc2_tcflow()}
@findex fsc2_tcflow()
@end table

The only functions that are rather different to their normal
counterparts are @code{fsc2_serial_open()} and
@code{fsc2_serial_close()}.

@code{fsc2_serial_open()} is defined as
@example
struct termios *fsc2_serial_open( int sn, const char *devname,
                                  int flags )
@end example
@noindent
where @code{sn} is the number of the serial port as already used in
@code{fsc2_request_serial_port()}, @code{devname} has to be the same
device name that was used in the call of
@code{fsc2_request_serial_port()} and @code{flags} are the same flags
you would pass to a normal @code{open()} call. The function not only
opens the file but also creates the necessary lock file and determines
the current communication parameter settings for the serial port. These
are returned via a pointer to a @code{termios} structure, that can be
freely changed within the module. If the function returns a @code{NULL}
pointer opening the device file failed and you can determine the reasons
by checking @code{errno}.

@code{fsc2_serial_close()} expects just one argument, the serial port
number. Before closing the serial port device file it flushes it an
resets the communication parameters to their initial state. It also
deletes lock files. (If you don't close the serial ports device files
they will be automatically closed at the end of the experiment.)

All the remaining functions are completely identical to their usual form
(see the @code{termios(3)} man page for all details) except that the
first argument is always the serial port number instead of a file
descriptor. If the function gets passed an invalid serial port number
@code{errno} is set to @code{EBADF}.


@subsection Hook functions
@cindex hook functions
@findex init_hook()
@findex test_hook()
@findex end_of_test_hook
@findex exp_hook()
@findex end_of_exp_hook
@findex exit_hook()


As you will already know the interpretation of an @acronym{EDL} file
consists of several steps. When the file is tested and a @code{DEVICES}
section is found all modules for the devices listed here are loaded.
When in the test the @code{EXPERIMENT} section is found the test run is
started in which the program is tested as far as possible. When the test
was successful, the experiment may be run repeatedly. To allow
initialization of the modules internal parameters, initialization of the
devices etc. for each of these stages hook functions can be defined in
the modules that will be executed automatically at appropriate times (if
they exist).

Thus, each module may contain up to six pre-defined hook functions that
don't have to be declared in the function data base file,
@file{Functions}. They all start with the name of the module followed by
@code{_init_hook}, @code{_test_hook}, @code{_end_of_test_hook},
@code{_exp_hook}, @code{_end_of_exp_hook} and @code{_exit_hook}. Thus,
if the new device is named `SR510' (as the lock-in amplifier mentioned
at the start) and thus the module is `sr510' these functions are
(together with the parameters):
@example
int sr510_init_hook( void )
int sr510_test_hook( void )
int sr510_end_of_test_hook( void )
int sr510_exp_hook( void )
int sr510_end_of_exp_hook( void )
void sr510_exit_hook( void )
@end example


If it exists, the first function, i.e.@: @code{sr510_init_hook()} is
called immediately after the functions defined in all modules are
loaded. That means, the internal loader loads the module libraries and
when done runs the init hook functions of the modules in the order the
modules did appear in the devices section. The main purpose of the init
hook functions is to allow the modules to get all kinds of initialization
done. Since all other modules are already loaded, they also may be used to
test for the existence of other modules by calling a function called
@code{exist_device()}. But you should not call functions from other
modules at this stage, because the other modules may still be
uninitialized. If the initialization completes successfully, the
function must return a non-zero value. If there are problems that don't
make the module unusable it may return a zero value -- in this case a
warning message will be printed. If the initialization fails in a
non-recoverable way, the function should throw an exception.

The second function, @code{sr510_test_hook()}, is called at the start
of the test run of the @code{EXPERIMENT} section of the @acronym{EDL}
input file. Again, it can be used for initializations. But it should be
noted that changes to the variables defined in the @acronym{EDL} file
will remain only visible for the test run, after the test is completed
they will revert to their former values, i.e.@: the ones they had before
the test run started! The return code of the function is the same as for
the init hook function (i.e.@: always return a non-zero value on success).

The third function, @code{sr510_end_of_test_hook()} is called when the
test hook functions of the modules have been run. This hook function
might be used to reset internal variables of the module that got changed
during the test run. The return code of the function is the same as for
the init hook and test hook function (i.e.@: always return a non-zero
value on success).

The fourth function, @code{sr510_exp_hook()}, is run when the actual
experiment is started. Initialization of devices should be done
here. Return codes are again identical to the ones of the former
functions.

The fifth function, @code{sr510_end_of_exp_hook()} is run after the
experiment has been stopped. This hook function should be used to get
the device back into a usable state with local control.

Finally, the sixth and final function, @code{sr510_exit_hook()}, is run
just before the module is unloaded.

Please note that the first three functions, i.e.@:
@code{sr510__init_hook}, @code{sr510_test_hook} and
@code{sr510_end_of_test_hook} as well as the last function,
@code{sr510_exit_hook()}, will be run only once, while both the
remaining functions, @code{sr510_exp_hook()} and
@code{sr510_end_of_exp_hook()} will be run each time the experiment is
started.


@subsection Caveats for the test run

There is one rather nasty problem with the test run. In the test run the
program is checked extensively and as far as possible everything is done
as it will be done later in the real experiment. But this leads the
problem that the functions in the module must return data even though
they can't talk to the devices yet. If the program asks for the measured
value from a device reasonable, valid values most be returned.  This can
be quite tricky, because, while writing the module it is less than clear
what will be reasonable, valid values in all imaginable situations.

I don't have a failsafe method to select values to return during the
test run and I also fear that there isn't one. But after some
experimenting the values now used in the modules didn't lead to too many
problems. To make them stand out they are always defined as macros at
some prominent place at the start of the module. If necessary the users
must be made aware of possible problems, i.e.@: if they test values
returned from the @acronym{EDL} file they must be prepared to write the
@acronym{EDL} program to accept some unexpected values.


@subsection How to compile a module

A module is a shareable library that gets loaded while @acronym{fsc2} is
running if the name of the module is listed in the @code{DEVICES}
section of an @acronym{EDL} file. Probably the simplest way to make such
a shareable library from the source files you have written is to include
it in the existing @file{Makefile} in the @file{modules} subdirectory
of the packages. But, of course, it's also possible to use other methods.


If you want to include your module into the existing Makefile you have
to distinguish between two cases:
@enumerate
@item The new module consists of just one @code{C} file with the same
      name as the module and the @code{config} file (residing in the
      @file{config} directory)
@item The new module consists of several source files, one header file
      (with the same name as the module and the extension @code{.h}) and
      and the @code{config} file
@end enumerate

In both cases all you have to do is to edit the @file{Makefile} in the
@file{modules} directory. In the first case look for the variable
@code{simp_modules}, defined near the start of the file. The line
defining this variable is at the moment (while I'm writing this):
@example
simp_modules  := User_Functions.c sr510.c sr530.c sr810.c sr830.c \
                 aeg_s_band.c aeg_x_band.c er035m.c er035m_s.c \
                 er035m_sa.c er035m_sas.c bh15.c keithley228a.c egg4402.c \
                 kontron4060.c lakeshore330.c pt2025.c
@end example
@noindent
(The @code{\} characters at the ends of the lines tell make that the
line continues on the next line.) All you've got to do to include your
new module is to append the name of the single @code{C} file you have
written to this list, i.e.@: if it is called @file{abc.c} just change
the last line to
@example
simp_modules  := User_Functions.c sr510.c sr530.c sr810.c sr830.c \
                 aeg_s_band.c aeg_x_band.c er035m.c er035m_s.c \
                 er035m_sa.c er035m_sas.c bh15.c keithley228a.c egg4402.c \
                 kontron4060.c lakeshore330.c pt2025.c abc.c
@end example
@noindent
If you now re-compile it will also be compiled, a shareable library will
be created from it and when you do @code{make install} it will be copied
to the appropriate place where @acronym{fsc2} will find it (but don't
forget that you also have to declare it in the devices data base file
@file{config/Devices} and the functions it exports in the functions data
base file @file{config/Functions}).

If you wrote a larger module that consists of more than just one source
file you will have to apply two changes to the @file{Makefile}. Directly
beneath the definition of the make variable @code{simp_modules} another
variable, @code{comp_modules}, is defined, which (at the moment) is set to:
@example
comp_modules   = dg2020_f dg2020_b hfs9000 tds754a tds744a tds540 tds520c \
                 tds520a tds520 hp8647a
@end example
@noindent
Here you have to append the name of your own module (just the name with
no extension). Next you have to create a second variable that has the
same name as your module (again without extension, i.e.@: identical to
what you just appended to @code{comp_modules}) and which has to be set
to the list of the all the names of your @code{C} source files. As an
example have a look at the definition of the variable @code{tds754a}:
@example
tds754a       := tds754a.c tds754a_gpib.c tds754a_util.c
@end example
@noindent
The module @code{tds754a} consists of the four @code{C} source files
listed here. You have to create a similar entry for your own
module. After you've down so you're done and can now re-compile to
create the new module and re-install to make it available to
@acronym{fsc2}.

When you want to compile a module 'by hand' you'll have to make sure
that the @file{src} and the @file{config} directory are in the include
paths and that both the flags @code{-shared} and @code{-fpic} are set
both for compiling as well as linking. If you have a @code{C} source
called @code{abc123.c} in the @file{modules} directory and you want to
make a shareable library out of it you should compile it with at least
@example
  gcc -I../src -I../config -shared -fpic -o abc.o abc.c
@end example
@noindent
To create a shareable library from it you need
@example
  ld -shared -fpic -o abc.so abc.c
@end example
@noindent
(assuming you're using GNU's @code{gcc} and @code{ld}). If this succeeds
you will still have to copy the library to the place where
@acronym{fsc2} expects it, i.e.@: usually @file{/usr/local/lib/fsc2}.


@subsection Calling EDL functions from a modules

Calling an @acronym{EDL} function (built-in as well as @acronym{EDL}
functions defined in other modules) consists of three to four steps:

@enumerate
@item
You may first want to check if the function you're planning to call
exists at all. To do so call @code{func_exists()}
@findex func_exists()
with the name of
the function as the argument. It will return @code{0} if the function
does not exist and can not be used, otherwise a non-zero value.
@item
Call @code{func_get()}
@findex func_get()
with the name of the function you want to call as the first argument and
the address of an integer variable for returning the access flags (you
may specify also @code{NULL} instead if you're not interested in the
access flag) -- this will return a variable with a pointer to the
function which you have to store. If the returned pointer is @code{NULL}
the function does not exist or isn't loaded.  The variable pointed to by
the second argument will be set to either @code{ALL}, @code{PREP} or
@code{EXP}.
@item
Now call @code{vars_push()} for each of the arguments of the function -
see the description of @code{vars_push()} in the section about
@acronym{fsc2}'s built in variable types.
@item
Finally, call @code{func_call()} with the pointer returned by the call
to @code{func_get()}
@findex func_get()
as the argument. This will return a pointer to the
variable with the result.
@end enumerate

As an example let's assume there is an @acronym{EDL} function named
@code{foo()} you want to call from your module, that takes two
arguments, an integer and a floating point value. Then a typical piece
of C code to call the function would be

@example
Var *func_ptr;
Var *ret_value;
int access;

if ( func_exists( "foo" )                  /* test if function exists */
@{
    /* do your error handling here */ 
@}
else                                  
@{                                    
    func_ptr = func_get( "foo", &access ); /* get pointer to function */
    vars_push( INT_VAR, 5 );               /* push first argument */
    vars_push( FLOAT_VAR, 3.1415 );        /* push second argument */
    ret_value = func_call( func_ptr );     /* call the function */
@}
@end example


There is one point that need attention:
After the call to @code{func_call()} the variable with the pointer to
the function returned by @code{func_get()}
@findex func_get()
, @code{func_ptr}, will
disappear automatically. Thus, when you need to call the function again
you will have to go through this procedure, since the value
stored in @code{func_ptr} after the call to @code{func_call()} is
completely useless and even dangerous to use for any purpose whatsoever!
So, don't assume that the value of @code{func_prtr} you got from
@code{func_get()}
@findex func_get()
will have any meaning later on. Not only will the value be invalid but,
even worse, there is an high probability that hard to trace bugs will
result if you try to use it.



@node Programming Utils, Pulser Modules, New Modules, Modules
@section Additional utilities provided by fsc2

When writing a module some of the following information might be useful.
First a special function for printing out messages to the user is
discussed.

The second topic, exceptions, is a well-known concept implemented for
example in @code{C++}. Unfortunately, @code{C} does not have this kind
of mechanism, but when being a bit careful one can implement something
very similar also in @code{C} using a few macros. 

When writing the program I had to deal a lot with memory leaks,
segmentation faults etc.@: and hacked together a few routines for
allocation and deallocation of memory that have some build in code and
which help me with debugging (and throw an exception when an allocation
fails). You might find it useful to also use these routines for your
modules.

Finally, a boolean type is something that was missing until the new C99
standard (and which only a few compilers already support, if any at
all), so there's already a @code{typedef} for this type included in
@acronym{fsc2} that you can use. It's also documented here in order to
avoid confusion should you accidentally try to redefine it.


@subsection Printing out messages
@cindex eprint()

When writing a module one often has places where it is necessary to
print out messages to inform the user e.g.@: about invalid arguments
etc.  For this purpose there's the @code{eprint()} function in
@acronym{fsc2} that helps you deal with this and prints messages to the
lower browser in the main form. Except for the first two arguments the
function is identical to the @code{printf()} in @code{C}, i.e.@: the
third parameter is a format string in exactly the same format
@code{printf()} expects, followed by as many values as there are
conversion specifiers in the format string.

The first parameter is an integer describing the severity of the problem.
There are four levels:
@itemize
@item @code{NO_ERROR} Just an informational message (in black)
@item @code{WARN} A warning message (in green)
@item @code{SEVERE} A severe warning, which the user really should
      think about (printed in blue)
@item @code{FATAL} A fatal error message (printed in red) - to stay consistent
      with the usual way this type of error message is used you should
      now throw an exception (see next subsection) to make the program stop.
@end itemize

The second parameter is a boolean value, use
@itemize
@item @code{SET} This will start your error message with the name of the
      current @acronym{EDL} file, followed by a colon and the actual
      line number, again followed by a colon and a space character.
@item @code{UNSET} Don't print file name and line number - use this e.g.
      in the hook functions where the position in the @acronym{EDL} file
      is irrelevant.
@end itemize

The full @code{C} declaration of this function is:
@example
void eprint( int severity, bool flag, const char *fmt, ... )
@end example
@noindent
See the one of the following subsections for the definition of the
@code{bool} type.


@subsection Exceptions
@cindex exceptions

One of the most annoying things in programming is error handling. In
order to make a program failsafe in every place where there is even the
remotest chance that something may go wrong one has to include error
handling code.  This is especially tedious within deeply nested function
calls where it is often not clear on which level the error handling is
done best.

In order to alleviate this problem in @acronym{fsc2} there is a mechanism
called exceptions. An exception can be seen as a kind of flag that can
be raised at any instance in the program and leads to the flow of
control being changed to a place were the error can be handled.

As far as raising exceptions in a module is concerned it's very
simple. If you run into an error that can't be handled within the module
just use
@example
if ( non_recoverable_error )
    THROW( EXCEPTION );
@end example
@findex THROW()
@findex EXCEPTION
@noindent
and @acronym{fsc2} will take care of all error handling. That's all you
need to know about exceptions for nearly all cases that have to be
dealt with in modules.


@subsubsection More on programming with exceptions

Of course, to allow the `throwing' of exceptions there must be a place
that will `catch' the exception, otherwise the exception will simply
kill the program. Lets assume that you have a function @code{foo()},
that in turn calls a lot of other functions, each of which might lead to
non-recoverable errors and that can't be handled within the functions
themselves. The way to handle this problem with exceptions is
demonstrated by the following example:
@example
TRY
@{
    foo( );
    TRY_SUCCESS;         /* never forget this ! */
@}
CATCH( EXCEPTION )
@{
    ...                  /* the error handling code goes here */
@}
@end example
@findex TRY
@findex TRY_SUCCESS
@findex CATCH()
@noindent
With @code{TRY} the program is told that the following code might throw
an exception. If everything works out well and no exception is thrown
the @code{CATCH()} block is never executed and in this case
@code{TRY_SUCCESS} must be called to do some cleaning up. But if an
error happens and an exception gets thrown the flow of control is
changed immediately from the function the exception is thrown in to the
first statements in the @code{CATCH()} block.

@code{CATCH} can be used to catch a specific exception and you can have
several of them for different types of exceptions. If you want to catch
all types of exceptions in one go you can use @code{OTHERWISE}
@findex OTHERWISE
instead of @code{CATCH}.  Finally, if you can not really deal with the
error condition but need to do some cleaning up but before bailing out
you can catch the exception using either @code{CATCH} or
@code{OTHERWISE} and then re-throw the exception by calling
@code{PASSTHROUGH()}
@findex PASSTHROUGH()
to pass it on to higher level routines that are supposed to take care of
the problem. Here's some example code
@example
TRY
@{
    do_something_error_prone();
    TRY_SUCCESS;
@}
OTHERWISE
@{
    do_cleanup();       /* e.g. deallocate memory */
    PASSTHROUGH();
@}
@end example

There is a caveat when using exceptions: The values of non-static
automatic variables may differ from the values they were set to after an
exception got thrown. This could become a problem in cases where you do
error handling in a @code{CATCH()} or @code{OTHERWISE} block as in the
above example and rely on the values of such variables. You can avoid
this problem if you declare these variables as @code{static}. If you
need to find out more about this problem, have a look at the code in
@file{exceptions.h} and @file{exceptions.c} and read the documentation
for the standard C functions @code{setjmp()}
@findex setjmp()
and
@code{longjmp()}
@findex longjmp()
which are used to implement exceptions.


There are three types of exceptions that may be relevant when writing
a module:
@example
EXCEPTION
OUT_OF_MEMORY_EXCEPTION
USER_BREAK_EXCEPTION
@end example
@noindent
@code{EXCEPTION} stands for all kinds of exceptions not covered by one
of the following two types. @code{OUT_OF_MEMORY_EXCEPTION} will only be
thrown by @acronym{fsc2}s special functions for memory allocation (see
next section), so don't throw it yourself without a very good reason. A
@code{USER_BREAK_EXCEPTION} should be thrown from within a module when
the module is doing something rather time consuming (e.g.@: waiting for
a device to become ready or doing some calibration). In this case you
should think about checking if the user pressed the @code{Stop}
buttom. To find out you can use a macro, @code{DO_STOP} -- if it
returns @code{TRUE} the user has pressed the stop button. Ifyour
prepared to stop on the users request you simply have to throw an
@code{USER_BREAK_EXCEPTION}.


Here's some code taken from the module for a digitizer. It waits
indefinitely in a loop for the digitizer to become finished with a
measurement. To allow the user to break from it within this loop
@code{DO_STOP} is tested, and if set, an @code{USER_BREAK_EXCEPTION} is
thrown:
@example
while ( 1 )                   /* loop forever */
@{
    if ( DO_STOP )
        THROW( USER_BREAK_EXCEPTION );

    length = 40;
    usleep( 100000 );

    if ( gpib_write( tds754a.device, "BUSY?\n", 6 ) == FAILURE ||
         gpib_read_w( tds754a.device, reply, &length ) == FAILURE )
        THROW( EXCEPTION );

    if ( reply[ 0 ] == '1' )  /* leave loop when digitizer is ready */
        break;
@}
@end example


The idea and most of the code used for exceptions in @acronym{fsc2} is taken
from an article by Peter Simons in the the iX magazine
(@uref{http://www.heise.de/ix/}), No. 5, 1998, pp. 160-162.


@subsection Functions for memory allocation
@cindex memory allocation
@findex T_malloc()
@findex T_calloc()
@findex T_realloc()
@findex T_free()
@findex T_strdup()

There are special function for @acronym{fsc2} for allocating memory.
These functions not only allocate memory but also check that the
allocation really returned as much memory as you asked for (on failure
the program is stopped and an appropriate error message is
printed). That means that you don't have to care for error handling --
if thesr memory allocation functions return everything is ok, otherwise
they won't return at all. The first of these functions called
@code{T_malloc()} (think about it as @i{tested malloc}). And, of course,
there is also a replacement for @code{realloc()} and @code{calloc()},
called @code{T_realloc()} and @code{T_calloc()}. For the duplication of
strings you should use @code{T_strdup()} instead of the normal
@code{strdup()}. And, to make things complete, the replacement for
@code{free()} is called @code{T_free()}. All five functions accept the
same input and return values as their normal counterparts, i.e.@:
@example
void *T_malloc( size_t size )
void *T_calloc( size_t nmemb, size_t size )
void *T_realloc( void *ptr, size_t size )
char *T_strdup( const char *string )
void *T_free( void *ptr )
@end example
@noindent
For @code{T_free()} there's is small deviation from the behavior of
the normal @code{free()} function. @code{T_free()} returns a @code{void}
pointer, which is always @code{NULL}.

There might be cases where you need a call of one of the functions for
allocation of memory to return even if it fails. In this case you have
to call the fucntion from within a @code{TRY} block and be prepared to
catch the @code{OUT_OF_MEMORY_EXCEPTION} exception that gets thrown when
the memory allocation fails. Here's some example code:
@example
TRY
@{
    array = T_malloc( length );
    TRY_SUCCESS;
@}
CATCH( OUT_OF_MEMORY_EXCEPTION )
@{
    ...                  /* your error handling code goes here */
@}
@end example


@subsection The @code{bool} type
@cindex bool type

@acronym{fsc2} already has a @code{typedef} for the @code{bool} type,
i.e.@: for variables that can have only two values, either @code{1} or
@code{0}. It is declared as
@example
typedef enum
@{
    false = 0,
    true  = 1
@} bool;
@end example


You can use either the macros @code{SET}, @code{OK} or @code{TRUE}
instead of @code{1} and @code{UNSET}, @code{FAIL} or @code{FALSE}
instead of @code{1}. Use this type to do things like
@example
bool is_flag;

flag = SET;
...
if ( ! flag )
@{
    do_something( );
    flag = UNSET;
@}
...
if ( flag )
    do_something_else( );
@end example


@node Pulser Modules, , Programming Utils, Modules
@section Writing modules for pulsers

Modules for pulsers are a bit more difficult to write than drivers for
other devices. The reason is that pulsers play a rather important role
in modern spectrometers and thus setting the pulses should be made as
easy as possible for the user. Of course, it would be possible to deal
with pulsers in exactly the same way as normal devices, i.e.@: to define
just a set of functions for setting different pulse properties etc.@:
but this would make the programs much harder to write and understand.
Instead many aspects of dealing with pulses and pulsers are integrated
directly into the @acronym{EDL} language. While this makes it easier for
the user writing @acronym{EDL} programs it requires more work by the
writer of the module for a pulsers.

If, for example, the user defines a new pulse in the @code{PREPARATIONS}
section the relevant part of the @acronym{EDL} file will similar look to
this:
@example
P3: FUNCTION = MW,
    START    = P1.START + 200 ns,
    LENGTH   = 140 ns;
@end example
@noindent
When @code{fsc2} finds these lines it will have to call several
functions that must be defined within the module. First it needs to call
a function that allows it to inform the module that there is a new pulse
numbered 3. Next it will inform the module that the pulse function the
new pulse 3 is associated with is the function for microwave pulses.
Next it detects that the start position of the new pulse is defined in
terms of the values that (hopefully) have been already set for the pulse
1 and must ask the module for the start position of pulse 1. Using the
returned value @acronym{fsc2} now can calculate the start position of
the new pulse 3 and must then call another function in the module to
tell the module about this position. Finally, another function in the
module must exist so that @acronym{fsc2} can inform it about the length
of the new pulse. Using these (and a lot more) functions the module will
be able to set up an internal representation of the pulser state and to
bring the pulser into this state at the start of the experiment.

To make it possible to integrate handling of pulsers in this way
directly into @acronym{EDL} the module for a pulser must obviously
define quite a lot of non-@acronym{EDL} functions and some additional
variables. Pointers to all of these needed functions are collected in one
structure, @code{pulser_struct}:
@example
struct @{
    const char *name;
    bool needs_phase_pulses;

    bool ( *assign_channel_to_function )( int function, long channel );
    bool ( *assign_function )( int function, long connector );
    bool ( *set_function_high_level )( int function, double high_voltage );
    bool ( *set_function_low_level )( int function, double low_voltage );
    bool ( *invert_function )( int function );
    bool ( *set_function_delay )( int function, double delay );

    bool ( *set_timebase )( double timebase );

    bool ( *set_trigger_mode )( int mode );
    bool ( *set_repeat_time )( double rep_time );
    bool ( *set_trig_in_level )( double voltage );
    bool ( *set_trig_in_slope )( int slope );
    bool ( *set_trig_in_impedance )( int state );

    bool ( *set_max_seq_len )( double seq_len );
    bool ( *keep_all_pulses )( void );

    bool ( *set_phase_reference )( int phase, int function );

    bool ( *set_phase_switch_delay )( int function, double del_time );
    bool ( *set_grace_period )( double gp_time );

    bool ( *phase_setup_prep )( int func, int type, int pod, long val );
    bool ( *phase_setup )( int func );

    bool ( *new_pulse )( long pulse_number );
    bool ( *set_pulse_function )( long pulse_number, int function );
    bool ( *set_pulse_position )( long pulse_number, double ptime );
    bool ( *set_pulse_length )( long pulse_number, double ptime );
    bool ( *set_pulse_position_change )( long pulse_number, double ptime );
    bool ( *set_pulse_length_change )( long pulse_number, double ptime );
    bool ( *set_pulse_phase_cycle )( long pulse_number, long cycle );

    bool ( *get_pulse_function )( long pulse_number, int *function );
    bool ( *get_pulse_position )( long pulse_number, double *ptime );
    bool ( *get_pulse_length )( long pulse_number, double *ptime );
    bool ( *get_pulse_position_change )( long pulse_number, double *ptime );
    bool ( *get_pulse_length_change )( long pulse_number, double *ptime );
    bool ( *get_pulse_phase_cycle )( long pulse_number, long *cycle );

@} pulser_struct;
@end example
@noindent
At the start all the pointers in this structure are set to @code{NULL}
(@acronym{fsc2} has still no idea which functions it actually has to
call), @code{name} is also a @code{NULL} pointer and the boolean
variable @code{needs_phase_pulses} is set to false. Now, when the
@code{init_hook} of the pulser module gets run it has to fill in values
for all the function pointers it supplies functions for - only this will
allow @acronym{fsc2} to figure out where the relevant functions to call
are. When the module does not define a function it must leave the
corresponding entry in the structure unchanged, i.e.@: leave it a
@code{NULL} pointer. Most of the following text will try to explain in
detail what the different functions are supposed to do and the meaning
of the arguments of the functions.

But first the two variables to be set will be discussed. The first
variable, @code{name}, is simply the name of the pulser that will be
used in error messages etc. When setting this variable within the
@code{init_hook} function it should first be checked if it is still a
@code{NULL} pointer. If not the module should print an error message and
quit immediately - when @code{name} is not @code{NULL} a different
pulser module has already been loaded and currently it is not possible
to deal with more than one pulser.

The second variable, @code{needs_phase_pulses} must be set to a true
value only if the experiment the pulser is connected to has phase
switches that need their own pulses and if the module is prepared to
create these phase pulses automatically. Currently, this is only the
case for the Frankfurt S-band spectrometer.


@subsection Pulse functions


Now follows a list of all functions that can be defined within a pulser
module and advertised to @acronym{fsc2} by assigning a pointer to the
function in the pulsers structure. All functions are supposed to return
a boolean value. Please remember that not all functions must exist, if
they don't exist and you don't supply a pointer for some of the
functions in the pulser structure @acronym{fsc2} will tell the user
automatically, that the ability associated with the function is not
available with the driver. You can be sure that all time values that
these function receive are integer multiples of one nanosecond.


Except four of the functions for setting pulse properties, i.e.@:
@code{set_pulse_position()}, @code{set_pulse_length()},
@code{set_pulse_position_change()} and @code{set_pulse_length_change()},
and the functions for asking pulse properties from the module, i.e.@:
all functions with names starting with @code{get_pulse_}, all functions
will only be called before the experiment is started, i.e. in the time
between the calls of the init_hook() and the test_hook() function.


During the test run. i.e.@: between the @code{test_hook()} and the
@code{exp_hook()} function call (while the global variable
@code{TEST_RUN} is set) functions to change pulse positions and lengths
will be called. In this functions the internal representation of the
pulser state has to be updated and the consistency of the state has to
be checked (i.e. do the pulses stay separated, don't they overtake each
other, do the lengths remain larger than zero, do the positions stay
larger than zero and don't exceed the maximum channel length, etc.). The
driver also might choose to store the longest duration of a pulse
sequence during the test run to be used later in the calculation of the
padding needed to set a fixed repeat time for the experiment.


@table @samp

@item bool assign_channel_to_function( int function, long channel )
This function is called when in the @code{ASSIGNMENTS} section in the
description of a pulse function the @code{CHANNEL} (or @code{CH})
keyword is found, i.e.@:
@example
ASSIGNMENTS:
MW: CH = 1, ....
@end example
@noindent
There are two types of pulsers, pulsers (like the @strong{Sony/Tektronix
DG2020} that have some internal channels, that can be freely assigned to
output connector (and for which the variable @code{needs_phase_pulses}
in the pulser structure must be set), and pulsers (like the
@strong{Tektronix HFS9000} that just have output channels. For the first
type of pulsers this function is called to assign a pulse function to
one of the internal channels (and @strong{not} the output connector,
this is what the next function is for, see below), while for the second
type of pulsers th function is for assigning a pulse function to one of
the output connectors.

As discussed in the chapter about pulsers (@pxref{Channel setup}) there
are 15 different types of pulse functions. To avoid having to change
your module in case the numbering of the functions changes you should
only use symbolic names for functions. These symbolic names are defined
in @file{src/global.h}:
@example
enum @{
    PULSER_CHANNEL_MW = 0,
    PULSER_CHANNEL_TWT,
    PULSER_CHANNEL_TWT_GATE,
    PULSER_CHANNEL_DET,
    PULSER_CHANNEL_DET_GATE,
    PULSER_CHANNEL_DEFENSE,
    PULSER_CHANNEL_RF,
    PULSER_CHANNEL_RF_GATE,
    PULSER_CHANNEL_PULSE_SHAPE,
    PULSER_CHANNEL_PHASE_1,
    PULSER_CHANNEL_PHASE_2,
    PULSER_CHANNEL_OTHER_1,
    PULSER_CHANNEL_OTHER_2,
    PULSER_CHANNEL_OTHER_3,
    PULSER_CHANNEL_OTHER_4
@};

#if defined ( FSC2_MAIN )
const char *Function_Names[ ] = @{
    "MW", "TWT", "TWT_GATE","DETECTION", "DETECTION_GATE",
    "DEFENSE", "RF", "RF_GATE", "PULSE_SHAPE", "PHASE_1",
    "PHASE_2", "OTHER_1", "OTHER_2", "OTHER_3", "OTHER_4" @};
#else
extern const char *Function_Names[ ];
#endif
@end example
@noindent
Beside the definition of pulse function numbers there is also an array
with the full names for the functions (to be used in error messages).

The functions @w{@code{PULSER_CHANNEL_PHASE_1}} and
@w{@code{PULSER_CHANNEL_PHASE_2}} are a bit different from the rest because
these functions are reserved for automatically created pulses pulses, so
the user shouldn't be able to create pulses with both these functions.

The second argument obviously is either the number of channel (for
pulsers of the first type) or the output connector (for pulsers of the
second type). Please note that for pulsers of the first type several
channels may be assigned to one function (e.g.@: when automatically
created phase pulses are used, i.e.@: the variable
@code{needs_phase_pulses} is set).


@item bool assign_function( int function, long connector )
For pulsers of the second type, i.e.@: pulsers that have internal
channels and independent output channels this function is used to
associate a pulse function to one of the output functions, i.e.@: if in
the function description the @code{POD} keyword is found:
@example
ASSIGNMENTS:
  MW: POD = 3, ...
@end example
@noindent
Only one function should be assignable to an output connector.


@item bool set_function_high_level( int function, double high_voltage );
This function is called to set the high voltage level to be output for a
certain pulse function, i.e.@: when the @code{V_HIGH} keyword is found
in the function description. Obviously, @code{high_voltage} is the
voltage to be used for the high voltage level in Volts.


@item bool set_function_low_level( int function, double low_voltage );
This function is called to set the low voltage level to be output for a
certain pulse function, i.e.@: when the @code{V_LOW} keyword is found in
the function description. To stay compatible with other pulser modules I
would recommend not to accept low voltage levels that are actually
higher than the high voltage level and to tell the user to use the
function @code{invert_function()} instead.


@item bool invert_function( int function )
This function is called to tell the pulser module that the output for a
certain pulse function has to be reversed polarity, i.e.@: that a high
voltage is to be output for a pulse off state while a high voltage has
to be output while a pulse with this function is switched on. The
function is automatically called for the @code{INV} or @code{INVERT}
keyword in the pulse function description.


@item bool set_function_delay( int function, double delay )
This function is called to tell the pulser to use a delay for one of the
pulse function, i.e.@: when the @code{DELAY} keyword is found in the
description of a function. When possible you should be prepared also
to accept negative delays (which of course requires that the pulser is
triggered internally).


@item bool set_timebase( double timebase )
This function gets called when the @code{TIMEBASE} keyword is found in
the @code{ASSIGNMENTS} section, i.e.@:
@example
ASSIGNMENTS:
  TIMEBASE: 10 ns;
@end example
@noindent
You will have to check that this is an acceptable time base value and
you will also have to check later that all pulse positions, lengths
etc.@: are integer multiples of this time base.


@item bool set_trigger_mode( int mode )
This function gets called when a trigger mode description is found in
the assignments section, i.e.@:
@example
ASSIGNMENTS:
  TRIGGER_MODE: EXTERNAL;
@end example
@noindent
There are two possible values for the trigger mode, either external or
internal. In @file{src/global.h} an enumeration is already defined for
the values of @code{mode} with @code{EXTERNAL} (set to @code{1}) and
@code{INTERNAL} (set to @code{0}). In order to avoid problems if the
values should ever get changed you should use these predefined values.


@item bool set_repeat_time( double rep_time )
The function gets called to set a repetition time or a repetition
frequency to do an pulsed experiment, i.e.@: when either the
@w{@code{REPETITION_TIME}} or @w{@code{REPETITION_FREQUENCY}} keyword is
found in the trigger mode description in the @code{ASSIGNMENTS} section.
Obviously, to be able to set a repetition time or frequency the trigger
mode must be internal and the module has to check that this is the case.


@item bool set_trig_in_level( double voltage )
This function is called when the @code{LEVEL} keyword is found in the
trigger mode description in the @code{ASSIGNMENTS} section to set the
trigger level for external trigger mode. The module should tell the user
that setting a trigger level doesn't make sense in the case that the
user specified internal trigger mode.


@item bool set_trig_in_slope( int slope )
This function is called when the @code{SLOPE} keyword is found in the
trigger mode description in the @code{ASSIGNMENTS} section to set the
trigger slope for external trigger mode.  In @file{src/global.h} an
enumeration is already defined for the values of @code{slope} with
@code{POSITIVE} (for triggering on the trigger input signal crossing the
trigger level coming from a lower voltage and set to @code{1}) and
@code{NEGATIVE} (set to @code{0}). In order to avoid problems if the
values should ever get changed you should use these predefined
values. The module should tell the user that setting a trigger slope
doesn't make sense in the case that the user specified internal trigger
mode.


@item bool set_trig_in_impedance( int state )
This function gets called to set the input impedance of the trigger
input channel when the @code{IMPEDANCE} keyword is found in the trigger
mode description in the @code{ASSIGNMENTS} section. In
@file{src/global.h} an enumeration is already defined for the values of
@code{state} with @code{HIGH} (set to @code{1}) and @code{LOW} (set to
@code{0}). In order to avoid problems if the values should ever get
changed you should use these predefined values -- this could be the case
when a pulser has to be integrated that has more than two different
trigger input impedances. The module should tell the user that setting a
trigger input impedance doesn't make sense in the case that the user
specified internal trigger mode.


@item bool set_max_seq_len( double seq_len )
This function is called when the @code{MAXIMUM_SEQUENCE_LENGTH} is found
in the  @code{ASSIGNMENTS} section, i.e.@:
@example
ASSIGNMENTS:
  MAXIMUM_SEQUENCE_LENGTH: 10 us;
@end example
@noindent
If you determine the maximum length of the pulser pattern in your module
during the test run the value you get can be plain wrong if the
@acronym{EDL} program contains e.g.@: @code{FOREVER} loops,
@code{IF}/@code{ELSE} constructs etc.@: because it is not possible to
determine during the test run which branches of the @acronym{EDL}
program will be run in the real experiment. The
@code{MAXIMUM_SEQUENCE_LENGTH} command should allow the user to correct
the possible wrong value when necessary.

The obvious question is why bother at all to determine the maximum
length of the pulse pattern and not use instead the maximum pattern
length all the time? The reason is that clearing the whole pattern at
the start of the experiment for some pulsers can take a rather long
time. E.g.@: for the @strong{Sony/Tektronix DG2020} for each of the
internal channels that are going to be used more than @w{64 kB} would
have to be send to the pulser while in most experiments only a small
fraction of the maximum pattern length is really needed.


@item bool bool keep_all_pulses( void )
This function is called when the @w{@code{KEEP_ALL_PULSES}} keyword is
found in the @code{ASSIGNMENTS} section. If this function is called your
module may not delete pulses that it found during the test run never to
be used.

The question, of course, is why delete pulses at all that are never used
and not keep them? The reason is that when doing phase cycling it can
happen that for each additional pulse lots of channels in the digitizer
are needed, even to the point that the number of channels gets exceeded.
Therefor, as a default, pulses that are found to be never used during
the test run are removed (after printing out a message to the user).


@item bool set_phase_reference( int phase, int function )
This again a function that gets called under somewhat different
circumstances, depending on how the pulser module is supposed to work.
If you are writing a module that has to create phase pulses
automatically (and thus you have set the variable
@code{needs_phase_pulses} in the pulser structure), this function will
be called when in the definition of a phase function the function, the
phase pulses will be used with, is set. That means if the @acronym{EDL}
program contains a line like
@example
ASSIGNMENTS:
  PHASE_2: MICROWAVE, POD = 2, 3, ....
@end example
@noindent
Obviously, this is meant for a pulser module that automatically creates
phase pulses (otherwise the use of a phase function would not be
allowed) and this statement is intended to tell the module that the
function @code{PHASE_2} (with its pulses appearing on the output
connectors 2 and) is to be used to create phase pulses for the microwave
pulses. To tell the module the function @code{set_phase_reference()}
gets called with the number of the phase function (i.e.@:
@w{@code{PULSER_CHANNEL_PHASE_1}} or @w{@code{PULSER_CHANNEL_PHASE_1}})
as the first argument and the number of the pulse function (in the
example the @code{MICROWAVE} phase function) as the second argument.

In contrast, for modules that don't have to create phase pulses this
function is called from within the @code{ASSIGNMENTS} section when
lines of the form
@example
ASSIGNMENTS:
  PHASE_SETUP_2:  MICROWAVE, ...
@end example
@noindent
In this case @code{MICROWAVE} is again the function that has to be phase
cycled and is passed to the function as the second argument. The first
argument is either @code{0} or @code{1}, depending on if the this for the
first phase cycled function (i.e.@: when the command in @acronym{EDL}
program starts with either @code{PHASE_SETUP} or @code{PASE_SETUP_1}) or
for the second phase cycled function (i.e.@: for @code{PHASE_SETUP_2}).


@item bool set_phase_switch_delay( int function, double del_time )
This function is called when in the @code{ASSIGNMENTS} section a line like
@example
  PHASE_SWITCH_DELAY: 40 ns;
@end example
@noindent
is found. The module must use the value of the second argument
@code{del_time} as the time that pulses of the phase function indicated
by the first argument (which currently can be only either @code{1} or
@code{2}) start before the 'real' pulses of the pulse function the phase
function is associated with. Of course, if the module is not prepared to
create phase pulses at all, this function does not need to exist and the
corresponding entry in the pulsers structure should be left a @code{NULL}
pointer. If no phase switch delay is set for a phase-cycled function it
should (but that's not a necessity but just a recommendation) use a
default value of @w{20 ns}.


@item bool set_grace_period( double gp_time )
This function is called when in the @code{ASSIGNMENTS} section a line like
@example
  GRACE_PERIOD: 20 ns;
@end example
@noindent
is found. The module must use the value of the second argument
@code{gp_time} as the time that pulses of the phase function indicated
by the first argument remain switched on after the 'real' pulses of the
pulse function the phase function is associated with already ended. If
these 'real' pulses get to near to each other to allow having both a
phase switch delay as well as the 'grace period' the later may be
reduced below the value set by the user. If the module is not prepared
to create phase pulses at all, this function does not need to exist and
the corresponding function pointer entry in the pulsers structure should
remain a @code{NULL} pointer.


@item bool phase_setup_prep( int func, int type, int pod, long val )
Again this function is called under slightly different circumstances,
i.e.@: depending on if you have set the variable
@code{needs_phase_pulses} in the pulser structure (meaning that phase
pulses have to be created) or not. In the first case a syntax of
@example
PHASE_1:  MICROWAVE, POD = 2, 3;

PHASE_SETUP_1:  +X: POD_1 = ON, POD2 = OFF,
                +Y: POD1  = ON, POD_2 = 1,
                -X: POD2 = 0, 0,
                -Y: 1, 1;
@end example
@noindent
is expected in the @acronym{EDL} program. The first line indicates that
the phase function 1 is to be used to control phase pulses for microwave
pulses and the output pods to be used are the pods 2 and 3. The
following lines are supposed to tell the module that in order to create
a @code{+X} phase pulse the first output pod set in the definition of
the first phase function (@code{PHASE_1}) (i.e.@: pod 2) must be in the
high state, while the second pod (i.e.@: pod 3) must be low.

For this kind of phase setup the function @code{phase_setup_prep()} will
be called exactly 8 times in a row, 2 times for each phase type (i.e.@:
@code{+X}, @code{+Y}, @code{-X} and @code{-Y}). It will be called always
with the first argument set to @code{0} to indicate that
@code{PHASE_SETUP_1} is currently done (where @code{PHASE_SETUP} without
a number is just a short form for this), in for @code{PHASE_SETUP_2} the
first parameter would be @code{1}.

The second argument is type of phase, in @file{src/global.h} an
enumeration defining @code{PHASE_PLUS_X} for a phase of @code{+X},
@code{PHASE_PLUS_Y} for @code{+Y}, @code{PHASE_MINUS_X} for @code{-X} and
@code{PHASE_MINUS_Y} for @code{-Y} is defined and should be used in your
module. There is also a @code{PHASE_CW} pseudo phase type defined in
case your module has to support a special cw-mode configuration.

The third argument is the output pod to use, where @code{0} stands for
the first pod defined previously for the phase function, i.e.@: in our
example a @code{0} would represent the pod numbered 2. In contrast, an
argument of @code{1} indicates the second output pod, i.e.@: in our
example the pod numbered 3. Finally, you also have to expect an argument
of @code{-1}, meaning "the first of the two pods" if none of both the
pods has been set yet for this phase type or "the other one" if already
one one the two pods has been set.

The fourth and final argument is the state of the output for the put
when the pulse is output. In our example this means that it will be
@code{1} when a @code{1} or @code{ON} is found in the @acronym{EDL}
program and @code{0} for @code{OFF} or @code{0}.

Accordingly, the @acronym{EDL} code for the phase setup given above will
lead to the following sequence of calls of the function
@code{phase_setup_prep()}:
@example
/* PHASE_SETUP_1:  +X: POD_1 = ON, POD2 = OFF, */

phase_setup_prep( 0, PHASE_PLUS_X, 0, 1 );   
phase_setup_prep( 0, PHASE_PLUS_X, 1, 0 );

/* +Y: POD1  = ON, POD_2 = 1, */

phase_setup_prep( 0, PHASE_PLUS_Y, 0, 1 );   
phase_setup_prep( 0, PHASE_PLUS_Y, 1, 1 );

/* -X: POD2 = 0, 0, */

phase_setup_prep( 0, PHASE_MINUS_X, 1, 0 );   
phase_setup_prep( 0, PHASE_MINUS_X, -1, 0 );

/* -Y: 1, 1; */

phase_setup_prep( 0, PHASE_MINUS_Y, -1, 1 );   
phase_setup_prep( 0, PHASE_MINUS_Y, -1, 1 );
@end example

If you are writing a module that does not create phase pulses (and you
accordingly set the variable @code{needs_phase_pulses} in the pulser
structure to false) the phase setup command looks a bit different:
@example
PHASE_SETUP_1:  MICROWAVE,
              +X: POD = 1,
              +Y: POD = 2,
              -X: POD = 4,
              -Y: 5,
              CW: 3;
@end example
@noindent
For these @acronym{EDL} code the function @code{phase_setup_prep()} gets
called five times in a row. Again the first and second parameter the
function will receive is the phase setup number (i.e.@: either @code{0}
or @code{1}, for our example it would be @code{0} because we're dealing
with the first phase setup), and the second is the phase type (i.e.@:
@code{PHASE_PLUS_X}, @code{PHASE_PLUS_Y}, @code{PHASE_MINUS_X},
@code{PHASE_MINUS_Y} and @code{PHASE_CW}). The third parameter has in
this case no meaning at all and its value should be discarded. The
fourth and final is the output pod or channel to be used for a pulse
with the current phase. Thus, the function would be called in the
following sequence (without any other intervening calls except possibly
@code{set_phase_reference()}):
@example
phase_setup_prep( 0, PHASE_PLUS_X, (discard), 1 );   
phase_setup_prep( 0, PHASE_PLUS_Y, (discard), 2 );
phase_setup_prep( 0, PHASE_MINUS_X, (discard), 1 );   
phase_setup_prep( 0, PHASE_MINUS_Y, (discard), 2 );
phase_setup_prep( 0, PHASE_CW, (discard), 1 );   
@end example
@noindent
Here @code{(discard)} stands for an arbitrary value that has to be discarded.


@item bool phase_setup( int func )
This function is called to tell the module that a phase setup sequence
is finished and no further commands of @code{phase_setup_prep()} for the
phase setup with number @code{function} (i.e.@: either @code{0} for the
first phase setup or @code{1} for the second) should happen. The module can
now do some sanity checks on the data it received from the previous
@code{phase_setup_prep()} calls or whatever else it needs to do.


@item bool new_pulse( long pulse_number )
This function is called when a new pulse definition is found in the
@code{PREPARATIONS} section, i.e.@: for lines starting like this
@example
  PULSE_13: ...
@end example
@noindent
For this the function will called (with @code{13} as the
@code{pulse_number} argument) to tell the module that there's a new
pulse to be dealt with. Pulse numbers are always non-negative, so
negative pulse numbers can be used for pulses generated internally by
the module.


@item bool set_pulse_function( long pulse_number, int function )
This function is called when the function of a new pulse is set in the
@code{PREPARATIONS} section, i.e.@: for
@example
  PULSE_13:   FUNCTION = MICROWAVE, ...
@end example
@noindent
The first argument is the pulse number (you can be sure that the
function @code{new_pulse()} will have been called before with this pulse
number as argument) and the pulse function number as the second argument
(see the discussion of pulse function numbers above in the description
of the function @w{@code{assign_channel_to_function()}}). If you don't
have a god reason to do otherwise I would recommend to allow neither
@w{@code{PULSER_CHANNEL_PHASE_1}} nor @w{@code{PULSER_CHANNEL_PHASE_2}}
as pulse functions because these functions are usually reserved for
internally generated phase pulses.


@item bool set_pulse_position( long pulse_number, double ptime )
This is the function that gets called to tell the module about the
start position of a pulse, i.e.@: for lines like
@example
  PULSE_13: START = 100 ns, ...
@end example
@noindent
within the experiment section or when during the experiment the position
of a pulse is changed directly by assigning a new start position i.e.@:
for lines like
@example
  P13.START = 260 ns;
@end example
@noindent
If you need different handling of both situations you can assign a new
function pointer to the corresponding structure entry at the start of
the @code{EXPERIMENT} section, for example in the @code{exp_hook}
function (or at any other time it is convenient).

As in the case of the @code{set_pulse_function()} function the first
argument is the pulse number, the second the start position of the pulse
in seconds (but guaranteed to be an integer multiple of @w{1 ns}, you
still will have to check if it's not negative and also that it isn't an
integer multiple of the pulsers time base).


@item bool set_pulse_length( long pulse_number, double ptime )
The function gets called when the length of a pulse is set in the
@acronym{EDL} file. As usual, the first argument is the pulse number,
the second is the initial length of the pulse in seconds. You will have
to check yourself within the module that the pulse length hasn't an
invalid value. If the length of the pulse is zero you should treat the
pulse as switched off for the time being.


@item bool set_pulse_position_change( long pulse_number, double ptime )
This function is used to tell the module about the start position change
of a pulse (i.e.@: when a pulse definition line containing the
@code{DELTA_START} keyword is found in the @code{PREPARATIONS} section
or a new value is assigned to the @code{DELTA_START} value of a pulse during
the experiment), with the first argument being the pulse number, the
second the start position change for the pulse (which might be
negative).


@item bool set_pulse_length_change( long pulse_number, double ptime )
This function is used to tell the module about the length change of a
pulse (i.e.@: when a pulse definition line containing the
@code{DELTA_LENGTH} keyword is found in the @code{PREPARATIONS} section
or a new value is assigned to the @code{DELTA_LENGTH} value of a pulse
during the experiment), with the first argument being the pulse number,
the second the length change for the pulse.


@item bool set_pulse_phase_cycle( long pulse_number, long cycle )
This function is called to set the phase sequence to be used for phase
cycling the pulse indexed by the first argument, i.e.@: when commands
like
@example
  PULSE_13: PHASE_CYCLE = PHASE_SEQUENCE_1, ...
@end example
@noindent
are found in the @code{EXPERIMENT} section of the @acronym{EDL} file.
The second argument is either the number @code{1} or @code{2},
indicating one of the currently allowed two phase sequences. But to
avoid the necessity of changes of the module it is probably a good idea
to test this value within the function.


@item bool get_pulse_function( long pulse_number, int *function )
This function is called by @acronym{fsc2} to find out about the function
of a pulse from the module. If a pulse with the number passed to the
function exists (otherwise the module should print out an error message
and throw an exception), it should set the variable pointed to by the
second argument to the number of the pulses function and return a true
value. If no function has been set for the pulse an error message should
be printed out and an exception has to be thrown.


@item bool get_pulse_position( long pulse_number, double *ptime )
This function is called by @acronym{fsc2} to find out about the current
position of a pulse from the module. If a pulse with the number passed
to the function exists (otherwise the module should print out an error
message and throw an exception), it should set the variable pointed to
by the second argument to the start position (in seconds) of the
pulse. If no start position has been set for the pulse an error message
should be printed out and an exception has to be thrown.



@item bool get_pulse_length( long pulse_number, double *ptime )
This function in the module is called to determine the current length of
a pulse. If a pulse with the number passed as the first argument exists
the variable the second argument points to has to be set to the length
of the pulse (in seconds).  If no length has been set for the pulse an
error message should be printed out and an exception has to be thrown.

@item bool get_pulse_position_change( long pulse_number, double *ptime )
This function should return the current setting of the position change
setting for the pulse indexed by the argument in the variable pointed to
by the second argument. If no start position change vale has been set
for the pulse an error message should be printed out and an exception
has to be thrown.


@item bool get_pulse_length_change( long pulse_number, double *ptime )
This function should return the current setting of the length change
setting for the pulse indexed by the argument in the variable pointed to
by the second argument. If no length change value has been set for the
pulse an error message should be printed out and an exception has to be
thrown.


@item bool get_pulse_phase_cycle( long pulse_number, long *cycle )
The function should return the the number of the phase sequence (i.e.@:
@code{1} or @code{2}) associated with the pulse associated with pulse
with the number passed to the function as the first argument. If a phase
sequence has been set for the pulse the number has to be written into
the variable pointed to by @code{cycle}, otherwise (or if no pulse with
the number of the first argument exists) an error message has to be
printed out and an exception should be thrown.


@end table
