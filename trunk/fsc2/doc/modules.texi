@c $Id$
@c
@c Copyright (C) 2001 Jens Thoms Toerring
@c
@c This file is part of fsc2.
@c
@c Fsc2 is free software; you can redistribute it and/or modify
@c it under the terms of the GNU General Public License as published by
@c the Free Software Foundation; either version 2, or (at your option)
@c any later version.
@c
@c Fsc2 is distributed in the hope that it will be useful,
@c but WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with fsc2; see the file COPYING.  If not, write to
@c the Free Software Foundation, 59 Temple Place - Suite 330,
@c Boston, MA 02111-1307, USA.


@node Modules, Reserved Words, Interfacing, Top
@chapter Modules
@cindex modules

This chapter tries to describe how to write new modules for use with
@acronym{fsc2}.

@ifinfo
@menu
* Module Overview::       What modules are good for.
* fsc2s Variables::       How to use fsc2's variables.
* New Modules::           How to write new modules.
* Programming Utils::     Functions that help in programming modules
@end menu
@end ifinfo

@node Module Overview, fsc2s Variables, Modules, Modules
@section What modules are good for


Modules allow extending the set of commands to be used in an
@acronym{EDL} file. This is especially important if a new device needs
to be integrated into @acronym{fsc2}. You don't have to change
@acronym{fsc2} itself but write a new module for the new devices without
having to understand completely how the @acronym{fsc2} works. It's only
necessary to be able to write functions in C for the communication with
the new device. The only exception is some basic knowledge about
@acronym{fsc2}'s variables. They are explained in one of the following
sections. But modules may also be used for other purposes beside handling
new devices - one might also write modules that supply new mathematical
functions or other useful functionalities. But the following the
discussion will mainly concentrate on modules for new devices, writing
other modules is even simpler.

Let's start with a short summary of the things a module for a device has
to do.  Usually, a module contains just a few functions that talk to the
device via an hardware interface, e.g.@: the GPIB bus or a serial port
(or whatever else there might be). As an example for the following a
lock-in amplifier will be used. Probably the most basic operation is to
get data from the amplifier. So one will have to create a function
called for example @code{lockin_get_data()}. This name will be used in
the module written in C as well as in the @acronym{EDL} file.

Before starting to write a new module you have to decide about the name
for the device, which will also be the name of the module. If the lock-in
amplifier is a @i{Stanford Research 510} model a useful name might be SR510.

A new device has to be included into the device name data base called
@file{Devices}
@cindex @code{Devices} file
, which is a simple ASCII file consisting of the names of all the
supported devices. It can be found in the @file{config} subdirectory of
the source tree and usually gets installed in
@file{/usr/local/lib/fsc2}. The entries in this file are
case-insensitive, so you might add `SR510', `sr510' or `Sr510'
etc. Within the file C and C++ style comments can be used.  By adding
the device name to this file you tell @acronym{fsc2} that there is now a
module called `sr510' (take care - all modules are spelled with
@strong{lower} case characters!). Actually, the file compiled from the C
file defining the functions has to be @file{sr510.so} - that means it's
a shareable library, how to create it from the C file is described
later. Here is a short snippet from the @file{Devices} file with the
entries for the lock-in amplifiers:
@example
sr510         // Stanford Research lock-in amplifier, model 510
sr530         // Stanford Research lock-in amplifier, model 530
sr810         // Stanford Research lock-in amplifier, model 810
sr830         // Stanford Research lock-in amplifier, model 830
@end example

The next thing is to append the function(s) exported (in the sense that
they can be used from @acronym{EDL} programs) by the module to the
function data base file called @file{Functions}
@cindex @code{Functions} file
. Also this file is located in the @file{config} subdirectory of the
source tree and will usually be installed in
@file{/usr/local/lib/fsc2}. Here one would add lines with the names of
the exported function, i.e.@: @code{lockin_get_data}, followed by the
number of arguments the function takes (or a negative number if the
function takes a variable number of arguments). Optionally, you can add
the keywords @code{ALL},
@cindex @code{ALL} (in @code{Functions} file)
@code{EXP}
@cindex @code{EXP} (in @code{Functions} file)
or @code{PREP},
@cindex @code{PREP} (in @code{Functions} file)
where @code{ALL} means that the function can be used in all parts of the
@acronym{EDL} file, while @code{EXP} tells @acronym{fsc2} to use this
functions only during an experiment and, finally, @code{PREP} restricts
the use of the function to the @code{PREPARATION} section of the
@acronym{EDL} file.  Each line has to end with a semicolon and the
entries in the line must be separated by commas.  As in the device data
base, C and C++ style comments can be used. Here are a few lines from
a valid @file{Functions} file with the entries for lock-in amplifier
functions:
@example
/* Functions exported by the lock-in amplifier modules
   (SR510, SR530, SR810, SR830) */

lockin_name,           0, ALL;  // return the device name
lockin_get_data,      -1, EXP;  // return the lock-in voltage 
lockin_get_adc_data,   1, EXP;  // return a ADC voltage
lockin_dac_voltage,   -1, ALL;  // get/set DAC voltage
lockin_sensitivity,   -1, ALL;  // get/set the sensitivity
lockin_time_constant, -1, ALL;  // get/set the time constant
lockin_phase,         -1, ALL;  // get/set the phase
lockin_ref_freq,      -1, ALL;  // Get/set mod frequency (SR8x0 only)
lockin_ref_mode,       0, EXP;  // Get mod. mode (SR8x0 only)
lockin_ref_level,     -1, EXP;  // Get/set mod. level (SR8x0 only)
lockin_lock_keyboard, -1, EXP;  // Lock/unlock the keyboard
@end example


Writing the C file(s) with these functions, compiling it to create a
shareable library file from it and extending the device and function
data base is all there is to be done. If in the devices sections of the
@acronym{EDL} file the new device is found (and it's also listed in the
devices data base file @file{Devices}) the new module will be loaded by
@acronym{fsc2} and the functions defined in the module can be used in
the @acronym{EDL} file.



@node fsc2s Variables, New Modules, Module Overview, Modules
@section How @acronym{fsc2}'s variables work and how to use them


Of course, the first question is: Why do I have to know about this at
all?  The answer is that all functions to be used in an @acronym{EDL}
file get their input parameters in form of this kind of variables and
@acronym{fsc2} expects that you return values also in the form of
@acronym{fsc2}'s variables.

Now let's have a look at the way @acronym{fsc2} internally stores
variables. Here is the (actually somewhat simplified) @code{typedef} of the
structure for variables:

@example
typedef struct Var_
@{
    int  type;               /* type of the variable */
    union
    @{
        long    lval;        /* value of integer values */
        double  dval;        /* value of float values */
        long   *lpnt;        /* pointer to integer arrays */
        double *dpnt;        /* pointer to floating point arrays */
    @} val;
    long len;                /* length of array */
    struct Var_ *next;       /* next variable on stack */
@} Var;
@end example
@noindent
There are only four types of variables you have to know about:

@multitable {FLOAT_ARR} {a one-dimensional array of floating point values}
@item @code{INT_VAR} @tab a variable for integer values
@item @code{FLOAT_VAR} @tab a variable for floating point values
@item @code{INT_ARR} @tab a one-dimensional array of integer values
@item @code{FLOAT_ARR} @tab a one-dimensional array of floating
point values
@end multitable

To give you a better idea what these variables are good for let's assume
that you want to write a function that returns the curve between the two
cursor bars of your shiny new LeCronix digitizer. So, you may want to
write a function that has the two positions of the cursor bars as input
parameters and returns the data of the curve between the cursor
bars. Let's call this function
@example
get_curve_between_cursors( cursor_1, cursor_2 )
@end example
@noindent
This hypothetical function expects two values, the positions of two
cursors, and is expected to return the data between these two cursors it
fetched from the digitizer. Now, a typical C declaration for this
function is

@example
Var *get_curve_between_cursors( Var *var );
@end example
@noindent
Surprisingly, there seems to be only one input variable! And how to return an
array of data?

Actually, it's not too complicated. The pointer to the variable
structure @code{var} points to the first of the two parameters. And if
you look back at the typedef for @acronym{fsc2}'s variables, there is a
@code{next} pointer. This is the key to access the next parameter --
@code{var->next} points to next of the input parameters. If the function
expects even more arguments, @code{var->next->next} etc. let's you get
them, i.e.@: the input variables are organized as a linked list:
@example
  var                               pointer passed to function
   |                                  |
   V                                  |
  ---------------                     V
 |        | next |                  first input parameter
  ---------------                         |
              |                           |
              V                           |
             ---------------              V
            |        | next |       second input paramter
             ---------------                  |
                         |                    |
                         V                    V
                        NULL        no more parameters...
@end example
@noindent
If you declared your function to expect two input parameters the
function will always get exactly two. The @code{next}-pointer of the
very last parameter will always be @code{NULL}. If the function gets
called in the @acronym{EDL} file with more variables than you declared
it to have a warning will be printed automatically and the superfluous
variables are discarded and not passed to the function. If, on the other
hand, there are not enough parameters the program will just print an
error message and then stop (and not call your function). Having the
parameters organized as a linked list also makes it easy to handle
variable numbers of variables: as long as the @code{next}-pointer of a
functions argument isn't @code{NULL} there is at least another one.

One word of warning: @strong{Never ever try to change the variables you
get passed to your functions in any way!}

What @acronym{fsc2} won't do is check if the arguments it passes to your
function have the type you expect. Let's assume that you expect two
integer values. What you should do first is to check if the parameters
you got are really integers. There is a function that can do this for you,
@code{vars_check()}.
@findex vars_check()
All you have to do is to call @code{vars_check()}
with the pointer to the variable and the type you expect it to have,
e.g.@:
@example
vars_check( var, INT_VAR );
vars_check( var->next, FLOAT_VAR );
@end example
@noindent
If @code{vars_check()} finds that everything is ok it simply returns,
otherwise an error message will be printed and the the program stops, so
you don't have to take care of error handling. If you're prepared to accept
integers as well as floating point data, call @code{vars_check()} instead
with
@example
vars_check( var, INT_VAR | FLOAT_VAR );
@end example
@noindent
As you probably already guessed from this the different types of
variables are coded into the bits of the the integer @code{type} in the
variable's structure, so you have to use the bitwise inclusive OR
operator @code{|} to test alternatives.


@code{vars_check()} not only checks that the variables has the correct
type but will also do some internal consistency checks to make sure
that the variable actually exists and has been assigned a value etc.


A function that expects just integer arguments would probably start
like te following example, just running through the linked list of
parameters:
@example
Var *my_function( Var *var )
@{
    Var *current;

    for ( current = var; current != NULL; current = current->next )
        vars_check( current, INT_VAR );

    ....
@}
@end example


The next question is how to access the value of the variable. As you can
seein the typedef for variables above the value is stored in the union
@code{val}.  If the variable has integer type, you can access it as

@quotation
    @code{var->INT}@ @ @ @ (which is a macro standing for @code{var->val.lval})
@end quotation
@noindent
and what you get is a value of type @code{long int} --- @acronym{fsc2}
is using long integers internally. On the other hand, if the type of the
variable is @code{FLOAT_VAR} you get at the data with
@quotation
    @code{var->FLOAT}@ @ @ @ (i.e.@: a macro for @code{var->val.dval})
@end quotation
@noindent
in which case you get a value of type @code{double}. Of course, you may
also access the contents of the union directly.


@subsection Returning data from an @acronym{EDL} function

If your function just wants to return an integer or a float, things are
very easy: just call the function @code{vars_push()} with the type of
the return value as the first and the value itself as the second
argument, e.g.@:
@example
return vars_push( INT_VAR, i_value );
@end example
@noindent
or
@example
return vars_push( FLOAT_VAR, f_value );
@end example
@noindent
where @code{i_value} is a @code{long int} and @code{f_value} is supposed
to be a @code{double} value. Of course, you don't have to use
@code{vars_push()} in return statements only, it simply returns a
pointer to the new variable holding the value.

For arrays @code{vars_push()} the first argument is either
@code{INT_ARRAY} or @code{FLOAT_ARRAY}, The second argument is a pointer
to the array (i.e.@: its first argument). For creation of an array
variable alsoa third argument is needed, the length of the array (a
@code{long} integer). If you want to return an array with two integer
arguments you would use for example
@example
data[ 0 ] = 1;
data[ 1 ] = 2;
return vars_push( INT_ARRAY, data, 2 );
@end example
@noindent
assuming that @code{data} is an array of @code{long int}s.

As a complete example here is a rather simple but working function named
@code{square()} that returns the square of the value it got passed:
@example
Var *square( Var *var )
@{
    long int_square;
    double float_square;
    Var *ret_val;

    vars_check( var, INT_VAR | FLOAT_VAR );   /* is it a number ? */ 

    if ( var->type == INT_VAR )
    @{
        int_square = var->INT * var->INT;
        ret_val = vars_push( INT_VAR, int_square );
    @}
    else
    @{
        float_square = var->FLOAT * var->FLOAT;
        ret_val = vars_push( FLOAT_VAR, float_square );
    @}

    return ret_val;
@}
@end example
@noindent
As you see, first it is checked that the variable passed to the function
has the correct type - both integer and floating point values are ok.
Next we distinguish between the possibilities that the value is
either an integer or a floating point number by testing the @code{type}
field of the variable. Then we create either a new integer variable by
calling @code{vars_push()} with the square of the integer value or a new
floating point variable. Finally, we return the variable pointer
@code{vars_push()} had delivered.

Of course, we could also have written the function in a more compact way:
@example
Var *square( Var *var )
@{
    vars_check( var, INT_VAR | FLOAT_VAR );

    if ( var->type == INT_VAR )
        return vars_push( INT_VAR, var->INT * var->INT );
    else
        return vars_push( FLOAT_VAR, var->FLOAT * var->FLOAT );
@}
@end example


If your function does not has to return a value at all there are two ways to
handle this situation. Either return a pointer to a variable with an arbitrary
value. e.g.@: write
@example
return vars_push( INT_VAR, 0 );
@end example
@noindent
or simply return a @code{NULL} pointer, i.e.@:
@example
return NULL;
@end example


What if you want to write to function that returns more than one value?
Again we use a function for a digitizer that has to return a curve as
an array as an example. Let's assume the data you got from the digitizer
are stored in an array of integers called @code{data} which has
@code{len} elements (where @code{len} is a @code{long}). Now all you've
got to do is call the function @code{vars_push()} as
@example
Var *ret_var;

...
ret = vars_push( INT_ARR, data, len );
...
return ret_var;
@end example
@noindent
Actually, at some point of your function you may have allocated memory
for storing the data. It is your responsibility to free this memory
before you return from your function, @acronym{fsc2} just uses a copy of
the data you pass to it using @code{vars_push()}. As you probably already
guessed, if you want to return a float array, you will have to use
@code{FLOAT_ARR} instead of @code{INT_ARR} in the call to
@code{vars_push()}.

The same method may be used if your function has to return two different
values and both have the same type. Again an array can be returned
@example
VARIABLES:

V1; V2;         // results of call to my_function()
Dummy[ * ];     // variable sized array for values returned by my_function()

...             // lots of stuff left out

Dummy[ ] = my_function( );   // automagically sets dimension 
                             // of Dummy to 2
V1 = Dummy[ 1 ];
V2 = Dummy[ 2 ];
@end example
@noindent
and the C code for function @code{my_function()} would look like
@example
Var *my_function( Var *var )
@{
    long v[ 2 ];

    v[ 0 ] = ...;    /* just fill in all the stuff you */
    v[ 1 ] = ...;    /* need to calculate both data    */

    return vars_push( INT_ARR, v, 2 );
@}
@end example


An alternative (e.g.@: if the type of the variables you need to return
differs) is two write two functions where the first one does the
calculations needed and stores the second value in a global
variable. All the second function has to do is just to return the value
of the global variable. This way, the @acronym{EDL} file might look like
@example
V1 = my_function_1( );
v2 = my_function_2( );
@end example
@noindent
while the C code would define both functions as

@example
static double v2;   /* global variable used by my_function_1() 
                       and my_function_2() */
Var *my_function_1( Var *v )
@{
    long V1;

    V1 = ...;       /* just fill in all the stuff you */
    v2 = ...;       /* need to calculate both data    */

    return vars_push( INT_VAR, V1 );
@}

Var *my_function_2( Var *v )
@{
    return vars_push( FLOAT_VAR, v2 );
@}
@end example


Alternatively, you also could write the function in a way that it counts the
number of times it has been called and returns values accordingly, e.g.@: 
@example
V1 = my_function( );
v2 = my_function( );
@end example
@noindent
with the corresponding C code
@example
Var *my_function( Var *v )
@{
    long V1;
    static double v2;
    static int call_count = 0;


    if ( call_count > 0 )    /* on second call return second value */
    @{
        call_count = 0;      /* don't forget to reset the call counter! */
        return vars_push( FLOAT_VAR, v2 );
    @}
        
    V1 = ...                 /* just fill in all the stuff you */
    v2 = ...                 /* need to calculate both data    */

    return vars_push( INT_VAR, V1 );
@}
@end example
@noindent
Of course, in both cases one has to be careful to call the function(s) in the
correct sequence, so it's not completely foolproof.



@node New Modules, Programming Utils, fsc2s Variables, Modules
@section How to write a new module

@subsection Files to be included

First of all, each module has to include the header file @file{fsc2.h}
--- otherwise it will not be able to use @acronym{fsc2}'s variables.

Second, all modules that use the GPIB bus should include
@file{gpib_if.h}, this contains all the definitions and declarations of
macros, variables and functions for GPIB functions. Actually, it will in
turn include further header files and knows (hopefully) which are the
correct ones -- @acronym{fsc2} is supposed to work with different
implementations of the GPIB functionality and by including
@code{gpib_if.h} you don't have to care about which on is going to be
used.

Third, each module should but its basic configuration information into a
special file which should be well enough commented to allow even people
without much programming experience to adapt the behaviour of the module
to his/her needs. A good example are modules for devices that are
accessed via the serial port. Because you probably won't know which
serial port the user is going to use you shouldn't hide this information
somewhere deep down in the innards of your module but put it in a
prominent place where it's easy to find. Thus this is one of the items
that should go into the configuration file.

All configuration files are in the @file{config} directory. For obvious
reasons the names of the configuration files should make it clear for
which module they are supposed to be. Currently, all of them have the
extension @code{.conf}. Each configuration file should contain at least
to items. First a string with the device name should be defined, e.g.
@example
#define DEVICE_NAME     "TDS754A"
@end example
@noindent
This device name should be used in all places where the module has to
print out error messages or warnings. For devices connected via the GPIB
bus this device name should be identical to the one it is advertised as
in the GPIB configuration file (usually @file{/etc/gpib.conf}).

It is probably a good idea to select a name for a device that is
identical to the name of the module in order to avoid confusion for the
users.

For each module also a second string needs to be defined which describes
the device type, e.g.
@example
#define DEVICE_TYPE     "digitizer"
@end example
@noindent
The device type string is used by @acronym{fsc2} to figure out if more
than one device with the same functionality is being used by an
@acronym{EDL} program. You probably already have read that when you have
two such devices you can access the second device by appending a
'@code{#2}' when calling an @acronym{EDL}-function. But, obviously, for
this to work @acronym{fsc2} must know which devices have similar
capabilities and which don't. This it finds out from the device type
string. Thus if you decide which device type string you're going to use
please first check the device types of other devices as defined in their
configuration files.  If your device is similar enough to one of the
exiting devices pick the same device type string, otherwise pick a
new and descriptive name. Please also see the next section.


@subsection Variables a module should define

In the previous section the meaning of the device type string has
already been discussed. While the definition of the string should go
into the configuration file for the device, no memory has been allocated
for this string yet. This should be done as one of the first things after
the include files having been included. Each and every device module
should define a constant character array called @code{generic_type},
that contaings the device type string, i.e. one of the first lines
should always be
@example
const char generic_type[ ] = DEVICE_TYPE;
@end example
@acronym{fsc2} will try to find a variable with this name in the module
to find out about the type of the device. If this variable does not
exist it won't have any information about the device type and having
another device of the same type recognized automatically will not work.


@subsection Global variables

There are a few important global variables for modules. The first on is
a flag, called @code{TEST_RUN}. If it is set, the function in the module
is called during a test run, thus can devices  be used yet. Only
if @code{TEST_RUN} is unset the hardware interfaces to the devices are
initialized and devices may be used. During a test run, the module
should try to return reasonable dummy data.  That means that the module
functions should at least return data of the same type as it will do in
the actual experiment. E.g., if a function will return an array during
the experiment it should do the same during the a test run, even though
the data in the array probably are going to be completely bogus.

Another important global variable, @code{need_GPIB}, has to be set by the
init hook function if the hardware interface for the device controlled
by the module is the GPIB bus. Thus, if the GPIB bus is needed, include
a line in the init hook function similar to
@example
need_GPIB = SET;
@end example
Don't try to assign anything else to this variable.


@subsection Requesting hardware

If a device is controlled via the GPIB bus it has to set the global
variable @code{need_GPIB}, as already explained in the previous section.
Of course, the device needs also a valid entry in the GPIB configuration
file but this is nothing @acronym{fsc2} can handle.

For serial ports things are handled a bit differently. In the init hook
function you must try to request the serial port you need by calling
the function @code{fsc2_request_serial_port()}
@example
fsc2_request_serial_port( SERIAL_PORT, DEVICE_NAME );
@end example
@noindent
with the number of the serial port (0 stands for the device file
@file{/dev/ttyS0}, which is what is called @code{COM1} in DOS-speak, 1
for @file{/dev/ttyS1} or for @code{COM2} etc.@.) as the first and the
device name as the second argument. If the requested serial port has
already been claimed by a different device the function will print an
error message and stop the @acronym{EDL} program, so you don't have to
deal with error handling.

All further dealings with the serial port are your own responsibility,
i.e.@: you have to open the device file, set the communication
parameters, write and read data and, when done with the serial port,
reset the communication parameters back to reasonable values and close
the device file.


@subsection Hook functions
@cindex hook functions
@findex init_hook()
@findex test_hook()
@findex end_of_test_hook
@findex exp_hook()
@findex end_of_exp_hook
@findex exit_hook()


As you will already know the interpretation of an @acronym{EDL} file
consists of several steps. When the file is tested and a @code{DEVICES}
section is found all modules for the devices listed here are loaded.
When in the test the @code{EXPERIMENT} section is found the test run is
started in which the program is tested as far as possible. When the test
was successful, the experiment may be run repeatedly. To allow
intialization of the modules internal parameters, initialization of the
devices etc. for each of these stages hook functions can be defined in
the modules that will be executed automatically at appropriate times (if
they exist).

Thus, each module may contain up to six pre-defined hook functions that
don't have to be declared in the function data base file,
@file{Functions}. They all start with the name of the module followed by
@code{_init_hook}, @code{_test_hook}, @code{_end_of_test_hook},
@code{_exp_hook}, @code{_end_of_exp_hook} and @code{_exit_hook}. Thus,
if the new device is named `SR510' (as the lock-in amplifier mentioned
at the start) and thus the module is `sr510' these functions are
(together with the parameters):
@example
int sr510_init_hook( void )
int sr510_test_hook( void )
int sr510_end_of_test_hook( void )
int sr510_exp_hook( void )
int sr510_end_of_exp_hook( void )
void sr510_exit_hook( void )
@end example
@noindent

If it exists, the first function, i.e.@: @code{sr510_init_hook()} is
called immediately after the functions defined in all modules are
loaded. That means, the internal loader loads the module libraries and
when done runs the init hook functions of the modules in the order the
modules did appear in the devices section. The main purpose of the init
hook functions is to allow the modules to get all kinds of initialization
done. Since all other modules are already loaded, they also may be used to
test for the existence of other modules by calling a function called
@code{exist_device()}. But you should not call functions from other
modules at this stage, because the other modules may still be
uninitialized. If the initialization completes successfully, the
function must return a non-zero value. If there are problems that don't
make the module unusable it may return a zero value --- in this case a
warning message will be printed. If the initialization fails in a
non-recoverable way, the function should throw an exception.

The second function, @code{sr510_test_hook()}, is called at the start
of the test run of the @code{EXPERIMENT} section of the @acronym{EDL}
input file. Again, it can be used for initializations. But it should be
noted that changes to the variables defined in the @acronym{EDL} file
will remain only visible for the test run, after the test is completed
they will revert to their former values, i.e.@: the ones they had before
the test run started! The return code of the function is the same as for
the init hook function (i.e.@: always return a non-zero value on success).

The third function, @code{sr510_end_of_test_hook()} is called when the
test hook functions of the modules have been run. This hook function
might be used to reset internal variables of the module that got changed
during the test run. The return code of the function is the same as for
the init hook and test hook function (i.e.@: always return a non-zero
value on success).

The fourth function, @code{sr510_exp_hook()}, is run when the actual
experiment is started. Initialization of devices should be done
here. Return codes are again identical to the ones of the former
functions.

The fifth function, @code{sr510_end_of_exp_hook()} is run after the
experiment has been stopped. This hook function should be used to get
the device back into a usable state with local control.

Finally, the sixth and final function, @code{sr510_exit_hook()}, is run
just before the module is unloaded.

Please note that the first three functions, i.e.@:
@code{sr510__init_hook}, @code{sr510_test_hook} and
@code{sr510_end_of_test_hook} as well as the last function,
@code{sr510_exit_hook()}, will be run only once, while both the
remaining functions, @code{sr510_exp_hook()} and
@code{sr510_end_of_exp_hook()} will be run each time the experiment is
started.


@subsection Caveats for the test run

There is one rather nasty problem with the test run. In the test run the
program is checked extensively and as far as possible everything is done
as it will be done later in the real experiment. But this leads the
problem that the functions in the module must return data even though
they can't talk to the devices yet. If the program asks for the measured
value from a device reasonable, valid value most be returned.  This can
be quite tricky, because, while writing the module it is less than clear
what will be reasonable, valid value in all imaginable situations.

I didn't found a fail safe method to select values to return during the
test run and I also fear that there isn't one. But after some
experimenting the values now used in the modules didn't lead to too many
problems. If necessary the users must be made aware of possible problems,
i.e. if they test the return values from the @acronym{EDL} file they
must be prepared to accept unexpected values.


@subsection How to call an @acronym{EDL} function from a module

Calling an @acronym{EDL} function (built-in as well as @acronym{EDL}
functions defined in other modules) consists of three steps:

@enumerate
@item
Call @code{function_get()} with the name of the function you want to
call as the argument --- this will return a variable pointer to the
function which you have to store. If the returned pointer is @code{NULL}
the function does not exist or isn't loaded.

@item
Now call @code{vars_push()} for each of the arguments of the function -
see the description of @code{vars_push()} in the section about
@acronym{fsc2}'s built in variable types.

@item
Finally, call @code{func_call()} with the pointer returned by the call
to @code{func_get()}
@findex func_get()
as the argument. This will return a pointer to the
variable with the result.
@end enumerate

As an example let's assume there is an @acronym{EDL} function named
@code{foo()} you want to call from your module, that takes two
arguments, an integer and a floating point value. Then a typical piece
of C code to call the function would be

@example
Var *func_ptr;
Var *ret_value;
int access;

func_ptr = func_get( "foo", &access ); /* get pointer to function */
if ( func_ptr == NULL )                /* test if function exists */
@{
    /* do your error handling here */ 
@}
else                                  
@{                                    
    vars_push( INT_VAR, 5 );           /* push first argument */
    vars_push( FLOAT_VAR, 3.1415 );    /* push second argument */
    ret_value = func_call( func_ptr ); /* call the function */
@}
@end example


There are two points that need attention:
@enumerate
@item
After the call to @code{func_call()} the variable with the pointer to
the function returned by @code{func_get()}
@findex func_get()
, @code{func_ptr}, will
disappear automatically. Thus, when you need to call the function again
you will have to go through the complete procedure, since the value
stored in @code{func_ptr} after the call to @code{func_call()} is
completely useless and even dangerous to use for any purpose whatsoever!
@item
If you just want to test if an @acronym{EDL} function exists at all just do
only step 1 but after checking the pointer @strong{never} forget to call
@code{vars_pop()} on the returned variable! I.e.@: do
@example
Var *func_ptr;
int access;

func_ptr = func_get( "foo", &access );    /* get pointer to function */
if ( func == NULL )                       /* test if function exists */
    /* do your error handling here */ 
else                                  
@{                                    
    vars_pop( func_ptr );                 /* never ever forget this ! */
    /* code depending on the existence of `foo()' goes here */
@}
@end example
@noindent
Don't assume that the value of @code{func_prtr} you got from
@code{func_get()}
@findex func_get()
will have any meaning later on. Not only will the value be invalid but,
even worse, there is an high probability that hard to trace bugs will
result if you try to use it.
@end enumerate

Actually, if you look closely at the code you will see that you have to
call @code{vars_pop()} on the returned value only if it wasn't the
@code{NULL} pointer (i.e.@: if the function was not found) --- but nothing
bad is going to happen if you call @code{vars_pop()}on the @code{NULL}
pointer, anyway.



@node Programming Utils, , New Modules, Modules
@section Additional utilities provided by fsc2

When writing a module some of the following information might be useful.
The first topic, execeptions, is a well-known concept implemented for
example in @code{C++}. Unfortunately, @code{C} does not have this kind
of mechanism, but when being a bit careful one can implement something
very similar also in @code{C} using a few macros. 

When writing the program I had to deal a lot with memory leaks,
segmentation faults etc.@: and hacked together a few routines for
allocation and deallocation of memory, that have some build in code that
helps me with debugging (and throws an exception when an allocation
fails). You might find it useful also to use these routines for your
modules.

Finally, a boolean type is something that was missing until the new C99
standard (which only a few compilersd already support, if any at all),
so there's already a @code{typedef} for this type included in
@acronym{fsc2} that you can use. It's also documented here in order to
avoid confusion should you accidentally redefine it.



@subsection Exceptions
@cindex exceptions

One of the most annoying things in programming is error handling. In
order to make a program failsafe in every place where there is even the
remotest chance that something may go wrong one has to include error
handling code.  This is especially tedious within deeply nested function
calls where it is often not clear on which level the error handling is
done best.

In order to alleviate ths problem in @acronym{fsc2} there is a mechanism
called exceptions. An exception can be seens as a kind of flag that can
be raised at any instance in the program and leads to the flow of
control being changed to a place were the error can be handled.

As far as raising exceptions in a module is concerned it's very
simple. If you run into an error that can't be handled by the module
just use something like
@example
if ( non_recoverable_error )
    THROW( EXCEPTION );
@end example
@findex THROW()
@findex EXCEPTION
@noindent
and @acronym{fsc2} will take care of all error handling. That's all you need to
know about exceptions for nearly all cases that have to be handled within
modules.


@subsubsection Programing with exceptions

Of course, to allow the `throwing' of exceptions there must be a place that
will `catch' the exception, otherwise the exception will simply kill the
program. Lets assume that you have a function @code{foo()}, that in turn
calls a lot of other functions, each of which might lead to non-recoverable
errors and that can't be handled by the functions themselves. The way to
handle this problem with exceptions is demonstrated by the following example:
@example
TRY
@{
    foo( );
    TRY_SUCCESS;         /* never forget this ! */
@}
CATCH( EXCEPTION )
@{
    ...                  /* the error handling code goes here */
@}
@end example
@findex TRY
@findex TRY_SUCCESS
@findex CATCH()
@noindent
With @code{TRY} the program is told that the following code might throw
an exception. If everything works out well and no exception is thrown
the @code{CATCH()} block is never executed and in which case
@code{TRY_SUCCESS} must be called. But if an error happens and an
exception is thrown the flow of control is changed immediately from the
function the exception is thrown in to the first statements in the
@code{CATCH()} block.

@code{CATCH} can be used to catch a specific exception and you can have
several of them for different types of exceptions. If you want to catch
all types of exceptions in one go you can use @code{OTHERWISE}
@findex OTHERWISE
instead.
Finally, if you need to do some cleaning up but can not really deal
with the error condition you can catch the exception using either
@code{CATCH} or @code{OTHERWISE} and then rethrow the exception by calling
@code{PASSTHROU()}
@findex PASSTHROU()
to pass it on to higher level routines that are supposed to take care of
the problem. Here's some example code
@example
TRY
@{
    do_something_error_prone();
    TRY_SUCCESS;
@}
OTHERWISE
@{
    do_cleanup();       /* e.g. deallocate memory */
    PASSTHROU();
@}
@end example


There is a caveat when using exceptions: The values of non-volatile
automatic variables may differ from the values they were set to after an
exception got thrown. This could become a problem in cases where you do
error handling in a @code{CATCH()} or @code{OTHERWISE} block as in the
above example and rely on the values of such variables. You can avoid
this problem if you declare these variables as @code{volatile}. If you
need to find out more about this problem, have a look at the code in
@file{exceptions.h} and @file{exceptions.c} and read the documentation
for the standard C functions @code{setjmp()}
@findex setjmp()
and
@code{longjmp()}
@findex longjmp()
which are used to implement exceptions.


There are three types of exceptions that may be relevant when writing
a module:
@example
EXCEPTION
OUT_OF_MEMORY_EXCEPTION
USER_BREAK_EXCEPTION
@end example
@noindent
@code{EXCEPTION} stands for all kinds of exceptions not covered by one
of the fowlloing two types. @code{OUT_OF_MEMORY_EXCEPTION} will only be
thrown by @acronym{fsc2}s special functions for memory allocation (see
next section), so don't throw it yourself without a very good reason. A
@code{USER_BREAK_EXCEPTION} should be thrown from within a module when
the module is doing something rather time consuming (e.g. waiting for a
device to become ready or doing some calbration) and the module detects
that the user has pressed the stop button. To find about the this you
can use a macro, @code{DO_STOP} - if it returns @code{TRUE} the user has
pressed the stop button. Here's some code taken from the module for a
digitizer. It waits indefinitely in a loop for the digitizer to become
ready. To allow the user to break from it within the loop @code{DO_STOP}
is tested, and if set, an @code{USER_BREAK_EXCEPTION} is thrown:
@example
do
@{
    if ( DO_STOP )
        THROW( USER_BREAK_EXCEPTION );

    length = 40;
    usleep( 100000 );
    if ( gpib_write( tds754a.device, "BUSY?\n", 6 ) == FAILURE ||
         gpib_read_w( tds754a.device, reply, &length ) == FAILURE )
        THROW( EXCEPTION );
@} while ( reply[ 0 ] == '1' ); 
@end example


The idea and most of the code used for exceptions in @acronym{fsc2} is taken
from an article by Peter Simons in the the iX magazine
(@uref{http://www.heise.de/ix/}), No. 5, 1998, pp. 160-162.


@subsection Functions for memory allocation
@cindex memory allocation
@findex T_malloc()
@findex T_calloc()
@findex T_realloc()
@findex T_free()
@findex T_strdup()

There are special function for @acronym{fsc2} for allocating memory.
These functions does not only allocates memory but also checks that the
allocation really returns as much memory as you asked for (i.e.@: on
failure the program gets stopped and an appropriate error message is
printed). That means that you don't have to care for error handling - if
the functions return everything is ok, otherwise they won't return at
all. The first of these functions is called @code{T_malloc()} (think
about it as @i{tested malloc}). And, of course, there is also a
replacement for @code{realloc()} and @code{calloc()}, called
@code{T_realloc()} and @code{T_calloc()}. Also for duplication of
strings you should use @code{T_strdup()} instead of the normal
@code{strdup()}. And, to make things complete, the replacement for
@code{free()} is called @code{T_free()}. All five functions accept the
same input and return values as their normal counterparts, i.e.@:
@example
void *T_malloc( size_t size )
void *T_calloc( size_t nmemb, size_t size )
void *T_realloc( void *ptr, size_t size )
char *T_strdup( const char *string )
void *T_free( void *ptr )
@end example
@noindent
For @code{T_free()} there's is small deviation from the behaviour of
the normal @code{free()} function. @code{T_free()} returns a @code{void}
pointer, which is always @code{NULL}.

There might be cases where you want a call of one of the functions
allocating memory to return even if it fails. In this case you have
to do the call within a @code{TRY} block and be prepared to catch an
exception that gets thrown when the memory allocation fails. The
exception that will be thrown is an @code{OUT_OF_MEMORY_EXCEPTION}.
Here's some example code:
@example
TRY
@{
    array = T_malloc( length );
    TRY_SUCCESS;
@}
CATCH( OUT_OF_MEMORY_EXCEPTION )
@{
    ...                  /* your error handling code goes here */
@}
@end example


@subsection @code{bool} type

@acronym{fsc2} already has a @code{typedef} for the @code{bool} type,
i.e.@: for variables that can have only two values, either @code{1} or
@code{0}. You can use either the macros @code{SET}, @code{OK} or
@code{TRUE} instead of @code{1} and @code{UNSET}, @code{FAIL} or
@code{FALSE} instead of @code{1}. You can use this type to do things
like this
@example
bool is_flag;

flag = SET;
...
if ( ! flag )
@{
    do_something( );
    flag = UNSET;
@}
...
if ( flag )
    do_something_else( );
@end example
