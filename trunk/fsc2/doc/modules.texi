@c $Id$
@c
@c Copyright (C) 2001 Jens Thoms Toerring
@c
@c This file is part of fsc2.
@c
@c Fsc2 is free software; you can redistribute it and/or modify
@c it under the terms of the GNU General Public License as published by
@c the Free Software Foundation; either version 2, or (at your option)
@c any later version.
@c
@c Fsc2 is distributed in the hope that it will be useful,
@c but WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with fsc2; see the file COPYING.  If not, write to
@c the Free Software Foundation, 59 Temple Place - Suite 330,
@c Boston, MA 02111-1307, USA.


@node Modules, Reserved Words, Interfacing, Top
@chapter Modules
@cindex modules

This chapter tries to describe how to write new modules for use with
@acronym{fsc2}.

@ifinfo
@menu
* Module overview::       What modules are good for.
* fsc2s variables::       How to use fsc2's variables.
* New modules::           How to write new modules.
@end menu
@end ifinfo

@node Module overview, fsc2s variables, Modules, Modules
@section What modules are good for


Modules allow extending the set of commands to be used in an
@acronym{EDL} file. This is especially important if a new device needs
to be integrated into @acronym{fsc2}. You don't have to change
@acronym{fsc2} itself but write a new module for the new devices without
having to understand completely how the @acronym{fsc2} works. It's only
necessary to be able to write functions in C for the communication with
the new device. The only exception is some basic knowledge about
@acronym{fsc2}'s variables. They are explained in one of the following
sections. But modules may also be used for other purposes beside handling
new devices - one might also write modules that supply new mathematical
functions or other useful functionalities. But the following the
discussion will mainly concentrate on modules for new devices, writing
other modules is even simpler.

Let's start with a short summary of the things a module for a device has
to do.  Usually, a module contains just a few functions that talk to the
device via an hardware interface, e.g.@: the GPIB bus or a serial port
(or whatever else there might be). As an example for the following a
lock-in amplifier will be used. Probably the most basic operation is to
get data from the amplifier. So one will have to create a function
called for example @code{lockin_get_data()}. This name will be used in
the module written in C as well as in the @acronym{EDL} file.

Before starting to write a new module you have to decide about the name
for the device, which will also be the name of the module. If the lock-in
amplifier is a @i{Stanford Research 510} model a useful name might be SR510.

A new device has to be included into the device name data base called
@file{Devices}
@cindex @code{Devices} file
, which is a simple ASCII file consisting of the names of all the
supported devices. It can be found in the @file{config} subdirectory of
the source tree and usually gets installed in
@file{/usr/local/lib/fsc2}. The entries in this file are
case-insensitive, so you might add `SR510', `sr510' or `Sr510'
etc. Within the file C and C++ style comments can be used.  By adding
the device name to this file you tell @acronym{fsc2} that there is now a
module called `sr510' (take care - all modules are spelled with
@strong{lower} case characters!). Actually, the file compiled from the C
file defining the functions has to be @file{sr510.so} - that means it's
a shareable library, how to create it from the C file is described
later. Here is a short snippet from the @file{Devices} file with the
entries for the lock-in amplifiers:
@example
sr510         // Stanford Research lock-in amplifier, model 510
sr530         // Stanford Research lock-in amplifier, model 530
sr810         // Stanford Research lock-in amplifier, model 810
sr830         // Stanford Research lock-in amplifier, model 830
@end example

The next thing is to append the function(s) exported (in the sense that
they can be used from @acronym{EDL} programs) by the module to the
function data base file called @file{Functions}
@cindex @code{Functions} file
. Also this file is located in the @file{config} subdirectory of the
source tree and will usually be installed in
@file{/usr/local/lib/fsc2}. Here one would add lines with the names of
the exported function, i.e.@: @code{lockin_get_data}, followed by the
number of arguments the function takes (or a negative number if the
function takes a variable number of arguments). Optionally, you can add
the keywords @code{ALL},
@cindex @code{ALL} (in @code{Functions} file)
@code{EXP}
@cindex @code{EXP} (in @code{Functions} file)
or @code{PREP},
@cindex @code{PREP} (in @code{Functions} file)
where @code{ALL} means that the function can be used in all parts of the
@acronym{EDL} file, while @code{EXP} tells @acronym{fsc2} to use this
functions only during an experiment and, finally, @code{PREP} restricts
the use of the function to the @code{PREPARATION} section of the
@acronym{EDL} file.  Each line has to end with a semicolon and the
entries in the line must be separated by commas.  As in the device data
base, C and C++ style comments can be used. Here are a few lines from
a valid @file{Functions} file with the entries for lock-in amplifier
functions:
@example
/* Functions exported by the lock-in amplifier modules
   (SR510, SR530, SR810, SR830) */

lockin_name,           0, ALL;  // return the device name
lockin_get_data,      -1, EXP;  // return the lock-in voltage 
lockin_get_adc_data,   1, EXP;  // return a ADC voltage
lockin_dac_voltage,   -1, ALL;  // get/set DAC voltage
lockin_sensitivity,   -1, ALL;  // get/set the sensitivity
lockin_time_constant, -1, ALL;  // get/set the time constant
lockin_phase,         -1, ALL;  // get/set the phase
lockin_ref_freq,      -1, EXP;  // Get/set mod frequency (SR8x0 only)
lockin_ref_mode,       0, EXP;  // Get mod. mode (SR8x0 only)
lockin_ref_level,     -1, ALL;  // Get/set mod. level (SR8x0 only)
lockin_lock_keyboard, -1, EXP;  // Lock/unlock the keyboard
@end example


Writing the C file with the functions, compiling it to create a
shareable library file from it and extending the device and function
data base is all there is to be done. If in the devices sections of the
@acronym{EDL} file the new device is found (and it's also listed in
@file{Devices}) the new module will be loaded by @acronym{fsc2} and the
functions defined in the module can be used in the @acronym{EDL} file.



@node fsc2s variables, New modules, Module overview, Modules
@section How @acronym{fsc2}'s variables work and how to use them


Of course, the first question is: Why do I have to know about this at
all?  The answer is that all functions to be used in an @acronym{EDL}
file get their input parameters in form of this kind of variables and
@acronym{fsc2} expects that you return values also in the form of
@acronym{fsc2}'s variables.

Now let's have a look at the way @acronym{fsc2} internally stores
variables. Here is the (actually somewhat simplified) @code{typedef} of the
structure for variables:

@example
typedef struct Var_
@{
    int  type;               /* type of the variable */
    union
    @{
        long    lval;        /* for integer values */
        double  dval;        /* for float values */
        long   *lpnt;        /* for integer arrays */
        double *dpnt;        /* for floating point arrays */
    @} val;
    long len;                /* length of array */
    struct Var_ *next;       /* next variable on stack */
@} Var;
@end example
@noindent
There are only four types of variables you have to know about:

@multitable {FLOAT_TRANS_ARR} {a one-dimensional array of floating point values}
@item @code{INT_VAR} @tab a variable for integer values
@item @code{FLOAT_VAR} @tab a variable for floating point values
@item @code{INT_TRANS_ARR} @tab a one-dimensional array of integer values
@item @code{FLOAT_TRANS_ARR} @tab a one-dimensional array of floating
point values
@end multitable

To give you a better idea what these variables are good for let's assume
that you want to write a function that returns the curve between the two
cursor bars of your shiny new LeCronix digitizer. So, you may want to
write a function that has the two positions of the cursor bars as input
parameters and returns the data of the curve between the cursor
bars. Let's call this function
@example
    get_curve_between_cursors( cursor_1, cursor_2 )
@end example
@noindent
This hypothetical function expects two values, the positions of two
cursors, and is expected to return the data between these two cursors it
fetched from the digitizer. Now, a typical C declaration for this
function is

@example
    Var *get_curve_between_cursors( Var *var );
@end example
@noindent
Surprisingly, there seems to be only one input variable! And how to return an
array of data?

Actually, it's not too complicated. The pointer to the variable
structure @code{var} points to the first of the two parameters. And if
you look back at the typedef for @acronym{fsc2}'s variables,
there is a @code{next} pointer. That is the key to access the next
parameter -- @code{var->next} points to next of the input parameters. If
the function expects even more arguments, @code{var->next->next}
etc. would get you to them - that means the input variables are
organized as a linked list:
@example
    var                               pointer passed to function
     |                                  |
     V                                  |
    ---------------                     V
   |        | next |                  first input parameter
    ---------------                         |
                |                           |
                V                           |
               ---------------              V
              |        | next |       second input paramter
               ---------------                  |
                           |                    |
                           V                    V
                          NULL        no more parameters...
@end example
@noindent
If you declared your function to expect two input parameters the
function will always get exactly two. The @code{next}-pointer of the
very last parameter will always be @code{NULL}. If the function gets
called in the @acronym{EDL} file with more variables than you declared
it to have a warning will be printed automatically and the superfluous
variables are discarded and not passed to the function. If, on the other
hand, there are not enough parameters the program will just print an
error message and then stop (and not call your function). Having the
parameters organized as a linked list also makes it easy to handle
variable numbers of variables: as long as the @code{next}-pointer of a
function argument isn't @code{NULL} there is still another one.

One word of warning: @strong{Never ever try to change the variables you
get passed to your functions in any way!}

What @acronym{fsc2} won't do is check if the arguments it passes to your
function have the type you expect. Let's assume that you expect two
integer values. What you should do first is to check if the parameters
you got are really integers. There is a function that can do this for you,
@code{vars_check()}.
@findex vars_check()
All you have to do is to call @code{vars_check()}
with the pointer to the variable and the type you expect it to have,
e.g.@:
@example
    vars_check( var, INT_VAR );
    vars_check( var->next, FLOAT_VAR );
@end example
@noindent
If @code{vars_check()} finds that everything is ok it simply returns,
otherwise an error message will be printed and the the program stops, so
you don't have to take care of error handling. If you're prepared to accept
integers as well as floating point data, call @code{vars_check()} instead
with
@example
    vars_check( var, INT_VAR | FLOAT_VAR );
@end example
@noindent
(i.e.@: the different types of variables are coded into the bits of the
the integer @code{type} in the variable's structure, so you have to use
the bitwise inclusive OR operator @code{|} to test alternatives).

Thus, a function that expects just integer arguments would probably start
like this, just running through the linked list of parameters:
@example
Var *my_function( Var *var )
@{
    Var *current;

    for ( current = var; current != NULL; current = current->next )
        vars_check( current, INT_VAR );

    ....
@}
@end example


The next question is how to access the value of the variable. As you can
see above in the typedef for variables the value is stored in the union
@code{val}.  If the variable has integer type, you can access it as

@quotation
    @code{var->INT}@ @ @ @ (which is a macro standing for @code{var->val.lval})
@end quotation
@noindent
and what you get is a value of type @code{long int} --- @acronym{fsc2}
is using long integers internally. On the other hand, if the type of the
variable is @code{FLOAT_VAR} you get at the data with
@quotation
    @code{var->FLOAT}@ @ @ @ (i.e.@: a macro for @code{var->val.dval})
@end quotation
@noindent
in which case you get a value of type @code{double}. Of course, you may
also access the contents of the union directly.


@subsection Functions for memory allocation
@cindex memory allocation
@findex T_malloc()
@findex T_calloc()
@findex T_realloc()
@findex T_free()
@findex T_strdup()

By the way, there's a special function made for @acronym{fsc2} for
allocating memory.  This functions does not only allocates memory but
also checks that the allocation really returns as much memory as you
asked for (i.e.@: if it fails it will stop the program and print an
appropriate error message). That means that you don't have to care for
error handling - if the function returns everything is ok, otherwise it
won't return at all. This function is called @code{T_malloc()} (think
about it as @i{tested malloc}). And, of course, there is also a
replacement for @code{realloc()} and @code{calloc()}, called
@code{T_realloc()} and @code{T_calloc()}. Also for duplication of
strings you should use @code{T_strdup()} instead of the normal
@code{strdup()}.And, to make things complete, the replacement for
@code{free()} is called @code{T_free()}. All five functions accept 
the same input and return values as their normal counterparts, i.e.@:
@example
  void *T_malloc( size_t size )
  void *T_calloc( size_t nmemb, size_t size )
  void *T_realloc( void *ptr, size_t size )
  char *T_strdup( const char *string )
  void  T_free( void *ptr )
@end example
@noindent
I would strongly recommend using this functions since they got built in
some code to help detecting memory leaks etc. --- but that's a completely
different topic...


@subsection Returning data from an @acronym{EDL} function

So, let's get back to our main theme and talk about returning values
from your module functions. If your function just wants to return an
integer or a float, things are very easy: just call the function
@code{vars_push()} with the type of the return value as the first and
the value itself as the second argument, e.g.@:
@example
    return vars_push( INT_VAR, i_value );
@end example
@noindent
or
@example
    return vars_push( FLOAT_VAR, f_value );
@end example
@noindent
where @code{i_value} is a @code{long int} and @code{f_value} is
supposed to be a @code{double} value. Of course, you don't have to use
@code{vars_push()} in returns only, it simply returns a pointer to the
new variable holding the value.

For arrays @code{vars_push()} the first argument is either
@code{INT_TRANS_ARRAY} or @code{FLOAT_TRANS_ARRAY}, The second argument
is a pointer to the array (i.e.@: its first argument). For creating an
array variable it also needs a third argument, the length of the array
(as a @code{long} integer). If you want to return an array with two
integer arguments you would use something like
@example
    data[ 0 ] = 1;
    data[ 1 ] = 2;
    return vars_push( INT_TRANS_ARRAY, data, 2 );
@end example
@noindent
assuming that @code{data} is an array of @code{long int}s.

As a further example here the rather simple but complete (and tested)
function @code{square()} that returns the square of the value passed to
it:
@example
Var *square( Var *var )
@{
    long int_square;
    double float_square;
    Var *ret_val;

    vars_check( var, INT_VAR | FLOAT_VAR );   /* is it a number ? */ 

    if ( var->type == INT_VAR )
    @{
        int_square = var->INT * var->INT;
        ret_val = vars_push( INT_VAR, int_square );
    @}
    else
    @{
        float_square = var->FLOAT * var->FLOAT;
        ret_val = vars_push( FLOAT_VAR, float_square );
    @}

    return ret_val;
@}
@end example
@noindent
As you see, we first check that the variable passed to the function has
the correct type - both integer and floating point values are ok
here. Next we distinguish between both the possibilities that the value
is either an integer or a floating point number by testing the
@code{type} field of the variable. Then we create either a new integer
variable by calling @code{vars_push()} with the square of the integer
value or a new floating point variable. Finally, we return the variable
pointer @code{vars_push()} had delivered.

Of course, we could also have written the function in a more compact way:
@example
Var *square( Var *var )
@{
    vars_check( var, INT_VAR | FLOAT_VAR );

    if ( var->type == INT_VAR )
        return vars_push( INT_VAR, var->INT * var->INT );
    else
        return vars_push( FLOAT_VAR, var->FLOAT * var->FLOAT );
@}
@end example


If your function does not has to return a value at all there are two ways to
handle this situation. Either return a pointer to a variable with an arbitrary
value. e.g.@: write
@example
    return vars_push( INT_VAR, 0 );
@end example
@noindent
or simply return a @code{NULL} pointer, i.e.@:
@example
    return NULL;
@end example


Now, what if you want to write to function that returns more than one
value? Again we take a function for a digitizer that has to return a
curve as an array as an example. Let's assume the data you got from the
digitizer are stored in an array of integers called @code{data} which
has @code{len} elements (where @code{len} is a @code{long}). Now all
you've got to do is call the function @code{vars_push()} as
@example
    Var *ret;

    ...

    return vars_push( INT_TRANS_ARR, data, len );
    T_free( data );
    return ret;
@end example
@noindent
Actually, at some point of your function you may have allocated memory
for storing the data. It is your responsibility to free this memory
before you return from your function, @acronym{fsc2} just uses a copy of
the data you pass to it using @code{vars_push()}. As you probably already
guessed, if you want to return a float array, you will have to use
@code{FLOAT_TRANS_ARR} instead of @code{INT_TRANS_ARR} in the call to
@code{vars_push()}.

The same method may be used if your function has to return two different
values and both have the same type. Again an array can be returned
@example
VARIABLES:

V1; V2;         // results of call to my_function()
Dummy[ * ];     // variable sized array for values returned by my_function()

...             // lots of stuff left out

Dummy[ ] = my_function( );   // automagically sets dimension 
                             // of Dummy to 2
V1 = Dummy[ 1 ];
V2 = Dummy[ 2 ];
@end example
@noindent
and the C code for function @code{my_function()} would look like
@example
Var *my_function( Var *var )
@{
    long v[ 2 ];

    v[ 0 ] = ...;    /* just fill in all the stuff you */
    v[ 1 ] = ...;    /* need to calculate both data    */

    return vars_push( INT_TRANS_ARR, v, 2 );
@}
@end example


An alternative (e.g.@: if the type of the variables you need to return
differs) is two write two functions where the first one does the
calculations needed and stores the second value in a global
variable. All the second function has to do is just to return the value
of the global variable. This way, the @acronym{EDL} file might look like
@example
V1 = my_function_1( );
v2 = my_function_2( );
@end example
@noindent
while the C code would define both functions as

@example
static double v2;   /* global variable used by my_function_1() 
                       and my_function_2() */
Var *my_function_1( Var *v )
@{
    long V1;

    V1 = ...;       /* just fill in all the stuff you */
    v2 = ...;       /* need to calculate both data    */

    return vars_push( INT_VAR, V1 );
@}

Var *my_function_2( Var *v )
@{
    return vars_push( FLOAT_VAR, v2 );
@}
@end example


Alternatively, you also could write the function in a way that it counts the
number of times it has been called and returns values accordingly, e.g.@: 
@example
V1 = my_function( );
v2 = my_function( );
@end example
@noindent
with the corresponding C code
@example
Var *my_function( Var *v )
@{
    long V1;
    static double v2;
    static int call_count = 0;


    if ( call_count > 0 )    /* on second call return second value */
    @{
        call_count = 0;      /* don't forget to reset the call counter! */
        return vars_push( FLOAT_VAR, v2 );
    @}
        
    V1 = ...                 /* just fill in all the stuff you */
    v2 = ...                 /* need to calculate both data    */

    return vars_push( INT_VAR, V1 );
@}
@end example
@noindent
Of course, in both cases one has to be careful to call the function(s) in the
correct sequence, so it's not completely foolproof.



@node New modules, , fsc2s variables, Modules
@section How to write a new module

@subsection Files to be included

Each module has to include the header file @file{fsc2.h} --- otherwise it
will not be able to use @acronym{fsc2}'s variables.


@subsection Hook functions
@cindex hook functions
@findex init_hook()
@findex test_hook()
@findex end_of_test_hook
@findex exp_hook()
@findex end_of_exp_hook
@findex exit_hook()

Each module may contain four pre-defined functions that don't have to be
declared in the function data base file, *Functions'. They all start
with the name of the module (always in lower case letters - the only
exception is `User_Functions' to make it stand out), followed by the
words @code{_init_hook}, @code{_test_hook}, @code{_end_of_test_hook},
@code{_exp_hook}, @code{_end_of_exp_hook} and @code{_exit_hook}. Thus,
if the new device is named `ABC123' and thus the module is `abc123'
these functions are (together with the parameters):
@example
    int abc123_init_hook( void )
    int abc123_test_hook( void )
    int abc123_end_of_test_hook( void )
    int abc123_exp_hook( void )
    int abc123_end_of_exp_hook( void )
    void abc123_exit_hook( void )
@end example
@noindent
The loader will test if these functions exist and if they do they will
be called automatically at certain points in the interpretation of the
@acronym{EDL} file.

If it exists, the first function, i.e.@: @code{abc123_init_hook()} is
called immediately after the functions defined in all modules are
loaded. Its main purpose is to allow the module to get all kinds of
initialization done. Since all other modules are already loaded, it also
may be used to test for the existence of other modules by calling a
function called @code{exist_device()}. But you should not call functions
from other modules at this stage, because the other module may still be
uninitialized. If the initialization completes successfully, the
function must return a non-zero value. If there are problems that don't
make the module unusable it may return a zero value --- in this case a
warning message will be printed. If the initialization fails in a
non-recoverable way, the function should throw an exception.

The second function, @code{abc123_test_hook()}, is called at the start
of the test run of the @code{EXPERIMENT} section of the @acronym{EDL}
input file. Again, it can be used for initializations. But it should be
noted that changes to the variables defined in the @acronym{EDL} file
will remain only visible for the test run, after the test is completed
they will revert to their former values, i.e.@: the ones they had before
the test run started! The return code of the function is the same as for
the init hook function (i.e.@: always return a non-zero value on success).

The third function, @code{abc123_exp_hook()}, is run when the actual
experiment is done. Initialization of devices should be done
here. Return codes are again identical to the ones of the former two
functions.

Finally, the fourth function, @code{abc123_exit_hook()}, is run after
the experiment has been completed.  Actually, the function is called
always at the end of the interpretation of the @acronym{EDL} input file,
even if exceptions made the interpreter stop reading in the input
file. That means, that @w{@code{abc123_exit_hook()}} will be executed
even if none of the other hook functions have been run!  The most
important thing to be done in this function is probably resetting the
devices. But since the function is even called even if
@code{abc_init_hook()} has not been executed at all (because another
module further to the top of the list of modules threw an exception) one
probably should use an initialized static global variable indicating if
the device has been initialized at all.


@subsection Global variables

There are a few important global variables for modules. The first on is
a flag, called @code{TEST_RUN}. If it is set, the function in the module
is called during a test run, thus no devices should be really used. Only
if @code{TEST_RUN} is unset the hardware interfaces to the devices are
initialized and devices may be used. During a test run, the module
should try to return reasonable dummy data.  That means that the module
functions should at least return data of the same type as it will do in
the actual experiment. E.g., if a function will return an array during
the experiment it should do the same during the a test run, even though
the data in the array probably will be bogus.

Another important global variable, @code{need_GPIB}, has to be set by the
init hook function if the hardware interface for the device controlled
by the module is the GPIB bus. Thus, if the GPIB bus is needed, include
a line in the init hook function similar to
@example
    need_GPIB = SET;
@end example

For serial ports things handled a bit differently. In the init_hook you
should try to request the serial port you need by calling the function
@code{fsc2_request_serial_port()}
@example
    fsc2_request_serial_port( SERIAL_PORT, DEVICE_NAME );
@end example
@noindent
with the number of the serial port (0 stands for what is called
@code{COM1} in DOS-speak, 1 for @code{COM2} et.@.) as the first and the
device name as the second argument. If the requested serial port has
already been claimed by a different device the function will print an
error message and stop the @acronym{EDL} program, so you don't have to
deal with error handling.


@subsection How to call an @acronym{EDL} function from a module

Calling an @acronym{EDL} function (built-in as well as @acronym{EDL}
functions defined in other modules) consists of three steps:

@enumerate
@item
Call @code{function_get()} with the name of the function you want to
call as the argument --- this will return a variable pointer to the
function which you have to store. If the returned pointer is @code{NULL}
the function does not exist or isn't loaded.

@item
Now call @code{vars_push()} for each of the arguments of the function -
see the description of @code{vars_push()} in the section about
@acronym{fsc2}'s built in variable types.

@item
Finally, call @code{func_call()} with the pointer returned by the call
to @code{func_get()}
@findex func_get()
as the argument. This will return a pointer to the
variable with the result.
@end enumerate

As an example let's assume there is an @acronym{EDL} function named
@code{foo()} you want to call from your module, that takes two
arguments, an integer and a floating point value. Then a typical piece
of C code to call the function would be

@example
Var *func_ptr;
Var *ret_value;
int access;

func_ptr = func_get( "foo", &access ); /* get pointer to function */
if ( func_ptr == NULL )                /* test if function exists */
@{
    /* do your error handling here */ 
@}
else                                  
@{                                    
    vars_push( INT_VAR, 5 );           /* push first argument */
    vars_push( FLOAT_VAR, 3.1415 );    /* push second argument */
    ret_value = func_call( func_ptr ); /* call the function */
@}
@end example


There are two points that need attention:
@enumerate
@item
After the call to @code{func_call()} the variable with the pointer to
the function returned by @code{func_get()}
@findex func_get()
, @code{func_ptr}, will
disappear automatically. Thus, when you need to call the function again
you will have to go through the complete procedure, since the value
stored in @code{func_ptr} after the call to @code{func_call()} is
completely useless and even dangerous to use for any purpose whatsoever!
@item
If you just want to test if an @acronym{EDL} function exists at all just do
only step 1 but after checking the pointer @strong{never} forget to call
@code{vars_pop()} on the returned variable! I.e.@: do
@example
Var *func_ptr;
int access;

func_ptr = func_get( "foo", &access );    /* get pointer to function */
if ( func == NULL )                       /* test if function exists */
    /* do your error handling here */ 
else                                  
@{                                    
    vars_pop( func_ptr );                 /* never ever forget this ! */
    /* code depending on the existence of `foo()' goes here */
@}
@end example
@noindent
Don't assume that the value of @code{func_prtr} you got from
@code{func_get()}
@findex func_get()
will have any meaning later on. Not only will the value be invalid but,
even worse, there is an high probability that hard to trace bugs will
result if you try to use it.
@end enumerate

Actually, if you look closely at the code you will see that you have to
call @code{vars_pop()} on the returned value only if it wasn't the
@code{NULL} pointer (i.e.@: if the function was not found) --- but nothing
bad is going to happen if you call @code{vars_pop()}on the @code{NULL}
pointer, anyway.


@section Exceptions
@cindex exceptions

One of the most annoying things in programming is error handling. In
order to make a program failsafe in every place where there is even the
remotest chance that something may go wrong one has to include error
handling code.  This is especially tedious within deeply nested function
calls where it is often not clear on which level the error handling is
done best.

In order to alleviate ths problem in @acronym{fsc2} there is a mechanism
called exceptions. An exception can be seens as a kind of flag that can
be raised at any instance in the program and leads to the flow of
control being changed to a place were the error can be handled.

As far as raising exceptions in a module is
concerned it's very simple. If you run into an error that can't be handled by
the module just use something like
@example
if ( non_recoverable_error )
    THROW( EXCEPTION );
@end example
@findex THROW()
@findex EXCEPTION
@noindent
and @acronym{fsc2} will ake care of all error handling. That's all you need to
know about exceptions for nearly all cases that have to be handled within
modules.


@subsection Programing with exceptions

Of course, to allow the `throwing' of exceptions there must be a place that
will `catch' the exception, otherwise the exception will simply end the
program. Lets assume that you have a function @code{foo()}, that in turn
calls a lot of other functions, each of which might lead to non-recoverable
errors and that can't be handled by the functions themselves. The way to
handle this problem with exceptions is demonstrated by the following example:
@example
TRY
@{
    foo( );
    TRY_SUCCESS;         /* never forget this ! */
@}
CATCH( EXCEPTION )
@{
    ...                  /* the error handling code goes here */
@}
@end example
@findex TRY
@findex TRY_SUCCESS
@findex CATCH()
@noindent
With @code{TRY} the program is told that the following code might throw
an exception. If everything works out well and no exception is thrown
the @code{CATCH} block is never executed. But if an error happens and an
exception is thrown the flow of control is changed immediately from the
function the exception is thrown in to the statements in the
@code{CATCH} block.

There is a caveat when using exceptions: The value of non-volatile automatic
variables may become undefined after an exception if they were changed in the
@code{TRY} block. If you need to find out more about this problem, have
a look at the code in @file{exceptions.c} and @file{exceptions.h}
and read the documentation for the standard C function @code{setjmp()}
@findex setjmp()
and
@code{longjmp()}
@findex longjmp()
which are used to implement exceptions.


The idea and most of the code used for exceptions in @acronym{fsc2} is taken
from an article by Peter Simons in the the iX magazine
(@uref{http://www.heise.de/ix/}), No. 5, 1998, pp. 160-162.


