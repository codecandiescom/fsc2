@c  $Id$
@c
@c  Copyright (C) 1999-2006 Jens Thoms Toerring
@c
@c  This file is part of fsc2.
@c
@c  Fsc2 is free software; you can redistribute it and/or modify
@c  it under the terms of the GNU General Public License as published by
@c  the Free Software Foundation; either version 2, or (at your option)
@c  any later version.
@c
@c  Fsc2 is distributed in the hope that it will be useful,
@c  but WITHOUT ANY WARRANTY; without even the implied warranty of
@c  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c  GNU General Public License for more details.
@c
@c  You should have received a copy of the GNU General Public License
@c  along with fsc2; see the file COPYING.  If not, write to
@c  the Free Software Foundation, 59 Temple Place - Suite 330,
@c  Boston, MA 02111-1307, USA.


@node Device Functions, Using Pulsers, Built-in Functions, Top
@chapter Device Functions

@ifinfo
@menu
* Overview::            
* Using two (or more) devices of the same type::
* Magnet Functions::
* Gaussmeter Functions::
* Lock-In Functions::
* Digitizer Functions::
* Pulser Functions::
* Synthesizer Functions::
* Temperature Controller Functions::
* Multimeter Functions::
* Boxcar Integrator Functions::
* Frequency Counter Functions::
* DAQ Functions::
* DIO Functions::
* Event Counter Functions::
* CCD Camera Functions::
* Monochromator Functions::
* Power Supply Functions::
* Microwave Attenuator Functions::
* Light Chopper Functions::
* Multi-Device Functions::
@end menu
@end ifinfo


@node Overview, Using two (or more) devices of the same type, Device Functions, Device Functions
@section Overview


The simple-minded approach to dealing with device-specific functions
would be to have a set of functions for each individual device, all with
different names. Then one would have a different function for e.g.@:
fetching data from each of a series of different digitizing
oscilloscopes. But this would become a nuisance whenever an oscilloscope
has to be changed in the experimental setup - one would have to
carefully check all function calls in the @code{EDL} scripts and adjust
the names of the functions to fit the new digitizer.

So it's more useful to have generic functions for similar devices
that have a lot in common. It's much more convenient just to write
@example
new_data = digitizer_get_curve( CH1 );    // get curve from channel 1
@end example
@noindent
instead of
@example
new_data = tds754a_get_curve( 1 );        // get curve from channel 1
@end example
@noindent
and then changing dozens of references to the TDS754A oscilloscope in
each and every @code{EDL} script when someone else needs your
oscilloscope for a few days and you have to use a LeCroy9450
oscilloscope in between.

Of course, using generic functions is not the silver bullet for all
problems - if e.g.@: the new lock-in amplifier has only a single channel
while the previously used one had two no abstraction will make the new
lock-in have two channels. This means that while a lot of abstraction
is possible not all device functions can be completely identical for
all devices of the same type. Thus, while the names of the functions
remain identical, the arguments the functions are called with sometimes
may differ for different devices. But while this can be annoyingly
enough it at least reduces the amount of changes to be done to an
@code{EDL} script considerably.


@node Using two (or more) devices of the same type, Magnet Functions, Overview, Device Functions
@section Using two (or more) devices of the same type
@cindex Using two (or more) devices of the same type

But what if you need to use e.g.@: two digitizers simultaneously?
When the names of the functions for accessing both the digitizers are
identical how does one specify which one to use for a command? Actually,
it's quite simple. In the @code{DEVICES} section the two digitizers will
be listed as
@example
tds754a;         // first digitizing oscilloscope
lecroy_wr2;      // second digitizing oscilloscope
@end example
@noindent
If now a curve from the first digitizer is needed one simply uses the
normal way to fetch it, i.e.@: the usual function name:
@example
curve1 = digitizer_get_curve( );
@end example
@noindent
And to get a curve from the second only @code{"#2"} needs to be appended
to the function name:
@example
curve2 = digitizer_get_curve#2( );
@end example
@noindent
and @code{fsc2} will automatically know that now the second of the
digitizers from the list of devices is meant.

Of course, if there are three digitizers listed in the DEVICE section
you would append @code{"#3"} to the function name for the third one
etc. (You can also append @code{"#1"} to the name of the function for
the first digitizer, but that's optional.)

In situations where only the module of the second of two similar devices
defines a function (e.g.@: because the first device doesn't has the
necessary capabilities) the function can be used with and without
appending the @code{"#2"} to the function name. To remind you about this
a short message is printed out when the module gets loaded.

The only situation were it's a bit more complicated is the case where two
identical devices are to be used simultaneously. Due to limitations not
only of @code{fsc2} but already to the way the libraries used for accessing
e.g.@: the GPIB bus work you can't simply list the same device twice in the
@code{DEVICES} section and then use them as outlined above. Instead, two
device modules with different names have to be created for these identical
devices and made known to the program. Fortunately, there's a Perl script
that can automatically "clone" a module for an already existing device,
please see one of the following chapters (@pxref{Cloning Devices}) on how
this can be done.


@node Magnet Functions, Gaussmeter Functions, Using two (or more) devices of the same type, Device Functions
@section Magnet Functions
@cindex Magnet Functions


All the following functions may be used to control the field of a magnet.
Currently the following magnet power supplies are supported:
@table @samp
@item aeg_x_band
AEG magnet for X-band with homebuilt controller
@item aeg_s_band
AEG magnet for S-band with homebuilt controller
@item er032m
Bruker ER032M Field Controller
@item keithley228a
Berlin W-band magnet sweep power supply Keithley 228A
@item ips20_4
Berlin 360 GHz spectrometer Oxford Instruments magnet sweep power supply
@item ips120_10
Leiden J-band spectrometer Oxford Instruments magnet power supply
@item ips120_10_mod
Leiden W-band spectrometer Oxford Instruments magnet power supply (with
additional modulation input)
@item s_band_magnet_broad
Frankfurt S-band magnet via homebuilt DAC, broad field range
@item s_band_magnet_narrow
Frankfurt S-band magnet via homebuilt DAC, narrow field range
@item hjs_sfc
Pseudo-device for magnet control in the Osnabrueck group (without field
measurement)
@item hjs_fc
Pseudo-device for magnet control in the Osnabrueck group
@end table

Since it is not possible for the @strong{AEG} magnets to measure the
field using just the magnet power supply it is necessary also to specify
a gaussmeter to enable @code{fsc2} to control the magnet. The module
name of the gaussmeter has to appear @b{before} the magnet module entry
in the @code{DEVICES} section. See the next section for the implemented
gaussmeter and the related functions.

All magnet power supplies (except the ones used with the Oxford Instruments
magnets) don't do continuous sweeps but the field current is stepped instead.
Thus many of the functions discussed in the following don't expect sweep rates
are but field (or current, see below) step sizes for defining a sweep. The
only exception are the power supplies for the Oxford magnets, here only
continuous sweeps can be done and sweep rates must be specified.

If an @strong{AEG} magnet module is listed in the @code{DEVICES} section
the program will try to calibrate the field sweep parameters at the
start of the experiment, i.e.@: it will sweep the field up and down for
some time, so please be patient. Also see below on how to reduce the
amount of time spent for field calibration. If the program finds during
the calibration procedure that the sweep speed isn't set to the highest
speed it will stop and ask you to do so. When running in batch mode
having the sweep speed not set to the highest possible speed will
make @code{fsc2} skip the @code{EDL} script.

The Keithley 228A power supply is used for the sweep coil of the Berlin
W-band magnet. Because there is no well-defined relationship between the
current produced by the power supply and the magnetic field and because
the magnetic field can't be measured directly during measurements, for
this device the following functions expect arguments in current units
(i.e.@: Ampere) instead of field units (i.e.@: Gauss) as for the other
devices.

It's similar for the magnet used for the @w{360 GHz} spectrometer:
there's also no fixed relation between the current and the field, so
also for this module all values have to be given in current instead of
field units.

Because the normal current resolution of the Keithley power supply is
not sufficient an additional device is needed supplying DC voltages in
the range between @w{-10 V} and @w{+10 V} to the modulation input of the
power supply. Currently the DAC ports of one of the Stanford Research
lock-in amplifiers @strong{SR510, SR530, SR810 or SR830}) are used for this
purpose. Which of the lock-ins is used can be specified during
compilation by an entry in the configuration file for the Keithley
driver, usually it's the @strong{SR510} lock-in amplifier. Alternatively,
if no lock-in has been set in the configuration file the
@code{keithley228a} module will assume that the very first lock-in
listed in the devices section is to be used.

In the configuration file it also can be defined which of the DAC ports
of the lock-in amplifiers is to be used. If not defined, port 6 will be
used for the SR510 and SR530 and port 4 for the SR810 and SR830 lock-in
amplifier. But there exists also a function to directly select the DAC
port to be used, see below.

Both the modules for the controlling the magnets in the group of H.-J.@:
Steinhoff in Osnabrueck are not for real devices but instead they use
further modules to achive field control. The first of the two modules
can set the field only according to a previous calibration because it
does not have any access to a gaussmeter while the second uses the
Bruker BNM12 gaussmeter. Both modules require the DA converter of the
home-built DA and AD converter (module @code{hjs_daadc}, see below). The
@code{hjs_fc} module also depends on the module for the the Bruker BNM12
gaussmeter (@code{bnm12}) and the WITIO-48 DIO card (module
@code{witio_48}, also see below) for reading values from the Bruker
BNM12 gaussmeter. These required modules have to be listed
@strong{before} the module itself, so in the @code{DEVICES} section
they would appear as
@example
hjs_daadc;
hjs_sfc;
@end example
@noindent
and
@example
hjs_daadc;
witio_48;
bnm12;
hjs_fc;
@end example


@noindent
@strong{List of all magnet functions}:
@table @samp
@item @ref{magnet_name()}
@item @ref{magnet_setup()}
@item @ref{magnet_fast_init()}
@item @ref{magnet_field()}
@item @ref{magnet_sweep_up()}
@item @ref{magnet_sweep_down()}
@item @ref{magnet_reset_field()}
@item @ref{magnet_use_correction()}
@item @ref{magnet_use_dac_port()}
@item @ref{magnet_sweep()}
@item @ref{magnet_sweep_rate()}
@item @ref{magnet_goto_field_on_end()}
@item @ref{magnet_B0()}
@item @ref{magnet_slope()}
@item @ref{magnet_calibration_file()}
@item @ref{set_field()} (deprecated)
@item @ref{get_field()} (deprecated)
@item @ref{sweep_up()} (deprecated)
@item @ref{sweep_down()} (deprecated)
@item @ref{reset_field()} (deprecated)
@end table


@noindent
@strong{Descriptions of magnet functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{magnet_name()}
@findex magnet_name()

@table @samp
@item magnet_name()
Returns a string with the name of the magnet that is being used.


@anchor{magnet_setup()}
@findex magnet_setup()
@item magnet_setup()
The function can be called in the @code{PREPARATIONS} section to set the
start field and the field step size used in sweeps.  The function
expects two floating point parameters, the start field or current,
e.g.@: @w{0.345 T}, and, in most cases, the step size, e.g.@: @w{0.35
G}.

Use current instead of field units for the Keithley 228A power supply
(@code{keithley228a}).

Because the @strong{Oxford Instruments IPS20-4} magnet sweep power supply
(@code{ips20_4}) does continuous sweeps (instead of simulating a sweep by
stepping the current) the second argument isn't the sweep step size but must
be the sweep rate in units of @code{A/s}.

Similarly, for the @strong{Oxford Instruments IPS120-10} power supply
(@code{ips120_10}) the second argument is the sweep rate in @code{G/s}.

For the @strong{Bruker ER032M} field controller for some combinations of
the start field and field step size deviations between the requested
field and the real field may result of up to @w{25 mG}. If the maximum
field deviation was larger than @w{5 mG} at the end of the test run as
well as the experiment the maximum field deviation is printed out. To
minimize these deviations use a start field that is a multiple of @w{50
mG} and avoid sweeps with more than about 2000 steps away from the start
field.

Please note that at least with some of the drivers it is not possible to
specify a negative field step size or sweep rate. Therefore it is
probably prudent never to try this and use in all cases the functions
for sweeping down if a sweep to lower field values is required.


@anchor{magnet_fast_init()}
@findex magnet_fast_init()
@item magnet_fast_init()
Calling this functions in the @code{PREPARATIONS} section will shorten
the time used for the calibration of the field sweep at the start of the
experiment for the @strong{AEG} magnet power supplies. Unfortunately,
this also reduces the precision of the field sweep. Whenever an
experiment is restarted (i.e.@: if no new @code{EDL} file has been
loaded in between) this shortened calibration is done anyways to check
that the parameters didn't change significantly since the last run.

This function does not exist for the modules @code{hfs_sfc} and
@code{hjs_fc}.


@anchor{magnet_field()}
@findex magnet_field()
@item magnet_field()
This functions allows to either query the current magnetic field or set
a new field value.

If called with no arguments it returns the current magnetic field.
For the @strong{AEG} magnets this is only a convenience function that
just calls a function supplied by the gaussmeter used together with the
magnet power supply to determine the current field. In contrast, for the
@strong{ER032M Field Controller} this function returns the current field
setting in Gauss. For both the Berlin W-band magnet (@code{keithley228a})
and the @w{360 GHz} spectrometer magnet (@code{ips20_4}) the actual current
through the magnets sweep coil is returned instead of the field.

If called with arguments the function expects a floating point argument for
the field value and will set the magnetic field to this value. Please note
tah for the @strong{Keithley} power supply (@code{keithley228a}) and the
@w{360 GHz} magnet (@code{ips20_4}) a current value instead of a field must
be specified.

The function then returns the new value of the field (which, in some
cases might differ a bit from the requested value due to the properties
of the device, i.e.@: restrictions of the resolution).

For the @strong{AEG} magnets and the @code{hjs_fc} module the function
also accepts a second optional parameter, the maximum acceptable
deviation of the field from the value to be set. For example by the call
@example
set_field( 3421.5 G, 0.2 G );
@end example
@noindent
the field will be set to a value between @w{3421.3 G} and @w{3421.7 G}.

If in the case of @strong{AEG} magnets (or the @code{hjs_fc} module)
this second parameter is missing the precision of the gaussmeter used
for measuring the field is used. If the maximum deviation parameter is
smaller than the precision of the gaussmeter the precision of the
gaussmeter is used instead. The function can only be called in the
@code{EXPERIMENT} section.

For both the @strong{Oxford Instruments} magnet sweep power supplies
(@code{ips20_4} and @code{ips120_10}) this function will automatically
stop a running sweep.

For the @strong{Bruker ER032M} field controller setting a field with
this function while also having initialized the magnet using
@ref{magnet_setup()} may result in deviations between the requested
field and the real field of up to @w{25 mG}. If the maximum field
deviation was larger than @w{5 mG} at the end of the test run as well
as the experiment the maximum field deviation is printed out.

The function can only be used in the @code{EXPERIMENT} section.
.

@anchor{magnet_sweep_up()}
@findex magnet_sweep_up()
@item magnet_sweep_up()
The function can be called in the @code{EXPERIMENT} section, but only if
the function @ref{magnet_setup()} (see above) has been called
before. It doesn't take an argument and will sweep up the magnet by the
field step size value set in the @ref{magnet_setup()} function.  For
magnets where the field is controlled via a gaussmeter the actual size
of the step is @b{not} tested using the gaussmeter and can thus faster
than e.g.@: @ref{magnet_field()}. 

The function returns the new field value.

For the @strong{AEG} magnets the precision of the field sweep depends on
the step size. While the precision is usually quite good for step sizes
of up to @w{1 G}, with much larger step sizes it may deteriorate quite
significantly. It sometimes helps to add a short waiting time (use
function @ref{wait()}) after a sweep step to allow the field to settle
at the new point. On the other hand, it then might be faster (and more
reliable) not to use the sweep functions at all but the @ref{magnet_field()}
function (which always checks and if necessary re-adjusts the field if
necessray) in these cases instead.

This function is not available for the @strong{Oxford Instruments} power
supplyies (modules @code{ips20_4} and @code{ips120_10}). Use the function
@code{magnet_sweep} instead.

The function can only be called in the @code{EXPERIMENT} section.


@anchor{magnet_sweep_down()}
@findex magnet_sweep_down()
@item magnet_sweep_down()
This is the exact analog to the function @ref{magnet_sweep_up()} but will
sweep the magnetic field down instead of up by the field step size
defined in @ref{magnet_setup()}.

The function returns the new field value.

This function is not available for the @strong{Oxford Instruments} magnet
power supplies (modules @code{ips20_4} and @code{ips120_10}). Use the function
@ref{magnet_sweep()} instead.


@anchor{magnet_reset_field()}
@findex magnet_reset_field()
@item magnet_reset_field()
This function resets the magnetic field to the start field value defined
in a previous call of the function @ref{magnet_setup()}.

The function returns the new field value.

Please note that for the @strong{Oxford Instruments} magnet power supplies
(@code{ips20_4} and @code{ips120_10}) calling this function also automatically
stops a running sweep.

The function can only be used in the @code{EXPERIMENT} section.


@anchor{magnet_use_correction()}
@findex magnet_use_correction()
@item magnet_use_correction()
This function is only defined for the @strong{Keithley} power supply
(@code{keithley228a}) and accepts not more than one argument. If it is
called with no argument or a non-zero number or the string @code{"ON"}
corrections are applied to reduce the effects of certain inaccuracies of
the power supply. If called with either an argument of @code{0} or a
string @code{"OFF"} the use of these corrections is switched off.  Per
default @strong{no} corrections are used.


@anchor{magnet_use_dac_port()}
@findex magnet_use_dac_port()
@item magnet_use_dac_port()
This function is only defined for the @strong{Keithley} power supply and tells
the driver which of the DAC ports of the lock-in amplifier is connected
(following a voltage divider) to the modulation input of the power supply. The
function expects a single integer value, the DAC port number to be used -- for
the @strong{SR510} and @strong{SR530} this can be @code{5} or @code{6}, while
for the @strong{SR810} and @strong{SR830} all values in the range between
@code{1} and @code{4} may be used.

The function can only be used in the @code{PREPARATIONS} section.


@anchor{magnet_sweep()}
@findex magnet_sweep()
@item magnet_sweep()
This function is only available for the @strong{Oxford Instruments} magnet
sweep power supplies (@code{ips20_4} and @code{ips120_10}) to control their
continuous sweep. It can be called with either an integer argument of @code{1}
to start a sweep to higher field and current values, an argument of @code{-1}
to start a downward sweep or, finally, an argument of @code{0} to stop a
running sweep.

To be able to do a sweep a sweep rate must have been set. This can be
either done by a call of the function @ref{magnet_setup()} within the
@code{PREPARATIONS} section or by calling @ref{magnet_sweep_rate()}.

The function can also be called without an argument, in which case
either @code{1}, @code{-1} or @code{0} is returned if the magnet is
sweeping up or down or the sweep is stopped.

Sweeps will be automatically stopped when a current limit is reached. By
calling this function without an argument you may check if this has
happened.

The function can only be used in the @code{EXPERIMENT} section.


@anchor{magnet_sweep_rate()}
@findex magnet_sweep_rate()
@item magnet_sweep_rate()
This function is only available for the @strong{Oxford Instruments} magnet
power supplies (@code{ips20_4} and @code{ips120_10}) to set or query the sweep
rate for continuous sweeps.  If no argument is passed to the function the
currently set sweep rate is returned. Otherwise a (positive) sweep rate in
units of either @code{A/s} (for the IPS20-4) or @code{G/s} (for the IPS120_19)
must be passed to the function.


@anchor{magnet_goto_field_on_end()}
@findex magnet_goto_field_on_end()
@item magnet_goto_field_on_end()
This function is only available for the @strong{Oxford Instruments} magnet
power supplies (@code{ips20_4} and @code{ips120_10}) and the S-band field
modules @code{s_band_magnet_narrow} and @code{s_band_magnet_broad}. It allows
to set a target current or field that the magnet will be swept to @b{after}
the experiment has ended (per default the magnet would stay at the last field
position for the @strong{Oxford Instruments} magnet supplies or move to the
middle of the allowed field range for the S-band drivers). This function can
be called in the @code{PREPARATION} as well the @code{EXPERIMENT} section and
returns for the IPS20-4 the target current and for the three other modules the
target field the magnet will sweept to after the end of the experiment.  If
called more than once the current or field of the last call will be used.


@anchor{magnet_B0()}
@findex magnet_B0()
@item magnet_B0()
This function is only available for the module @code{hfs_sfc}. For this
module the magnet is controlled via the output voltage of a DAC. The
function allows to tell the module about the field at an output voltage
of @code{0 V}. The value can't be changed anymore after it has been used
(e.g.@: to calculate an output voltage required to set a certain field).

When called without an argument the current value of what
the module assumes to be the field at a DAC output voltage of @code{0 V}.

The function can only be used in the @code{PREPARATIONS} section.


@anchor{magnet_slope()}
@findex magnet_slope()
@item magnet_slope()
This function is only available for the module @code{hfs_sfc}. For this
module the magnet is controlled via the output voltage of a DAC. The
function allows to tell the module about the field change (in Gauss) for
an output voltage change of @code{1 V}. The value can't be changed
anymore after the field-to-voltage change ratio has been used (e.g.@: to
calculate an output voltage required to set a certain field).

When called without an argument the current value of what the module
assumes to be the field change for a DAC output voltage change of
@code{1 V}.

The function can only be used in the @code{PREPARATIONS} section.


@anchor{magnet_calibration_file()}
@findex magnet_calibration_file()
@item magnet_calibration_file()
This function is only available for the modules @code{hfs_sfc} and
@code{hjs_fc}. For both modules the magnet is controlled via the
output voltage of a DAC (currently only module @code{hjs_daadc}
is supported).

For the @code{hfs_sfc} module two data must be read from a calibration
file, the field values for the minumum and the maximum DAC output
voltage. Normally the name of the calibration file is taken from the
configuration file for the module (if it isn't given with an absolute
path the default directory where modules etc.@: get installed, usually
@file{/usr/local/lib/fsc2}, is prepended to the file name). Using this
function, a different calibration file can be used. The function expects
the name of an existent, readable file (if given without an absolute
path it's looked up relative to the current working directory, i.e.@:
the directory @code{fsc2} was started from).  This file must contain two
values, first the field (in Gauss) at the minimum DAC output voltage and
second the field at the maximum DAC output voltage. The file may contain
@code{C} and @code{C++} style comments. Also lines starting with a hash
character ('@code{#}') are taken to be comments.

The module @code{hfs_fc} per default tries to determine the data
described above by doing a measurement of the minimum and maximum field
position at the start of each experiment. But if in the
@code{PREPARATIONS} section @ref{magnet_calibration_file()} is invoked
the data from the configuration file are used instead, thus avoiding the
lengthy measurement.

The function can only be used in the @code{PREPARATIONS} section.


@anchor{set_field()}
@findex set_field()
@item set_field()
This function has been deprecated, please use @ref{magnet_field()} instead.


@anchor{get_field()}
@findex get_field()
@item get_field()
This function is deprecated, please use @ref{magnet_field()} instead.


@anchor{sweep_up()}
@findex sweep_up()
@item sweep_up()
This function is deprecated, please use @ref{magnet_sweep_up()} instead.


@anchor{sweep_down()}
@findex sweep_down()
@item sweep_down()
This function is deprecated, please use @ref{magnet_sweep_down()} instead.


@anchor{reset_field()}
@findex reset_field()
@item reset_field()
This function is deprecated, please use @ref{magnet_reset_field()} instead.


@end table


@node Gaussmeter Functions, Lock-In Functions, Magnet Functions, Device Functions
@section Gaussmeter Functions
@cindex Gaussmeter Functions


Currently, four types of gaussmeters are implemented, the @strong{Bruker
ER035M} NMR gaussmeter, the @strong{Bruker BH15} hall probe field controller,
the @strong{Metrolab PT2025} NMR gaussmeter and, finally, the @strong{Bruke
BNM12 NMR} gaussmeter. The range of fields that can be measured with the
@strong{Bruker ER035M} NMR gaussmeter depends on the probe being used. With
the F0 probe (S-band) the range is @w{460 G} to @w{2390 G} while with the F1
probe (X-band) a range between @w{1460 G} and @w{19900 G} can be measured.
With the @strong{BH15} field controller a range between @w{-50 G} and
@w{2300 G} can be used. Finally, for the @strong{Metrolab PT2025} it is
currently assumed that a probe for the field range between @w{1.5 T} and
@w{3.4 T} (W-band) is used.

The modules defining the gaussmeter functions (to be listed in the
@code{DEVICES} section) are:
@example
er035m
er035m_s
er035m_sa
er035m_sas
bh15
pt2025
bnm12
@end example
@noindent
The modules with names starting with @code{er035m} are for the @strong{Bruker
ER035M} NMR gaussmeter. @code{er035m} and @code{er035m_sa} are to be used
when the device is controlled via the GPIB bus while @code{er035m_s} and
@code{er035m_sas} expect the device to be connected to a serial port of
the computer. (If you're wondering why there are versions for both the
GPIB bus and the serial port, the simple explanation is that some of the
@strong{ER035M} gaussmeters simple don't work with the GPIB bus even though
they should.) The @code{bh15} module is for the Hall controller used in some
setups, the @code{pt2025} module is for the @strong{Metrolab} NMR gaussmeter
from the Berlin W-Band spectrometer. The last module, @code{bnm12}, is for
the @strong{Bruker BNM12} gaussmeter.


The three gaussmeter modules, @code{er035m}, @code{er035m_s} and
@code{bh15}, are only to be used for controlling the sweep of a magnet
power supply. Thus only one of these gaussmeter drivers can be loaded at
the same time. If other gaussmeters are also to be used the
@code{er035m}, @code{er035m_s} or @code{bh15} module must be listed
first in the @code{DEVICES} section and specified @b{before} the magnet
module (see above) which relies on its existence,

In contrast, the four other modules, @code{er035m_sa},
@code{er035m_sas}, @code{pt2025} and @code{bnm12}, are only to be used
for field measurements but not for direct field control.

The @strong{Bruker BNM12} NMR gaussmeter can only be read out when the
@strong{WITIO-48 DIO} card (module @code{witio_48}and the home-built
DA/AD converter (@code{hjs_daadc} are available and their modules have
already been loaded.


@noindent
@strong{List of all gaussmeter functions}:
@table @samp
@item @ref{gaussmeter_name()}
@item @ref{gaussmeter_field()}
@item @ref{gaussmeter_resolution()}
@item @ref{gaussmeter_probe_orientation()}
@item @ref{gaussmeter_upper_search_limit()}
@item @ref{gaussmeter_lower_search_limit()}
@item @ref{find_field()} (deprecated)
@item @ref{measure_field()} (deprecated)
@end table


@noindent
@strong{Descriptions of gaussmeter functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{gaussmeter_name()}
@findex gaussmeter_name()

@table @samp
@item gaussmeter_name()
Returns a string with the name of the gaussmeter being used.


@anchor{gaussmeter_field()}
@findex gaussmeter_field()
@item gaussmeter_field()
The function returns the current field in Gauss. It takes no arguments
and can only be used in the @code{EXPERIMENT} section.

@strong{Please note}: for the @strong{Bruker BNM12} NMR gaussmeter with a field
resolution setting of @code{0.01 G} the kG part of the field value gets
cut off, i.e.@: with this resolution setting a field of @code{3125.63 G}
will be reported as being @code{123.63 G}.


@anchor{gaussmeter_resolution()}
@findex gaussmeter_resolution()
@item gaussmeter_resolution()
This function is defined in the device drivers for the @strong{Bruker} NMR
gaussmeters (@code{er035m}, @code{er035m_s}, @code{er035m_sa} and
@code{er035m_sas}), the @strong{Metrolab} NMR gaussmeter, @code{pt2025} and
for the @code{bnm12} @strong{Bruker BNM12} NMR gaussmeter.  It can be used to
set or query the resolution in Gauss used in measurements of the magnetic
field.

To set a resolution the values @code{0.1 G}, @code{0.01 G} and
@code{0.001 G} can be used for the @strong{Bruker} NMR gaussmeter. For the
@strong{Metrolab} Gaussmeter only @code{0.01 G} and @code{0.001 G} are usable.
Finally, for the @strong{Bruker BNM12} NMR gaussmeter the values @code{1.0 G},
@code{0.1 G} and @code{0.01 G} can be used.

@strong{Please note}: for the modules @code{er035m} and @code{er035m_s},
i.e.@: the modules for direct field control, the resolution will be
increased automatically from @code{0.1 G} to @code{0.01 G} at the
initialization (i.e.@: at the very start of the experiment) unless 
the low resolution has been set explicitely during the
@code{PREPARATIONS} section.

@strong{Also note}: for the @strong{Bruker BNM12} gaussmeter changing the
resolution won't effect the device directly, it can only be read
out. The device has a switch at its front panel where the resolution can
be set and calling this function is for making the module aware of the
setting of the switch (its position can't be determined from within the
program). This is @strong{necessary} to be able to interpret the data
received from the device correctly. Per default the module will assume
that the resolution is set to @code{0.1 G}.


@anchor{gaussmeter_probe_orientation()}
@findex gaussmeter_probe_orientation()
@item gaussmeter_probe_orientation()
This function is currently implemented for the @strong{Metrolab} NMR gaussmeter
@code{pt2025} only. It allows to set or query the current probe
orientation relative to the field. To set an orientation a parameter of
@code{1} or @code{"+"} can be used to define an orientation parallel to
the field and an argument of @code{0} or @code{"-"} for the antiparallel
direction. On queries the function returns either @code{1} or @code{0}.
The function can only be called in the @code{EXPERIMENT} section for
queries.


@anchor{gaussmeter_upper_search_limit()}
@findex gaussmeter_upper_search_limit()
@item gaussmeter_upper_search_limit()
This function can be called to set of query the upper search limit (in
Gauss) for the modules @code{er035m}, @code{er035m_s}, @code{er035m_sa}
and @code{er035m_sas}. The function can only be called in the
@code{EXPERIMENT} section.


@anchor{gaussmeter_lower_search_limit()}
@findex gaussmeter_lower_search_limit()
@item gaussmeter_lower_search_limit()
This function can be called to set of query the lower search limit (in
Gauss) for the modules @code{er035m}, @code{er035m_s}, @code{er035m_sa}
and @code{er035m_sas}. The function can only be called in the
@code{EXPERIMENT} section.


@anchor{find_field()}
@findex find_field()
@item find_field()
Use of this function is deprecated, use @ref{gaussmeter_field()}


@anchor{measure_field()}
@findex measure_field()
@item measure_field()
Use of this function is deprecated, use @ref{gaussmeter_field()}
instead.


@end table


@node Lock-In Functions, Digitizer Functions, Gaussmeter Functions, Device Functions
@section Lock-In Functions
@cindex Lock-In Functions

Modules for five different lock-in amplifiers are implemented. Most are by
@strong{Stanford Research} and have the model names @strong{SR510},
@strong{SR530}, @strong{SR810} and @strong{SR830}. The fifth is the
@strong{ER023M Signal Channel} used in @strong{Bruker} spectrometers of the
ESP series. The module names to be specified in the @code{DEVICES} section are
@example
sr510
sr530
sr810
sr830
er023m
@end example
@noindent
Because the models have different capabilities, some of the functions
are either only defined for parts of the models or may expect slightly
different parameters.

Several of the following functions can be called both to query the
current settings of the lock-in amplifier and to set a new value. In the
first case the function usually has to be called with no argument, while
to set a parameter an argument has to be passed to the function. Because
of these different modes of calling the functions one should carefully
check the arguments to achieve the desired results.


@noindent
@strong{List of all lock-in functions}:
@table @samp
@item @ref{lockin_name()}
@item @ref{lockin_get_data()}
@item @ref{lockin_auto_setup()}
@item @ref{lockin_auto_acquisition()}
@item @ref{lockin_get_adc_data()}
@item @ref{lockin_dac_voltage()}
@item @ref{lockin_sensitivity()}
@item @ref{lockin_time_constant()}
@item @ref{lockin_phase()}
@item @ref{lockin_ref_freq()}
@item @ref{lockin_ref_level()}
@item @ref{lockin_ref_mode()}
@item @ref{lockin_harmonic()}
@item @ref{lockin_lock_keyboard()}
@item @ref{lockin_conversion_time()}
@item @ref{lockin_resonator()}
@item @ref{lockin_is_overload()}
@end table


@noindent
@strong{Descriptions of lock-in functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{lockin_name()}
@findex lockin_name()

@table @samp
@item lockin_name()
Returns a string with the name of the lock-in amplifier being used.


@anchor{lockin_get_data()}
@findex lockin_get_data()
@item lockin_get_data()
This is a function only to be used in queries, i.e.@: to fetch measured
values from the lock-in amplifier. This function can only be called in
the @code{EXPERIMENT} section. The parameters that may be passed to the
function differ according to the model:
@table @samp
@item SR510
No argument is allowed -- the function returns the measured value of the
only channel as a floating point number (i.e.@: in Volts).

@item SR530
If no argument is specified the measured value at channel @code{1} is
returned. Alternatively, one parameter may be passed to the function
with a value of either @code{1} or @code{2}, in which case the measure
value from channel @code{1} or @code{2} is returned. Finally, two
arguments can be given, with values of @code{1} or @code{2}. In this
case a 1-dimensional array with two elements is returned, containing the
measured values of the corresponding channels.

@item SR810
@itemx SR830
If no argument is specified the 'X' signal is returned. If a parameter
is passed to the function the value at the corresponding channel is
returned. Possible channel numbers and their meaning are (please note
that some of these can only be used when in auto-acquisition mode, see
below in the explanation of the functions @ref{lockin_auto_setup()} and
@ref{lockin_auto_acquisition()} and some even then with the @strong{SR830}
only):
@table @samp
@item 1
'X' signal
@item 2
'Y' signal - in auto-acquisition mode only available for the
@strong{SR830}
@item 3
Amplitude 'R' of data from X channel (@code{1}) and Y channel (@code{2})
in polar coordinates
@item 4
Phase 'theta' of data from channel @code{1} and @code{2} (relative to
reference) in polar coordinates - in auto-acquisition mode only
available for the @strong{SR830}
@item 5
Voltage at rear panel auxiliary ADC input 1
@item 6
Voltage at rear panel auxiliary ADC input 2
@item 7
Voltage at rear panel auxiliary ADC input 3 - in auto-acquisition mode
only available for the @strong{SR830}
@item 8
Voltage at rear panel auxiliary ADC input 4 - in auto-acquisition mode
only available for the @strong{SR830}
@item 9
X noise data - this is only allowed when the lock-in-amplifier is
running in auto-acquisition mode and the CH1 display is set to display X
noise.
@item 10
Y noise data - only available for the @strong{SR830} and only allowed
when the lock-in-amplifier is running in auto-acquisition mode and the
CH2 display is set to display Y noise.
@end table

A maximum of 6 different channels can be passed to the function (which
must be be different). If there is more than one argument an
1-dimensional array is returned with as many data as there were
arguments (in the same sequence as the arguments).

@item ER023M
No argument is allowed -- the function returns a floating point value.
@end table


@anchor{lockin_auto_setup()}
@findex lockin_auto_setup()
@item lockin_auto_setup()
This function is only available for the Stanford Research lock-in
amplifiers @strong{SR810} and @strong{SR830}. Both lock-in amplifiers
can automatically acquire data at fixed time intervals (or on receiving
an external trigger) and store the data into an internal buffer. By
using this acquisition mode one can be sure that the data have been
sampled at well-defined times (in contrast to normal measurements where
the exact timing can vary slightly depending on how busy the computer
is). Data can be acquired in this mode only from the channel(s)
displayed at the front side, which means that the @code{SR810} can only
sample one data type in this mode (because it only has one displayable
channel), while the @code{SR830} can sample two data channels
simultaneously.

@ref{lockin_auto_setup()} @strong{must} be invoked to setup
auto-acquisition (if not called auto-acquisition can't be started). The
first parameter passed to the function is the sample time, i.e.@: the
time interval at which data are sampled. Sample times can range between
@w{1.953125 ms} (@w{512 Hz}) and @w{16 s}. Allowed values are powers of
2, multiplied by the shortest sample time (i.e.@: only sample rates of
@w{512 Hz}, @w{256 Hz}, @code{128 Hz} etc.@: can be used). Instead also
an @strong{integer} value of @code{0} or @code{-1} can be passed to the
function. For@code{0} the nearest allowed sample time equal to or larger
than the lock-in's time constant is used while for @code{-1} it is
assumed that an external trigger, applied to the rear trigger input, is
going to be used -- the user has to take care that the trigger input
rate is not larger than @w{512 Hz}.

The next one or two parameter define which data type should be sampled
in auto-acquisition mode (the @strong{SR810} only accepts one data type
arguments while the @strong{SR830} accepts two). You may specify integer
numbers with exactly the same meaning as the arguments to the function
@ref{lockin_get_data()}. This will also automatically switch the type
of data displayed on the front side channels to the specified values.
Not all combinations are possible, the following list shows which
combinations are possible:
@multitable @columnfractions 0.1 .35 .35
@item @tab 1st argument @tab 2nd argument
@item @tab @code{1} (X) @tab @code{2} (Y)
@item @tab @code{3} (R) @tab @code{4} (theta)
@item @tab @code{5} (ADC 1) @tab @code{6} (ADC 3)
@item @tab @code{7} (ADC 2) @tab @code{8} (ADC 4)
@item @tab @code{9} (X noise) @tab @code{10} (Y noise)
@end multitable
For the @strong{SR810} only the first column is relevant.

Additionally, you also may specify a value of @code{0}, indicating that
the function to be displayed should not be changed, i.e.@: the data type
already set manually should be used.

This function can be used in all sections of an @code{EDL} script. If
the auto-acquisition setup is changed during an already running
auto-acquisition all data stored in the lock-in's internal buffer are
discarded before the measurement continues using the new settings.


@anchor{lockin_auto_acquisition()}
@findex lockin_auto_acquisition()
@item lockin_auto_acquisition()
This function is only available for the Stanford Research lock-in
amplifiers @strong{SR810} and @strong{SR830}. It allows to start or stop
the automatic acquisition of data at constant time intervals. Before
this function can be used auto-acquisition must be initialized by a call
of the function @ref{lockin_auto_setup()}.

When called with an argument of @code{1} (or a string @code{"ON}")
auto-acquisition is started. If you now request data from one of the
channels configured to be used in @ref{lockin_auto_setup()} via the
function @ref{lockin_get_data()} the next data sample from the internal
buffer of the lock-in amplifier will be returned (instead of returning
the value at the moment of the call of the function).

When called with an argument of @code{0} (or a string @code{"OFF"})
auto-acquisition is stopped and the internal buffer of the lock-in is
cleared. Following calls of @ref{lockin_get_data()} will then return
values measured in the 'normal' way.

@strong{Please note}: The sizes of the internal buffers of the lock-in
amplifiers are restricted: while the @strong{SR830} can store up to 16383
data points for each of the two channel, the @strong{SR810} can only store
a maximum of 8191 samples. If the program detects when fetching new data
that the maximum number of data have already been fetched from the
lock-in the internal buffer is cleared. In this case data which should
have been acquired between the time the lock-in's internal buffer got
filled up and the moment the program noticed that the buffers are full
will be lost and an error message will be printed. Thus prudence
dictates to stop auto-acquisition, thereby automatically clearing the
lock-in's internal buffers, whenever possible.


@anchor{lockin_get_adc_data()}
@findex lockin_get_adc_data()
@item lockin_get_adc_data()
The function returns the voltage at one of the ADC ports at the back
side of the lock-in amplifier. Allowed values of the required argument
are between @code{1} and @code{4}, corresponding to the port numbering.

This function can only be used with the @strong{Stanford Research}
lock-in amplifiers and can only be called in the @code{EXPERIMENT} section.


@anchor{lockin_dac_voltage()}
@findex lockin_dac_voltage()
@item lockin_dac_voltage()
The function can be used to set or query the voltage at one of the DAC
ports at the back side of the @strong{Stanford Research} lock-in
amplifier. While for the models @strong{SR510} and @strong{SR530} the
allowed values for the required arguments are @code{5} or @code{6}, for
the models @strong{SR810} and @strong{SR830} the values can range from
@code{1} to @code{4}, corresponding to the different numbers of DAC
ports and their numbering printed on the back side. If no further
argument is given the function returns the current voltage applied to
the DAC port (which is automatically set to @w{0 V} at the
initialization of the lock-in amplifier if no voltage has been set
previously in the @code{PREPARATIONS} section using this function). If a
second argument is given the DAC will be set to the corresponding
voltage. The function returns the voltage that has been set.

For the models @strong{SR510} and @strong{SR530} this voltage has to be
in the range between @w{-10.24 V} and @w{+10.24 V} while for the models
@strong{SR810} and @strong{SR830} the allowed voltage range is
@w{-10.5V} to @w{+10.5 V}.

This function can only be used with the @strong{Stanford Research}
lock-in amplifiers. 

In the @code{PREPARATIONS} section this function can only be called
with two argument, i.e@: to set the output voltage of one of the DACs
to be used in the initialization of the device.


@anchor{lockin_sensitivity()}
@findex lockin_sensitivity()
@item lockin_sensitivity()
This function can be used to query or set the sensitivity of the lock-in
amplifier. If no argument is passed to the function the current
sensitivity is returned. For the models @strong{SR510} and
@strong{SR530} a 10 times higher sensitivity than the sensitivity set on
the front panel is returned when the @code{EXPAND} button is switched
on.

When called with a second argument the corresponding sensitivity is
set. This value has to be positive. If the argument does not coincide
with one of the possible sensitivity settings the sensitivity is set to
the nearest available sensitivity setting and a warning is printed. The
function will return the sensitivity that has been set.

Valid sensitivity settings for the @strong{SR510} and @strong{SR530} are
in the range between @w{10 nV} and @w{500 mV} in steps of about @w{3
dB}, i.e.@: you can use @w{10 uV}, @w{20 uV}, @w{50 uV}, @w{100 uV} etc.
To achieve the two highest sensitivity settings the @code{EXPAND} button
is automatically switched on.

For the @strong{SR810} and the @strong{SR810} vaid sensitivity settings
range from @w{2 nV} up to @w{1 V}, using the same system of steps as
the @strong{SR510} and @strong{SR530}.

For the @strong{ER023M Signal Channel} the function does not set the
sensitivity in units of the output voltage but sets the receiver
gain. Valid receiver gains are in the range between @code{2.0E+1} and
@code{1.0E+7} and in increments of about @w{2 dB}. Thus in this range
the following multiplier steps can be used: @code{1.0}, @code{1.25},
@code{1.5}, @code{2.0}, @code{2.5}, @code{3.0}, @code{4.0}, @code{5.0},
@code{6.0} and @code{8.0}.

In the @code{PREPARATION} section this function can't be called in query
mode, i.e.@: without an argument.


@anchor{lockin_time_constant()}
@findex lockin_time_constant()
@item lockin_time_constant()
The function queries or sets the time constant of the lock-in
amplifier. If no argument is passed to the function the current time
constant is returned. If there's an argument the time constant is set
accordingly.  The argument has to be positive. If there is no time
constant setting fitting the argument the nearest available setting is
used and a warning is printed. The function will return the time
constant setting that has been set.


For the @strong{SR510} and @strong{SR530} lock-ins valid time constant
settings are @w{1 ms} and @w{100 s} with steps of about a factor of 3,
i.e.@: you can use @w{10 ms}, @w{30 ms}, @w{100 ms} etc. The POST time
constant is set to a value equal or lower than the time constant.

For the @strong{SR810} and @strong{SR810} lock-ins vali time constants
range from @w{10 us} up to @w{30,000 s}, using the same system of steps
as the @strong{SR510} and the @strong{SR530}.

For the @strong{ER023M} the following (approximate) time constant
settings can be used: @code{2.5 ms}, @code{5 ms}, @code{10 ms}, @code{20
ms}, @code{40 ms}, @code{65 ms}, @code{130 ms}, @code{330 ms}, @code{650
ms}, @code{1.3 s}, @code{2.6 s} and @code{5.2 s}.

In the @code{PREPARATIONS} section this function can't be called as a
query, i.e.@: without an argument.


@anchor{lockin_phase()}
@findex lockin_phase()
@item lockin_phase()
The function queries or sets the phase of the lock-in amplifier. If
called with no argument it will return the current phase setting in the
interval between 0 and 360 degrees. If called with an argument the phase
is set accordingly.

In the @code{PREPARATIONS} section this function can't be called without
an argument, i.e.@: as a query.


@anchor{lockin_ref_freq()}
@findex lockin_ref_freq()
@item lockin_ref_freq()
The function can be used to query the modulation frequency and, for the
@strong{SR810}, @strong{SR830} and @strong{ER023M} to set the modulation
frequency (both the other models need an external modulation). If called
with no argument the current modulation frequency is returned. If called
with an argument the modulation frequency is set.

If for the @strong{SR810} and @strong{SR830} the frequency is not within
the admissible range an error message is printed and the experiment is
stopped. The admissible range depends on the harmonics setting, see
the manuals for full details.

For the @strong{ER023M} only certain modulation frequencies can be set,
these are @code{100 kHz}, @code{50 kHz}, @code{25 kHz}, @code{12.5 kHz},
@code{6.25 kHz} and @code{3.125 kHz}. If a modulation frequency is
specified that does not fit one of these values the nearest valid
frequency is used.

In the @code{PREPARATIONS} section this function can't be called in
query mode, i.e.@: without an argument.


@anchor{lockin_ref_level()}
@findex lockin_ref_level()
@item lockin_ref_level()
This function can be only used with the models @strong{SR810},
@strong{SR830} and the @strong{ER023M}. It queries (if called with no
argument) or sets (if called with an argument) the level of the
modulation frequency. For the @strong{Stanford} lock-in amplifiers the
allowed levels are between @w{4 mV} and @w{5 V}, if the argument is not
within this range an error message is printed and the experiment is
stopped. For the @strong{Bruker ER023M} signal channel the range is (as
long as no calibration has been done) between @w{10 mG} and @w{100 G}
(but don't expect the values to have any real meaning without a
calibration).

In the @code{PREPARATIONS} section this function can't be called in query
mode, i.e.@: without an argument.


@anchor{lockin_ref_mode()}
@findex lockin_ref_mode()
@item lockin_ref_mode()
This function can be only used with the models @strong{SR810},
@strong{SR830}. It returns the modulation mode, i.e.@: if the internal
modulation or an external modulation input is used. In the first case
the function returns an integer value of @code{1} while in the second
case @code{0} is returned.


@anchor{lockin_harmonic()}
@findex lockin_harmonic()
@item lockin_harmonic()
SR8[13]0: 1-19999
ER023M:   1-2


@anchor{lockin_lock_keyboard()}
@findex lockin_lock_keyboard()
@item lockin_lock_keyboard()
Usually, during an experiment the keyboard of the lock-in amplifier is
locked. But for situations where it would be useful to be able to control
the lock-in also via its keyboard it can be unlocked (and also re-locked)
from within the script. To unlock the keyboard call this function with
an argument of @code{0} or @code{"OFF"}, to re-lock the keyboard call it
again with a non-zero argument, @code{"ON"} or no argument at all.

This function can only be used with the @strong{Stanford Research}
lock-in amplifiers.


@anchor{lockin_conversion_time()}
@findex lockin_conversion_time()
@item lockin_conversion_time()
This function exists for the @strong{Bruker ER023M} signal channel only
and either queries or sets the time that the built-in ADC takes to
convert a voltage into a binary data value. The voltage resolution is
higher for longer conversion times. Possible conversion times are
integer multiples of @w{320 us} in the range between 10 and 9999, thus
allowing conversion times between @code{3.2 ms} and ca.@: @code{3.2 s}.

Unfortunately, according to my tests, for conversion times between @w{40
ms} and @w{64 ms} the data the signal channels sends for large signal
amplitudes are garbled. For this reason the function will not accept
conversion times in this range but will instead set the nearest
conversion time for which correct data are delivered.

If no argument is supplied to the function the current conversion time
is returned. If there is an argument this is used as the new conversion
time. If the argument is not an integer multiple of @w{320 us} (within
the possible range) the nearest allowed conversion time is used.

In the @code{PREPARATIONS} section this function can't be called without
an argument, i.e.@: as a query.


@anchor{lockin_resonator()}
@findex lockin_resonator()
@item lockin_resonator()
This function exists for the @strong{Bruker ER023M} signal channel only
and queries or returns the selected resonator. If called without an
argument it returns either @code{1} or @code{2} for the first or second
resonator. It accepts the same values as arguments to select a resonator.

In the @code{PREPARATIONS} section this function can't be called without
an argument, i.e.@: as a query.


@anchor{lockin_is_overload()}
@findex lockin_is_overload()
@item lockin_is_overload()
This function exists for the @strong{Bruker ER023M} signal channel only
and can only be used as a query, i.e.@: it does not allows arguments. It
can be called before a new data value is fetched from the lock-in to
find out if an overload has occurred while the data value was measured
(where a return value of @code{1} indicates that an overload happened,
otherwise @code{0} is returned). Calling this function (or fetching the
data value) will reset the overload condition and calls of the function
will return @code{0} as long as no further overloads occur.

The function can only be used in the @code{EXPERIMENT} section.

@end table


@node Digitizer Functions, Pulser Functions, Lock-In Functions, Device Functions
@section Digitizer Functions
@cindex Digitizer Functions

The digitizing oscilloscopes currently implemented are the Tektronix
TDS520, TDS520A, TDS540, TDS744A and TDS754A and the LeCroy 9400 (with the
WP01 Waveform Processing option), 9410, 9420, 9424, 9424E, 9450, the
Waverunner-2 (models LT262, LT264, LT354, LT372, LT374 and LT584) and
the WaveSurfer (models 422, 424, 432, 434, 452 and 454). The corresponding
module names to be used in the @code{DEVICES} section are
@example
tds520
tds520a
tds540
tds744a
tds754a
lecroy9400
lecroy9410
lecroy9420
lecroy9424
lecroy9424e
lecroy9450
lecroy_wr2
lecroy_ws
@end example

When specifying digitizer channels or trigger inputs you should use only
the following symbolic names (internally these symbolic names get
replaced by integer numbers, so the functions expecting channel numbers
accept integers, but the relation between a channel specified by its
symbolic name and the corresponding number isn't trivial).
@table @samp
@item CH1
First digitizer channel (all models)
@item CH2
Second digitizer channel (all models)
@item CH3
Third digitizer channel (Tektronix TDS540, TDS744A, TDS754A, LeCroy 9424, 
LeCroy 9424E, some models of the Waverunner-2)
@item CH4
Fourth digitizer channel (Tektronix TDS540, TDS744A, TDS754A, LeCroy 9424, 
LeCroy 9424E, some models of the Waverunner-2)
@item MATH1
First mathematic function channel (all Tektronix digitizers)
@item MATH2
Second mathematic function channel (all Tektronix digitizers)
@item MATH3
Third mathematic function channel (all Tektronix digitizers)
@item REF1
First reference channel (all Tektronix digitizers)
@item REF2
Second reference channel (all Tektronix digitizers)
@item REF3
Third reference channel (all Tektronix digitizers)
@item REF4
Fourth reference channel (all Tektronix digitizers)
@item AUX
Auxiliary channel (Tektronix TDS540, TDS744A, TDS754A)
@item AUX1
First auxiliary channel (Tektronix TDS520, TDS520A, TDS520C)
@item AUX2
Second auxiliary channel (Tektronix TDS520, TDS520A, TDS520C)
@item LINE
Line In for trigger (all models)
@item EXP_A
First expansion channel (LeCroy 9400, 9410, 9420, 9424, 9424E, 9450)
@item EXB_B
Second expansion channel (LeCroy 9400, 9410, 9420, 9424, 9424E, 9450)
@item MEM_A
Memory channel A (LeCroy Waverunner-2)
@item MEM_B
Memory channel B (LeCroy Waverunner-2)
@item MEM_C
Memory channel C (all LeCroy digitizers except WaveSurfer)
@item MEM_D
Memory channel D (all LeCroy digitizers except WaveSurfer)
@item MATH
Math (function) channel (LeCroy WaveSurfer)
@item FUNC_E
First function (averaging) channel (LeCroy 9400, 9410, 9420, 9424, 9424E, 9450)
@item FUNC_F
Second function (averaging) channel (LeCroy  9400, 9410, 9420, 9424, 9424E,
9450)
@item TRACE_A
First function (averaging) channel (LeCroy Waverunner-2)
@item TRACE_B
Second function (averaging) channel (LeCroy Waverunner-2)
@item TRACE_C
Third function (averaging) channel (LeCroy Waverunner-2)
@item TRACE_D
Fourth function (averaging) channel (LeCroy Waverunner-2)
@item EXT
External trigger input (LeCroy 9400, 9410, 9420, 9424E, 9450, Waverunner-2)
@item EXT10
External amplified trigger input (LeCroy 9400, 9410, 9420, 9450, Waverunner-2)
@end table


@noindent
@strong{List of all digitizer functions}:
@table @samp
@item @ref{digitizer_name()}
@item @ref{digitizer_timebase()}
@item @ref{digitizer_interleave_mode()}
@item @ref{digitizer_time_per_point()}
@item @ref{digitizer_sensitivity()}
@item @ref{digitizer_offset()}
@item @ref{digitizer_coupling()}
@item @ref{digitizer_bandwidth_limiter()}
@item @ref{digitizer_num_averages()}
@item @ref{digitizer_averaging()}
@item @ref{digitizer_trigger_channel()}
@item @ref{digitizer_trigger_level()}
@item @ref{digitizer_trigger_slope()}
@item @ref{digitizer_trigger_coupling()}
@item @ref{digitizer_trigger_mode()}
@item @ref{digitizer_trigger_position()}
@item @ref{digitizer_trigger_delay()}
@item @ref{digitizer_record_length()}
@item @ref{digitizer_memory_size()}
@item @ref{digitizer_define_window()}
@item @ref{digitizer_change_window()}
@item @ref{digitizer_window_position()}
@item @ref{digitizer_window_width()}
@item @ref{digitizer_display_channel()}
@item @ref{digitizer_start_acquisition()}
@item @ref{digitizer_get_curve()}
@item @ref{digitizer_get_curve_fast()}
@item @ref{digitizer_get_area()}
@item @ref{digitizer_get_area_fast()}
@item @ref{digitizer_get_amplitude()}
@item @ref{digitizer_get_amplitude_fast()}
@item @ref{digitizer_run()}
@item @ref{digitizer_copy_curve()}
@item @ref{digitizer_lock_keyboard()}
@end table

@noindent
@strong{Descriptions of digitizer functions}:


@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{digitizer_name()}
@findex digitizer_name()

@table @samp

@item digitizer_name()
Returns a string with the name of the digitizer being used.


@anchor{digitizer_timebase()}
@findex digitizer_timebase()
@item digitizer_timebase()
The function queries (if called with no argument) or sets (if called
with an argument) the timebase setting of the oscilloscope. The
possible timebases depend on the model, please check the manual.

For the @strong{LeCroy} digitizers (except the @strong{9400} model)
interleaved sample (RIS) mode will be automatically switched on if
the selected timebase requires it (see the manuals at which timebase
settings RIS or single shot mode is only possible). Changing the
timebase for these digitizers also can lead to changes in the number
of points of a trace.

Please note that trying to change the timebase may lead to the program
getting aborted if the new timebase setting isn't compatible with a
previously set trigger delay (i.e.@: if the trigger delay requested
previously isn't possible with the new setting of the timebase).

The function can be called in query mode (i.e.@: without an argument)
in the @code{EXPERIMENT} section only.


@anchor{digitizer_time_per_point()}
@findex digitizer_time_per_point()
@item digitizer_time_per_point()
The function (to be called in the @code{EXPERIMENT} section only)
returns the time difference (in seconds) between two data points
measured by the digitizer.


@anchor{digitizer_interleave_mode()}
@findex digitizer_interleave_mode()
@item digitizer_interleave_mode()
This function is only available for the @strong{LeCroy} digitizers (except
the @strong{9400} model). It allows to switch between interleaved (RIS) and
single shot (SS) mode, given that setting the mode is compatible with the
currently selected timebase. Please note that by changing the timebase
interleaved mode may get switched on or off automatically.

If called without an argument the function returns the requested mode
(independent of the mode the digitizer is currently in due to the
timebase setting, i.e. it reflects the prefered setting, not the actual
setting, which might be different due to requeirements from the current
timebase setting), @code{1} when interleaved (RIS) mode is requested,
and @code{0} for single shot (SS) mode.


@anchor{digitizer_sensitivity()}
@findex digitizer_sensitivity()
@item digitizer_sensitivity()
The function queries (if called with just one argument) or sets (if
called with two arguments) the sensitivity setting of one of the channels
of the oscilloscope. It needs at least one argument, the channel. Which
channels that can be used as arguments depends on the model of the
oscilloscope:
@table @samp
@item TDS520
@itemx TDS520A
@itemx LeCroy 9400
@itemx LeCroy 9410
@itemx LeCroy 9420
@itemx LeCroy 9450
@itemx LeCroy Waverunner-2 (LT262, LT372, LT584)
@itemx LeCroy WaveSurfer (422, 432, 452)
@code{CH1} or @code{CH2}
@item TDS540
@itemx TDS744A
@itemx TDS754A
@itemx LeCroy 9424
@itemx LeCroy 9424E
@itemx LeCroy Waverunner-2 (LT264, LT354, LT374)
@itemx LeCroy WaveSurfer (424, 434, 454)
@code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@end table

If a second argument is given this is taken to be the new sensitivity
setting (in Volts per division). If the sensitivity value passed to the
function is not one of the available settings the nearest allowed value
is used instead. Please note that for some of the oscilloscopes the
range of admissible sensitivity settings depends on the input impedance
-- unfortunately this can only be checked for when the experiment has
already been started!

If no second argument is given the current sensitivity setting for the
channel is returned.

Please note that for some of the oscilloscopes the range of input sensitivity
settings may depend on the input impedance and requesting an invalid
combination may result in aborting the @code{EDL} script.

The function can be called in query mode (i.e.@: without a second
argument) only in the @code{EXPERIMENT} section.


@anchor{digitizer_offset()}
@findex digitizer_offset()
@item digitizer_offset()
The function queries (if called with just one argument) or sets (if
called with two arguments) the offset setting of one of the channels
of the oscilloscope. Currently this function only exists for the
@strong{LeCroy} osccilloscopes @strong{9410}, @strong{9420}, @strong{9424},
@strong{9424E} and @strong{9450}. It needs at least one argument, the channel.
The channels that can be used as arguments depends on the model of the
oscilloscope:
@table @samp
@itemx LeCroy 9400
@itemx LeCroy 9420
@itemx LeCroy 9410
@itemx LeCroy 9450
@itemx LeCroy Waverunner-2 (LT262, LT372, LT584)
@itemx LeCroy WaveSurfer (422, 432, 452)
@code{CH1} or @code{CH2}
@itemx LeCroy 9424
@itemx LeCroy 9424E
@itemx LeCroy Waverunner-2 (LT264, LT354, LT374)
@itemx LeCroy WaveSurfer (424, 434, 454)
@code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@end table

If a second argument is given this is taken to be the new offset
setting (in Volts). If no second argument is given the current offset
setting for the channel is returned.

The function can be called in query mode (i.e.@: without a second
argument) only in the @code{EXPERIMENT} section.


@anchor{digitizer_coupling()}
@findex digitizer_coupling()
@item digitizer_coupling()
The function queries (if called with just one argument) or sets (if
called with two arguments) the input coupling of one of the channels
of the oscilloscope. Currently this function only exists for the
@strong{LeCroy} osccilloscopes @strong{9410}, @strong{9420}, @strong{9424},
@strong{9424E} @strong{9450}, @strong{Waverunner-2} and @strong{WaveSurver}.
It needs at least one argument, the channel. The channels that can be used
as arguments depends on the model of the oscilloscope:
@table @samp
@itemx LeCroy 9400
@itemx LeCroy 9420
@itemx LeCroy 9410
@itemx LeCroy 9450
@itemx LeCroy Waverunner-2 (LT262, LT372, LT584)
@itemx LeCroy Wavesurver (422, 432, 452)
@code{CH1} or @code{CH2}
@itemx LeCroy 9424
@itemx LeCroy 9424E
@itemx LeCroy Waverunner-2 (LT264, LT354, LT374)
@itemx LeCroy Wavesurver (424, 434, 454)
@code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@end table

If a second argument is given this is taken to be the new input coupling
setting, which has to b specified a string or an integer number, where
@code{"A1M"} or @code{0} stands for AC with @w{1 MOhm}, @code{"D1M"} or
@code{1} for DC with @w{1 MOhm}, @code{"D50"} for DC with @w{50 Ohm} and,
finally, @code{"GND"} or @code{3} for Ground. If no second argument is
given the current setting for the channel is returned as an integer number.

Please note that for some of the oscilloscopes the range of input sensitivity
settings may depend on the input impedance and requesting an invalid
combination may result in aborting the @code{EDL} script.

The function can be called in query mode (i.e.@: without a second
argument) only in the @code{EXPERIMENT} section.


@anchor{digitizer_bandwidth_limiter()}
@findex digitizer_bandwidth_limiter()
@item digitizer_bandwidth_limiter()
For the @strong{LeCroy 9410, 9420, 9424, 9424E, 9450} the function queries
(if called with no argument) or sets (if called with an arguments) if
the bandwidth limiter (@w{80 MHz}) is switched on or off. If an argument
is given and it is a non-zero number or the string @code{"ON"} the
bandwidth limiter is switched on, if the argument is zero or the string
@code{"OFF"} the bandwidth limiter is switched off. If called without an
argument the function returns @code{1} if the bandwidth limiter is on,
@code{0} if it's off.

For the @strong{LeCroy Waverunner-2} three possible setings exist.
The bandwidth limiter can be either on (i.e.@. set to @w{20 MHz},
off or set to @w{200 MHz}. If called with a string argument of @code{"OFF"}
(or an integer argument of @code{0}) the bandwidth limiter gets switched off.
If called with a string argument of @code{"ON"} (or the number @code{1})
the bandwidth limiter is switched on (with a limit of @w{20 MHz}). Finally,
if called with the string @code{"200MHZ"} (or the value @code{2}) the
bandwidth limiter also gets swithed on, but with a limit of @w{200 MHz}.
If called without an argument the currently set state of the bandwidth
limiter gets returned as an integer value with the same meaning as above.

For the @strong{LeCroy WaveSurfer} for the models 422 and 424 only
@code{"OFF"} and @code{"ON"} can be set, while for the other models
also @code{"200MHZ"} can be set (the maximum bandwidth of the 422 and 424
models is @w{200 MHz}, so this limit is already reached when the bandwidth
limiter is set to @code{"OFF"}.

The function does not exis for the @strong{Tektronix} digitizers.

The function can be called in query mode (i.e.@: without a second
argument) only in the @code{EXPERIMENT} section.


@anchor{digitizer_num_averages()}
@findex digitizer_num_averages()
@item digitizer_num_averages()
This function is intended for the @strong{Tektronix} digitizers, see at
the end on how to also use it with the @strong{LeCroy} oscilloscopes. It
queries (if called with no argument) or sets (if called with an argument)
the number of averages done by the oscilloscope. If the number of averages
is passed to the function it must be at least 1 (which will switch the
oscilloscope into @code{SAMPLE} mode). If the argument is larger than
the maximum number of averages the maximum available number of averages
is used instead.

The function can be called in query mode (i.e.@: without an argument)
only in the @code{EXPERIMENT} section.

For the @strong{LeCroy} oscilloscopes this function can only be used in
query mode and returns the number of averages that has been set in a
previous call of @ref{digitizer_averaging()}. It needs exactly one
argument, the the channel used to do the averaging, i.e.@: either
@code{FUNC_E} or @code{FUNC_F} for the @strong{LeCroy 9400, 9410, 9420, 9424,
9424E, 9450} and @code{TRACE_A}, @code{TRACE_B}, @code{TRACE_C} or
@code{TRACE_D} for the @strong{LeCroy Waverunner-2}.

@strong{Please note}: Anton Savitzky noticed that there seems to be
firmware bug in the @strong{Tektronix} digitzers from the 500 series
(i.e. @strong{TDS520}, @strong{TDS520A}, @strong{TDS520C} and @strong{TDS540}).
For numbers of averages above about 16 only half of the number of
averages seem to be taken by the device it has been instructed to do.
It's hard to say which is the exact number of averages this bug starts
at because it only shows up in the signal-to-noise ratio being worse
by a factor of the square root of 2 than is to be expected.


@anchor{digitizer_averaging()}
@findex digitizer_averaging()
@item digitizer_averaging()
This function only exists for the @strong{LeCroy} oscilloscopes and
must be used to set up averaging. It expects at least three arguments.
The first argument is the channel to be used to do the averaging, i.e.@:
@table @samp
@itemx LeCroy 9400
@itemx LeCroy 9410
@itemx LeCroy 9420
@itemx LeCroy 9424
@itemx LeCroy 9424E
@itemx LeCroy 9450
@code{FUNC_E} or @code{FUNC_F}
@itemx LeCroy Waverunner-2
@code{TRACE_A}, @code{TRACE_B}, @code{TRACE_C} or @code{TRACE_D}
@itemx LeCroy WaveSurfer
@code{MATH}
@end table
The second is the source channel to be averaged, i.e.@:
@table @samp
@itemx LeCroy 9400
@itemx LeCroy 9410
@itemx LeCroy 9420
@itemx LeCroy 9450
@itemx LeCroy Waverunner-2 (LT262, LT372, LT584)
@itemx LeCroy WaveSurfer (422, 432, 452)
@code{CH1} or @code{CH2}
@itemx LeCroy 9424
@itemx LeCroy 9424E
@itemx LeCroy Waverunner-2 (LT264, LT354, LT374)
@itemx LeCroy WaveSurfer (424, 434, 454)
@code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@end table
Alternatively, for all digitizers except the @strong{LeCroy9400} the
second (and in this case final) argument can be the string @code{"OFF"}
to switch of averaging for the channel. Normally, this won't be necessary
unless you want to fetch a curve acquired in @code{SINGLE} trigger mode.
Normally, at the start of an acquisition, the trigger mode gets changed
to @code{NORM} (or @code{AUTO}, if you have set the trigger mode to this).
Only in these trigger modes averaging can be done. Only when no averaging
setup has been done (or all previously done setups have been deleted by
using the @code{"OFF"} instead of a source channel) it is possible to
start an acquisition in @code{SINGLE} trigger mode.

Otherwise the third required argument is the number of averages. For the
@strong{LeCroy9400} this has to be either @code{1}, @code{2} or @code{5},
multiplied by @code{10}, @code{100}, @code{1,000}, @code{10,000} etc.@: up
to @code{1,000,000} (if a number not fitting this scheme is passed to the
function the nearest allowd number is used instead).

For the @strong{LeCroy 9410, 9420, 9424, 9424E, 9450} this can be an arbitrary 
number between @code{1} and @code{1,000} or @code{1,000,000} if the device
is fitted with the WP01 Waveform Processing option.

For the @strong{LeCroy Waverunner-2} this also can be an arbitrary
number with an upper limit of @code{4,000} or @code{1,000,000} if it is
fitted with the WaveAnalyzer option.

Finally, for the @code{WaveSurfer} the number of averages can be set to
a number with an upper limit of @code{1,000,000}.

For the @strong{LeCroy9400} two more optionals argument can be passed to
the function. The first one is either an integer number, with a non-zero
value representing truth and @code{0} falsehood, or a string, either
@code{"ON"} or @code{"OFF"}, that determines if overflow rejection is
switched on or off (if switched on all traces that overflowed the ADC
range will be rejected automatically). The second one is the number of
points that get included into the average. Usually it doesn't make too
much sense to set this value because the program will make sure that at
least as many points of a curve as can be read from the digitizer are
included into the averaging. If the value is set only as many points as
have been set will be returned by a @ref{digitizer_get_curve()} command.


@anchor{digitizer_trigger_channel()}
@findex digitizer_trigger_channel()
@item digitizer_trigger_channel()
The function queries or sets the channel of the digitizing oscilloscope
to be used as trigger input. Possible arguments or return values are,
depending on the type of the oscilloscope (return values are always
numeric!):
@table @samp
@item TDS520
@itemx TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{AUX1}, @code{AUX2} or @code{LINE} (can be abbreviated to
@code{LIN})
@end itemize
@item TDS540
@itemx TDS744A
@itemx TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{AUX} or @code{LINE} (can be abbreviated to @code{LIN})
@end itemize
@item LeCroy 9400
@itemx LeCroy 9410
@itemx LeCroy 9420
@itemx LeCroy 9424E
@itemx LeCroy 9450
@itemx LeCroy Waverunner-2 (LT262, LT372, LT584)
@itemx LeCroy WaveSurfer (422, 432, 452)
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{EXT}, @code{EXT10} or @code{LINE} (can be abbreviated to
@code{LIN})
@end itemize
@item LeCroy Waverunner-2 (LT264, LT354, LT374)
@itemx LeCroy WaveSurfer (424, 434, 454)
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{EXT}, @code{EXT10} or @code{LINE} (can be abbreviated to
@code{LIN})
@end itemize
@item LeCroy 9424
@itemize @bullet
@item @code{CH1}, @code{CH2} or @code{CH4}
@item @code{LINE} (can be abbreviated to @code{LIN})
@end itemize
@item LeCroy 9424E
@itemize @bullet
@item @code{CH1}, @code{CH2}
@item @code{EXT} or @code{LINE} (can be abbreviated to @code{LIN})
@end itemize
@end table
The function can be called in query mode (i.e.@: without an argument)
only if either it has already been called with an argument or in the
@code{EXPERIMENT} section.



@anchor{digitizer_trigger_level()}
@findex digitizer_trigger_level()
@item digitizer_trigger_level()

Function for setting or quering the trigger level of one of the trigger
channels of the @strong{LeCroy 9410, 9420, 9424, 9424E, 9450} and
@strong{Waverunner-2} digitizers. It expects at least a single argument, the
trigger channel, see the channels listed for the function
@ref{digitizer_trigger_channel()}, for obvious reasons excluding the
@code{LINE} channel. If called with no further argument the current setting
for the trigger level of this channel is returned. If called with a second
argument it must be the trigger level (in Volt) to be set for that channel.



@anchor{digitizer_trigger_slope()}
@findex digitizer_trigger_slope()
@item digitizer_trigger_slope()
Function for setting or quering the trigger slope of one of the trigger
channels of the @strong{LeCroy 9410, 9420, 9424, 9424E, 9450} and
@strong{Waverunner-2} digitizers. It expects at least a single argument, the
trigger channel, see the channels listed for the function
@ref{digitizer_trigger_channel()}. If called with no further argument the
current setting for the trigger slope of this channel as a number, where
@code{1} stands for positive slope and @code{0} for negative slope. If called
with a second argument it must be either the string @code{"POSITIVE"} or
@code{"POS"} (or the number @code{1}) to set a positive slope or the string
@code{"NEGATIVE"} or @code{"NEG"} (or the number @code{0}) to set a negative
trigger slope for that channel.

Please note: setting a trigger slope for a trigger channel does @strong{not}
automatically make this channel the selected trigger channel.



@anchor{digitizer_trigger_coupling()}
@findex digitizer_trigger_coupling()
@item digitizer_trigger_coupling()

Function for setting or quering the trigger coupling of one of the trigger
channels of the @strong{LeCroy 9410, 9420, 9424, 9424E, 9450} and
@strong{Waverunner-2} digitizers. If called with a single argument, the
trigger channel (see the description of the function
digitizer_trigger_channel() for a list of the possible trigger channels), the
trigger coupling gets returned as a number, where @code{0} stands for
@code{AC} coupling, @code{1} for @code{DC} coupling, @code{2} for @code{LF
REJ} coupling, @code{3} for @code{HF REF} coupling and @code{4} for @code{HF}
coupling. To change the coupling for the channel pass the function a second
argument, either an integer as it gets returnedon queries, or one of the
strings @code{"AC"}, @code{"DC"}, @code{"LF REF"}, @code{"HF REJ"} or
(exceptt for the @strong{LeCroy 9410}) @code{"HF"} .

Please note: setting a trigger coupling for a trigger channel does @strong{not}
automatically make this channel the selected trigger channel.



@anchor{digitizer_trigger_mode()}
@findex digitizer_trigger_mode()
@item digitizer_trigger_mode()

Function for setting or quering the trigger mode of one of the @strong{LeCroy
9410, 9420, 9424, 9424E, 9450} and @strong{Waverunner-2} digitizers. If called
without an argument the function returns the currently set trigger mode as an
integer, if called to set the mode it can either be a string or an integer.
The following values are allowed:
@table @samp
@item LeCroy 9410
@itemx LeCroy 9420
@itemx LeCroy 9424
@itemx LeCroy 9424E
@itemx LeCroy 9450
@itemize @bullet
@item @code{AUTO} or @code{0}
@item @code{NORM} or @code{1}
@item @code{SINGLE} or @code{2}
@item @code{SEQUENCE} or @code{3}
@item @code{WRAP} or @code{4}
@end itemize
@item LeCroy Waverunner-2
@itemx LeCroy Waverunner-2
@itemize @bullet
@item @code{AUTO} or @code{0}
@item @code{NORM} or @code{1}
@item @code{SINGLE} or @code{2}
@item @code{STOP} or @code{3}
@end itemize
@end table
Currently, setting the @code{SEQUENCE} or @code{WRAP} trigger modes isn't
supported.



@anchor{digitizer_record_length()}
@findex digitizer_record_length()
@item digitizer_record_length()
The function queries (if called with no argument) or sets (if called
with an argument) the length of the traces measured by the digitizer.
If called with an argument the value passed to the function will be
rounded up to the nearest allowed values if necessary.

For all @strong{LeCroy} oscilloscopes the function can only be called
in query mode, i.e.@: without an argument.

Except for the @strong{LeCroy} oscilloscopes, the function can be called
in query mode (i.e.@: without an argument) only if either it has already
been called with an argument or when in the @code{EXPERIMENT} section.


@anchor{digitizer_memory_size()}
@findex digitizer_memory_size()
@item digitizer_memory_size()
This function is only available for the @strong{LeCroy Waverunner-2} and
the @code{LeCroy WaveSurfer} and can be used to query or set the memory
size to be used for storing curves. If the function gets called with an
(integer) argument the memory size is set accordingly. Please note that
memory sizes can only be set according to an 1-2.5-5 scheme, starting
with a minimum memory size of @code{500} samples (i.e. the lowest memory
sizes are @code{500}, @code{1000}, @code{2500} etc.). If the argument
doesn't fit into this scheme the next larger memory size is used and a
warning is printed. If called without an argument the function returns
the currently set memory size.

Please note that changing the memory size may also change the time resolution
(but not the timebase), i.e.@: when going to a lower memory size the time
distance between adjacent measured data points may become larger and vice
versa. This in turn may have an effect on the exact positions of previously
set windows (see below).


@anchor{digitizer_trigger_position()}
@findex digitizer_trigger_position()
@item digitizer_trigger_position()
This function only exists for the @strong{Tectronics} oszilloscopes
and is deprecated, please use the @ref{digitizer_trigger_delay()}
function instead.

It queries (if called with no argument) or sets (if called with an
argument) the amount of pre-triggering, i.e.@: the portion of the
trace shown with data before the trigger was detected. The function
accepts or returns values from the interval @w{[0, 1]} (where 0 means
that the trigger is at the very first point of the trace, i.e.@: no
pre-trigger is used, and 1 that it's at the last point, i.e.@: the
complete curve is recorded before the trigger).

The function can be called in query mode (i.e.@: without an argument)
only if either it has already been called with an argument or in the
@code{EXPERIMENT} section.



@anchor{digitizer_trigger_delay()}
@findex digitizer_trigger_delay()
@item digitizer_trigger_delay()
The function queries (if called with no argument) or sets (if called
with an argument) the amount of pre- or post-triggering (in seconds),
i.e. the time difference between the start of the acquisition and the
trigger. Thus, if called with a positive value, the acquisitions starts
by the specified value before the trigger is received (pre-trigger
acquisition), if called with a negative value start of the acquisition
is delayed by that value relative to the trigger position (post-trigger
acquisition).

Please note that the @strong{Tektronix} oscilloscopes don't allow post-trigger
acquisitions, post-trigger acquisitions can only done with the @strong{LeCroy}
oszilloscopes (where the maximum pre-trigger delay is typically 10 times the
timebase and the maximum post-trigger delay @code{10,000} times the timebase
setting).

If called without an argument the current setting of the pre- or post-trigger
delay is returned. 

Please note that, if a trigger delay has been set and a new timebase
gets set, the program may get aborted if the requested trigger delay
isn't possible with the changed timebase setting.

The function can be called in query mode (i.e.@: without an argument)
only if either it has already been called with an argument or in the
@code{EXPERIMENT} section.



@anchor{digitizer_define_window()}
@findex digitizer_define_window()
@item digitizer_define_window()
The function must be used to define a time window to be used in later
calls of the functions to measure an area, an amplitude or to fetch a
curve from the oscilloscope. Typically, it is called with two arguments,
the starting point and the width of the window (both in seconds, where the
window width must always be positive).

For the @strong{Tektronix} oscilloscopes it also may be called with no
or only a single argument. If called with no argument the window defined
by the cursor pair on the oscilloscopes screen is used. If no width is
specified the distance between the pair of cursors is used. In both cases
the smallest possible non-zero value for the distance is used if the
cursors on the screen are exactly on top of each other.

The function returns an integer number that can be used in later calls
to address the window. Thus, you need to store this number in an integer
variable to be able to use this window in further calls of digitizer
functions.

The allowed ranges of the arguments for the start point and width of the
window depend on the timebase setting of the oscilloscope as well as
the pre- or post-trigger setting (and, for the @strong{Tektronix}
oscillosopes, the current record length or, for the @strong{LeCroy
Waverunner-2}, the memory size). The position of the trigger event
itself corresponds to a time of exactly 0. Times before the trigger are
negative, times after the trigger positive. If a window width is given
it has to be positive and the window must fit into the time interval
measured by the oscilloscope.

Because the data measured by the oscilloscope are discreet it is not
possible to specify arbitrary values for the starting point and window
width but they must fit with the current minimum time resolution. If the
specified values don't fit the requirement a warning is printed and the
position and width are adjusted to the nearest allowed values.



@anchor{digitizer_change_window()}
@findex digitizer_change_window()
@item digitizer_change_window()
This function can be used to change the position and width of an already
existing window. As the first parameter the function expects a window
number as returned by @ref{digitizer_define_window()}. The following
two arguments are the new position and width for this window. During the
experiment neither the position nor the width argument must be
specified.

For the @strong{Tektronix} oscilloscopes the function can also be called
without or with only a single argument. If no arguemnt is given the
positions of the cursor displayed on the screen are used to redefine the
windows new start position and width. If only a new start position is
given the distance between the cursors on the screen is used for the
window width.



@anchor{digitizer_window_position()}
@findex digitizer_window_position()
@item digitizer_window_position()
This function can be used to query the position or to set a new position
for an already defined window. It expects at least one argument, a window
number as returned by @ref{digitizer_define_window()}. If there is no
further argument the position of the window is returned. Otherwise the
second parameter is taken to be the new window position.



@anchor{digitizer_window_width()}
@findex digitizer_window_width()
@item digitizer_window_width()
This function can be used to query the width or to set a new width for
an already existing window. It expects at least one argument, a window
number as returned by @ref{digitizer_define_window()}. If there is no
further argument the width of the window is returned. Otherwise the
second parameter is taken to be the new window width.



@anchor{digitizer_display_channel()}
@findex digitizer_display_channel()
@item digitizer_display_channel()
This function can be used during the @code{PREPARATIONS} section to tell
the program that you want a certain channel or a set of channels to be
displayed in any case. It expects a channel name or number (or a comma
separated list of channel specifiers) as defined above. There are only
certain circumstances where this function is really needed. Normally,
the program will not switch off channels. Only if in the test run it is
found that some channels are needed for the experiment which aren't
switched on but there are already too many other channels displayed
which don't seem to be needed the program has to switch off some of
them. If in this case the program switches off a channel that you don't
want to be off (or that the program erroneously assumes to be useless)
you may have to use this function to make sure the channel stays
switched on.



@anchor{digitizer_start_acquisition()}
@findex digitizer_start_acquisition()
@item digitizer_start_acquisition()
This function starts an acquisition sequence of the oscilloscope.
Previously measured curves are discarded and new data are sampled
until the requested number of averages has been reached. The function
can only be used in the @code{EXPERIMENT} section of the @code{EDL} file.

Please note that for starting an acquisition involving averages for the
@strong{LeCroy} oscilloscopes the function @ref{digitizer_averaging()}
must have been called before starting the acquisition.


@anchor{digitizer_get_curve()}
@findex digitizer_get_curve()
@item digitizer_get_curve()
The function fetches a curve from the digitizer. It expects up to two
arguments, the channel the data are to be fetched from and, optionally,
a window ID as returned by @ref{digitizer_define_window()} to specify
the time interval. Valid choices of the data channel depend on the model
of the digitizer:
@table @samp
@item TDS520
@itemx TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@item TDS540
@itemx TDS744A
@itemx TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@item LeCroy 9400
@itemx LeCroy 9410
@itemx LeCroy 9420
@itemx LeCroy 9450
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MEM_C} or @code{MEM_D}
@item @code{FUNC_E} or @code{FUNC_F}
@end itemize
@item LeCroy 9424
@itemx LeCroy 9424E
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MEM_C} or @code{MEM_D}
@item @code{FUNC_E} or @code{FUNC_F}
@end itemize
@item LeCroy Waverunner-2 (LT262, LT372, LT582)
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MEM_A}, @code{MEM_B}, @code{MEM_C} or @code{MEM_D}
@item @code{TRACE_A}, @code{TRACE_B}, @code{TRACE_C} or @code{TRACE_D}
@end itemize
@item LeCroy Waverunner-2 (LT264, LT354, LT374)
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MEM_A}, @code{MEM_B}, @code{MEM_C} or @code{MEM_D}
@item @code{TRACE_A}, @code{TRACE_B}, @code{TRACE_C} or @code{TRACE_D}
@end itemize
@item LeCroy WaveSurfer (422, 432, 452)
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MATH}
@end itemize
@item LeCroy WaveSurfer (424, 434, 454)
@itemize @bullet
@item @code{CH1} or @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MATH}
@end itemize
@end table

Unless data from a memory channel are fetched the function only returns
after a still running acquisition sequence (started by a call of
@ref{digitizer_start_acquisition()}) is finished. The data will b
returned as an array of floating point numbers with a number of
elements depending on the current settings of the digitizer (timebase,
record lengths, memory size etc.) and possibly the window width
(if a window is to be used).

For the @strong{Tektronix} oscilloscopes the function positions the
cursors at the start and end point of the specified window (or the first
and last point if no window as been specified) to give a visual feedback.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} file.



@anchor{digitizer_get_curve_fast()}
@findex digitizer_get_curve_fast()
@item digitizer_get_curve_fast()
This function is nearly identical to the function @ref{digitizer_get_curve()}
with the only difference that the cursor are not positioned at the start and
end point of the curve to be fetched. For the @strong{LeCroy} digitizers,
where no visual feedback is used, the function is identical to
@ref{digitizer_get_curve()}.



@anchor{digitizer_get_area()}
@findex digitizer_get_area()
@item digitizer_get_area()
This function is currently not implemented for the @strong{LeCroy 9400}
oscilloscope.

The function returns the area under one of the measured curves. It
expects at least one argument, the oscilloscopes channel the data are to
be taken from. The channel that can be used depend on the model of
the digitizer:
@table @samp
@item TDS520
@itemx TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@item TDS540
@itemx TDS744A
@itemx TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4} 
@end itemize
@item LeCroy 9410
@itemx LeCroy 9420
@itemx LeCroy 9450
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MEM_C} or @code{MEM_D}
@item @code{FUNC_E} or @code{FUNC_F}
@end itemize
@item LeCroy 9424
@itemx LeCroy 9424E
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MEM_C} or @code{MEM_D}
@item @code{FUNC_E} or @code{FUNC_F}
@end itemize
@item LeCroy Waverunner-2 (LT262, LT372, LT584)
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MEM_A}, @code{MEM_B}, @code{MEM_C} or @code{MEM_D}
@item @code{TRACE_A}, @code{TRACE_B}, @code{TRACE_C} or @code{TRACE_D}
@end itemize
@item LeCroy Waverunner-2 (LT264, LT354, LT374)
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MEM_A}, @code{MEM_B}, @code{MEM_C} or @code{MEM_D}
@item @code{TRACE_A}, @code{TRACE_B}, @code{TRACE_C} or @code{TRACE_D}
@end itemize
@item LeCroy WaveSurfer (422, 432, 452)
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MATH}
@end itemize
@item LeCroy WaveSurfer (424, 434, 454)
@itemize @bullet
@item @code{CH1} or @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MATH}
@end itemize
@end table

The following, optional arguments are a list of integer variables or
1-dimensional integer arrays, where each number (or array element) is a
window ID as returned by @ref{digitizer_define_window()}, specifying
the time interval the area is computed from.

If you pass the function no argument beside the channel number the area
of the whole curve is returned. If you pass it a single window number
(either by passing it an integer variable or a one-dimensional array of
length @code{1}) the function return a floating point variable with the
area in the specified window.

Unless you want to fetch an area from a memory channel the function only
returns after an acquisition (started by a call of the function
@ref{digitizer_start_acquisition()}) has been finished.

Finally, if you pass the function more than one window identifier
(either by passing it more than one integer variable or or one or more
integer arrays), it returns a flat, 1-dimensional floating point array
with as many elements as there were window identifiers, each element
being the area for the corresponding window.

Except for the @strong{TDS520} and the @strong{LeCroy} digitizers
this function positions the cursors at the start and end point of the
specified window (or the first and last point if no window as been
specified) and uses the function built into the digitizer to compute the
area. For the @strong{TDS520} and the @strong{LeCroy} digitizers, which miss
this built-in function, the curve in the interval is fetched and then
used to compute the area. To give some visual feedback also for the
@strong{TDS520} the cursors are moved to the borders of the interval.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} file.


@anchor{digitizer_get_area_fast()}
@findex digitizer_get_area_fast()
@item digitizer_get_area_fast()
This function takes the same arguments as the function
@ref{digitizer_get_area()} and also basically does the same. The only
difference is that instead of using the function built into the
digitizer to compute the area the curve in the specified interval is
fetched and the area is computed from these data. This function can be a
bit faster because it doesn't set the cursors (which also means that
there is no visual feedback). For the @strong{LeCroy} digitizers, where
no visual feedback is used, the function is identical to
@ref{digitizer_get_area()}.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} file.



@anchor{digitizer_get_amplitude()}
@findex digitizer_get_amplitude()
@item digitizer_get_amplitude()
This function is currently not implemented for the @strong{LeCroy 9400}
oscilloscope.

The function returns the amplitude, i.e.@: the difference between the
maximum and minimum voltage, from the digitizer. The function takes at
least one argument, the channel the data are to be fetched from. Valid
choices of the data channel depend on the model of the digitizer:
@table @samp
@item TDS520
@itemx TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@item TDS540
@itemx TDS744A
@itemx TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@item LeCroy 9410
@itemx LeCroy 9420
@itemx LeCroy 9450
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MEM_C} or @code{MEM_D}
@item @code{FUNC_E} or @code{FUNC_F}
@end itemize
@item LeCroy 9424
@itemx LeCroy 9424E
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MEM_C} or @code{MEM_D}
@item @code{FUNC_E} or @code{FUNC_F}
@end itemize
@item LeCroy Waverunner-2 (LT262, LT372, LT584)
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MEM_A}, @code{MEM_B}, @code{MEM_C} or @code{MEM_D}
@item @code{TRACE_A}, @code{TRACE_B}, @code{TRACE_C} or @code{TRACE_D}
@end itemize
@item LeCroy Waverunner-2 (LT264, LT354, LT374)
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MEM_A}, @code{MEM_B}, @code{MEM_C} or @code{MEM_D}
@item @code{TRACE_A}, @code{TRACE_B}, @code{TRACE_C} or @code{TRACE_D}
@end itemize
@item LeCroy WaveSurfer (422, 432, 452)
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MATH}
@end itemize
@item LeCroy WaveSurfer (424, 434, 454)
@itemize @bullet
@item @code{CH1} or @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MATH}
@end itemize
@end table

The following, optional arguments are a list of integer variables or
1-dimensional integer arrays, where each number (or array element) is a
window ID as returned by @ref{digitizer_define_window()}, specifying
the time interval the amplitude is determined from.

If you pass the function no argument beside the channel number the
amplitude of the whole curve is returned. If you pass it a single window
number (either by passing it an integer variable or a one-dimensional
array of length @code{1}) the function returns a floating point variable
with the amplitude in the specified window.

Finally, if you pass the function more than one window identifier
(either by passing it more than one integer variable or one or more
integer arrays), it returns a flat, 1-dimensional floating point array
with as many elements as there were window identifiers, each element
being the amplitide for the corresponding window.

Unless you want to fetch an amplitude from a memory channel the function
only returns after an acquisition (started by a call of the function
@ref{digitizer_start_acquisition()}) has been finished.

Except for the @strong{TDS520} and the @strong{LeCroy} digitizers
this function positions the cursors at the start and end point of the
specified window (or the first and last point if no window as been
specified) and uses the function built into the digitizer to compute the
amplitude. For the @strong{TDS520} and the @strong{LeCroy} digitizers, that
miss this built-in function the curve in the interval is fetched and then
is used to compute the amplitude. To give some visual feedback also for
the @strong{TDS520} the cursors are moved to the borders of the interval.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} file.



@anchor{digitizer_get_amplitude_fast()}
@findex digitizer_get_amplitude_fast()
@item digitizer_get_amplitude_fast()
This function is nearly identical to @ref{digitizer_get_amplitude()}
except that the function to compute amplitudes built into the digitizer
isn't used and the cursors aren't positioned at the start and end of the
time interval. It is not implemented for the @strong{LeCroy} digitizers,
where no visual feedback is used.


@anchor{digitizer_run()}
@findex digitizer_run()
@item digitizer_run()
Usually, during an experiment the @strong{Tektronix} digitizers start
acquisitions after a call of @ref{digitizer_start_acquisition()} and
then stop when it's done. To have the digitizer running constantly
following an acquisition (at least up to the next call of
@ref{digitizer_start_acquisition()}) call this function after the
acquisition is done. It accepts no arguments and can only be used in
the @code{EXPERIMENT} section. The function does not exist for the
@strong{LeCroy} oscilloscopes.


@anchor{digitizer_copy_curve()}
@findex digitizer_copy_curve()
@item digitizer_copy_curve()
This function is available for the @strong{Tektronix} and all @strong{LeCroy}
digitizers except the @strong{LeCroy 9400}. It allows to save a curve from on
of the normal measurement or @code{MATH} / @code{FUNC} channels to one of the
@code{REF}/@code{MEM} channels. It takes two arguments, first the source
channel, i.e.@: the channel to copy the data from, which must be (depending
on the model of
the digitizer)
@table @samp
@item TDS520
@itemx TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@end itemize
@item TDS540
@itemx TDS744A
@itemx TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@end itemize
@item LeCroy 9410
@itemx LeCroy 9420
@itemx LeCroy 9450
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{FUNC_E} or @code{FUNC_F}
@end itemize
@item LeCroy 9424
@itemx LeCroy 9424E
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{FUNC_E} or @code{FUNC_F}
@end itemize
@item LeCroy Waverunner-2 (LT262, LT372, LT584)
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{TRACE_A}, @code{TRACE_B}, @code{TRACE_C} or @code{TRACE_D}
@end itemize
@item LeCroy Waverunner-2 (LT264, LT354, LT374)
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{TRACE_A}, @code{TRACE_B}, @code{TRACE_C} or @code{TRACE_D}
@end itemize
@item LeCroy WaveSurfer (422, 432, 452)
@itemize @bullet
@item @code{CH1} or @code{CH2}
@end itemize
@item LeCroy WaveSurfer (424, 434, 454)
@itemize @bullet
@item @code{CH1} or @code{CH2}, @code{CH3} or @code{CH4}
@end itemize
@end table

The second argument is the channel the data are to be copied to, i.e.@: one
from
@table @samp
@item TDS520
@itemx TDS520A
@itemx TDS540
@itemx TDS744A
@itemx TDS754A
@itemize @bullet
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@item LeCroy 9410
@itemx LeCroy 9420
@itemx LeCroy 9424
@itemx LeCroy 9424E
@itemx LeCroy 9450
@itemize @bullet
@item @code{MEM_C} or @code{MEM_D}
@end itemize
@item LeCroy Waverunner-2 (all models)
@itemize @bullet
@item @code{MEM_A}, @code{MEM_B}, @code{MEM_C} or @code{MEM_D}
@end itemize
@item LeCroy WaveSurfer (all models)
@itemize @bullet
@item @code{M1}, @code{M2}, @code{M3}, @code{M4}
@end itemize
@end table

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script and is probably most useful for being able to start
a new acquisition before fetching the data from the prvious one, thus
reducing the time required to do an experiment.



@anchor{digitizer_lock_keyboard()}
@findex digitizer_lock_keyboard()
@item digitizer_lock_keyboard()
This funtion is only available for the @strong{Tectronix} oszilloscopes.
Usually, during an experiment the keyboard of the digitizer is
locked. But for situations where it would be useful to be able to
control the digitizer also via its keyboard it can be unlocked (and also
re-locked) from within the program. To unlock the keyboard call this
function with an argument of @code{0} or @code{"OFF"}, to re-lock the
keyboard call it again with a non-zero argument, @code{"ON"} or no
argument at all.

@end table


@node Pulser Functions, Synthesizer Functions, Digitizer Functions, Device Functions
@section Pulser Functions
@cindex Pulser Functions

Currently, there are three pulser/spectrometer combinations implemented:
@itemize @bullet
@item Sony/Tektronix DG2020 (S-band spectrometer, Frankfurt/Main)
@item Sony/Tektronix DG2020 (X-band spectrometer, Berlin)
@item Tektronix HFS9003 (W-band spectrometer, Berlin)
@item Bruker EP385 Pulse Programmer (X-band spectrometer, Berlin)
@item Interface Technology RS690 (360 GHz spectrometer, Berlin)
@item Rulbus Pulser for J-band (275 GHz spectrometer), Leiden
@item Rulbus Pulser for W-band (95 GHz spectrometer), Leiden
@end itemize
To load the functions for one of these pulsers use in the @code{DEVICES}
section one of the lines
@example
dg2020_f;
dg2020_b;
hfs9003;
ep385;
rs690;
rb_pulser_j;
rb_pulser_w;
@end example

Pulsers are rather special and even the @code{EDL} syntax for dealing
with the pulsers differs slightly. Thus there is a whole chapter dealing
with pulsers and how to define and use pulses, see @ref{Using
Pulsers}. Several of the aspects of the following short descriptions of
the pulser functions will probably only become understandable after
reading the chapter about pulsers and pulses.

@strong{Please note}: Most functions for changing pulses will
@strong{not} lead to an immediate change of the pulse sequence the
pulser outputs. E.g.@: calling the function @ref{pulser_shift()} (for
moving pulses) will not shift the pulses immediately. Instead, all
changes to pulses are recorded and but only executed when the function
@ref{pulser_update()} gets called.

The reason for this is twofold: Changes to only parts of the pulses
might lead to a pulse sequence, which can't be output, e.g.@: because
pulses would collide. Thus it is necessary to wait until all changes of
pulse parameters have been done before trying to create a new pulse
sequence. The second reason is that updating the pulser can be quite a
time-consuming activity and if it would be done whenever only parts of a
more complex change of the pulse sequence is finished might increase the
time needed to do an experiment a lot.

The only functions that immediately change the pulse sequence are
@ref{pulser_update()}, @ref{pulser_reset()}, @ref{pulser_next_phase()}
and @ref{pulser_phase_reset()}. For all other functions the new state
of the pulse sequence has to be committed explicitely by calling
@ref{pulser_update()}.


@noindent
@strong{List of all pulser functions}:
@table @samp
@item @ref{pulser_name()}
@item @ref{pulser_state()}
@item @ref{pulser_channel_state()}
@item @ref{pulser_lock_keyboard()}
@item @ref{pulser_update()}
@item @ref{pulser_shift()}
@item @ref{pulser_increment()}
@item @ref{pulser_pulse_reset()}
@item @ref{pulser_next_phase()}
@item @ref{pulser_phase_reset()}
@item @ref{pulser_reset()}
@item @ref{pulser_stop_on_update()}
@item @ref{pulser_shape_to_defense_minimum_distance()}
@item @ref{pulser_defense_to_shape_minimum_distance()}
@item @ref{pulser_automatic_shape_pulses()}
@item @ref{pulser_automatic_twt_pulses()}
@item @ref{pulser_minimum_twt_pulse_distance()}
@item @ref{pulser_keep_all_pulses()}
@item @ref{pulser_maximum_pattern_length()}
@item @ref{pulser_phase_switch_delay()}
@item @ref{pulser_grace_period()}
@item @ref{pulser_show_pulses()}
@item @ref{pulser_dump_pulses()}
@item @ref{pulser_pulse_minimum_specs()}
@item @ref{pulser_minimum_defense_distance()}
@item @ref{pulser_defense_pulse_mode()}
@end table

@noindent
@strong{Descriptions of pulser functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{pulser_name()}
@findex pulser_name()

@table @samp

@item pulser_name()
Returns a string with the name of the digitizer being used.


@anchor{pulser_state()}
@findex pulser_state()
@item pulser_state()
This function can be either used to determine if the pulser is running
when called without an argument, in which case either @code{1} (i.e.@:
the pulser is running) or @code{0} (pulser is stopped) is returned. if
called with either a numerical argument or a string of @code{"ON"} or
@code{"OFF"} the pulser will be started or stopped (a numerical argument
of @code{0} stops the pulser, a non-zero argument starts it).

This function can also be called during the @code{PREPARATIONS} section
e.g.@: to keep the pulser to get started immediately at the start of
the experiment.


@anchor{pulser_channel_state()}
@findex pulser_channel_state()
@item pulser_channel_state()
For the @strong{Tektronix HFS9003} this function can be used to
determine or set the state of individual channels of the pulser. If
called with a single integer argument between @code{1} and @code{4} the
state of the corresponding channel is returned. If called with an
additional numeric argument or a string of @code{"ON"} or @code{"OFF"}
the channel can be switched on or off.


@anchor{pulser_lock_keyboard()}
@findex pulser_lock_keyboard()
@item pulser_lock_keyboard()
Usually, during an experiment the keyboard of the pulser (if it has one)
is locked. But for situations where it would be useful to be able to
control the pulser also via its keyboard it can be unlocked (and also
re-locked) from within the script. To unlock the keyboard call this
function with an argument of @code{0} or @code{"OFF"}, to re-lock the
keyboard call it again with a non-zero argument, @code{"ON"} or no
argument at all. This command is only available for the
@strong{Sony/Tektronix DG2020}.


@anchor{pulser_update()}
@findex pulser_update()
@item pulser_update()
This function has to be called after changes have been applied to pulses
either via any of the following pulser functions or by changing a pulse
property directly. Before this function is called, all changes are only
done to the internal representation of the pulser, but not yet send to
the pulser. Only by calling the function these changes are committed and
the real pulses will change.


@anchor{pulser_shift()}
@findex pulser_shift()
@item pulser_shift()
This function can be called with either no argument or with a list of
(comma separated) pulse identifiers (pulse numbers will also do). If no
argument is given the positions of all pulses which have a
@code{DELTA_START} defined and are currently active (i.e.@: don't have a
length of 0) are shifted by their respective @code{DELTA_START}. If
there is only one argument or a list of pulses only the start position
of the listed pulses are changed.


@anchor{pulser_increment()}
@findex pulser_increment()
@item pulser_increment()
This function can be called with either no argument or with a list of
(comma separated) pulse identifiers (pulse numbers will also do). If no
argument is given the lengths of all pulses which have a
@code{DELTA_LENGTH} defined and are currently active (i.e.@: don't have
a length of 0) are incremented by their respective
@code{DELTA_LENGTH}. If there is only one argument or a list of pulses
only the lengths of the listed pulses are changed.


@anchor{pulser_pulse_reset()}
@findex pulser_pulse_reset()
@item pulser_pulse_reset()
This function can be called with either no argument or with a list of
(comma separated) pulse identifiers (pulse numbers will also do). If no
argument is given all pulses are reset to their initial states, i.e.@:
the states of the pulses set in the @code{PREPARATIONS} section. The
function also does a reset of all pulse phases, as done by
@ref{pulser_phase_reset()}. It does @strong{not} update the pulser, if
you want to reset all pulses @strong{and} and also update the pulser use
the function @ref{pulser_reset()} instead.

If called with one argument or a list of pulses only the pulses from the
list are set back to their initial states.


@anchor{pulser_next_phase()}
@findex pulser_next_phase()
@item pulser_next_phase()
When the experiment starts the phases of all pulses are set to the first
phase of the phase sequence (defined in the @code{PHASE} section)
associated with the pulses. By calling this function the phases of the
pulses are switched to the next phase. By repeatedly calling the
function one can run through the complete list of phases for the pulses.

This function also immediately updates the pulse sequence, as it is done
by calling @ref{pulser_update()}.

This function is only available for pulser modules that allow phase cycling,
i.e.@: @strong{dg2020_f}, @strong{dg2020_b}, @strong{ep385}, @strong{rs690}
and @code{rb_pulser_w}.


@anchor{pulser_phase_reset()}
@findex pulser_phase_reset()
@item pulser_phase_reset()
This function can be called with either no argument or with a list of
@code{PULSE_SETUP}s numbers. A @code{PHASE_SETUP} (see also @ref{Phase
channel setup}) defines on which output connectors of the pulser the
pulses of a function with a certain phase will appear. I.e.@: if the
pulses of the @code{MICROWAVE} function are to be phase-cycled one has
to specify which of the connectors is to be used to output microwave
pulses with an @i{x}-phase, which one is to be used for microwave pulses
pulses with an @i{y}-phase etc. Pulses of not more than two functions
can be phase-cycled, so there's a maximum of two @code{PULSE_SETUP}s,
@code{PULSE_SETUP_1} and @code{PULSE_SETUP_2}. By specifying the number
@code{1} or @code{2} on can restrict resetting the phases of the pulses
of the function associated with either @code{PULSE_SETUP_1} or
@code{PULSE_SETUP_2}.

This function also immediately updates the pulse sequence, as it is done
by calling @ref{pulser_update()}.

This function is only available for pulser modules that allow phase cycling,
i.e.@: @strong{dg2020_f}, @strong{dg2020_b}, @strong{ep385}, @strong{rs690}
and @code{rb_pulser_w}.


@anchor{pulser_reset()}
@findex pulser_reset()
@item pulser_reset()
This function does not take any arguments at all. It switches the pulser
back to the initial state it was in at the start of the experiment. It
includes the complete functionality of @ref{pulser_pulse_reset()} but
also immediately updates the pulser as it is done by calling
@ref{pulser_update()}.


@anchor{pulser_stop_on_update()}
@findex pulser_stop_on_update()
@item pulser_stop_on_update()
This function exists for the @strong{Tektronix HFS9003} only. While
doing updates of the pulser to set new pulse positions and length etc.@:
it usually gets switched off. By calling this function with an argument
of @code{0} you can tell to pulser to continue even while doing
updates. If called with an argument of @code{1} you may switch back to
the default behavior.


@anchor{pulser_shape_to_defense_minimum_distance()}
@findex pulser_shape_to_defense_minimum_distance()
@item pulser_shape_to_defense_minimum_distance()
This function exists for the pulser modules @code{dg2020_b}, @code{ep385}
and @code{rs690} only, i.e.@: pulser modules that automatically can create
shape pulses. It sets the minimum allowed distance between the end of a
pulse shaper pulse and the start of a defense pulse to avoid destroying
the detector by excessive microwave power. The default minimum value for
this distance is intentionally set to an unreasonably long value and this
function allows to reduce (but also enlarge) the value. As another security
measure the function requires the user to explicitely confirm the new value
before an experiment is started. When running in batch mode this security
feature is @strong{deactivated}, @code{fsc2} will accept any value you set
without requesting a confirmation, so be careful.

This function can only be called during the @code{PREPARATIONS} section
of an @code{EDL} script.


@anchor{pulser_defense_to_shape_minimum_distance()}
@findex pulser_defense_to_shape_minimum_distance()
@item pulser_defense_to_shape_minimum_distance()
This function exists for the pulser modules @code{dg2020_b}, @code{ep385}
and @code{rs690} only. It sets the minimum allowed distance between the
end of a defense pulse and the start of a pulse shaper pulse to avoid
destroying the detector by excessive microwave power. The function also
makes sure that the time between the last defense pulse in a sequence and
the first shape pulse of the next pulse sequence does not get too short
when a very high repetition rate is used.

The default minimum value for this distance is intentionally set to an
unreasonably long value and this function allows to reduce (but also
enlarge) the value. As another security measure the function requires
the user to explicitely confirm the new value before an experiment is
started. When running in batch mode this security feature is
@strong{deactivated}, @code{fsc2} will accept any value you set without
requesting a confirmation, so be careful.

This function can only be called during the @code{PREPARATIONS} section
of an @code{EDL} script.


@anchor{pulser_automatic_shape_pulses()}
@findex pulser_automatic_shape_pulses()
@item pulser_automatic_shape_pulses()
This function exists for the pulser modules @code{dg2020_b}, @code{ep385}
and @code{rs690} only. It tells @code{fsc2} to automatically create shape
pulses in the @code{PULSE_SHAPE} function. Obviously, this requires that
a pod or channel has been assigned to the @code{PULSE_SHAPE} function. The
first (and required) argument is the function for which shape pulses
are to be created, typically this will be @code{MICROWAVE} in which case
shape pulses are created for all microwave pulses.

The shape pulses have exactly the same length as the pulses they are
created for. The pulses the shape pulses are created for in turn are
automatically lengthened a bit to make them start before their shape
pulses and also to last a bit longer.

The amount of time the pulse a pulse with an automatically generated
shape pulse will start earlier than specified in the @code{EDL} script
("left padding") can be set by the second function argument, if it is
missing a default value (set in the configuration file for the pulser)
is used. In the same way the third argument specifies how much longer
the pulse lasts  ("right padding") than the shape pulse. (It is not a
problem if the pulses should become that long that they overlap due to
padding, if necessary they are shortened.)

To make this more clear an example. Let's assume that @code{MICROWAVE}
pulse has been set in the @code{EDL} script:
@example
P1:   FUNCTION = MICROWAVE,
      START    = 400 ns,
      LENGTH   = 600 ns;
@end example
@noindent
If now the @ref{pulser_automatic_shape_pulses()} function is called as
@example
pulser_automatic_shape_pulses( MICROWAVE, 24 ns, 16 ns );
@end example
the automatically created shape pulse will start at @w{400 ns} and last
for @w{600 ns} but the microwave pulse @code{P1} will now start
@w{24 ns} earlier, i.e.@: at @w{376 ns}, and will have a length of @w{640 ns}.

The function @ref{pulser_automatic_shape_pulses()} can be called for
more than one function (e.g.@: for both the @code{MICROWAVE} and the
@code{OTHER_2} function) and also additional shape pulses can be created
manually. The only requirement is that the shape pulses (both
automatically and manually created ones) for a certain channel don't
overlap during the experiment.

This function can only be called during the @code{PREPARATIONS} section
of an @code{EDL} script.


@anchor{pulser_automatic_twt_pulses()}
@findex pulser_automatic_twt_pulses()
@item pulser_automatic_twt_pulses()
This function exists for the pulser modules @code{dg2020_b}, @code{ep385}
and @code{rs690} only. It tells @code{fsc2} to automatically create the
pulses of the @code{TWT} function at the appropriate moments, i.e.@: to
coincide with the microwave pulses. Obviously, this requires that a pod or
channel has been assigned to the @code{TWT} function. The first (and required)
argument is the function for which TWT pulses are to be created, typically
this will be @code{MICROWAVE} in which case shape pulses are created for
all microwave pulses.

Usually, the TWT pulses will have to start before the pulse for which
they were created. The amount of time the TWT pulse starts before its
associated pulse can be specified as the second argument. If there is no
second argument a default value is used as defined in the configuration
file for the pulser. The third argument is the time the automatically
created TWT pulses last longer than the associated pulse. Again, if not
specified a default value is used.

The function @ref{pulser_automatic_twt_pulses()} can be called for
more than one function (e.g.@: for both the @code{MICROWAVE} and the
@code{OTHER_2} function) and also additional TWT pulses can be created
manually. It isn't a problem if the TWT pulses would overlap, if
necessary they are shortenend.

Since TWTs often require a minimum distance between pulses the
automatically created pulses will automatically lengthened to cover too
short a distance between them. If not set via the function
@ref{pulser_minimum_twt_pulse_distance()} a compile time constant (that
can be adjusted in the configuration file for the module) is used as
the minimum TWT pulse distance.

This function can only be called during the @code{PREPARATIONS} section
of an @code{EDL} script.


@anchor{pulser_minimum_twt_pulse_distance()}
@findex pulser_minimum_twt_pulse_distance
@item pulser_minimum_twt_pulse_distance
This function exists for the pulser modules @code{dg2020_b}, @code{ep385}
and @code{rs690} only, i.e.@: pulser modules than can create automatic
TWT pulses. It can be used to set or query the minimum time the module
allows between automatically generated TWT pulses (if the distance between
TWT pulses gets shorter than this minimum time they are automatically
lengthened to cover the whole intermediate time interval). If you try to
set a time that is shorter than the default minimum time distance (as set
in the configuration file for the module) a warning is printed.

This function can be used in all sections of the script and even allows
to change the minimum time during an already running experiment repeatedly.
Please note that setting a new minimum TWT pulse distance does not
automatically change the current state of the pulses, they only get
changed to reflect the new setting when either @ref{pulser_update()} is
called or another function that automatically updates the pulser, i.e.@:
either @ref{pulser_reset()}, @ref{pulser_next_phase()} or
@ref{pulser_phase_reset()}


@anchor{pulser_keep_all_pulses()}
@findex pulser_keep_all_pulses()
@item pulser_keep_all_pulses()
Usually pulses that in the test run were found to be unused (i.e.@:
always had a length of @code{0}) are deleted and a warning message is
printed indicating this. Any further references to or use of these
deleted pulses leads to the immediate termination of the experiment. But
there are a few situations where it can't be detected reliable in the
test run that a pulse is actually needed (e.g.@: if it is only used in
an untestable @code{IF} construct) and thus the pulse gets deleted even
though it is needed. In this case you have to force the program to keep
all pulses even if it assumes them to be useless by calling this
function (without any arguments).


@anchor{pulser_maximum_pattern_length()}
@findex pulser_maximum_pattern_length()
@item pulser_maximum_pattern_length()
This function only exists for the @strong{Sony/Tektronix DG2020} pulser
(both the @code{dg2020_b} and @code{dg2020_b} module) and the
@strong{Tektronix HFS9003} pulser.

For the @strong{Bruker EP385} a maximum pattern length can't be
specified, it is fixed to 32768 times the clocks oscillation period
(i.e.@: @w{262.144 us} when using the internal clock). The
@strong{Interface Technology RS690} uses a rather different concept and
there is no maximum pattern length. Calling the function for either of
these pulsers does nothing.

For the @strong{Sony/Tektronix DG2020} the program will in most cases be
able to figure out automatically how long the length of the longest
pulse pattern in the experiment is going to be when doing the test
run. The longest pulse pattern length is needed to set up the pulser
correctly. Unfortunately, there are certain syntax constructs that make
it difficult or even impossible to find out this maximum pattern
length. These constructs are @code{FOREVER} loops and sometimes cases,
where changes of pulse positions or lengths are done within
@code{IF-ELSE} or @code{UNLESS-ELSE} constructs (please also see the
discussion of the problems introduced by @code{FOREVER} loops and
@code{IF} and @code{ELSE} constructs, @pxref{Control structures}).

Whenever there is a reason to suspect that these problems may occur one
can set the maximum pulse pattern length manually (i.e.@: the end point
of the last pulse when it has been set to its latest position during the
experiment) by calling @ref{pulser_maximum_pattern_length()} with the
the maximum pulse pattern length as the only argument.

Unless in the test run an even longer pattern length is found, this
value is used. It is not a problem to specify too long a maximum pattern
length, so a conservative guess will do. The only penalty incurred is
longer time needed to set up the pulser at the start of the
experiment. On the other hand, too short a pattern length will lead to
the experiment being stopped with an error message when the actual
pattern length becomes larger than the one specified.

In contrast with the @strong{Tektronix HFS9003} pulser the pattern
length is per default set to the maximum possible length of 65536 times
the time constant. If your pulse pattern is shorter than this length and
using the defualt length isn't desirable (e.g.@: because you need a
higher repetition rate) you can shorten the length of the pulse sequence
by using this function.


@anchor{pulser_phase_switch_delay()}
@findex pulser_phase_switch_delay()
@item pulser_phase_switch_delay()
This function is only implemented for the Frankfurt version the
@strong{Sony/Tektronix DG2020} pulser, @code{dg2020_f} and the W-band
configuration of the @strong{Rulbus pulser}, @code{rb_pulser_w}. It lets
you specify the time a phase pulse has to start before the beginning of
a microwave pulse (or other phase cycled pulses), the phase switch
needing some small amount of time to settle.

For the @code{dg2020_f} module the function takes two arguments, the first
one being the phase function the phase switch delay is to be applied to
(i.e.@: either @code{PHASE_1} (or @code{PHASE} for short) or @code{PHASE_2}).
The second argument is the amount of time.

For the W-band @strong{Rulbus pulser} (module @code{rb_pulser_w} only the
amount of time is to be specified, no further arguments are allowed (only
microwave pulses can be phase-cycled, so only a single phase function is
used).

When this function isn't called a default value as specified in the
configuration file for the device is used.

When the program does its tests it will always check if the distances
between the pulses are large enough to allow setting the phase
pulses. If the pulse distances get too short to set the phase switch
delays the program will abort with an error message.

The function can only be called during the @code{PREPARATIONS} section
of an @code{EDL} script.


@anchor{pulser_grace_period()}
@findex pulser_grace_period()
@item pulser_grace_period()
This function is only implemented for the Frankfurt version the
@strong{Sony/Tektronix DG2020} pulser, @code{dg2020_f}, and the W-band
configuration of the @strong{Rulbus pulser}, @code{rb_pulser_w}.  While
the time a phase pulse must start before the pulse it was set for can is
supposed to start via the @ref{pulser_phase_switch_delay()} function, you
also may set how much longer a phase (pulse) has to be kept set after the
original pulse ended.

The function takes only one argument, the time the phase pulses will last
after the end of the pulse. For the @code{dg2020_f} module it applies
automatically to both phase functions while for the @code{rb_pulser_w}
only the @code{MICROWAVE} function allows phase switching.

If this function isn't called a default grace period as defined in the
configuration file for the device will be used.

Here's a diagram that shows the phase switch delay and the grace period
for the @code{dg2020_f} module (assuming that the microwave pulses are
to be phase-cycled):
@example
                   ____________________________
                  |                            |
Phase pulse       |                            |
             _____|                            |_________
                           _________________
                          |                 |
Microwave pulse           |                 |
             _____________|                 |____________
         
                ->|       |<-             ->|  |<-
               phase switch delay        grace period
@end example

When the program does its tests it will always check if the distances
between the pulses are large enough to allow setting the phase
pulses. If the pulse distances get very small it may drop the grace
period.

The function can only be called during the @code{PREPARATIONS} section
of an @code{EDL} script.


@anchor{pulser_show_pulses()}
@findex pulser_show_pulses()
@item pulser_show_pulses()
This function allows to view the pulses as they become set during the
test run. If this function is called an additional window pops up after
the end of the test run which shows the position of all pulses at the
start of the experiment. By using the (fast) forward and backward)
buttons, the @w{@code{<PAGE UP>}} and @w{@code{<PAGE DOWN>}} as well as
the @code{<HOME>} and @code{<END}> keys) you may view all pulse settings
during the experiment (as far as they can be determined during the test
run). Alternatively, the step number can be edited directly.

By using the @code{Show delays} button you can switch between a display
where the pulses are shown at their "logical" positions (as they would
be set if there would be no delays) and the positions at which they,
due to delays really will be set.

In an additional window the paramters of the pulse the mouse is currenty
positioned on are displayed. These include the pulse number (when the
pulse number is enclosed in parentheses it's an automatically created
pulse, the number itself is identical to the pulse number of the pulse
it was created for), the positions with and without delays (depending on
the current setting of the @code{Show delays} button, in parentheses the
value for the other button state is shown), the pulse length, its
function and the number of the pod or channel to which the pulse will be
routed.

Further informations are the edge-to-edge distance to the previous and
the next pulse (in parentheses the center-to center distance) is shown.

Finally, for automatically created pulses informations about the parent
pulse, i.e.@: the pulse for which this pulse was created for, are
displayed. 

The function uses the @code{fsc2_pulses} program to display the pulse
settings. @code{fsc2_pulses} only works if both Perl and Perl/Tk (in not
too ancient a version) is installed on the system.

When running in batch mode this function does nothing.

This function can only be called during the @code{PREPARATIONS} section
of an @code{EDL} script.


@anchor{pulser_dump_pulses()}
@findex pulser_dump_pulses()
@item pulser_dump_pulses()
This function requests the user to select a file name and then writes
all pulse settings during the test run into the file in a format
suitable to be used as input for the @code{fsc2_pulses} utility.

When running in batch mode this function does nothing.

This function can only be called during the @code{PREPARATIONS} section
of an @code{EDL} script.


@anchor{pulser_pulse_minimum_specs()}
@findex pulser_pulse_minimum_specs()
@item pulser_pulse_minimum_specs()
This function is available only for the @strong{Rulbus pulser} modules, i.e.@:
the pulsers used with the J-band and W-band spectrometers in Leiden. It
expects a single argument, a pulse, e.g. @code{P1}. If it is the first
pulse of a function (i.e.@: @code{MICROWAVE}, @code{RF} or @code{DETECTION}),
the function returns the earliest possible absolute position of the pulse.
For all later pulses, the minimum distance to the end of the previous
pulse is returned. Please note that the minimum positions of both the
@code{RF} pulse and the detection pulse depend on the position of the
first @code{MW} pulse, so after changes of the position of this pulse
minimum start positions for the @code{RF} and detection pulses have to
be recalculated.

This function can only be called during the @code{EXPERIMENT} section
of an @code{EDL} script.


@anchor{pulser_minimum_defense_distance()}
@findex pulser_minimum_defense_distance()
@item pulser_minimum_defense_distance()
This function exists only for the W-band configuration of the @strong{Rulbus
pulser}, @code{rb_pulser_w}. Unless explicitely forbidden by a call of
@ref{pulser_defense_pulse_mode()} with the appropriate argument, for this
module a defense pulse is created automatically, lasting from the start of
the pulse pattern to some time after end of the last microwave pulse, in
order to protect amplifiers and receivers from excessive levels of microwave
power. Using this function the minimum distance between the end of the last
microwave pulse and the end of the defense pulse can be set (this time can
end up being be slightly longer, up to the length of the timebase of the
pulser).

If this function isn't called a default minimum time as defined in the
configuration file for the device will be used.

This function can only be called during the @code{PEPARATIONS} section
of an @code{EDL} script.


@anchor{pulser_defense_pulse_mode()}
@findex pulser_defense_pulse_mode()
@item pulser_defense_pulse_mode()
This function exists only for the W-band configuration of the @strong{Rulbus
pulser}, @code{rb_pulser_w}. For this module a defense pulse, starting at the
very start of the pulse pattern and lasting to some time after end of the
last microwave pulse, is created in order to protect amplifiers and receivers
from excessive levels of microwave power. But in some situations such an
aautomatic creation of a defense pulse is not desirable, in which case this
function can be called during the @code{PREPARATIONS} section of the
@code{EDL} script before a defense pulse is defined. It can be called with
a string argument of either @code{"AUTOMATIC"} or @code{"MANUAL"} (or an
integer argument of @code{0} or @code{1}). Calling it with the argument
@code{"AUTOMATIC"} isn't really useful since this is the default (and
switching back to automatic creation isn't possible once the function has
been called with the @code{"MANUAL"} argument). To be able to create the
defense pulse yourself and later control its length you need to call the
function with an argument of @code{"MANUAL"}. Please note that you only
can set the length of the defense pulse, it's position is fixed to the
very start of the pulse pattern. Calling it with this argument and not
defining a defense pulse at all allows to avoid the creation of a defense
pulse.

Once in manual mode the module does not evaluate the value set by a call
of @ref{pulser_minimum_defense_distance()} anymore - the user is now
completely responsible for setting the correct length of the defense pulse.

If the function has been called with the argument @code{"MANUAL"} the user
will always explicitely asked if the defense pulse is really to be created
manually.


@end table



@node Synthesizer Functions, Temperature Controller Functions, Pulser Functions, Device Functions
@section Synthesizer Functions
@cindex Synthesizer Functions
Supported synthesizers so far are the @strong{Hewlett-Packard} models
@strong{HP8647A}, @strong{HP8648B} and @strong{HP8672A} and the
@strong{Rohde&Schwarz SML01}. Their modules are loaded by
specifying
@example
hp8647a
hp8648b
hp8672a
rs_sml01
@end example
@noindent
in the @code{DEVICES} section.


@noindent
@strong{List of all synthesizer functions}:
@table @samp
@item @ref{synthesizer_name()}
@item @ref{synthesizer_state()}
@item @ref{synthesizer_frequency()}
@item @ref{synthesizer_attenuation()}
@item @ref{synthesizer_minimum_attenuation()}
@item @ref{synthesizer_step_frequency()}
@item @ref{synthesizer_sweep_up()}
@item @ref{synthesizer_sweep_down()}
@item @ref{synthesizer_reset_frequency()}
@item @ref{synthesizer_use_table()}
@item @ref{synthesizer_att_ref_freq()}
@item @ref{synthesizer_modulation()}
@item @ref{synthesizer_mod_type()}
@item @ref{synthesizer_mod_source()}
@item @ref{synthesizer_mod_freq()}
@item @ref{synthesizer_mod_ampl()}
@item @ref{synthesizer_pulse_state()}
@item @ref{synthesizer_pulse_trigger_slope()}
@item @ref{synthesizer_pulse_width()}
@item @ref{synthesizer_pulse_delay()}
@end table

@noindent
@strong{Descriptions of synthesizer functions}:


@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{synthesizer_name()}
@findex synthesizer_name()

@table @samp

@item synthesizer_name()
Returns a string with the name of the synthesizer being used.


@anchor{synthesizer_state()}
@findex synthesizer_state()
@item synthesizer_state()
The function queries or sets the output state of the synthesizer. i.e.@:
to switch output of RF on or off. If called to set the output state it
accepts one argument, either a non-zero value or the string @code{"ON"}
to switch output on, or zero or the string @code{"OFF"} to switch it
off. The synthesizer output is never switched on automatically!

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e.@: without an argument (unless the state has already been
set by calling the function with an argument). In query mode it either
returns either @code{1} or @code{0} to indicate the on/off state of the
RF output.


@anchor{synthesizer_frequency()}
@findex synthesizer_frequency()
@item synthesizer_frequency()
The function queries or sets the RF output frequency. If called to set
the frequency it accepts a frequency as the only argument. For the
@strong{HP8647A} the frequency must be in the range between @w{250 kHz}
and @w{1000 MHz}, for the @strong{HP8648B} between @w{10 kHz} and @w{2 GHz}
and for the @strong{HP8672A} between @w{2 GHz} and @w{18 GHz}. For the
@strong{Rohde&Schwarz} model @strong{SML01} the frequency range is @w{9 KHz}
to @w{1.1 GHz}.

If a attenuation table is used (@ref{synthesizer_use_table()} then on
setting a frequency also the attenuation is corrected according to the
setting in the attenuation table for the frequency.

The frequency set by the very first call of this function is also the
function that is set automatically by a call of the function
@ref{synthesizer_reset_frequency()}.

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e.@: without an argument (unless the frequency has already
been set by calling the function with an argument). For the
@strong{HP8672A} the function can be called in query mode only when the
frequency has been set previously.


@anchor{synthesizer_attenuation()}
@findex synthesizer_attenuation()
@item synthesizer_attenuation()
The function queries or sets the output attenuation. The function always
sets the attenuation as given in the argument or returns the value that
currently is set, independent of the use of an attenuation table.

If called without an argument the currently set attenuation is returned.
To set the attenuation the function must be called with one argument, the
attenuation.

For the @strong{HP8647A} the attenuation must be in the range between
@w{+10 dB} and @w{-136 dB} with a resolution of @w{0.1 dB}, for the
@strong{HP8648B} between @w{+14.5 dB} and @w{-136 dB} (with the same
resolution) and for the @strong{HP8672A} between @w{+3 dB} and
@w{-120 dB} with a resolution of @w{1 dB}.

For the @strong{Rohde&Schwarz} the allowed range of attenuations is from
@w{+13 dBm} to @w{- 140 dBm} with a resolution of @w{0.1 dBm}.

Currently for the @strong{HP8647A} the minimum attenuation that can be set
from an @code{EDL} script is limited to @w{-5 dB}, should you need lower
attenuations change the definition of @code{MIN_ATTEN} in the
configuration file for the device.

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e.@: without an argument (unless the attenuation has already
been set by calling the function with an argument). For the
@strong{HP8672A} the function can be called in query mode only when the
attenuation has been set previously.


@anchor{synthesizer_minimum_attenuation()}
@findex synthesizer_minimum_attenuation()
@item synthesizer_minimum_attenuation()
The function can be used to restrict the minimum output attenuation to
avoid to inadvertently set too high output power levels. It can be
called to both query and sets the minimum output attenuation. If called
to set the attenuation it accepts one argument, the attenuation within
the allowed range of attenuations of the device. Calling the function
disables setting the attenuation by further calls of
@ref{synthesizer_attenuation()} to ranges below the value set by this
function.


@anchor{synthesizer_step_frequency()}
@findex synthesizer_step_frequency()
@item synthesizer_step_frequency()
The function queries or sets the RF step frequency to be used in calls
of the functions @ref{synthesizer_sweep_up()} and
@ref{synthesizer_sweep_down()} (see below). In order to set the step
frequency it expects one argument, the step frequency in Hz. The step
frequency can be set in the @code{PREPARATIONS} section only once, but
it can be changed later in the @code{EXPERIMENT} section.

Before the step frequency has been set by calling the function with an
argument the query form of the function (i.e.@: calling it without an
argument can't be used).


@anchor{synthesizer_sweep_up()}
@findex synthesizer_sweep_up()
@item synthesizer_sweep_up()
If there has been set both a frequency and a step frequency the function
will increment the synthesizers frequency. It returns the newly set
frequency. The function can only be called in the @code{EXPERIMENT}
section.


@anchor{synthesizer_sweep_down()}
@findex synthesizer_sweep_down()
@item synthesizer_sweep_down()
If there has been set both a frequency and a step frequency the function
will decrement the synthesizers frequency. It returns the newly set
frequency. The function can only be called in the @code{EXPERIMENT}
section.


@anchor{synthesizer_reset_frequency()}
@findex synthesizer_reset_frequency()
@item synthesizer_reset_frequency()
If a frequency has been set at all the function will reset the
synthesizers frequency to the frequency that has been set at first. The
function can only be called in the @code{EXPERIMENT} section.


@anchor{synthesizer_use_table()}
@findex synthesizer_use_table()
@item synthesizer_use_table()
This function tells the program to also adjust the attenuation when a
new frequency is set. To find out which attenuation has to be set for a
new frequency a table file is used. The name of this table file can be
passed to the function as a (string) argument. If no argument is given a
default table file is used (typically this is
@file{/usr/local/lib/fsc2/hp8647a.table} for the @strong{HP8647A},
@file{/usr/local/lib/fsc2/hp8648b.table} for the @strong{HP8648B},
@file{/usr/local/lib/fsc2/hp8672a.table} for the @strong{HP8672A} and
@file{/usr/local/lib/fsc2/rs_sml01.table} for the @strong{Rhode&Schwarz
SML01}, but this may depend on the installation of @code{fsc2}).

The table file must consist of pairs of entries, a frequency and a
corresponding attenuation in db. The attenuation is being added to the
'raw' attenuation, i.e.@: to achieve an higher attenuation and a lower
output power a negative attenuation has to be specified.  If no unit are
given in the table file (i.e.@: @code{MHz} and @code{dB}) the first
member of an entry must be the frequency, the second the attenuation.
The entries in the file don't have to be sorted in any way, and
the frequencies don't have to spaced equally.

The items in the table file can be separated by spaces, commas,
semicolons, colons, tabs or newlines or any combination of these
characters (a unit will also work as a separator) and the entries don't
have to be separated by a newline. Thus all the following entries would
be valid:
@example
7.90000000 MHz,   -1.90000000 db
-2.10000000 db 8.00000000 MHz   
8.1E6 -2.2 8.20000000 MHz : -2.30000000 db 8300 kHz

   -2.4 db
8.70000000MHz-2.40000000db
@end example
@noindent
As you see also blank lines don't matter. Finally, all lines starting
with a hash character, `@code{#}', are treated as comments.

If a frequency is used that isn't in the table the attenuation to be used
is extrapolated from the next neighboring frequencies. If the frequency
isn't within the range of frequencies covered by the table a warning is
printed and the attenuation for the nearest frequency is used.


@anchor{synthesizer_att_ref_freq()}
@findex synthesizer_att_ref_freq()
@item synthesizer_att_ref_freq()
When a table file is used there remains the question for which frequency to
use the attenuation has been set e.g.@: by @ref{synthesizer_attenuation()}.
To set this reference frequency the function @ref{synthesizer_att_ref_freq()}
can be used. If the function isn't called a frequency of @w{14 MHz} is used
for the @strong{HP8647A}, @strong{HP8648B} and @strong{R&S SML01} and @w{2 GHz}
for the @strong{HP8672A} (but this is a compile time constant that can be
adjusted in the configuration file for the device by changing the definition
of @code{DEF_ATT_REF_FREQ}).


@anchor{synthesizer_modulation()}
@findex synthesizer_modulation()
@item synthesizer_modulation()
Using this function for the @strong{HP8647A}, @strong{HP8648B} and @strong{RS
SML01} the type, source and amplitude of the modulation can be set, for
the @strong{HP8672A} both type and amplitude. It can set all of these
parameters at once or only a subset of them.

For the @strong{HP8647A}, @strong{HP8648B} and @strong{R&S SML01} there are
four possible types of modulation: FM, AM and phase modulation. The
modulation type is specified by a string, either @code{"FM"},
@code{"AM"}, @code{"PHASE"} or, finally, @code{"OFF"} to switch off
modulation. For the @strong{HP8672A} @code{"FM"}, @code{"AM"} and
@code{"OFF"} can be used.

Please note that setting a modulation source or amplitude while the
modulation is off (i.e.@: when @code{"OFF"} has been specified as the
modulation type) is not possible and trying to do so will make the
program abort.

For the @strong{HP8647A} and @strong{HP8648B} the possible modulation
sources are either external AC coupled, external DC coupled, internal
@w{1 kHz} or internal @w{400 Hz}. For external AC or DC coupled
modulation specify one the strings @code{"EXT AC"}, @code{"AC"},
@code{"EXT DC"} or @code{"DC"}. For internally generated modulation with
@w{1 kHz} or @w{400 Hz} use a string argument from the following list:
@code{"INT 1kHz"}, @code{"INT 1 kHz"}, @code{"INT 1"}, @code{"1kHz"},
@code{"1 kHz"}, @code{"1"}, @code{"INT 400Hz"}, @code{"INT 400 Hz"},
@code{"INT 400"}, @code{"400Hz"}, @code{"400 Hz"} or @code{"400"}. But
please note: external DC coupled modulation source does not work with
amplitude and phase modulation@!

For the @strong{HP8672A} no modulation source can be specified.

For the @strong{Rohde&Schwarz} model @strong{SML01} the possible modulation
sources are also either external AC coupled (specified by either,
@code{"EXT AC"} or @code{"AC"}), external DC coupled (use @code{"EXT
DC"} or just @code{"DC"}) and internal (specified by the string
@code{"INT}). For internal modulation the function expects another
argument, directly following the argument specifying the internal
modulation source, the frequency of the internal modulation, which can
be in the range between @w{0.1 Hz} and @code{1 MHz}.

Finally you may specify the modulation amplitude, which has to be a
number (preferably a floating point number). For the @strong{HP8647A} FM
and @strong{HP8648B} modulation amplitudes have to be in the range between
@w{0 Hz} and @w{100 kHz}, AM modulation amplitudes between @w{0%} and
@w{100%} and phase modulation amplitudes between @w{0 degree} and @w{10
degree}.

For the @strong{HP8672A} FM modulation can be set to either @w{30 kHz},
@w{100 kHz}, @w{300 kHz}, @w{1 MHz}, @w{3 MHz} or @w{10 MHz}. AM
modulation can only be set to either @w{30%} or @w{100%}.

For the @strong{Rohde&Schwarz SML01} AM modulations between
@w{0%} and @w{100%} can be used. Both the ranges of FM and phase modulation
depend on the RF frequency. For frequencies below @w{76 MHz} and above
@w{605.25 MHz} FM modulation amplitudes between @w{0 Hz} and @w{1 MHz}
and phase modulation amplitutes between @w{0 rad} and @w{10 rad} can be
used. In the frequency range above @w{76 MHz} and up to @w{151.3125 MHz}
the upper limits for the modulation amplitude levels are @w{125 kHz} and
@w{1.25 rad}, respectively. In the frequency range above @w{151.3125 MHz}
and up to @w{302.625 MHz} the upper limits are @w{250 MHz} and @w{2.5
rad}. Finally, between @w{302.625 MHz} and @w{605.25 MHz} the upper
limits for FM and phase modulation are @w{500 kHz} and @w{5
rad}. Because the allowed ranges (at least for FM and phase modulation)
depend on the RF frequency it is required that a RF frequency must be
known before the modulation amplitide can be set.

Only in the first call of the function all two or three arguments,
i.e.@: the modulation type, amplitude and source (if applicable) should
be passed to the function. In further calls not all of the arguments
must be specified again. Instead, in further calls it is sufficient to
specify only for example a new amplitude. The same, of course, holds for
the modulation source.

If the modulation type becomes changed, the source and amplitude reverts
to the settings that were specified in previous calls of the function
when this modulation type was still active. I.e.@: if e.g.@: for the
@strong{HP8647A} at first AM modulation using an external AC coupled
source and an amplitude of @w{50%} was set and then the modulation was
changed to FM with different settings for source and amplitude, another
call switching back to AM modulation will also restore the settings of
external AC coupled source and @w{50%} amplitude.


@anchor{synthesizer_mod_type()}
@findex synthesizer_mod_type()
@item synthesizer_mod_type()
As an alternative to the function @ref{synthesizer_modulation()} the
modulation type can be also set via the function @ref{synthesizer_mod_type()}.
It accepts a string argument, either @code{"FM"} for frequency modulation,
@code{"AM"} for amplitude modulation or @code{"OFF"} to switch off
modulation. The @strong{HP8647A}, @strong{HP8648B} and @strong{R&S SML01} also
allow another argument, @code{"PHASE"} for phase modulation.


@anchor{synthesizer_mod_source()}
@findex synthesizer_mod_source()
@item synthesizer_mod_source()
This function is only available for the @strong{HP8647A}, @strong{HP8648B}
and the @strong{R&S SML01}. If the modulation type has been set before the
modulation source can be set directly via this function.

The function accepts the strings @code{"OFF"} to switch off modulation,
@code{"EXT AC} (or just simply @code{"AC"}) to use an external AC
coupled modulation source and @code{"EXT DC} (or @code{"DC"}) for an
external DC coupled modulation source.

For both the @strong{HP8647A} and the @strong{HP8648B} it also accepts one
of the following strings for the internal modulation settings that are
available for these devices: @code{"INT 1kHz"}, @code{"INT 1 kHz"},
@code{"INT 1"}, @code{"1kHz"}, @code{"1 kHz"}, @code{"1"}, @code{"INT
400Hz"}, @code{"INT 400 Hz"}, @code{"INT 400"}, @code{"400Hz"},
@code{"400 Hz"} or @code{"400"}.

To set up use of the internal modulation source of the @strong{R&S SML01}
pass the function either two arguments, first the string @code{"INT"}
and second the modulation frequency (between @w{0.1 Hz} and @w{1 MHz}),
or just a single argument, the modulation frequency.

If the function is called with no argument it will return the modulation
source setting for the currently active modulation type as an integer
number. It returns @code{0} for an external, AC coupled modulation
source and @code{1} for an external, DC coupled source. For the
@strong{HP8647A} and the @strong{HP8648B} @code{3} is returned for intenal
modulation with @w{400 Hz} and @code{4} for @w{1 kHz}.  For the
@strong{R&S SML01} a return value of @code{3} indicates internal
modulation. To find out the frequency of the modulation for this device
use the function @ref{synthesizer_mod_freq()}.

You can neither set nor obtain the modulation source as long as the
modulation is switched off, trying to do so will result in aborting the
program.


@anchor{synthesizer_mod_freq()}
@findex synthesizer_mod_freq()
@item synthesizer_mod_freq()
This function only exists for the @strong{Rohde&Schwarz SML01} synthesizer. It
can be used to change the modulation frequency if modulation is switched on
and the synthesizer has been set up to use the internal oszillator as the
modulation source (otherwise the function will print out a warning message and
do nothing else). It expects a single argument, the modulation frequency,
which must be between @w{0.1 Hz} and @w{1 MHz}.

If called without an argument the function returns the currently used
modulation frequency - this only works when the device is set up to use
internal modulation, if this isn't the case the function will print an
error message and abort the experiment.

You can neither set nor obtain the modulation frequency as long as the
modulation is switched off, trying to do so will result in aborting the
program.


@anchor{synthesizer_mod_ampl()}
@findex synthesizer_mod_ampl()
@item synthesizer_mod_ampl()

If the modulation type has been set this function can be used to set the
modulation amplitude. For the @strong{HP8647A} and @strong{HP8648B} the
allowed range of FM frequencies is from @w{0 Hz} to @w{100 kHz}, for AM
amplitudes between @w{0%} and @w{100%} are acceptable and for phase
modulation values between @w{0 degree} and @w{10 degree} are valid.

For the @strong{HP8672A} FM modulation can be set to either @w{30 kHz},
@w{100 kHz}, @w{300 kHz}, @w{1 MHz}, @w{3 MHz} or @w{10 MHz}. AM
modulation can only be set to either @w{30%} or @w{100%}.

For the @strong{Rohde&Schwarz SML01} AM modulations between @w{0%} and
@w{100%} can be used. Both the ranges of FM and phase modulation depend on the
RF frequency. For frequencies below @w{76 MHz} and above @w{605.25 MHz} FM
modulation amplitudes between @w{0 Hz} and @w{1 MHz} and phase modulation
amplitutes between @w{0 rad} and @w{10 rad} can be used. In the frequency
range above @w{76 MHz} and up to @w{151.3125 MHz} the upper limits for the
modulation amplitude levels are @w{125 kHz} and @w{1.25 rad}, respectively. In
the frequency range above @w{151.3125 MHz} and up to @w{302.625 MHz} the upper
limits are @w{250 MHz} and @w{2.5 rad}. Finally, between @w{302.625 MHz} and
@w{605.25 MHz} the upper limits for FM and phase modulation are @w{500 kHz}
and @w{5 rad}.

If called with no argument, the function will return the amplitude
setting for the currently active modulation type. You can neither set
nor obtain the modulation amplitude as long as the modulation is
switched off, trying to do so will result in aborting the program.


@anchor{synthesizer_pulse_state()}
@findex synthesizer_pulse_state()
@item synthesizer_pulse_state()
This function is only available for the @strong{Rohde&Schwarz SML01}
synthesizer with @strong{SML-B3} option. These devices have a pulse
modulation mode that allows th creation of RF pulses of user defined
length and position. The function allows to query or switch on or off
this pulse mode. If called without an argument it returns @code{1} or
@code{0} if pulse modulation mode is on or off. If called with an
argument of @code{"ON"} or @code{1} pulse modulation mode is switched
on, if called with an argument of @code{"OFF"} or @code{1} pulse
modulation mode is switched off.


@anchor{synthesizer_pulse_trigger_slope()}
@findex synthesizer_pulse_trigger_slope()
@item synthesizer_pulse_trigger_slope()
This function is only available for the @strong{Rohde&Schwarz SML01}
synthesizer with @strong{SML-B3} option. This function can be used to
query or set if the trigger leading to the creation a RF pulse is
detected on the raising or falling edge of an external trigger input.
If called with no argument the function returns @code{1} when the
trigger is detected on the positive (raising) edge, and @code{0} when
it's detected on the falling edge. When called with the string argument
@code{"POSITIVE"} or @code{"POS"} the device is set up to detect
triggers on the raising edge of the trigger input, when called with
the argument @code{"NEGATIVE"} or @code{"NEG"} triggers are detected on
the falling edge.

@anchor{synthesizer_pulse_width()}
@findex synthesizer_pulse_width()
@item synthesizer_pulse_width()
This function is only available for the @strong{Rohde&Schwarz SML01}
synthesizer with @strong{SML-B3} option. It allows to query or set the
length of the RF pulse generated by the synthseizer in pulse modulation
mode. If called with no argument the length of the RF pulse is returned.
If called with a (floating point) argument the pulse length is set
accordingly. The pulse length must be between @w{20 ns} and @w{1.3 s}.


@anchor{synthesizer_pulse_delay()}
@findex synthesizer_pulse_delay()
@item synthesizer_pulse_delay()
This function is only available for the @strong{Rohde&Schwarz SML01}
synthesizer with @strong{SML-B3} option. It allows to query or set the
delay between receiving an external trigger and the creation of the RF
pulse. If called with no argument the value of this delay is returned.
If called wih a (floating point) argument the delay is set accordingly.
The delay must be betwen @w{20 ns} and @w{1.3 s}. Please note that the
device will always add another intrinsic delay of about @w{50 ns} to
this value.


@end table



@node Temperature Controller Functions, Multimeter Functions, Synthesizer Functions, Device Functions
@section Temperature Controller Functions
@cindex Temperature Controller Functions
The only currently implemented temperature controllers are the @strong{Lake
Shore 330} and the @strong{Oxford Instruments ITC503}. Their modules get
loaded by specifying
@example
lakeshore330
itc503
@end example
@noindent
in the @code{DEVICES} section. All functions for the temperature
controllers can only be used in the @code{EXPERIMENT} section of
the @code{EDL} script.


@noindent
@strong{List of all temperature controller functions}:
@table @samp
@item @ref{temp_contr_name()}
@item @ref{temp_contr_temperature()}
@item @ref{temp_contr_sample_channel()}
@item @ref{temp_contr_sensor_unit()}
@item @ref{temp_contr_lock_keyboard()}
@end table

@noindent
@strong{Descriptions of temperature controller functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{temp_contr_name()}
@findex temp_contr_name()

@table @samp

@item temp_contr_name()
Returns a string with the name of the temperature controller being used.


@anchor{temp_contr_temperature()}
@findex temp_contr_temperature()
@item temp_contr_temperature()
This function accepts no arguments and returns the temperature at the
currently active sample channel and with the currently selected unit.

If no sample channel has been selected for the @strong{Lake Shore 330}
channels @code{B} is used by default, while for the @strong{Oxford Instruments
ITC503} the default channel is channel @code{1}. When no temperature unit has
been selected temperatures are returned in Kelvin.


@anchor{temp_contr_sample_channel()}
@findex temp_contr_sample_channel()
@item temp_contr_sample_channel()
This function returns, when called with no argument, the currently
selected sample channel. For the @strong{Lake Shore 330} it returns
@code{1} for channel @code{A} and @code{2} for channel @code{B} while
for the @strong{Oxford Instruments ITC503} @code{1}, @code{2} or @code{3}
get returned, indicating which of sample channel is selected. These values
can also passed to the function to set a new sample channel.
Alternatively, one may also use the strings @code{"A"} or @code{"B"}
(and @code{"C"} for the third channel of the @strong{Oxford Instruments
ITC503}).

Please take note that setting a sample channel takes about half a second
with the @strong{Lake Shore 330}. For the @strong{Oxford Instruments ITC503}
not all sample channels may be usable, there are models with different numbers
of channels and this number is a compile time option that has to be set
in the configuration file for the device.


@anchor{temp_contr_sensor_unit()}
@findex temp_contr_sensor_unit()
@item temp_contr_sensor_unit()
The function either returns or sets the units returned by the device on
temperature readings. If used to set a unit the function must be called
with the value @code{0} or @code{"K"} to set the unit to Kelvin,
@code{1} or @code{"C"} to set to degree Celsius. The @strong{Lake Shore
330} also allows to select the most appropriate unit for the sensor 
(volts for diodes, Ohms for RTD or milli-Volts for thermocouples) by
passing the function an argument of @code{2} or @code{"S"}.

The function always return the unit setting as an integer value with
@code{0} for Kelvin, @code{1} for degree Celsius, or, for the @strong{Lake
Shore 330} only, @code{2} for Volts, @code{3} for Ohms and @code{4} for
milli-Volts.


@anchor{temp_contr_lock_keyboard()}
@findex temp_contr_lock_keyboard()
@item temp_contr_lock_keyboard()
Usually, during an experiment the keyboard of the temperature controller
is locked. But for situations where it would be useful to be able to
control the device also via its keyboard it can be unlocked (and also
re-locked) from within the script. To unlock the keyboard call this
function with an argument of @code{0} or @code{"OFF"}, to re-lock the
keyboard call it again with a non-zero argument, @code{"ON"} or no
argument at all.

@end table



@node Multimeter Functions, Boxcar Integrator Functions, Temperature Controller Functions, Device Functions
@section Multimeter Functions
@cindex Multimeter Functions
The only currently supported digital multimeters are the @strong{Kontron 4060}
and the @strong{Schlumberger 7150}. The modules are loaded by specifying
@example
kontron4060
schlumberger7140
@end example
@noindent
in the @code{DEVICES} section.

@noindent
@strong{List of all multimeter functions}:
@table @samp
@item @ref{multimeter_name()}
@item @ref{multimeter_mode()}
@item @ref{multimeter_precision()}
@item @ref{multimeter_get_data()}
@item @ref{multimeter_ac_measurement()}
@item @ref{multimeter_dc_measurement()}
@item @ref{multimeter_lock_keyboard()}
@end table

@noindent
@strong{Descriptions of multimeter functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{multimeter_name()}
@findex multimeter_name()

@table @samp

@item multimeter_name()
Returns a string with the name of the multimeter being used.


@anchor{multimeter_mode()}
@findex multimeter_mode()
@item multimeter_mode()
If called with no argument the function returns the currently set measurement
mode (as an integer), if called with an argument the mode gets set. For the
@strong{Kontron 4060} voltmeter the possible arguments are either the string
@code{"Vdc"} (or the integer number @code{0}) to switch to DC voltage mode
or the string @code{"Vac"} (or the integer @code{1}) to switch to AC voltage
mode. For the @strong{Schlumbreger 7150} additional possible arguments are
the strings @code{"Idc"} (or the integer @code{2}) for DC current mode and
@code{"Iac"} (or the integer @code{3}) for AC current mode.


@anchor{multimeter_precision()}
@findex multimeter_precision()
@item multimeter_precision()
This function exists only for the @strong{Schlumberger 7150}. It allows to
determine or set the precision measurements are done with. If called with
no argument, the current precision setting gets returned as an integer. If
called with an argument the precision gets set. Allowed arguments are the
string @code{"3.5"} (or the integer number @code{0}) to set the device to
a precision of 3.5 digits, @code{"4.5"} (or the integer @code{1}) for 4.5
digits, @code{"5.5"} (or @code{2}) for 5.5 digits or @code{"6.5"} (or
@code{3}) for 6.5 digits.


@anchor{multimeter_get_data()}
@findex multimeter_get_data()
@item multimeter_get_data()
The function returns the voltage or current (depending on the mode) measured
by the multimeter.


@anchor{multimeter_ac_measurement()}
@findex multimeter_ac_measurement()
@item multimeter_ac_measurement()
This function is only available for the @strong{Kontron 4060} and switches
it to doing AC measurements. The function is deprecated and should be replaced
by a call of @ref{multimeter_mode()}.


@anchor{multimeter_dc_measurement()}
@findex multimeter_dc_measurement()
@item multimeter_dc_measurement()
This function is only available for the @strong{Kontron 4060} and switches
it to doing DC measurements. The function is deprecated and should be replaced
by a call of @ref{multimeter_mode()}.


@anchor{multimeter_lock_keyboard()}
@findex multimeter_lock_keyboard()
@item multimeter_lock_keyboard()
This function is only available for the @strong{Schlumberger 7150}. Usually
 during an experiment the keyboard of the device is locked. But for situations
where it would be useful to be able to control the device also via its
keyboard it can be unlocked (and also re-locked) from within the script.
To unlock the keyboard call this function with an argument of @code{0} or
@code{"OFF"}, to re-lock the keyboard call it again with a non-zero argument,
@code{"ON"} or no argument at all.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@end table



@node Boxcar Integrator Functions, Frequency Counter Functions, Multimeter Functions, Device Functions
@section Boxcar Integrator Functions
@cindex Boxcar Integrator Functions
Currently there is only rudimentary support for one type of boxcar
integrator, the @strong{EG&G PARC 4402}. Its module is loaded by specifying
@example
egg4402
@end example
@noindent
in the @code{DEVICES} section. All functions for the boxcar integrator
can only be used in the @code{EXPERIMENT} section of the @code{EDL}
script.

@noindent
@strong{List of all boxcar functions}:
@table @samp
@item @ref{boxcar_name()}
@item @ref{boxcar_curve_length()}
@item @ref{boxcar_get_curve()}
@item @ref{boxcar_start_acquisition()}
@item @ref{boxcar_stop_acquisition()}
@item @ref{boxcar_single_shot()}
@end table

@noindent
@strong{Descriptions of boxcar functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{boxcar_name()}
@findex boxcar_name()

@table @samp

@item boxcar_name()
Returns a string with the name of the boxcar integrator being used.


@anchor{boxcar_curve_length()}
@findex boxcar_curve_length()
@item boxcar_curve_length()
Returns an integer variable with the length of curves to be sent by the
boxcar integrator.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{boxcar_get_curve()}
@findex boxcar_get_curve()
@item boxcar_get_curve()
Fetches a curve from the boxcar integrator. Two first argument is either
a number, either @code{0} for a live curve or @code{1} for a memory
curve, or one of the strings @code{"LC"}, @code{"LIVECURVE"},
@code{"LIVE_CURVE} or @code{"MC"}, @code{"MEMORYCURVE"} or
@code{"MEMORY_CURVE"}. The second argument must be an integer specifying
the curve number, it must be @code{1} or @code{2} for live curves and
between @code{1} and @code{3} for memory curves.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{boxcar_start_acquisition()}
@findex boxcar_start_acquisition()
@item boxcar_start_acquisition()
Function starts a new acquisition.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{boxcar_stop_acquisition()}
@findex boxcar_stop_acquisition()
@item boxcar_stop_acquisition()
Function stops a running acquisition.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{boxcar_single_shot()}
@findex boxcar_single_shot()
@item boxcar_single_shot()
The function expects either one or two arguments, the number of one or
two live curves (i.e.@: either @code{1} or @code{2}). The function
starts an acquisition and immediately stops the acquisition again when
the dirst data point has been measured. When only one curve was
specified as the argument the function returns the value of this data
point. If there were two arguments, the function returns an array with
two elements, containing the two data points from the specified live
curves.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@end table


@node Frequency Counter Functions, DAQ Functions, Boxcar Integrator Functions, Device Functions
@section Frequency Counter Functions
@cindex Frequency Counter Functions
Currently only one frequency counter is supported, the HP5340A. Because
this is a very old device (even pre-dating the GPIB-standard) only two
functions are defined for the device. All settings have to be done
manually via the front panel. Its module is loaded by specifying
@example
hp5340a
@end example
@noindent
in the @code{DEVICES} section. 

@noindent
@strong{List of all frequency counter functions}:
@table @samp
@item @ref{freq_counter_name()}
@item @ref{freq_counter_measure()}
@end table

@noindent
@strong{Descriptions of frequency counter functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{freq_counter_name()}
@findex freq_counter_name()

@table @samp

@item freq_counter_name()
Returns a string with the name of the frequency counter being used.


@anchor{freq_counter_measure()}
@findex freq_counter_measure()
@item freq_counter_measure()
Returns a floating point value with the measured frequency. The function
does not accept any parameters and can only by used in the
@code{EXPERIMENT} section.

@end table


@node DAQ Functions, DIO Functions, Frequency Counter Functions, Device Functions
@section DAQ Functions
@cindex DAQ Functions
Currently, the supported data acquisition (DAQ) devices are the
@strong{National Instruments PCI-MIO-16E-1} card, the @strong{Meilhaus
Electronic GmbH} digital-to-analog converter cards @strong{ME-6000} and
@strong{ME-6100}, a home-built DA and AD converter from the group of H.-J.@:
Steinhoff at the University of Osnabrueck and the 12-bit @strong{RB8509 ADC}
and the 12-bit @strong{RB8510 DAC} card connected via the @strong{Rulbus}
(Rijksuniversiteit Leiden BUS).

Both the @strong{National Instruments PCI-MIO-16E-1} and the @strong{ME-6000}
and @strong{ME-6100} cards require that a kernel module and an additional
library (both coming with @code{fsc2}) have been successfully installed.

The @strong{RB8509} and @strong{RB8510} ADC and DAC cards both require that a
kernel module and an additional library (coming with @code{fsc2}) have been
successfully installed.

The modules for these devices are loaded by specifying
@example
pci_mio_16e_1
me6000
hjs_daadc
rb8509
rb8510
@end example
@noindent
in the @code{DEVICES} section. 


@noindent
@strong{List of all DAQ functions}:
@table @samp
@item @ref{daq_name()}
@item @ref{daq_ai_channel_setup()}
@item @ref{daq_ai_acq_setup()}
@item @ref{daq_ai_start_acquisition()}
@item @ref{daq_ai_get_curve()}
@item @ref{daq_trigger_setup()}
@item @ref{daq_start_continuous_counter()}
@item @ref{daq_start_timed_counter()}
@item @ref{daq_timed_count()}
@item @ref{daq_intermediate_count()}
@item @ref{daq_final_count()}
@item @ref{daq_stop_counter()}
@item @ref{daq_single_pulse()}
@item @ref{daq_continuous_pulses()}
@item @ref{daq_dio_read()}
@item @ref{daq_dio_write()}
@item @ref{daq_ao_channel_setup()}
@item @ref{daq_freq_out()}
@item @ref{daq_reserve_dac()}
@item @ref{daq_set_voltage()}
@item @ref{daq_maximum_output_voltage()}
@item @ref{daq_reserve_adc()}
@item @ref{daq_get_voltage()}
@item @ref{daq_dac_parameter()}
@item @ref{daq_trigger_mode()}
@item @ref{daq_gain()}
@end table

@noindent
@strong{Descriptions of DAQ functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{daq_name()}
@findex daq_name()

@table @samp

@item daq_name()
Returns a string with the name of the DAC being used.


@anchor{daq_ai_channel_setup()}
@findex daq_ai_channel_setup()
@item daq_ai_channel_setup()
This function is only available for the @strong{PCI-MIO-16E-1} card. It is
required that this function is called before analog input (AI) can be
done to setup the properties of the input channels.

In order to understand what this function (as well as the next few do)
a short explanation of the way analog input (AI) is done with the card
is required: the most basic element of an acquisition is a single
conversion of an input voltage into a digital value. Since there's
only a single ADC on the card, converting the voltages of a set of
channels needs to be done serially. This is called a scan, consisting
of as many conversions as there are channels to be sampled. So a single
scan consists of one or more conversions, depending on the number of
channels involved. To acquire a a curve several scans have to be done.

But before even a single scan can be done, the card must be told about
all the channels that are to be sampled. Thus the first argument the
function expects is a channel number, specified by one of the symbolic
names between @code{CH0} and @code{CH15}.

The second non-optional argument is the range to use for the channel. For
channels set up for bipolar input the allowed ranges are @w{10 V},
@w{5 V}, @w{2.5 V}, @w{1 V}, @w{500 mV}, @w{250 mV}, @w{100 mV} and
@w{50 mV}, while for channels to be used in uniploar mode the possible
range settings are @w{10 V}, @w{5 V}, @w{2 V}, @w{1 V}, @w{500 mV},
@w{200 mV} and @w{100 mV}.

After these two required values three optional settings can follow. The
first one is the coupling of the channel, which must be given by one of
the strings @code{"Ground"}, @code{"Floating"} or
@code{"Differential"}. The first one, @code{"Ground"}, means that a
ground-referenced signal source is connected to the channel and is,
therefore, already connected to a common ground. @code{"Floating"} means
that the signal source is in no way connected to the ground system and
is therefore free floating. Examples are e.g.@: batteries,
thermocouples, transformers etc. Finally, @code{"Differential"} is for
cases where the signals source has its own reference signal or signal
return path. In these cases two inputs channels are required, one from
the range @code{CH0} to @code{CH7} and the second being the number of
the first channel incremented by 8 - thus if one of the channels
involved is @code{CH0} the other channel to be used for differential
input is @code{CH8} etc. This second channel must not be set up, it's
already clear from the setup for the first channel (which must be
between @code{CH0} and @code{CH7}) that it's is going to be used and
how. When not given the coupling will be set per default to
@code{"Ground"}.

The next optional argument is the polarity of the channel, specified
by the strings @code{"BIPLOAR"} or @code{"UNIPLOAR"}. Per default
@code{"BIPLOAR"} will be used, but if the specified range can only be
used with uniploar coupling @code{"UNIPLOAR"} must be specified.

Finally, the card allows to add approximately 0.5 LSBrms of white
Gaussian noise to the signal to be converted by the ADC, which is called
dithering. This addition is useful when averaging rather small samples
to increase the resolution. To enable dithering use the string
@code{"DITHER_ON"} as another argument. Per default dithering is
switched off, but you can make sure by passing the function the string
@code{"DITHER_OFF"} as another argument.

The above listed set of arguments have to be repeated for each channel.
Thus a typical invocation, setting up an acquisition using two channels
may look like this:
@example
daq_ai_channel_setup( CH3, 5 V, "Differential", "BIPLOAR",
                      CH1, 500 mV, "UNIPOLAR", "DITHER_ON" );
@end example
In this case @code{CH3} and @code{CH11} will be used together (remember
that for differential measurements always a second channel must be used
automatically) for a signal in the range between @w{-5 V} and @w{+5V}
(i.e. in bipolar mode), where the sampled voltage is the difference
between both channels, and @code{CH1} is going to be used in unipolar
mode for a voltage between @w{0 V} and @w{500 mV} in @code{"Ground"}
coupling mode and with dithering switched on.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{daq_ai_acq_setup()}
@findex daq_ai_acq_setup()
@item daq_ai_acq_setup()
This function is only available for the @strong{PCI-MIO-16E-1} card. It is
required that this function is called before analog input (AI) can be
done using the card to setup the trigger mode, trigger sources and
timings for the analog data acquisition.

As already explained in the paragraph for the previous function, an AI
data acquisition is a set of scans, which in turn consists of a set of
conversions, one for each channel to sample. Before an acquisition can
be started the program must be told how many scans are to be done, which
is the first argument the function expects. The next thing to specify is
when to start the acquisition and, during the acquisition, when scans
are to be started. It can even be set when each individual conversion
can be started. For this reason there are several trigger modes, and the
second argument the function expects is one of these:
@table @samp
@item "TRIGGER_NONE"
The acquisition is started immediately without requiring an external
trigger event when the function @ref{daq_ai_start_acquisition()} is
called, the start of scans and conversions is controlled via timers on
the card.
@item "TRIGGER_SCAN"
The acquisition is started automatically without an external trigger
event, each scan is started on receipt of a trigger event and
conversions are started via the cards timers.
@item "TRIGGER_SCAN_CONV"
The acquisition is started automatically without an external trigger
event while both scans and each conversion during a scan are started on
external trigger events.
@item "TRIGGER_CONV"
The acquisition is started automatically without an external trigger
event, scans are started via one of the cards timer, but each conversion
is started on receipt of an external trigger.
@item "TRIGGER_START"
The acquisition is started on receipt of an external trigger event while
the starts of both the scans as well as the conversions are started via
the cards timers.
@item "TRIGGER_START_SCAN"
The acquisition and the scans are started on receipt of an external
trigger event while the conversions are started via a card timer.
@item "TRIGGER_START_SCAN_CONV"
The acquisition, the scans and the conversions are all started on
receipt of external trigger events.
@item "TRIGGER_START_CONV"
The acquisition is started on receipt of an external trigger event,
scans are started by a card timer and the conversions making up the scan
are started by an external trigger event.
@item "TRIGGER_OUT"
In this mode the triggering of the acquisition is done via the counters
on the card (which then can't be used at the same time) and allows to
output a trigger signal at a well-defined time before or after the
start of the acquisition.
@end table

For each of these trigger modes different further arguments are
required. For the trigger modes where an external trigger event is used
it must be specified what input to use for the trigger. This can be
either one of the PFI input lines of the card, specified by the strings
@code{"PFI0"} to @code{PFI9}, or the output of the first counter of the
card (when used for creating pulses, see below), in which case the
string @code{"GOUT_0"} is to be passed to the function. Optionally, the
trigger input can be followed by another argument that tells if the
trigger event is supposed to happen on the rasing or the falling edge of
the input - the string argument @code{"POSITIVE"} (or abbreviated to
@code{"POS}) switches to trigger on the a raising edge, while an
argument of @code{"NEGATIVE"} (or @code{"NEG"}) is for triggering on the
falling edge.

A special role is played by the trigger input @code{PFI0}: while all
other trigger inputs work only on TTL levels, this input can be switched
to be used as an analog trigger. The function @ref{daq_trigger_setup()}
can be used to switch this input between TTL level mode and analog
trigger mode. (To make the difference easier to spot and to stay in tune
with the naming scheme in the documentation of the card instead of
@code{"PFI0"} also the name @code{"TRIG1"} can be used).

On the other hand, when no external timer is to be used for starting
scans or conversions the time distance between starts of scans and
conversions must be known. Here one has to take into account the
specifications of the card. The minimum time distance between
conversions is at least @w{800 ns}. Thus the time distance between scans
must be at least @w{800 ns} times the number of channels to sample.
But when channels are used with different ranges (or some in bipolar and
others in uniploar mod) this minimum time distance increases to @w{2 us}
to allow for settlings times of the internal preamplifier and thus also
the minimum time between starts of scans is increased accordingly.
Another point to note is that specifying the time distance between
conversions is optional - if not given the program will pick the
smallest pssible delay, i.e.@: either @w{800 ns} or @w{2 us}.

The @code{TRIGGER_OUT} mode is a poor mans pre-trigger mode, which can
be used as long as it is possible to use the DAQ board as the contolling
clock of the experiment. At a well-defined time before or after (or
exactly at) the start of the acquisition a trigger is output at the
@code{GPCTR1_OUT} pin of the board. This mode can be used e.g.@: to
start an acqisition and only afterward trigger e.g.@: a laser, or the
other way round, first trigger the laser and only after a well-defined
time delay start the acquisition. The length of the trigger being output
is an compile time option and can be changed in the configuration file
for the device, the default is @w{100 ns}.

According to the above discussion here's a list of all required and
optional arguments to the function when used with the different trigger
and timing modes. Optional arguments are enclosed in square braces:
@example
daq_ai_acq_setup( Num_Scans, "TRIGGER_NONE", t_scan
                  [ , t_conv ] );

daq_ai_acq_setup( Num_Scans, "TRIGGER_SCAN", S_scan
                  [ , P_scan ] [ , t_conv ] );

daq_ai_acq_setup( Num_Scans, "TRIGGER_SCAN_CONV", T_scan,
                  [ P_scan , ] T_conv [ , P_conv ] );

daq_ai_acq_setup( Num_Scans, "TRIGGER_CONV", t_scan,
                  S_conv [ , P_conv ] );

daq_ai_acq_setup( Num_Scans, "TRIGGER_START", S_start,
                  [ P_start, ] t_scan [ , t_conv ] );

daq_ai_acq_setup( Num_Scans, "TRIGGER_START_SCAN", S_start,
                  [ P_start, ] S_scan [ , P_scan ] [ , t_conv ] );

daq_ai_acq_setup( Num_Scans, "TRIGGER_START_SCAN_CONV", S_start,
                  [ P_start, ] S_scan, [ P_scan, ] S_conv
                  [ , P_conv ] );

daq_ai_acq_setup( Num_Scans, "TRIGGER_START_CONV", S_start,
                  [ P_start, ] t_scan, S_conv [ , P_conv ] );

daq_ai_acq_setup( Num_Scans, "TRIGGER_OUT", t_delay,
                  t_scan [ , t_conv ] );
@end example
The symbol @code{Num_Scans} stands for the number of scans to be done,
@code{S_start} for the source of the trigger starting the acquisition,
@code{P_start} is the "polarity" (i.e.@: rasing or falling edge) of this
trigger, @code{S_scan} and @code{P_scan} have the same meaning but for
the start-of-scan trigger and @code{S_conv} and @code{P_conv} are for
the start-of-conversion trigger. @code{t_scan} and @code{t_conv} are the
time distances between starts of scans and between conversions,
respectively. Finally, @code{t_delay} is the time between the start of
the aquisition and the trigger output appearing on the @code{GPCTR1_OUT}
pin of the card. It can be both positive and negative (a positive value
leads to the trigger being output after the start of the acquisition).

Please note that not all timings are possible, e.g.@: when very long
times between starts of scans are required (for example @w{1 s}) while
very short time distances between starts of conversions (for example
@w{800 ns}) it can be realized using the cards hardware and you will
have to fall back on using an external trigger for either the event that
starts the scans or the conversions.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{daq_ai_start_acquisition()}
@findex daq_ai_start_acquisition()
@item daq_ai_start_acquisition()
This function is only available for the @strong{PCI-MIO-16E-1} card. It is to
be used to start an analog input acquisition according to the paramter set
by previous calls of the functions @ref{daq_ai_channel_setup()} and
@ref{daq_ai_acq_setup()}. It expects no arguments.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{daq_ai_get_curve()}
@findex daq_ai_get_curve()
@item daq_ai_get_curve()
This function is only available for the @strong{PCI-MIO-16E-1} card and is used
to fetch the acquired data from the card. It expects no arguments.
What type of variable the function returns depends on the number of
channels that got sampled. If there was only a single channel the
function returns an 1-dimensional array with as many elements as scans
where done. If two or more channels where sampled a 2-dimensional array
is returned, with a rank of number-of-channels times number-of-scans.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{daq_trigger_setup()}
@findex daq_trigger_setup()
@item daq_trigger_setup()
This function is only available for the @strong{PCI-MIO-16E-1} card and can be
used to switch the first trigger input line (named @code{"PFI0"} or
@code{"TRIG1"} when specified in the function @ref{daq_ai_acq_setup()}
between "digital" (TTL level) and analog mode.

To switch to "digital mode where a TTL-level trigger signal is required
simply call it with the string @code{"TTL"} as the only argument. In
contrast, when switching to analog trigger mode there are several
options for the first argument:
@table @samp
@item "Low_Window"
Creates a trigger signal that raises from low to high state when the
input voltage falls below the threshold voltage @code{V_low}, that has
to be specified as the next argument. The trigger signal falls back to
the low state when the input voltage again gets raised above the
threshold voltage.
@item "High_Window"
This is the inverse of the previous mode: a triger signal that goes from
low to high is created when the input voltage is raised above a
threshold value @code{V_high} (to be specified as the next argument) and
that again goes back to low when the input voltage drops below the
threshold voltage.
@item "Middle_Window"
Here the trigger signal is raised whenever the input voltage enters an
voltage interval between the voltages @code{V_high} and @code{V_low},
taht have to be specified as the next two arguments, and drops to low
again when the input voltage is raised above @code{V_high} or drops
below @code{V_low}.
@item "High_Hysteresis"
In this mode the created trigger signal is raised when the input voltage
exceeds a high threshold voltage @code{V_high} (to be specified as the
next argument) and again falls back to low when the input voltage drops
below a second threshold voltage @code{V_low}, to be specified as the
final argument of the function (with @code{V_low} being lower that
@code{V_high}).
@item "Low_Hysteresis"
This mode is opposite of the previous one: the trigger signal is raised
when the input voltage drops below @code{V_low} and falls back to low
when the input voltage exceeds @code{V_high}.
@end table

According to this the function has to be called in one of these forms:
@example
daq_trigger_setup( "TTL" );
daq_trigger_setup( "Low_Window", v_low );
daq_trigger_setup( "High_Window", v_high );
daq_trigger_setup( "Middle_Window", v_high, v_low );
daq_trigger_setup( "High_Hysteresis", v_high, v_low );
daq_trigger_setup( "Low_Hysteresis", v_high, v_low );
@end example

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{daq_start_continuous_counter()}
@findex daq_start_continuous_counter()
@item daq_start_continuous_counter()
This function is only available for the @strong{PCI-MIO-16E-1} card. It starts
one of the two counters of the card. The counter will count until it is
stopped by a call of the @code{EDL} function @ref{daq_stop_counter()}.
The first required argument is the counter to be used, which needs to be
specified by one of the symbolic names @code{CH0} and @code{CH1} (please
@strong{don't} use numbers directly, the mapping between the symbolic
values and channel numbers is non-trivial). If the requested counter is
already running the function will fail.

As the second argument the source of events to be counted must be
specified by one of the following symbolic names: @code{PFI0} to
@code{PFI9}, indicating one of the 10 PFI input lines of the card.,
@code{TIMEBASE_1} or @code{TIMEBASE_2}, specifying the slow or
fast timebase of the card.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{daq_start_timed_counter()}
@findex daq_start_timed_counter()
@item daq_start_timed_counter()
This function is only available for the @strong{PCI-MIO-16E-1} card and starts
one of the counters of the card. The counter will count for a specified
time and then stops automatically. It requires at least two arguments,
the counter to be used, specified by a symbolic name, @code{CH0} or
@code{CH1}. If the requested counter is already running the function
will fail. The second required argument is the length of time the
counter is supposed to count. This time must be at least @w{100 ns} and
an integer multiple of @w{50 ns}.

@strong{Please note}: This function requires not only one counter
channel, i.e.@: the one passed to the function as the first argument,
but also the second counter. If @code{CH0} is specified as the
counter channel also @code{CH1} will be needed and vice versa. If
the adjacent counter is already in use for some other purpose the
function fails.

As the third argument the source of events to be counted must be
specified by one of the following symbolic names: @code{PFI0} to
@code{PFI9}, indicating one of the 10 PFI input lines of the card.,
@code{TIMEBASE_1} or @code{TIMEBASE_2}, specifying the slow or
fast timebase of the card.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{daq_timed_count()}
@findex daq_timed_count()
@item daq_timed_count()
This function is only available for the @strong{PCI-MIO-16E-1} card is and very
similar to the previous function, @ref{daq_start_timed_counter()},
i.e.@: it runs a counter for a specified of time, but in contrast it
waits for the requested duration of time and only then returns with the
masured count. In every other respect, e.g.@: the required arguments
etc.@: it is identical to the previous function.

The largest value that can be returned is @w{16777215}, i.e.@: @w{2^24
- 1}.


@anchor{daq_intermediate_count()}
@findex daq_intermediate_count()
@item daq_intermediate_count()
This function is only available for the @strong{PCI-MIO-16E-1} card and returns
the current value of a counter. The counter may still be running, in
which case each call of the function will return an updated value
according to the number of events that happened between invocations of
the function. The function requires one argument, the counter for which
the current value is to be returned. It must be specified by one of the
symbolic names @code{CH0} and @code{CH1} (please @strong{don't} use
numbers directly, the mapping between the symbolic values and channel
numbers is non-trivial).

The largest value that can be returned for a counter is @w{16777215},
i.e.@: @w{2^24 - 1}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{daq_final_count()}
@findex daq_final_count()
@item daq_final_count()
This function is only available for the @strong{PCI-MIO-16E-1} card and waits
for an counter to stop and only then returns the final value of the
counter. Trying to call this function on a counter that has been started by
the function @ref{daq_start_continuous_counter()} and hasn't already been
stopped will fail, because such a counter will never stop by itself.

The function requires one argument, the counter for which the current
value is to be returned. It must be specified by one of the symbolic
names @code{CH0} and @code{CH1} (please @strong{don't} use numbers
directly, the mapping between the symbolic values and channel numbers is
non-trivial).

The largest value that can be returned for a counter is @w{16777215},
i.e.@: @w{2^24 - 1}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{daq_stop_counter()}
@findex daq_stop_counter()
@item daq_stop_counter()
This function is only available for the @strong{PCI-MIO-16E-1} card and can be
used to stop a counter independently of the purpose (i.e.@: counting or
pulse train creation, see below) it was started for. It requires one
argument, the counter to be stopped. It must be specified by one of the
symbolic values @code{CH0} and @code{CH1} (please @strong{don't} use
numbers directly, the mapping between the symbolic values and channel
numbers is non-trivial).

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{daq_single_pulse()}
@findex daq_single_pulse()
@item daq_single_pulse()
This function is only available for the @strong{PCI-MIO-16E-1} card.  Beside
being used as event counters the counters can also be used to create
pulses on its default output port. This function can be used to create a
single pulse on the output port. It requires two arguments, the first
being the counter to be used, specified by a symbolic value @code{CH0}
and @code{CH1}. If the requested counter is already running the function
will fail. The second argument is the length of the pulse, which must be
at least @w{100 ns} and an integer multiple of @w{50 ns}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{daq_continuous_pulses()}
@findex daq_continuous_pulses()
@item daq_continuous_pulses()
This function is only available for the @strong{PCI-MIO-16E-1} card. It allows
to create a continuous train of pulses. It requires at least two
arguments, the first being the counter to be used, specified by a
symbolic value @code{CH0} and @code{CH1}. If the requested counter is
already running the function will fail. The second argument is the
length of the pulse, which must be at least @w{100 ns} and an integer
multiple of @w{50 ns}.

If no third argument is specified the distance between pulses will be
identical to the pulse length (resulting in a pulse frequency of twice
the value of the second argument). By specifying a third argument (with
the same restrictions as for the second argument) the distance between
pulses can be set.

To stop creation of pulses (and to free the counter for other uses) the
function @ref{daq_stop_counter()} must be called.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{daq_dio_read()}
@findex daq_dio_read()
@item daq_dio_read()
This function is only available for the @strong{PCI-MIO-16E-1} card. Beside
counters the card also can do digital input and output. There are 8
lines that can be monitored or set. Using this function the current
state of any subset of these 8 lines can be determined. If the function
is called without an argument the state of all lines is returned, with
the lowest bit of the number returned being the state of the lowest
numbered DIO line, the seond-lowest bit of the number standing for the
second-lowest numbered DIO line etc. If all lines are set the returned
value is thus @code{255}.

If an integer argument gets passed to the function it is taken as a
mask, determining which of the DIO lines are to be treated as input
lines. The lowest bit of the mask stands for the lowest numbered DIO
line, the second-lowest bit of the mask for the second-lowest DIO line
etc. Thus, by specifying a mask of value of @code{1} the state of only
the DIO line numbered @code{0} would be returned, for a mask of value of
@code{2} the state of DIO line @code{1}, for @code{4} DIO line @code{2}
etc. By adding values for different DIO lines a subset of the DIO lines
can be specified. Simple arithmetics show that the value of the mask
must be between @code{0} (no DIO lines selected) and @code{255} (all DIO
lines selected, which is the default). All bits in the resulting return
value for which bits in the mask ae not set will be returned as being
set to @code{0}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{daq_dio_write()}
@findex daq_dio_write()
@item daq_dio_write()
This function is only available for the @strong{PCI-MIO-16E-1} card. The 8 DIO
lines of the card can not only be monitored (see the previous function,
@ref{counter_dio_read()}) but also set, which this function is to be
used for. The function requires at least one integer argument, defining
the states of the DIO lines to be set to. To output a high voltage at
one of the DIO lines the corresponding bit of the value must be set.
The lowest bit of the value corresponds to the lowest numbered DIO line,
the second-lowest bit to the second-lowest numbered DIO line etc. To
only set the lowest numbered DIO line the value passed to the function
would have to be @code{1}, to set only the second-lowest numbered DIO
line the value would be @code{2}, to set only the third-lowest numbered
DIO line a value of @code{4} would be used. By combining these values
for the different DIO lines a certain output pattern can be set for all
DIO lines. Obviously, the allowed values are restricted to the range
between @code{0} (all DIO lines in low state) to @code{255} (all DIO
lines in high state).

Without a second argument all 8 DIO lines are switched to output mode
and the states of the lines set according to the value of the first
argument.  But by passing the function a mask value as the second
argument only a certain subset of the DIO lines will be set to output
mode, thus allowing to have some of the DIO lines for output, while the
can be used as input lines. Each set bit in the mask will switch the
corresponding lines to output state while not changing mode for the
lines for which no bit is set in the mask. Bits in the first argument
for which no bit is set in the second argument will be not used, i.e.@:
don't influence the state of the DIO lines.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{daq_ao_channel_setup()}
@findex daq_ao_channel_setup()
@item daq_ao_channel_setup()
This function is only available for the @strong{PCI-MIO-16E-1} card. It allows
to configure individulaly the analog outputs (AO) of the card. Both output
channels can be used to do biplor or unipolar output. While in bipolar mode
voltages between @w{-10 V} and @w{+10 V} with a resolution of ca.@: @w{5 mV}
can be produced, in unipolar mode voltages between only @w{0 V} and @w{+10 V}
but with an increased resolution of about @w{2.5 mV} can be produced.

The channels can also be used to either output a voltage derived from an
internal reference voltage (in which case voltages between @w{-10 V} and
@w{-10 V} or @w{0 V} and @w{+10 V} can be produced), the output voltages
can also be derived from an external voltage (between @w{-11 V} and
@w{+11 V} maximum) can be produced. Using the function one can switch
between internal and external reference.

The function expects at least two argument. The first one is the AO
channel to configure, either @code{CH0} or @code{CH1}. The second (or,
optionally, the third) is the polarity, either the string @code{"BIPOLAR"}
or @code{"UNIPOLAR"}. Alternatively, the second or third argument selects
the reference voltage to use, specified by the strings
@code{"INTERNAL_REFERENCE"} or @code{"EXTERNAL_REFERENCE"}. If no
argument for the polarity or reference are given this property of the
channels is not changed. Both channels are per default in bipolar mode
and use the internal reference voltage.


@anchor{daq_freq_out()}
@findex daq_freq_out()
@item daq_freq_out()
This function is only available for the @strong{PCI-MIO-16E-1} card. The card
has an @code{FREQ_OUT} in and this function can be used to determine or set
the frequency output at this pin (or switch output off). If called with no
argument it returns the currently output frequency (or @code{0.0} if the
output is switched off.

When called with an argument this must be the frequency to output (or
@code{0.0} to switch output off). The allowed frequencies are either
@w{20 MHz}, @w{10 MHz}, @w{200 kHz} or @w{100 KHz} or any frequency
that can be derived from these frequencies by a division by an integer
number between 2 and 16. If the frequency doesn't fit these requirements
a frequency as near as possible to the allowed values is output.

@strong{Please note:} Under certain circumstances it is possible that
changing the output frequency between a value that can only be derived
from @w{200 Khz} to one only derivable from @w{100 kHz} and vive versa
can also change the timing of both a currently runing analog input data
acquisition as well as that of counters or pulsers. Thus this function
should only be used while the analog input (AI) subsystem as well as the
counter and pulser subsystem of the card isn't active.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{daq_reserve_dac()}
@findex daq_reserve_dac()
@item daq_reserve_dac()
This function can be used to reserve (or un-reserve) a DAC so that it
can only be used with a pass-phrase. This will mainly be used by modules
for other devices that require a DAC to keep an @code{EDL} script from
accdentally changing the output of the DAC.

This function is not implemented for the Rulbus @strong{RB8905 ADC} card.

For the @strong{ME-6000} and @strong{ME-6100} card the function expects an
output port as the first argument specified by one of the symbolic values
between @code{CH0} and @code{CH15} (don't try to use simple numbers instead!).
For the home-built AD and DA converter this argument can't be specified since
it has only a single output.

If there is no further argument (or, in the case of the home-built AD
and DA converter, no argument) an integer is returned. If it @code{1}
the DAC channel is reserved, if it is @code{0} the DAC channel is not
reserved and can be used without a pass-phrase.

The next argument is a string variable to be used as the pass-phrase
in later calls of the function @ref{daq_set_voltage()} and, in the
case of the home-built AD and DA converter, the function
@ref{daq_maximum_output_voltage()}.

The final argument is optional. If is not given the function will try to
reserve the DAC channel. If called with either an argument of @code{0} or
a string @code{"OFF"} the DAC channel is released so that it can be
freely used again. If called with either an argument of @code{1} or
a string @code{"ON"} the DAC channel is reserved (which is identical to
not passing it this argument).

The function returns an integer, if it is @code{1} the operation (i.e.@:
reserving or releasing the DAC channel) succeeded, if it is @code{0} the
operation failed.


@anchor{daq_set_voltage()}
@findex daq_set_voltage()
@item daq_set_voltage()
This function has to be used to output a voltage at (one of) the output
ports. For the @strong{PCI-MIO-16E-1}, @strong{ME-6000} and @strong{ME-6100}
cards the first argument has to be the output port, specified by one of the
symbolic values between @code{CH0} and and @code{CH1} for the
@strong{PCI-MIO-16E-1} card and between @code{CH1} and @code{CH15} for the
@strong{ME-6000} and @strong{ME-6100} cards (don't try to use simple numbers
instead!). For the home-built AD and DA converter as well as the
@strong{RB8510 DAC} card this argument can't be specified since both have only
a single output.

If the @strong{PCI-MIO-16E-1} card he channel is in biploar mode and uses the
internal voltage reference the second argument, the voltage to be output, must
be between @w{-10 V} and @w{+10 V}). If it is set to unipolar mode it must be
between @w{0 V} and @w{+10 V}). If the channel is setup to use an external
refeference voltage the argument must be be either between @w{-1} and @w{+1}
or @w{0} and @w{1}, standing for the fraction of the external reference
voltage to be output.

For the @strong{ME-6000} and @strong{ME-6100} cards the second argument is the
output voltage to be output in the range between @w{-10 V} and @w{+10 V}.

In contrast, for the home-built AD and DA converter card, the only
argument is the output voltage. It must be between @w{0 V} and the
maximum voltage that has been spcified in the call of the function
@ref{daq_maximum_output_voltage()}. If this function hasn't been called
the default maximum output voltage is @w{+10 V}.

Also the module for the Rulbus @strong{RB8510 12-bit DAC} allows only a single
argument, the output voltage. Since there are different versions of the
card with different output voltage ranges the possible range can only be
determined at the start of the experiment.

If an output voltage has already been set for an output port the last
set voltage is returned when the function is called without a second
argument.

@strong{Please note}: the latest set output voltage will still appear on
the output port after the program is finished. If it is required that
the output voltage reverts to a default value at the end of the
experiment please put a command for setting this voltage into the
@code{ON_STOP} section of the @code{EDL} script.

For the home-built DA and AD card the output voltage will automatically
drop to @w{0 V} if the function @ref{daq_get_voltage()} (see below)
is called without a previous call of the function for setting an output
voltage.

@strong{Please note}: if the DAC channel had previously been reserved by
a call of the function @ref{daq_reserve_dac()} the pass-phrase
specified in that call has to be passed to the function as the very
first argument if you want to be able to change the output voltage of
the DAC channel.

The function can be used in the @code{EXPERIMENT} as well as in the
@code{PREPARATIONS} section.


@anchor{daq_maximum_output_voltage()}
@findex daq_maximum_output_voltage()
@item daq_maximum_output_voltage()
This function is only available for the home-built AD and DA converter.
This device has a potentiometer at the front side that can be used to
reduce the output voltage level from the maximum level of @w{+10 V}. By
calling this function you can tell the program about the new value of
the maximum output voltage, so that you afterwards may use the real
required output voltages instead of values that have to be too large by
the reduction factor of the potentiometer. So, if the potentiometer is
set to 5 (of its maximum range of 10) and you call this function with an
argument of @w{5 V} you then can specify the real voltage you want to
output in calls of @ref{daq_set_voltage()} instead of having to pass it
values that are too large by a factor of 2.

If this function hasn't been called the program will assume that the
potentiometer is set to its maximum of 10 and output voltages of the
DA converter are between @w{0 V} and @w{+10 V}.

@strong{Please note}: if the DAC channel had previously been reserved by
a call of the function @ref{daq_reserve_dac()} the pass-phrase
specified in that call has to be passed to the function as the very
first argument if you want to be able to change the maximum output
voltage.

The function can be used in the @code{EXPERIMENT} as well as in the
@code{PREPARATIONS} section.


@anchor{daq_reserve_adc()}
@findex daq_reserve_adc()
@item daq_reserve_adc()
This function is only available for the home-built AD and DA converter
and can be used to reserve (or un-reserve) the ADC so that it can only be
used with a pass-phrase. This will mainly be used by modules for other
devices that require a ADC to keep an @code{EDL} script from accidentally
triggering an input conversion.

If there is no argument an integer is returned. If it @code{1} the ADC
is reserved, if it is @code{0} the ADC channel is not reserved and can
be used without a pass-phrase.

The first argument is a string variable to be used as the pass-phrase
in later calls of the function @ref{daq_get_voltage()}.

The final argument is optional. If is not given the function will try to
reserve the ADC channel. If called with either an argument of @code{0} or
a string @code{"OFF"} the ADC is released so that it can be freely used
again. If called with either an argument of @code{1} or a string
@code{"ON"} the ADC is reserved (which is identical to not
passing it this argument).

The function returns an integer, if it is @code{1} the operation (i.e.@:
reserving or releasing the DAC channel) succeeded, if it is @code{0} the
operation failed.


@anchor{daq_get_voltage()}
@findex daq_get_voltage()
@item daq_get_voltage()
This function is only available for the home-built AD and DA converter
and the Rulbus @strong{RB8509 ADC} card. For the home-built AD and DA converter
it accepts no arguments and returns the current voltage at the input of
the AD converter, a value between @w{-10 V} and @w{+10 V}. For the
Rulbus RB8509 card it expects a single argument, the input channel. This
must be a symbolic name, starting from @code{CH0} up to @code{CHx},
where the @code{x} stands for one less than the number of channels the
card has.The voltage value returned depends on the type of the RB8509
card (there are several versions with different voltage ranges and some
allowing only unipolar input while others can convert biplor voltages)
and the gain setting for the card, see function @ref{daq_gain()} below.

The function can be used in the @code{EXPERIMENT} section only.

The following remarks apply to the home-built AD and DA converter only:

@strong{Please note}: If this function is called without a previous call
of the function @ref{daq_set_voltage()} (see above) the voltage at the
output of the DA converter will switch to @w{0 V} automatically. So you
should call @ref{daq_set_voltage()} always before
@ref{daq_get_voltage()} if something is connected to the DA output!

@strong{Note also}: if the ADC had previously been reserved by a call of
the function @ref{daq_reserve_adc()} the pass-phrase specified in that
call has to be passed to the function as the very first argument if you
want to be able to read in the voltage at the ADC.


@anchor{daq_dac_parameter()}
@findex daq_dac_parameter()
@item daq_dac_parameter()
This function is available only for the @strong{ME-6000} and @strong{ME-6100}
cards and the home-built AD and DA converter. It can be used to determine the
current parameter of a DAC (channel). It returns an array of three floating
point values. The first element of the array is the minimum voltage that can
be output by the DAC, the second is the maximum output voltage and the third
is the voltage resolution. If the device has more than one DAC channel, the
function expects a channel as the only argument (which can be omitted if
settings for alll channels must be identical).


@anchor{daq_trigger_mode()}
@findex daq_trigger_mode()
@item daq_trigger_mode()
Some of the Rulbus @strong{RB8509 ADC} cards allow to trigger a conversion on
receipt of an external trigger. When in internal trigger mode a
conversion is triggered automatically by calling the function
@ref{daq_get_voltage()}. In external trigger mode the conversion is
triggered by an external event and the @ref{daq_get_voltage()} function
only returns after such a trigger as been received. The function expects
a string argument, either @code{"INT"} or @code{"INTERNAL"} to select
internal trigger mode, or @code{"EXT"} or @code{"EXTERNAL"} to switch to
external trigger mode.


@anchor{daq_gain()}
@findex daq_gain()
@item daq_gain()
The Rulbus @strong{RB8509 ADC} card has a pre-amplifier with a gain factor
that can be set to either @code{1}, @code{2}, @code{4} or @code{8} using
this function. Trying to set it to any other values will result in an
error message an the running experiment is immediately stopped.


@end table


@node DIO Functions, Event Counter Functions, DAQ Functions, Device Functions
@section DIO Functions
@cindex DIO Functions
Currently, there's only one DIO device, the @strong{Wasco WITIO-48} ISA
DIO card by Messcomp Datentechnik GmbH. It can be used for digital input
and output. The module for the card gets loaded by specifying
@example
witio_48
@end example
in the @code{DEVICES} section. 

Use of this card requires that a kernel module and an additional
library (both coming with @code{fsc2}) have been successfully installed.


@noindent
@strong{List of all DIO functions}:
@table @samp
@item @ref{dio_name()}
@item @ref{dio_reserve_dio()}
@item @ref{dio_mode()}
@item @ref{dio_value()}
@end table

@noindent
@strong{Descriptions of DIO functions}:


@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{dio_name()}
@findex dio_name()

@table @samp

@item dio_name()
Returns a string with the name of the DIO device being used.

@anchor{dio_reserve_dio()}
@findex dio_reserve_dio()
@item dio_reserve_dio()
This function can be used to reserve (or un-reserve) a DIO so that it
can only be used with a pass-phrase. This will mainly be used by modules
for other devices that require a DIO to keep an @code{EDL} script from
accdentally changing the output or reading the input of the DIO.

The first argument is the DIO to be reserved (or released). This must be
either a number, @code{1} or @code{2} or, better, a symbolic name,
@code{DIO1} or @code{DIO2}.

If there is no further argument an integer is returned. If it @code{1}
the DIO is reserved, if it is @code{0} the DIO is not reserved and can
be used without a pass-phrase.

The next argument is a string variable to be used as the pass-phrase
in later calls of the functions @ref{dio_mode()} and @ref{dio_value()}.

The final argument is optional. If is not given the function will try to
reserve the DIO channel. If called with either an argument of @code{0} or
a string @code{"OFF"} the DIO is released so that it can be freely used
again. If called with either an argument of @code{1} or a string
@code{"ON"} the DIO is reserved (which is identical to not passing it
this argument).

The function returns an integer, if it is @code{1} the operation (i.e.@:
reserving or releasing the DIO) succeeded, if it is @code{0} the
operation failed.


@anchor{dio_mode()}
@findex dio_mode()
@item dio_mode()
The WITIO-48 card has two DIO chips, both allowing 24 bit wide input and
output. These DIOs can be further split up into sub-DIOs of smaller
width. By calling this function you can set the way a DIO is split up.

The function expects at least one argument, the DIO to be used with the
function. This must be either a number, @code{1} or @code{2} or, better,
a symbolic name, @code{DIO1} or @code{DIO2}. When called without another
argument the current mode is returned as an integer number (as they
could also be specified to set a mode, see below). If there is a second
argument this is the mode to be set. You can use either a number or a
string to specify the new mode:
@table @samp
@item @code{0} or @code{"3x8"}
The DIO is split up into three independent 8-bit DIOs, which then can be
addressed as channels in calls of the function @ref{dio_value()}.

@item @code{1} or @code{"2x12"}
The DIO is split up into two independent 12-bit DIOs, which then can be
addressed as channels in calls of the function @ref{dio_value()}.

@item @code{2} or @code{"1x24"}
The DIO isn't split up at all but used as a 24-bit wide DIO.

@item @code{3} or @code{"16_8"}
The DIO is split up into two independent DIOs, one with a width of 16
bit and one 8-bit wide. These can be addressed as channels in calls of
the function @ref{dio_value()}.
@end table

If no mode is set for a DIO the mode for 24-bit input and output is used
per default.

@strong{Please note}: if the DIO had previously been reserved by a call
of the function @ref{dio_reserve_dio()} the pass-phrase specified in
that call has to be passed to the function as the very first argument if
you want to be able to change the mode of the DIO.



@anchor{dio_value()}
@findex dio_value()
@item dio_value()
This function is used to either input or output a value. It expects at
least two arguments, the DIO to be used (preferably use the symbolic
names @code{DIO1} and @code{DIO2}) and a channel. Depending on the mode
the DIO has been set to using the function @ref{dio_mode()}, either
one, two or three channels can be used. Use the symbolic names
@code{CH1}, @code{CH2} and @code{CH3}. If there is no further argument
data will be read in from the DIO and pass it back to the @code{EDL}
script as the return value of the function.

If there's a third argument it is taken as the value to output at the
DIO (or, to be precise, the sub-DIO specified by the channel argument).
How many channels can be used, what range of data can be output and how
each bit the value is mapped to the output pins depends on the mode
the DIO is been set to:
@table @samp
@item @code{"3x8"} mode
Since in this mode there are three independent sub-DIOs, three channels,
@code{CH1}, @code{CH2} and @code{CH3}, can be used. Each channel is
8-bit wide, so the range of values that can be output (or input) is
restricted to numbers between @code{0} and @code{255}.

If the channel is @code{CH1} the bits of the value are output at the
pins of the connector labeled @code{1PA7} to @code{1PA0} for @code{DIO1}
and at the pins @code{2PA7} to @code{2PA0} for @code{DIO2}, where the
most significant bit goes to the highest numbered pin 7 and the least
sigificant bit to the pin numbered 0.  If a channel of @code{CH2} has
been selected the bits are mapped to the pins @code{1PB7} to @code{1PB0}
or @code{2PB7} to @code{2PB0} and for @code{CH3} to the pins @code{1PC7}
to @code{1PC0} or @code{2PC7} to @code{2PC0}.

@item @code{"2x12"} mode
In this mode the DIO is split into two 12-bit wide sub-DIOs, so only
@code{CH1} and @code{CH2} can be used to output a value between @code{0}
and @code{4096}. For @code{CH1} the topmost 4 bits of the value are
mapped to the pins @code{1PC7} to @code{1PC4} or @code{2PC7} to
@code{2PC4} (with the most sigificant bit at @code{1PC7} or @code{2PC7})
while the lower 8 bits go to the pins @code{1PA7} to @code{1PA0} or
@code{2PA7} to @code{2PA0} (depending on the selected DIO). For
@code{CH2} the topmost 4 bits of the value appear at the pins
@code{1PC3} to @code{1PC0} or @code{2PC3} to @code{2PC0} and the lower
8 bits are mapped to the @code{B}-pins, @code{1PB7} to @code{1PB0} or
@code{2PB7} to @code{2PB0}.

@item @code{"1x24"} mode
The DIO isn't split into sub-DIOs, so the only allowed channel in this
mode is @code{CH1} and the range of valid values is @code{0} to
@code{16777215}. The highest 8 bits of the value go to the @code{C}-pins
(i.e.@: @code{1PC7} to @code{1PC0} for @code{DIO} or @code{2PC7} to
@code{2PC0} for @code{DIO2}), the middle byte is mapped to the
@code{B}-pins and the lowest byte of the value to the @code{A}-pins.

@item @code{"16_8"} mode
In this mode the DIO is split into a 16-bit and an 8-bit wide
DIO. @code{CH1} is the 16-bit DIO, allowing to output values between
@code{0} and @code{65535}, and @code{CH2} is the 8-bit DIO, allowing a
the value to be between @code{0} and @code{255}. For @code{CH1} the
upper byte of the value is mapped to the @code{B}-pins while the lower
byte appears at the @code{A}-pins. The @code{C}-pins are used to
output the value for @code{CH2}.

@end table

@strong{Please note}: trying to output a negative value will make the
program abort immediately as will trying to output too large a value
during the test run. During the experiment a too large value will be
truncated to the allowed range by stripping off the higher order bits
and a warning message is printed out.

@strong{Note also}: if the DIO had previously been reserved by a call of
the function @ref{dio_reserve_dio()} the pass-phrase specified in that
call has to be passed to the function as the very first argument if you
want to be able to read from or write to the DIO.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@end table



@node Event Counter Functions, CCD Camera Functions, DIO Functions, Device Functions
@section Event Counter Functions
@cindex Event Counter Functions
The only currently supported event counter is the @strong{National
Instruments GPCT 6601} card. It can be used for counting as well as for
creating pulses. The module for this card is loaded by specifying
@example
ni6601
@end example
@noindent
in the @code{DEVICES} section. 

Use of this card requires that a kernel module and an additional
library (both coming with @code{fsc2}) have been successfully installed.


@noindent
@strong{List of all counter functions}:
@table @samp
@item @ref{counter_name()}
@item @ref{counter_start_continuous_counter()}
@item @ref{counter_start_timed_counter()}
@item @ref{counter_timed_count()}
@item @ref{counter_intermediate_count()}
@item @ref{counter_final_count()}
@item @ref{counter_start_buffered_counter()}
@item @ref{counter_get_buffered_counts()}
@item @ref{counter_stop_counter()}
@item @ref{counter_single_pulse()}
@item @ref{counter_continuous_pulses()}
@item @ref{counter_dio_read()}
@item @ref{counter_dio_write()}
@item @ref{ccd_camera_name()}
@end table

@noindent
@strong{Descriptions of counter functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{counter_name()}
@findex counter_name()

@table @samp

@item counter_name()
Returns a string with the name of the event counter being used.


@anchor{counter_start_continuous_counter()}
@findex counter_start_continuous_counter()
@item counter_start_continuous_counter()
This functions starts one of the counters of the card. The counter will
count until it is stopped by a call of the @code{EDL} function
@ref{counter_stop_counter()}. It requires at least one argument, the
counter to be used, which needs to be specified by one of the symbolic
names between @code{CH0} and @code{CH3} (please @strong{don't} use
numbers directly, the mapping between the symbolic values and channel
numbers is non-trivial). If the requested counter is already running the
function will fail.

If called without a further argument the counter will count events on
its default input. Alternatively, as a second argument the source of
events to be counted can be specified by one of the following symbolic
names: @code{DEFAULT_SOURCE} (which is what would be used if no second
argument is specified), @code{SOURCE_0} to @code{SOURCE_3} (the default
input sources for channel @code{0} to @code{3}), @code{NEXT_GATE} (the
gate input for the adjacent counter, where the adjacent counter for
channel @code{0} is channel @code{1} and vice versa, and channels
@code{2} and @code{3} also make up a pair) and @code{TIMEBASE_1} and
@code{TIMEBASE_2} (the internal timebases of @w{20 MHz} and @w{100 kHz}).

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{counter_start_timed_counter()}
@findex counter_start_timed_counter()
@item counter_start_timed_counter()
This function starts one of the counters of the card. The counter will
count for a specified time and then stops automatically. It requires at
least two arguments, the counter to be used, specified by a symbolic
name between @code{CH0} and @code{CH3}. If the requested counter is
already running the function will fail. The second required argument is
the length of time the counter is supposed to count. This time must be
between @w{100 ns} and about @w{214.748 s} and must be an integer
multiple of @w{50 ns}.

@strong{Please note}: This function requires not only one counter
channel, i.e.@: the one passed to the function as the first argument,
but also a second, adjacent counter. If @code{CH0} is specified as the
counter channel also @code{CH1} will be needed and vice versa, and if
@code{CH2} is specified also @code{CH3} is required and vice versa. If
the adjacent counter is already in use for some other purpose the
function fails.

If called without a further argument the counter will count events on
its default input. Alternatively, as a second argument, the source of
events to be counted can be specified by one of the following symbolic
names: @code{DEFAULT_SOURCE} (which is what would be used if no second
argument is specified), @code{SOURCE_1} to @code{SOURCE_3} (the default
input sources for channel @code{0} to @code{3}), @code{NEXT_GATE} (the
gate input for the adjacent counter, where the adjacent counter for
channel @code{0} is channel @code{1} and vice versa, and channels
@code{2} and @code{3} also make up a pair) and @code{TIMEBASE_1} and
@code{TIMEBASE_2} (the internal timebases of @w{20 MHz} and @w{100 kHz}).

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{counter_timed_count()}
@findex counter_timed_count()
@item counter_timed_count()
This function is very similar to the previous function,
@ref{counter_start_timed_counter()}, i.e.@: it runs a counter for a
specified of time, but in contrast it waits for the requested duration
of time and only then returns with the masured count. In every other
respect, e.g.@: the required arguments etc.@: it is identical to the
previous function.

The largest value that can be returned is @w{2147483647}, i.e.@:
@w{2^31 - 1}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.



@anchor{counter_intermediate_count()}
@findex counter_intermediate_count()
@item counter_intermediate_count()
The function returns the current value of a counter. The counter may
still be running, in which case each call of the function will return an
updated value according to the number of events that happened between
invocations of the function. The function requires one argument, the
counter for which the current value is to be returned. It must be
specified by one of the symbolic names between @code{CH0} and @code{CH3}
(please @strong{don't} use numbers directly, the mapping between the
symbolic values and channel numbers is non-trivial).

The largest value that can be returned for a counter is @w{2147483647},
i.e.@: @w{2^31 - 1}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{counter_final_count()}
@findex counter_final_count()
@item counter_final_count()
This function waits for an counter to stop and only then returns the
final value of the counter. Trying to call this function on a counter
that has been started by the function
@ref{counter_start_continuous_counter()} and hasn't already been
stopped will fail, because such a counter will never stop by itself.

The function requires one argument, the counter for which the current
value is to be returned. It must be specified by one of the symbolic
names between @code{CH0} and @code{CH3} (please @strong{don't} use
numbers directly, the mapping between the symbolic values and channel
numbers is non-trivial).

The largest value that can be returned for a counter is @w{2147483647},
i.e.@: @w{2^31 - 1}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{counter_start_buffered_counter()}
@findex counter_start_buffered_counter()
@item counter_start_buffered_counter()
The function starts a counter, counting repeatedly for a specified time,
restarting from 0 at the end of the specified time. It can run in continuous
or non-continuous mode. In the first case acquisitions will repeated until
the counter is explicitely stopped while in the second case the counter
stops after a certain number of data points have been acquired.

The first argument the function expects is the number of the counter
It must be specified by one of the symbolic names between @code{CH0}
and @code{CH3} (please @strong{don't} use numbers directly, the mapping
between the symbolic values and channel numbers is non-trivial).
If the requested counter is already running the function will fail. 
Moreover, only a single counter can be used as a buffered counter at once.

@strong{Please note}: This function requires not only one counter
channel, i.e.@: the one passed to the function as the first argument,
but also a second, adjacent counter. If @code{CH0} is specified as the
counter channel also @code{CH1} will be needed and vice versa, and if
@code{CH2} is specified also @code{CH3} is required and vice versa. If
the adjacent counter is already in use for some other purpose the
function fails.

The second required argument is the length of time the counter is suppose
to count before being reset to 0. This time must be between @w{100 ns} and
about @w{214.748 s} and must be an integer multiple of @w{50 ns}.

If called without a further argument the counter will count events on
its default input and will run in continuous mode.

Alternatively, if the third argument is a number (or symbolic name) it
is taken to be the source of events to be counted which can be specified
by one of the following symbolic names: @code{DEFAULT_SOURCE} (which is
what would be used if no second argument is specified), @code{SOURCE_1}
to @code{SOURCE_3} (the default input sources for channel @code{0} to
@code{3}), @code{NEXT_GATE} (the gate input for the adjacent counter,
where the adjacent counter for channel @code{0} is channel @code{1}
and vice versa, and channels @code{2} and @code{3} also make up a pair)
and @code{TIMEBASE_1} and @code{TIMEBASE_2} (the internal timebases of
@w{20 MHz} and @w{100 kHz}).

If the third argument or, if a source was specified, the fourth argument
must be a string, either @code{"CONTINUOUS"} or @code{"NON-CONTINUOUS"},
telling if the counter sshould run in continuous or non-continuous mode.

If it is to be run in non-continuous mode another argument is required,
the number of data points to acquire, which obviously must be larger
than 0.

Also in continuos mode another argument can be specified, the number
of points to be used for the internal buffers (or @code{0} to explicitely
tell the program to use a default value which is either 1 second worth
of data or 1024 points, whatever is larger).

Using a buffered counter should be done only with some care and after
running several checks. There are two potential problems: if the time
teh counter is running between resets is too short for the computer to
keep up the acquisition automatically gets stopped and when trying to
fetch data the @code{EDL}-script will automatically abort. Moreover,
when running in continuous mode, also the internal buffer may overflow
if data are produced at a high rate and not fetched from within the
script fast enough. Also in this case the script will abort when trying
to fetch data. It's rather difficult to estimate what is too fast since
it may depend a lot on the resources of the computer used and ho much
workload there is. Careful tests with the system under usual load is
recommended before using buffered counting for important experiments.

The data acquired by a buffered counter have to be fetched via the
function @ref{counter_get_buffered_counts()}.

When done with a buffered counter it is required that the function
@ref{counter_stop_counter()} is called.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{counter_get_buffered_counts()}
@findex counter_get_buffered_counts()
@item counter_get_buffered_counts()
This function is for fetching data from a buffered counter. A buffered
counter produces a (possibly conntinuos if running in continuous mode)
stream of data which get returned by this function.

The first argument the function expects is the number of the counter
It must be specified by one of the symbolic names between @code{CH0}
and @code{CH3} (please @strong{don't} use numbers directly, the mapping
between the symbolic values and channel numbers is non-trivial).

The second argument must be the maximum number of points to be fetched.
This may be @code{0}, indicating in the case of a continuously running
acquisition that there is going to be another argument, indication for
how long to wait for more data at most, in which case as many data get
returned as were available during that time. For a non-continuous buffered
acquisition (when no time limit is specified) a zero number of points
means that all (remaining) data points are to be returned, with the
function waiting for the counter to stop.

The third argument is the time the function waits for data. It must be
given in continuous mode when the number of points is set to @code{0},
otherwise it is optional. It is a time in seconds with a maximum of about
@w{4294 s} and a granularity of microseconds. If given the function returns
only as many points as became available during that time. It can be be
@code{0.0} to indicate that the function should not wait at all and only
return the data points available at the time of the call. If the argument
is missing the function only returns when as many data as requested have
become available or all data are fetched..

The function returns an array of data points to the @code{EDL}-script.
The length of the array depends on the the specified maximum number of
points and the maximum time to wait for points. The length can also be
@code{0} either because no points were available at all within the
specified time limit or because all data points already had been
fetched (in the case of a non-continuous acquisition).

The largest value that can be returned is @w{2147483647}, i.e.@: @w{2^31 - 1}.

If during the call it is detected that either the computer could not
keep up with the rate data were acquired or, in continuous mode,
the internal buffers did overflow, the experiment gets aborted.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.



@anchor{counter_stop_counter()}
@findex counter_stop_counter()
@item counter_stop_counter()
This function can be used to stop a counter independently of the purpose
(i.e.@: counting or pulse train creation, see below) it was started
for. It requires one argument, the counter to be stopped. It must be
specified by one of the symbolic values between @code{CH0} and
@code{CH3} (please @strong{don't} use numbers directly, the mapping
between the symbolic values and channel numbers is non-trivial).

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{counter_single_pulse()}
@findex counter_single_pulse()
@item counter_single_pulse()
Beside being used as event counters the counters can also be used to
create pulses on its default output port. This function can be used to
create a single pulse on the output port. It requires two arguments, the
first being the counter to be used, specified by a symbolic value
between @code{CH0} and @code{CH3}. If the requested counter is already
running the function will fail. The second argument is the length of the
pulse, which must be between @w{100 ns} and about @w{214.748 s} and must
be an integer multiple of @w{50 ns}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{counter_continuous_pulses()}
@findex counter_continuous_pulses()
@item counter_continuous_pulses()
This function allows to create a continuous train of pulses. It requires
at least two arguments, the first being the counter to be used,
specified by a symbolic value between @code{CH0} and @code{CH3}. If the
requested counter is already running the function will fail. The second
argument is the length of the pulse, which must be between @w{100 ns}
and about @w{214.748 s} and must be an integer multiple of @w{50 ns}.

If no third argument is specified the distance between pulses will be
identical to the pulse length (resulting in a pulse frequency of twice
the value of the second argument). By specifying a third argument (with
the same restrictions as for the second argument) the distance between
pulses can be set.

To stop creation of pulses (and to free the counter for other uses) the
function @ref{counter_stop_counter()} must be called.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{counter_dio_read()}
@findex counter_dio_read()
@item counter_dio_read()
Beside counters the card also can do digital input and output. There are
8 lines that can be monitored or set. Using this function the current
state of any subset of these 8 lines can be determined. If the function
is called without an argument the state of all lines is returned, with
the lowest bit of the number returned being the state of the
lowest numbered DIO line, the seond-lowest bit of the number standing
for the second-lowest numbered DIO line etc. If all lines are set the
returned value is thus @code{255}.

If an integer argument gets passed to the function it is taken as a
mask, determining which of the DIO lines are to be treated as input
lines. The lowest bit of the mask stands for the lowest numbered DIO
line, the second-lowest bit of the mask for the second-lowest DIO line
etc. Thus, by specifying a mask of value of @code{1} the state of only
the DIO line numbered @code{0} would be returned, for a mask of value of
@code{2} the state of DIO line @code{1}, for @code{4} DIO line @code{2}
etc. By adding values for different DIO lines a subset of the DIO lines
can be specified. Simple arithmetics show that the value of the mask
must be between @code{0} (no DIO lines selected) and @code{255} (all DIO
lines selected, which is the default). All bits in the resulting return
value for which bits in the mask ae not set will be returned as being
set to @code{0}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{counter_dio_write()}
@findex counter_dio_write()
@item counter_dio_write()
The 8 DIO lines of the card can not only be monitored (see the previous
function, @ref{counter_dio_read()}) but also set, which this function
is to be used for. The function requires at least one integer argument,
defining the states of the DIO lines to be set to. To output a high
voltage at one of the DIO lines the corresponding bit of the value must
be set.  The lowest bit of the value corresponds to the lowest numbered
DIO line, the second-lowest bit to the second-lowest numbered DIO line
etc. To only set the lowest numbered DIO line the value passed to the
function would have to be @code{1}, to set only the second-lowest
numbered DIO line the value would be @code{2}, to set only the
third-lowest numbered DIO line a value of @code{4} would be used. By
combining these values for the different DIO lines a certain output
pattern can be set for all DIO lines. Obviously, the allowed values are
restricted to the range between @code{0} (all DIO lines in low state) to
@code{255} (all DIO lines in high state).

Without a second argument all 8 DIO lines are switched to output mode
and the states of the lines set according to the value of the first
argument.  But by passing the function a mask value as the second
argument only a certain subset of the DIO lines will be set to output
mode, thus allowing to have some of the DIO lines for output, while the
can be used as input lines. Each set bit in the mask will switch the
corresponding lines to output state while not changing mode for the
lines for which no bit is set in the mask. Bits in the first argument
for which no bit is set in the second argument will be not used, i.e.@:
don't influence the state of the DIO lines.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.

@end table


@node CCD Camera Functions, Monochromator Functions, Event Counter Functions, Device Functions
@section CCD Camera Functions
@cindex CCD Camera Functions

The only currently supplied CCD camera is the @strong{Roper Scientific
Spec-10} camera (without a shutter and with LN cooling). Its module is loaded
by specifying
@example
rs_spec10
@end example
in the @code{DEVICES} section. 

The module requires the PVCAM library supplied by @strong{Roper Scientific} to
be installed. To to be able to work with the camera also the Linux device
driver for the PCI board used for the communication with camera, also supplied
by Roper Scientific, must be installed.

@strong{Please note}: By setting two variables the configuration file
the orientation of the spectra or images taken by the camera can be
influenced. They allow to mirror the spectra or images (i.e. exchanging
right and left side) and/or turn images upside-down. Since some
functions assume spectra to have an increasing wavelength or relative
wavenumber axis (or decreasing absolute wavenumber axis) this option
can be used to satisfy the requirement.

@strong{Please note}: At the start of the experiment the target
temperature for the camera is set to the lowest possible value unless a
target temperature is explicitely set using the function
@ref{ccd_camera_temperature()} (see below).

The values for the region of interest, the binning values, the binning
mode and the number of clear cycles are stored internally between
experiments, so at the start of an experiment these values are set
automatically to the ones they had in the previously run experiment.


@noindent
@strong{List of all CCD camera functions}:
@table @samp
@item @ref{ccd_camera_name()}
@item @ref{ccd_camera_roi()}
@item @ref{ccd_camera_binning()}
@item @ref{ccd_camera_binning_method()}
@item @ref{ccd_camera_exposure_time()}
@item @ref{ccd_camera_clear_cycles()}
@item @ref{ccd_camera_get_image()}
@item @ref{ccd_camera_get_spectrum()}
@item @ref{ccd_camera_temperature()}
@item @ref{ccd_camera_pixel_size()}
@item @ref{ccd_camera_pixel_area()}
@end table

@noindent
@strong{Descriptions of CCD camera functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{ccd_camera_name()}
@findex ccd_camera_name()

@table @samp

@item ccd_camera_name()
Returns a string with the name of the CCD camera being used.


@anchor{ccd_camera_roi()}
@findex ccd_camera_roi()
@item ccd_camera_roi()
The function is used to query or set the region of interest (ROI) of the
CCD chip to be used when fetching spectra or images from the
camera. When no arguments are specified the function returns an array
with 4 elements. Its first element is the @i{x}-coordinate of the lower
left hand of the ROI, the second element the @i{y}-coordinate of the
same point and the third and fourth element are the @i{x}- and
@i{y}-coordonate of the right hand upper corner of the ROI. The
coordinate of the lower left hand pixel of the CCD chip is @code{1,1},
the coordinates of the upper right hand corner are the width and height
of the chip.

If there is an argument this must be either an array with 4 elements that
specify the ROI as explained above or the string @code{"ALL"} to set the
ROI to the complete area of the CCD chip. Further calls of the functions
@ref{ccd_camera_get_image()} and @ref{ccd_camera_get_spectrum()} will
return pictures or spectra from the ROI specified by the command. If one
of the elements of the array specifying the ROI is @code{0} the
corresponding setting for the ROI remains unchanged.

If the ROI sizes do not fit the binning factors (i.e. the width or
height in pixels of the ROI isn't an integer multiple of the
corresponding binning factor) the upper right hand corner of the ROI
gets adjusted automatically when an image or spectrum is fetched from
the camera by reducing the ROI - only when the width or height would drop
below 1 the corresponing binning factors is reduced to guarantee that
at least a single value for the direction gets returned.

The ROI setting is stored between experiments, so when a new experiment
is started the ROI setting is identical to the one it had in a
previously run experiment.


@anchor{ccd_camera_binning()}
@findex ccd_camera_binning()
@item ccd_camera_binning()
The function allows to set or query the binning (i.e.@: the combining of
several pixels) done by the camera. If called with no arguments the
function returns an array with 2 elements. The first element is the
number of pixels that get binned in the (horizontal) @i{x}-direction,
the second element is the binning factor in (vertical) @i{y}-direction.

If the function is called with arguments the first argument must be an
either an array with 2 elements or a string. If the argument is an array
its first element is the number of pixels to be binned in
@i{x}-direction, the second the number in @i{y}-direction. If the number
is @code{0} the current setting of the binning value remains unchanged.
Alternatively, if the first argument is a string it can be only the
string @code{"NONE"} which tells the function to switch binning off.

If the number of pixels of the region of interest (ROI) in one of the
directions isn't a integer multiple of the corresponding binning size
the ROI is automatically reduced to an multiple of the binning size when
the next image or spectrum is fetched from the camera. Only if the ROI
size in a direction is smaller than the binning size the ROI size is
expanded to the binning size, resulting in a width of one of the
returned image or spectrum for this direction.

The function also accepts a second parameter, the binning method to be
used. You can use either hardware binning, i.e.@: binning is done by the
camera itself, or binning can be done by software, in which case the
whole image or spectrum is fetched from the camera and the binning is
done numerically on the received data). Wile hardware binning is faster
(mainly due to the reduced time required for the transfer) in some cases
it might lead to saturation effects when the sum of the values of all
pixels combined during binning would be larger than 65536. In this case
the value after binning would never exceed 65536.

The binning method argument must be either @code{0} or one of the
strings @code{"HARDWARE"} or @code{"HARD"} for use of hardware binning
or the number @code{1} or one of the strings @code{"SOFTWARE"} or
@code{"SOFT"} for software binning.

The binning factors and method are stored between experiments, so when a
new experiment is started the settings for the binnoing are identical to
the one they had in a previously run experiment.


@anchor{ccd_camera_binning_method()}
@findex ccd_camera_binning_method()
@item ccd_camera_binning_method()
This function lets you query or set the binning method to be used.  You
can use either hardware binning, i.e.@: binning is done by the camera
itself, or binning can be done by the software, in which case the whole
image or spectrum is fetched from the camera and the binning is done
numerically on the received data). Wile hardware binning is faster
(mainly due to the reduced time required for the transfer) in some cases
it might lead to artifacts when the sum of the values of all pixels
combined in binning would be larger than 65535. In this case the value
after binning is always 65536, leading to an effect that looks like
saturation of the region of the chip.

If called with no argument the function returns the number @code{0}
when hardware binning is used and @code{1} for software binning.

To set the binning method you must specify either @code{0} or one of the
strings @code{"HARDWARE"} or @code{"HARD"} for use of hardware binning
or the number @code{1} or one of the strings @code{"SOFTWARE"} or
@code{"SOFT"} for software binning.

The binning binning method is stored between experiments, so when a new
experiment is started its settingis identical to the it had in a
previously run experiment.


@anchor{ccd_camera_exposure_time()}
@findex ccd_camera_exposure_time()
@item ccd_camera_exposure_time()
The function can be used to determine or set the exposure time used by
the camera. If called without an argument the function returns the
exposure time in seconds. If called with an argument, the exposure time
in seconds, the exposure time is set. It must be between @w{1 us} and
one hour.

If no exposure time gets set a default value of @w{100 ms} is used.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{ccd_camera_clear_cycles()}
@findex ccd_camera_clear_cycles()
@item ccd_camera_clear_cycles()
The function allows to determine or set the number of clear cycles of
the CCD chip to be done before an exposure is started. If called without
an argument the function returns the number of clear cycles. If an
argument is passd to the function it must be a number between 0 and the
maximum number of clear cycles (which is 7 for the Spec-10 camera). The
default value of clear cycles is 1.

The number of clear cycles is stored between experiments, so when a new
experiment is started its setting is identical to the it had in a
previously run experiment.


The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{ccd_camera_get_image()}
@findex ccd_camera_get_image()
@item ccd_camera_get_image()
The function starts an exposure, fetches the resulting image from the
camera and returns it to the @code{EDL} script as a 2-dimensional
array. The size of the image depends on the setting of the region of
interest (ROI) and the settings for binning. When no ROI or binning has
been set the image returned is the whole area of the CCD chip.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{ccd_camera_get_spectrum()}
@findex ccd_camera_get_spectrum()
@item ccd_camera_get_spectrum()
The function starts an exposure, fetches the result from the camera and
returns it as an 1-dimensionl array to the @code{EDL} script. The length
of the array depends on the width of the region of interest (ROI) and
the binning setting for the (horizontal) @i{y}-direction. All pixels of
the ROI in the (vertical) @i{y}-direction are binned together.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{ccd_camera_temperature()}
@findex ccd_camera_temperature()
@item ccd_camera_temperature()
The function can be used to determine the current temperature of the CCD
chip or to set a target temperature for the chip. If called without an
argument the current temperature (in Kelvin) of the chip is returned.
If called with an argument this must be a number between @w{120.66 K}
(-152.5 degree Celsius) and @w{248.26 K} (-25 degree Celsius). Please
note that it may take quite some time until a target temperature is
reached.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{ccd_camera_pixel_size()}
@findex ccd_camera_pixel_size()
@item ccd_camera_pixel_size()
The function takes no arguments and returns the width of a pixel of the
CCD chip.


@anchor{ccd_camera_pixel_area()}
@findex ccd_camera_pixel_area()
@item ccd_camera_pixel_area()
The function accepts no arguments and returns an 1-dimensional array with
two elements, where the first argument is the number of pixels of the
CCD chip in the (horizintal) @i{x}-direction and the second element is
the number of pixels in the (vertical) @i{y}-direction.


@end table


@node Monochromator Functions, Power Supply Functions, CCD Camera Functions, Device Functions
@section Monochromator Functions
@cindex Monochromator Functions

Currently the @strong{SpectraPro-300i} series of monochromator (actually, the
module has only been tested with the @strong{308i}) by @strong{Acton Research
Corporation} and monochromators by @strong{SPEX} controlled via the CD2A
Compudrive interface are supported. The modules for the monochromators
get loaded by specifying
@example
spectrapro_300i
spex_cd2a
@end example
in the @code{DEVICES} section. 

There are two different types of monochromators by @strong{SPEX}. They are
either wavelength- or wavenumber-driven. In case of wavelength-driven
monochromators functions accepting or returning spectral positions
etc.@: expect or return them in units of wavelengths, i.e.@: in
@code{m}. In contrast, for wavenumber-driven monochromators the
functions expect or return values in wavenumber units, i.e.@: in
@code{cm^-1}. To make things even more interesting, for wavenumber
driven monochromators a laser line position can be set. If such a laser
line position is set values are expected or returned in relative
wavenumber units, i.e.@: as differences between the wavenumber of the
laser line and the absolute wavenumber.

Another important point is that for @strong{SPEX} type monochromators an offset
(between the wavelength or -number displayed by the CD2A unit and the
"real" wavelength or -number is automatically taken into account. Thus
the position reported by the program and at the console of the CD2A unit
may differ because the program tries to take care of the offset (see the
description of the function @ref{monochromator_calibrate()} below for
more information). Furthermore, for wavenumber-driven SPEX
monochromators also the position of the laser line gets remembered
between experiments. These informations are stored in a file in the same
directory where the module for the device resides (under the name
@file{spex_cd2a.calib} unless specified differently in the configuration
file for the device). This file automatically gets read in when the
module is loaded and at the start of each experiment and rewritten at
the end of the experiment.

Some of the functions listed below will only work when a monochromator is used
in conjunction with a CCD camera (and have been tested only with the
@strong{Spec-10} CCD camera by @strong{Roper Scientific} in conjunction with
the supported monochromatore).


@noindent
@strong{List of all monochromator functions}:
@table @samp
@item @ref{monochromator_name()}
@item @ref{monochromator_wavelength()}
@item @ref{monochromator_wavenumber()}
@item @ref{monochromator_laser_line()}
@item @ref{monochromator_scan_setup()}
@item @ref{monochromator_start_scan()}
@item @ref{monochromator_scan_step()}
@item @ref{monochromator_shutter_limits()}
@item @ref{monochromator_groove_density()}
@item @ref{monochromator_grating()}
@item @ref{monochromator_turret()}
@item @ref{monochromator_wavelength_axis()}
@item @ref{monochromator_wavenumber_axis()}
@item @ref{monochromator_calc_wavelength()}
@item @ref{monochromator_load_calibration()}
@item @ref{monochromator_set_calibration()}
@item @ref{monochromator_install_grating()}
@item @ref{monochromator_zero_offset()}
@item @ref{monochromator_grating_adjust()}
@item @ref{monochromator_calibrate()}
@end table

@noindent
@strong{Descriptions of monochromator functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{monochromator_name()}
@findex monochromator_name()

@table @samp

@item monochromator_name()
Returns a string with the name of the monochromator being used.


@anchor{monochromator_wavelength()}
@findex monochromator_wavelength()
@item monochromator_wavelength()
If called with no argument the function returns the current center
wavelength (in m) of the grating. If called with an argument the grating
is moved to the specified center wavelength (which must be in the range
covered by the monochromator and the current grating).

Please note: for @strong{SPEX} monochromators doing a scan calling this
function automatically aborts the currently running scan.


@anchor{monochromator_wavenumber()}
@findex monochromator_wavenumber()
@item monochromator_wavenumber()
If called with no argument this function returns the current center
wavenumber in @code{cm^-1} of the grating, either in absolute units or,
if a laser line position has been set, in relative units, i.e.@: as the
difference between the laser line position and the gratings center
wavenumber. If called with an argument the grating is moved to the
specified center wavenumber, which must be given in absolute units if no
laser line position has been set, otherwise in relative units. The
possible range depends on the grating being used.

Please note: for @strong{SPEX} monochromators doing a scan calling this
function automatically aborts the currently running scan.


@anchor{monochromator_laser_line()}
@findex monochromator_laser_line()
@item monochromator_laser_line()
The function is only supported for wavenumber-driven @strong{SPEX}
monochromators. It allows to set (or query if the function is called
without an argument) to set a laser line position. If such a laser line
has been set the device automatically switches to using relative
wavenumbers, i.e.@: differences between the laser line position and
absolute wavenumbers. All @code{EDL} functions accepting or returning
spectral positions will then also switch to such relative wavenumbers.

To set a laser line position the function expects a single argument, the
position in absolute wavenumbers (even when a different laser line
position has already been set and other functions expect spectral
positions in relative wavenumbers!). To switch use of a laser line
position off (and thus revert to spectral positions in absolute a zero
or negative value must be passed to the function.

The module will store the current value of the laser line position at
the end of an experiment and start off with this value when the next
experiment is started (even if the setting has been changed manually at
the CD2A console, so make sure you call this function at least once
after installing a new laser with a different line position).

Please note: for monochromators doing a scan calling this function
automatically aborts the currently running scan.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{monochromator_scan_setup()}
@findex monochromator_scan_setup()
@item monochromator_scan_setup()
The function is only supported for @strong{SPEX} monochromators. These have
a special scan mode, where scans can be done going from low to high
wavelengths or from high to low wavenumbers (during a scan the
monochromator doesn't have to do backslash removal, making the slew to a
new position faster). For being able to start a scan the start position
and the step width for the scan must be defined, which can be done using
this function. To set the scan parameter the function expects to
arguments, first the start position of the scan, given in wavelength
units for wavelength-driven monochromators and in wavenumbers (absolute,
if no laser line position is set, otherwise in relative units). The
second argument is the step width, which must be a positive wavelength
or wavenumber step size (even though for wavenumber-driven
monochromators the scan is always in the direction of lower
wavenumbers!).

If called without an argument, the function returns a two-dinemsional
array, with the first argument being the start position and the second
the scan step size.

Please note: for monochromators doing a scan calling this function
automatically aborts the currently running scan.


@anchor{monochromator_start_scan()}
@findex monochromator_start_scan()
@item monochromator_start_scan()
The function is only supported for @strong{SPEX} monochromators and requires
that the function @ref{monochromator_scan_setup()} has been called previously
to define the scan parameters. It slews the monochromator to the start
position of the scan, switches to scan mode and returns the spectral position
of the monochromator, either in wavelength units for wavelength driven
monochromators or wavenumbers for wavenumber driven ones (in absolute units,
if no laser line position has been set, otherwise in relative units).

Please note: if the monochromators is already doing a scan calling this
function automatically aborts the running scan.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{monochromator_scan_step()}
@findex monochromator_scan_step()
@item monochromator_scan_step()
The function is only supported for @strong{SPEX} monochromators and requires
that both the function @ref{monochromator_scan_setup()} has been called
previously to define the scan parameters and that the monochromator has been
switched to scan mode by calling @ref{monochromator_start_scan()}.  The
function slews the monochromator to the next spectral position by the scan
step size and returns the new position, either in wavelength units for
wavelength driven monochromators or wavenumbers for wavenumber driven ones (in
absolute units, if no laser line position has been set, otherwise in relative
units).

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{monochromator_shutter_limits()}
@findex monochromator_shutter_limits()
@item monochromator_shutter_limits()
The function is only supported for @strong{SPEX} monochromators that have
shutters to protect the PMT or APD etc.@: from excitation light in a
certain frequency range. The function can be used to query or set these
shutter limits. To set the shutter limits the function expects two
arguments, the lower and the upper shutter limit. If a laser line
position has been set the function won't allow to set the shutter limits
to values that don't cover the laser line. When called without an
argument the function returns a two-dimensional array, with the first
element being the lower shutter limit and the second the upper shutter
limit.

Please note: for monochromators doing a scan calling this function
automatically aborts the currently running scan.


@anchor{monochromator_groove_density()}
@findex monochromator_groove_density()
@item monochromator_groove_density()
If called with no argument the function returns the number of grooves
per meter of the currently used grating. If called with an integer
argument it returns the number of grooves per m of the grating indexed
by the number (an integer between 1 and the maximum number of installed
gratings) passed to the function.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{monochromator_grating()}
@findex monochromator_grating()
@item monochromator_grating()
The function is only supported for @strong{SpectraPro-300i} monochromators. It
queries or sets a new grating. If called with no argument the function
returns the number of the currently used grating (an integer between 1
and the maximum number of installed gratings). If called with an integer
argument the monochromator switches to the grating indexed by the number
if it is available. The center wavelength the new grating is set to
remains the same as for the previous grating.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{monochromator_turret()}
@findex monochromator_turret()
@item monochromator_turret()
The function is only supported for @strong{SpectraPro-300i} monochromators. If
called with no argument the function returns the number of the currently
used turret of the monochromator (an integer number starting at 1). If
called with an integer argument it switches the monochromator to the
indexed turret.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{monochromator_wavelength_axis()}
@findex monochromator_wavelength_axis()
@item monochromator_wavelength_axis()
The function requires that the module for a CCD camera is available that
returns information about the number of pixels of the CCD chip and the
distance between pixels. It then returns an array with two elements,
with the first element being the wavelength at the leftmost pixel of the
chip and the second element being the wavelength difference between
neighboring pixels. The function can also be called with up to two
arguments, an integer for the grating number and the wavelength at the
center of the chip. If these arguments aren't given, the currently used
grating and wavelength of the monochromator are used.

For @strong{SpectraPro-300i} monochromators it is required that a
calibration for the grating has been loaded, either by calling
@ref{monochromator_set_calibration()} or
@ref{monochromator_load_calibration()}. If no calibration
has been loaded for the grating a warning is printed and the returned
scaling values represent pixel numbers relative to the center of the CCD
chip, not wavelengths.

The function is mostly meant to make it easy to obtain a wavelength
scale to be used with the functions @ref{change_scale_1d()} and
@ref{change_scale_2d()}. If binning is used in @i{x}-direction the
elements of the returned array can't be used directly as arguments for
the functions for changing the scale but to the first element you will
have to add halve the number of pixels binned together and multiplied by
the second element while the second element needs to be multiplied by
the number of pixels binned together. Here's an example on how to use
the function to set a wavelength @code{x}-axis, assuming that
@code{xbin} is the number of bits binned together in @i{x}-direction and
@code{scale} is an array with two elements:
@example
scale = monochromator_wavelength_axis( );
change_scale_1d( scale[ 1 ] + 0.5 * xbin * scale[ 2 ],
                 xbin * scale[ 2 ] );
@end example

@strong{Please note}: The wavelength difference between two neighboring
pixels isn't really constant over the whole width of the CCD chip. When
you use the returned values only for the center of the chip the results
are in quite good agreement with the real wavelengths, but for the edges
of the chip the accuracy deteriorates significantly. For example for a
grating with 1200 grooves per mm the deviation is about @w{0.5 nm} and
for gratings with lower groove densities the deviation gets even larger,
proportional to the inverse of the groove density. To obtain the exact
wavelength for a certain pixel on the chip use the function
@ref{monochromator_calc_wavelength()} discussed below.

@strong{Please note}: The function assumes that the spectra taken with
the camera show increasing wavelengths going from the left to the right
side!

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{monochromator_wavenumber_axis()}
@findex monochromator_wavenumber_axis()
@item monochromator_wavenumber_axis()
This function is similar to the function
@ref{monochromator_wavelength_axis()} but instead of returning values
to be used for setting a wavelength axis the values are suitable for
setting up a wavenumber axis.

@strong{Please note}: The function assumes that the spectra taken with
the camera show decreasing absolute wavenumbers and increasing relative
wavenumbers going from the left to the right side!

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{monochromator_calc_wavelength()}
@findex monochromator_calc_wavelength()
@item monochromator_calc_wavelength()
The function is only supported for @strong{SpectraPro-300i} monochromators. It
requires that the module for a CCD camera is available that returns
information about the number of pixels of the CCD chip and the distance
between pixels. It accepts a pixel position or an array of pixel
positions on the CCD chip (relative to the left edge of the chip and
starting with 1) and returns, depending on the type of the argument,
either a number or an array with the exact wavelengths for the pixel
position(s). The function also accepts up to two arguments, an integer
for the grating number and the wavelength at the center of the chip. If
these arguments aren't given, the currently used grating and wavelength
of the monochromator are used.

To be able to work the function also requires that a calibration for the
grating has been loaded, either by calling
@ref{monochromator_set_calibration()} or
@ref{monochromator_load_calibration()} (see below). If no calibration
has been loaded for the grating a warning is printed and the input
value(s) are simply returned.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{monochromator_load_calibration()}
@findex monochromator_load_calibration()
@item monochromator_load_calibration()
The function is only supported for @strong{SpectraPro-300i} monochromators. It
tries to load a file with calibration data for one or more of the
gratings. For each grating three values are required for a complete
calibration.

The first value is the inclusion angle (i.e.@: the angle between the
incident and the reflected beam for the center wavelength of the
grating) of the monochromator (in degrees), the second the focal length
of the monochromator (in m) and the third and final value is the
detector angle (in degrees), i.e.@: the angle by which the plane of the
CCD chip is rotated out of the focal plane.

In the calibration file you will find lines like the following for each
of the gratings:
@example
INCLUSION_ANGLE_1  =   30.3
FOCAL_LENGTH_1     =   301.2 mm
DETECTOR_ANGLE_1   =   0.324871
@end example
@noindent
The number appended to each of the keywords stands for the grating (in
this example the first) they are to be used with.

Calling the function will load the data from the calibration file. These
calibration data are required to be able to calculate correct
wavelengths for the pixel positions of the CCD chip.

When the function gets called without an argument it tries to read a
default calibration file. The name of this file is compiled into the
module and can be changed via the configuration file of the module and
then recompiling the module. If an argument is passed to the function
this must be a string with the name of a file that the program has the
permissions to read.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{monochromator_set_calibration()}
@findex monochromator_set_calibration()
@item monochromator_set_calibration()
The function is only supported for @strong{SpectraPro-300i} monochromators. It
allows to set calibration data for a grating directly instead of reading
them from a file. It can also used to reset the calibration for a
grating.

The function expects 4 arguments, the grating number (an integer between
1 and the maximum number of installed gratings), the inclusion angle (in
degrees), the focal length (in m) and the detector angle (in degrees).

Alternatively, to clear the calibration for a grating the function can
also be called with two arguments, the number of the grating and the
string @code{"DELETE"}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{monochromator_install_grating()}
@findex monochromator_install_grating()
@item monochromator_install_grating()
The function is only supported for @strong{SpectraPro-300i} monochromators. It
can be used to tell the monochromator about a new grating.  It expects
two arguments, the grating number (an integer between 1 and the maximum
number of installable gratings) and a string with the part number of the
newly installed grating. All part numbers are expected to start with a
single digit, followed by a dash, a three-digit number with the number
grooves per thenth of a mm (if necessary left-filled with zeros),
another dash and an identifier for the blaze wavelength or type of the
grating. Thus a valid part number string would be e.g.@:
@code{"1-120-750"} for a grating with 1200 grooves per mm and a blazing
wavelength of @w{750 nm}. Another possible part number string is
@code{"2-030-HVIS"}. The total length of the string may not excceed 10
characters.

Alternatively, the function can also be used to tell the monochromator
that a grating has been removed. In this case the part number string has
to be replaced by the string @code{"UNINSTALL"}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{monochromator_zero_offset()}
@findex monochromator_zero_offset()
@item monochromator_zero_offset()
The function is only supported for @strong{SpectraPro-300i} monochromators. It
allows to either query or set the zero offset of a grating. The zero
offset is basically an angle that results from misalignments of the
grating (and the CCD chip) and leads to the zero order peak not
appearing exactly at the center of the CCD chip. By setting the zero
offset value correctly this misalignments can be compensated for. It is
expressed as a number in the interval @code{[-1,+1]} and the correct
value can only be found experimentally.

The function expects at least one argument, an integer number
designating the grating (an integer between 1 and the maximum number of
installed gratings). If there is no second argument the function returns
the zero offset used for the grating. If there is a second argument
(which must be between -1 and +1) the zero offset is set to this value.

Please note: setting a zero offset takes quite a long time (about half a
minute), mainly because the monochromator needs to be
reset. Fortunately, setting a new zero offset is only required when
e.g.@: the monochromator has been opened up. Since the zero offset
values are stored in non-volatile memory of the monochomator the setting
won't get lost when the monochromator is switched off.


The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{monochromator_grating_adjust()}
@findex monochromator_grating_adjust()
@item monochromator_grating_adjust()
The function is only supported for @strong{SpectraPro-300i} monochromators. The
value that can be queried or set by this function is used to adjust the
angle by which the grating is rotated when moving it to a certain
wavelength. The monochromator has a built-in default value for the ratio
between the angle and the wavelength which can be changed by the grating
adjust value. If this value (and also the zero offset, see above) is set
correctly, a line will appear at the center of the CCD chip when the
monochronator is set to the wavelength of the line.

The grating adjust value is a number in the interval @code{[-1,+1]} and
can the correct setting can only be found experimentally.

The function expects at least one argument, an integer number
designating the grating (an integer between 1 and the maximum number of
installed gratings). If there is no second argument the function returns
the currently used value for the grating adjust value. Otherwise the
second argument must be a number between -1 and +1 and the grating
adjust is set to this value.

Please note: setting a grating adjust value takes quite a long time (up
to half a minute), mainly because the monochromator needs to be
reset. Fortunately, setting a new grating adjust value is required when
e.g.@: the monochromator has been opened up. Since the grating adjust
values are stored in non-volatile memory of the monochomator the setting
won't get lost when the monochromator is switched off.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{monochromator_calibrate()}
@findex monochromator_calibrate()
@item monochromator_calibrate()
The function is takes different arguments for the @strong{SpectraPro-300i} and
the @strong{SPEX} monochromator.

For the @strong{SpectraPro-300i} it is for use in the dispersion
calibration of a grating, i.e.@: the procedure where from a set of at
least 4 measured positions of known lines (at at least two different
center wavelengths) the optimum values for the inclusion angle, the
focal length and the detector angle are determined.  This function
requires that the module for a CCD camera is available that returns
information about the number of pixels of the CCD chip and the distance
between pixels.

The function expects a minimum of 5 arguments. The first is the grating
number (an integer between 1 and the maximum number of installed
gratings). The second is an array of the wavelengths of at least 4
measured lines (given in m). The third is the array of the center
wavelengths used in the measurements of the lines (also given in m). The
fourth is the array of the diffraction orders the lines where measured
at. The fifth required array is the array of the measured line
positions, given in pixel positions on the CCD chip (relative to the
left edge, where the leftmost pixel is corresponds to position 1). All
arrays must have the same length.

Using these values the function will now try to find the best fit for
first the inclusion angle, then the focal length and finally the
detector angle using a Simplex algorithm.

You may influence the way the Simplex algorithm tries to find the
optimum values by specifying seven further, optional arguments: @w{1.@:
the} end criterion for the fit (per default this value is set to
@code{1.0e-9}, @w{2.@: the} start value for the inclusion angle (in
degrees), @w{3.@: the} start value for the focal length (in m), @w{4.@:
the} start value for the detector angle (in degrees), @w{5.@: the} start
deviation for the inclusion angle (in degrees), @w{6.@: the} start
deviation for the focal length (in m) and finally, @w{7.@: the} start
deviation for the detector angle (in degrees).

After the function found what it guesses to be the optimum paramters it
returns an (1-dimensional) array with three elements, where the first
element is the inclusion angle (in degrees), the second element is the
focal length (in m) and the third is the detector angle (in degrees).

When called without an argument for @strong{SpectraPro-300i}
monochromators the function returns an array with three elements, which
are the current calibration settings for the inclusion angle (in
degree), the focal length (in @code{m}) and the detector angle (in degree).

For the @strong{SPEX} monochromators it can be used to set an offset
between the wavelength or -number used to set the monochromator to
the current position and the "real", i.e.@: experimentally determined
wavelength or (absolute) wavenumber. Once it has been set, all functions
will take this offset into account when talking with the device.

The second calibration value (the optional second argument) to be set by
the function for @strong{SPEX} monochromators is the wavelength (even for
wavenumber driven monochromators) difference between two pixels of an
attached CCD camera.

The offset is taken to be the difference between the "real" position of
a line and the position where it appears when measured with @code{fsc2}.
Thus the usual procedure to set the offset is to measure the position of
a well-known line using @code{fsc2} and then to call the function with
the difference between the "real" position and the observed position.
Afterwards @code{fsc2} will automatically take the offset into account
and, after a further call to @ref{monochromator_wavelength()} or
@ref{monochromator_wavenumber()}, the line should seem to appear at the
expected position.

Please note that the offset can @strong{only} be set for wavenumber
driven monochromators while using absolute wavenumbers, i.e.@: while no
laser line position is set! If you want to determine and set a new
offset first store the current laser line position, switch off use of a
laser line position by calling @ref{monochromator_laser_line()} with a
zero argument and only after measuring and setting a new offset set the
laser line position again.

If called without an argument for @strong{SPEX} monochromators the
function returns an array with two elements, representing the current
calibration setting of the offset (in @code{m} for wavelength driven and
in @code{cm^-1} for wavenumber driven monochromators) and the wavelength
or -number difference between two adjacent CCD camera pixels (or
@code{0} if the value isn't known).

Please note: To set the offset of a @strong{SPEX} monochromator to
@code{0} @strong{don't} pass a zero argument for the offset to the
function. Instead determine the current offset setting by a call without
arguments and then call the function again with that offset as the first
argument!.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.

@end table


@node Power Supply Functions, Microwave Attenuator Functions, Monochromator Functions, Device Functions
@section Power Supply Functions
@cindex Power Supply Functions

The currently supplied power supplies are the @strong{Thurlby&Thandar
PL330DP} and the @strong{F.u.G. Elektronik GmbH MCN700-2000}. The modules
for these power supplies are loaded
by specifying
@example
thurlby330
mcn700_2000
@end example
@noindent
in the @code{DEVICES} section. 


@noindent
@strong{List of all power supply functions}:
@table @samp
@item @ref{powersupply_name()}
@item @ref{powersupply_channel_state()}
@item @ref{powersupply_damping()}
@item @ref{powersupply_voltage()}
@item @ref{powersupply_voltage_limit()}
@item @ref{powersupply_current()}
@item @ref{powersupply_current_limit()}
@end table

@noindent
@strong{Descriptions of power supply functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{powersupply_name()}
@findex powersuppy_name()

@table @samp

@item powersupply_name()
Returns a string with the name of the power supply being used.


@anchor{powersupply_channel_state()}
@findex powersupply_channel_state()
@item powersupply_channel_state()
This function exists only for the @strong{Thurlby&Thandar} power supply and
allows to switch the channels of the power supply on or off. It requires two
arguments. The first one is the channel, which must be either @code{CH1} or
@code{CH2} (don't try use simple numbers instead!). The second argument is
the state, i.e.@: either @code{"ON"} or @code{"OFF"} (or @code{1} for on
and @code{0} for off).

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{powersupply_damping()}
@findex powersupply_damping()
@item powersupply_damping()
This function exists only for the @strong{Thurlby&Thandar} power supply and
allows to switch damping of the output of one of the channels of the power
supply on or off. It requires two arguments. The first one is the channel,
which must be either @code{CH1} or @code{CH2} (don't use simple numbers
instead!).  The second argument is the damping state, i.e.@: either
@code{"ON"} or @code{"OFF"} (or @code{1} for on and @code{0} for off).

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{powersupply_voltage()}
@findex powersupply_voltage()
@item powersupply_voltage()
This function allows to either set or query the output voltage.

For the @strong{MCN700-2000} when called with no argument the
output voltage is returned, when called with an argument the voltage
is set to this value in the range between 0 and @w{2000 V} (unless the
current limiter kicks in - the returned value is the voltage that really
go set).

For the @strong{Thurlby&Thandar} it sets the output volatge for one of
its channels. For a query only one argument is required, the channel,
which must be specified as either @code{CH1} or @code{CH2} (don't use
simple numbers instead!). If there is no second argument the output
voltage at the channel is returned.

If there is a second argument, being a voltage in the range between @w{0
V} and @w{32 V}, the output voltage is set instead. Please note that this
voltage may not appear at the outputs when the setting for the current
limit does not allow it.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{powersupply_voltage_limit()}
@findex powersupply_voltage_limit()
@item powersupply_voltage_limit()
This function exists only for the @strong{Thurlby&Thandar} power supply and
allows to query the current setting of the voltage limit. It expects one
argument, the channel, which must be specified as either @code{CH1} or
@code{CH2} (don't use simple numbers instead!).

If there is a second argument, being a voltage in the range between @w{0
V} and @w{32 V}, this value is used as the new voltage limit. The same
effect can be achieved by calling the function
@ref{powersupply_voltage()}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{powersupply_current()}
@findex powersupply_current()
@item powersupply_current()
This function allows to either set or query the output current

For the @strong{MCN700-2000} when called with no argument the
output current is returned, when called with an argument the current
is set to this value in the range between 0 and @w{300 mA} (unless the
voltage limiter kicks in - the returned value is the current that really
go set).

For the @strong{Thurlby&Thandar} power supply the function sets or queries
the current of one of the channels. For a query only one argument is
required, the channel, which must be specified as either @code{CH1} or
@code{CH2} (don't use simple numbers instead!). If there is no second
argument the output current at the channel is returned.

If there is a second argument, being a current in the range between @w{0
A} and @w{3 A}, the output current is set instead. Please note that this
current may not appear at the outputs when the setting for the voltage
limit does not allow it.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{powersupply_current_limit()}
@findex powersupply_current_limit()
@item powersupply_current_limit()
This function exists only for the @strong{Thurlby&Thandar} power supply and
allows to query the current setting of the current limit. It expects one
argument, the channel, which must be specified as either @code{CH1} or
@code{CH2} (don't use simple numbers instead!).

If there is a second argument, being a current in the range between @w{0
A} and @w{3 A}, this value is used as the new current limit. The same
effect can be achieved by calling the function
@ref{powersupply_current()}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.

@end table


@node Microwave Attenuator Functions, Light Chopper Functions, Power Supply Functions, Device Functions
@section Microwave Attenuator Functions
@cindex Microwave Attenuator Functions

The only currently supported computer controllable microwave attenuator
is a home-built device from the group of H.-J.@: Steinhoff at the
University of Osnabrueck. It works with a stepper motor controlled via
the serial port. The module for the device is loaded by specifying
@example
hjs_attenuator
@end example
@noindent
in the @code{DEVICES} section. 

To load the device module a default calibration file is required that
states which attenuation gets set for the settings of the stepper
motor. The name of the file can be set in the configuration file for the
module.


@noindent
@strong{List of all microwave attenuator functions}:
@table @samp
@item @ref{mw_attenuator_name()}
@item @ref{mw_attenuator_load_calibration()}
@item @ref{mw_attenuator_initial_attenuation()}
@item @ref{mw_attenuator_attenuation()}
@end table

@noindent
@strong{Descriptions of microwave attenuator functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{mw_attenuator_name()}
@findex mw_attenuator_name()

@table @samp

@item mw_attenuator_name()
Returns a string with the name of the power supply being used.


@anchor{mw_attenuator_load_calibration()}
@findex mw_attenuator_load_calibration()
@item mw_attenuator_load_calibration()
This function can be used to load a calibration table file different
from the one read in when the module is loaded. It expects a single
argument, a (string) variable with the name of the table file. If no
argument is given a default table file is reloaded (typically this is
@file{/usr/local/lib/fsc2/hjs_attenuator.calib}, but this may depend on
the installation of @code{fsc2}).

If this function is used it @strong{must} be called before the functions
@ref{mw_attenuator_initial_attenuation()} or
@ref{mw_attenuator_attenuation()} are invoked. Once an attenuation has
been set calibrations can't be loaded in anymore.

The calibration file must consist of pairs of entries, an attenuation
(in dB) and a stepper motor position. Attenuations values may be
followed by an unit of @code{dB} or @code{dB}. The attenuation entries
in the file don't have to be sorted in any way and don't have to be
equidistant. The only requirement is that the stepper motor settings are
a monotonuously decreasing function of the attenuation.

The items in the table file can be separated by spaces, commas,
semicolons, colons, tabs or any combination of these characters (a unit
will also work as a separator). Thus all the following entries would be
valid:
@example
1.2 dB 2135
1.4, 2087
10.7 db786
@end example
@noindent
Blank lines don't matter. Finally, all lines starting with a hash
character, `@code{#}', are treated as comments.

If an attenuation is used that isn't in the table read in from the file
the stepper motor setting to be used is linearly interpolated from the
next neighboring values. as long as the attenuation isn't smaller or
larger than the minimum or maximum attenuation in the table.

The function can only be used in the @code{PREPARATIONS} section of an
@code{EDL} script.


@anchor{mw_attenuator_initial_attenuation()}
@findex mw_attenuator_initial_attenuation()
@item mw_attenuator_initial_attenuation()
The module has no way to find out to find out the setting of the
attenuation at the start of the experiment but this information is
obviously required to change the attenuation to a new value. Thus this
function @strong{must} be called before setting a new attenuation.  It
expects a single argument, the current attenuation setting, which has to
be within the range of attenuations covered by the calibration file. The
function may not be called again (until a new experiment is started).


@anchor{mw_attenuator_attenuation()}
@findex mw_attenuator_attenuation()
@item mw_attenuator_attenuation()
Thsi function can be used to query the current attenuation or set a new
one. If called with no argument it returns the currently attenuation. If
it is called with an argument the attenuation is set to this new value.
The new value has to be within the range of attenuations covered by the
calibration file either read in when the module was loaded or by a later
invocation of the function @ref{mw_attenuator_load_calibration()}.
Attenuation values within this range but not listed in the table are
handled by linear interpolation of the nearest neighboring values.

@strong{Please note}: The function
@ref{mw_attenuator_initial_attenuation()} must be called before the
first invocation of this function to make the module aware about the
setting of the attenuation when the experiment was started.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.

@end table


@node Light Chopper Functions, Multi-Device Functions, Microwave Attenuator Functions, Device Functions
@section Light Chopper Functions
@cindex Light Chopper Functions
Currently there's just a single supported light chopper. It is a chopper
used in the group of G.@: Gescheidt (Graz University of Technology,
Austria), that, via some homebuild electronics@footnote{see Ph.D.@:
thesis by Torsten Zytowski, Z@"urich 1998} is indirectly controlled by a
data acquisition device, currently the @strong{National Instruments
PCI-MIO-16E-1} DAQ card. The module for the device is loaded by
specifying
@example
gg_chopper
@end example
@noindent
in the @code{DEVICES} section. Please note that the name of the module
for the DAQ device (@code{pci_mio_16e_1}) must be listed before this
module.

Unless a rotation frequency has set already during the
@code{PREPARATIONS} section the chopper will only start to rotate
when a resonable rotation frequency is set by calling the function
@ref{chopper_rotation_frequency()}. At the end of an experiment the
chopper gets stopped automatically.


@noindent
@strong{List of all chopper functions}:
@table @samp
@item @ref{chopper_name()}
@item @ref{chopper_rotation_frequency()}
@item @ref{chopper_create_trigger()}
@end table

@noindent
@strong{Descriptions of chopper functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{chopper_name()}
@findex chopper_name()

@table @samp

@item chopper_name()
Returns a string with the name of the chopper being used.

@anchor{chopper_rotation_frequency()}
@findex chopper_rotation_frequency()
@item chopper_rotation_frequency()
This function allows to either query or set the rotation speed of the
chopper. When called without an argument the function returns the
current rotation frequency or @w{0 Hz} when the chopper is stopped.  If
called with an argument between @w{39.22 Hz} and @w{200 Hz} the chopper
rotation frequency gets set to this value (if it is not possible to set
the frequency with an accuracy of at least @w{1%} a warning is output,
informing the user about the real rotation frequency, which is also the
value returned by the function). If the function is called with a zero
or negative argument the chopper is stopped.

When called during the @code{PREPARATIONS} section of thr @code{EDL}
script the choppers rotation frequency is set to this value when the
experiment is started.


@anchor{chopper_create_trigger()}
@findex chopper_create_trigger()
@item chopper_create_trigger()
This function makes the electronics controlling the chopper create a
@code{TTL} trigger pulse the next time the light path gets opened,
e.g.@: to trigger an acquisition.


@end table


@node Multi-Device Functions, , Light Chopper Functions, Device Functions
@section Multi-Device Functions
@cindex Multi-Device Functions

Currently there is just one function that uses two devices at once. It
uses the single-device functions (and thus will print error messages if
the modules for the required devices aren't loaded or if the modules
don't support the needed functions). The module they are defined in is
automatically loaded, so it needs no special entry in the @code{DEVICES}
section.

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{get_phase_cycled_area()}
@findex get_phase_cycled_area()

@table @samp

@item get_phase_cycled_area()
This function is for doing a complete measurement sequence in a phase
cycled experiment. It goes through a complete phase cycle, setting the
pulser, fetching the data from the digitizer and finally returning the
measured data, i.e.@: the areas returned by the digitizer and added up
according to the setting of the @code{ACQUISITION_SEQUENCE}.

The function needs both a pulser and a digitizer. It is not possible to
use the function with more than one pulser or digitizer -- if more than
one pulser or digitizer is listed in the @code{DEVICES} section it will
always use the first pulser and digitizer listed only.

The function can be used both for 1-dimensional and 2-dimensional
measurements. In the first case there is just one signal channel, in the
second two, e.g.@: a real and an imaginary part of a signal. Which kind
of measurement has to be done is determined by the number of acquisition
sequences. If there's only one it's a 1-dimensional measurement,
otherwise a 2-dimensional one.

The first argument the function expects is a digitizer channel to be
used for measuring the area of the signal, see above which channels can
be used for the different digitizers. If the @code{ACQUISITION_SEQUENCE}
is written in way that it is clear that two digitizer channels are
needed, i.e.@: you have a line in the @code{PHASES} section like
@example
ACQUISITION_SEQUENCE = +A, -B, -A, +B;
@end example
@noindent
also the second argument to the function must be a digitizer
channel. The first channel is used for fetching the @code{A} data, the
second for the @code{B} data. This is, of course, only relevant when you
have two different signals, e.g.@: the two outputs of a quadrature mixer
and the measured data consist of adding up signals from both channels.

The following arguments are as many window identifiers (as returned by
@ref{digitizer_define_window()} as there are needed. If no window
argument is given always the area of the complete curve is returned!

The type of the return value depends on the number of window identifiers
passed to the function and the number of acquisition sequences. If there
is only one window identifier (or none) and only one acquisition
sequence a floating point value with the result of the measurement is
returned. If, on the other hand, there is more than one window
identifier and a single acquisition sequence an array will be returned
with as many elements as there are window identifiers, the first element
of the returned array containing the result for the first window, the
second element the value for the second window etc.

If, in contrast, there are two acquisition sequences an array of twice
the number of windows is returned. The first value in the array is the
result for the first acquistion sequence for the first window, the
second the result for the second acquistion sequence and the first
window, then follow the results of both acquisition sequences fort
he second window, etc.

As an example here parts of an @code{EDL} script for a 1-dimensional
stimulated echo experiment with phase cycling. The parts with the
definition of the pulses etc. are left out for sake of brevity.
@example
DEVICES:

dg2020_f;
tds754a;


VARIABLES:

Num_points = 256;
raw_data[ 2 ];
data[ Num_points ];
Win_ID_1;                // signal window
Win_ID_2;                // background window
I;

...

ASSIGNMENTS:

...

PHASES:

PHASE_SEQUENCE_1     = +x, -x, +x, -x;  // sequence for 2nd pulse
PHASE_SEQUENCE_2     = +x, +x, -x, -x;  // sequence for 3rd pulse

ACQUISITION_SEQUENCE =  +,  -,  -,  +;


PREPARATIONS:

init_1d( 1, Num_points );
Win_ID_1 = digitizer_define_window( 388 ns, 4 ns );
Win_ID_2 = digitizer_define_window( 620 ns, 4 ns );

...

EXPERIMENT:

FOR I = 1 : : Num_points @{
    raw_data = get_phase_cycled_area( CH1, Win_ID_1, Win_ID_2 );
    data[ I ] = raw_data[ 1 ] - raw_data[ 2 ];
    display( I, data[ I ] );
    pulser_shift( );
@}

...
@end example

The first thing the function does is to do a phase reset to be certain
the pulser starts with a pulse pattern for the first phase as defined in
the @code{PHASE_SEQUENCE} declarations. Then it will measure the signals
areas for both digitizer window areas. In the next step it switched the
pulser to the pulse pattern for the next phase and repeat the
measurement of both the signal areas and subtract them from the values
measured in the first step (because in the @code{ACQUISITION_SEQUNCE}
command requires subtraction of the data). Then, again the pulse pattern
is switched to the third phase and a third set of data for both windows
is measured. Also these data are subtracted according to the settings of
acquisition sequence. Finally, the fourth and last phase settings are
send to the pulser and a fourth set of signal areas is measured. These
data now must, according to the acquisition sequence, be added to the
previous accumulated data. The result, an array with two elements for
the first and second window is returned by the function.

You may note that in this script @ref{pulser_update()} isn't called
after @ref{pulser_shift()}. This is possible because
@ref{get_phase_cycled_area()} internally calls @ref{pulser_update()}
before it starts doing the measurement.

Two acquisition sequences would, for example, be used in an inversion
recovery experiment with FID detection and phase cycling. Parts of the
@code{EDL} script would look like this:
@example
DEVICES:

dg2020_f;
tds754a;


VARIABLES:

Num_points = 256;
raw_data[ 4 ];
data[ Num_x_points, 2 ];
Win_ID_1;                // signal window
Win_ID_2;                // background window
I;
...

ASSIGNMENTS:

...

PHASES:

PHASE_SEQUENCE_1       = +x, +x, +x, +x, -x, -x, -x, -x;
PHASE_SEQUENCE_2       = +x, -x, +y, -y, +x, -x, +y, -y;

ACQUISITION_SEQUENCE_1 = +A, -A, +B, -B, +A, -A, +B, -B;
ACQUISITION_SEQUENCE_2 = +B, -B, -A, +A, +B, -B, -A, +A;


PREPARATIONS:

init_1d( 2, Num_points );
Win_ID_1 = digitizer_define_window( 388 ns, 4 ns );
Win_ID_2 = digitizer_define_window( 620 ns, 4 ns );

...

EXPERIMENT:

FOR I = 1 : Num_points @{
    raw_data = get_phase_cycled_area( CH1, CH2,
                                      Win_ID_1, Win_ID_2 );
    data[ I, 1 ] = raw_data[ 1 ] - raw_data[ 3 ];
    data[ I, 2 ] = raw_data[ 2 ] - raw_data[ 4 ];
    display( I, data[ I, 1 ], 1, I, data[ I, 2 ], 2 );
    pulser_shift( );
@}
@end example
@noindent
We have two acquisition sequences and two digitizer windows, so the
function returns an array with 4 elements. The first and third element
of the array are the results for the first acquisition sequence for
window 1 and 2, the second and fourth are the ones for the second
acquisition for both windows. Since the data are measured with baseline
correction, i.e.@: the result for the second, off-resonance window must
be subtracted from the first windows result, to obtain the value for the
first acquisition sequence from the first array element the third must
be subtracted, and for the second acquisition sequence the value if the
fourth array element from the second.


@end table
