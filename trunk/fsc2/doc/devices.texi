@c $Id$
@c
@c Copyright (C) 1999-2002 Jens Thoms Toerring
@c
@c This file is part of fsc2.
@c
@c Fsc2 is free software; you can redistribute it and/or modify
@c it under the terms of the GNU General Public License as published by
@c the Free Software Foundation; either version 2, or (at your option)
@c any later version.
@c
@c Fsc2 is distributed in the hope that it will be useful,
@c but WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with fsc2; see the file COPYING.  If not, write to
@c the Free Software Foundation, 59 Temple Place - Suite 330,
@c Boston, MA 02111-1307, USA.


@node Device Functions, Using Pulsers, Built-in Functions, Top
@chapter Device Functions

@ifinfo
@menu
* Introduction::            
* Magnet Functions::        Functions for controlling the magnet.
* Gaussmeter Functions::    Functions for measuring the magnetic field.
* Lock-In Functions::       Functions for accessing the lock-in amplifiers.
* Digitizer Functions::     Functions for accessing the oscilloscopes.
* Pulser Functions::
* Synthesizer Functions::
* Temperature Controller Functions::
* Voltmeter Functions::
* Boxcar Integrator Functions::
* Frequency Counter Functions::
* DAC Functions::
* Event Counter Functions::
* Multi-Device Functions::
@end menu
@end ifinfo


@node Introduction, Magnet Functions, Device Functions, Device Functions
@section Introduction


The simplest approach to dealing with device-specific functions would
have been to have a set of functions for each individual device, all
with different names. Then one would have a different function for
e.g.@: fetching data from each of a series of different digitizing
oscilloscopes. But this would become a nuisance whenever the
oscilloscope had to be changed in the experimental setup. One then would
have to carefully check all function calls in the @code{EDL} scripts and
adjust the names of the functions to fit the new digitizer.

Thus it's more reasonable to have generic functions for similar devices
that usually have a lot in common. It's much more convenient just to
write
@example
new_data = digitizer_get_curve( CH1 );    // get curve from channel 1
@end example
@noindent
instead of
@example
new_data = tds754a_get_curve( 1 );        // get curve from channel 1
@end example
@noindent
and changing dozens of references to the TDS754A oscilloscope in each
and every @code{EDL} program when someone else needs just this
oscilloscope for a few days and one has to do with the TDS520
oscilloscope in between.

Of course, using generic functions is not the silver bullet for all
situations - if e.g.@: the new lock-in amplifier has only one channel
while the previously used one had two no abstraction will make the new
lock-in have two channels. This means that, while a lot of abstraction
is possible, not all device functions can be completely identical for
all devices of the same type. Thus, while the names of the functions
remain identical, the arguments the functions are called with sometimes
may differ for different devices. But while this can be annoyingly
enough it at least reduces the amount of changes to be done to an
@code{EDL} program considerably.

But what if you need to use for example two lock-in amplifiers
simultaneously? When the names of the functions for accessing both the
lock-ins are identical how does one specify which one to use for a
command? Actually, it's quite simple. In the @code{DEVICES} section the
two lock-in amplifiers will be listed as
@example
sr510;         // first lock-in amplifier
sr830;         // second lock-in amplifier
@end example
@noindent
If now data from the first lock-in amplifier are needed one simply may
uses the normal way to get data, i.e.@: the usual function name:
@example
data_from_1st_lockin = lockin_get_data( );
@end example
@noindent
But to get data from the second only the string @code{"#2"} needs to
be appended to the function name:
@example
data_from_2nd_lockin = lockin_get_data#2( );
@end example
@noindent
and @code{fsc2} will automatically know that now the second of the
lock-in amplifiers from the list of devices is meant.

Of course, if there are three lock-ins listed in the DEVICE section for
the third one would have to append @code{"#3"} to the function name
etc. (One also can append the string @code{"#1"} to the name of the
function for the first lock-in amplifier, but that's optional.)

In situations where only the module of the second of two similar devices
defines a function (e.g.@: because the first device doesn't has the
necessary capabilities) the function can be used with and without
appending the @code{"#2"} to the function name. To remind you about this
a short message is printed.


The only situation that still is a bit more problematical are cases
where two absolutely identical devices are to be used
simultaneously. Due to limitations not only of @code{fsc2} but already
to the way the libraries used for accessing the GPIB bus works you can't
simply list the same device twice in the @code{DEVICES} section and then
use these as outlined above. Instead, two device modules with different
names have to be created for the identical devices and made known to the
program.  Fortunately, there's a Perl script that will automatically
deal with this problem, please see one of the later chapters
(@pxref{Cloning Devices})


@node Magnet Functions, Gaussmeter Functions, Introduction, Device Functions
@section Magnet Functions
@cindex Magnet Functions


All the following functions may be used to control the magnetic field of
the magnet. Currently the following magnet power supplies are supported:
@table @samp
@item aeg_x_band
AEG magnet for X-band with homebuilt controller
@item aeg_s_band
AEG magnet for S-band with homebuilt controller
@item er032m
Bruker ER032M Field Controller
@item keithley228a
Berlin W-band magnet sweep power supply Keithley 228A
@item ips20_4
Berlin 360 GHz spectrometer Oxford magnet sweep power supply
@item s_band_magnet_broad
Frankfurt S-band magnet via homebuilt DAC, broad field range
@item s_band_magnet_narrow
Frankfurt S-band magnet via homebuilt DAC, narrow field range
@end table
@noindent
Because magnets hardly ever get changed (and if @code{fsc2} is set up
correctly for the spectrometer) one can use @code{magnet} as the module
name instead.

Since it is not possible for the @strong{AEG} magnets to measure the
field using just the magnet power supply it is necessary also to specify
a gaussmeter to enable @code{fsc2} to control the magnet. The module
name of the gaussmeter has to appear @b{before} the magnet module entry
in the @code{DEVICES} section. See the next section for the implemented
gaussmeter and the related functions.

All magnet power supplies except the magnet used for the @w{360 GHz}
don't really do continuous sweeps but the field current is stepped. Thus
normally no sweep rates are used but field (or current, see below) step
sizes are needed when defining a sweep. The only exception is the power
supply for the Oxford magnet, here continuous sweeps can be done and
sweep reates must be specified.

If a @strong{AEG} magnet module is listed in the @code{DEVICES} section
the program will try to calibrate the field sweep parameters at the
start of the experiment, i.e.@: it will sweep the field up and down for
some time, so please be patient. Also see below on how to reduce the
amount of time spent with field calibration.

The Keithley 228A power supply is used for the sweep coil of Berlin
W-band magnet. Because there is no well-defined relationship between the
current produced by the power supply and the total magnetic field and
because the magnetic field can't be measured directly during
measurements for this device the following functions expect arguments in
current units (i.e. Ampere) instead of field units (i.e. Gauss) as the
other devices.

The same holds for the magnet used for the @w{360 GHz} spectrometer.
Here also no fixed relation between the current and the field can be
given, so also for this module all values have to be given in current
instead of field units.

Because the normal current resolution of the Keithley power supply is
not sufficient an additional device is needed supplying DC voltages in
the range between @w{-10 V} and @w{+10 V} to the modulation input of the
power supply. Currently the DAC ports of one of the Stanford Research
lock-in amplifiers (SR510, SR530, SR810 or SR830)) are used for this
purpose. Which of the lock-ins is used can be specified during
compilation by an entry in the configuration file for the Keithley
driver, usually the @code{SR510} lock-in amplifier. Alternatively, if no
lock-in has been set in the configuration file the @code{keithley228a}
module will assume that the first lock-in listed in the devices section
is to be used.

In the configuration file it also can be defined which of the DAC ports
of the lock-in amplifiers is to be used. If not defined, port 6 will be
used for the SR510 and SR530 and port 4 for the SR810 and SR830 lock-in
amplifier. But there exists also a function to directly select the DAC
port to be used, see below.


@table @samp
@anchor{magnet_name}
@item magnet_name()
@findex magnet_name()
Returns a string with the name of the magnet that is being used.


@anchor{magnet_setup}
@item magnet_setup()
@findex magnet_setup()
The function can be called in the @code{PREPARATIONS} section to set the
start field and the field step size used in sweeps.  The function
expects two floating point parameters, the start field or current,
e.g.@: @w{0.345 T}, and, in most cases, the step size, e.g.@: @w{0.35
G}.

Use current instead of field units for the Keithley 228A power supply
(@code{keithley228a}).

Because the Oxford magnet sweep power supply (@code{ips20_4}) does
continuous sweeps (instead of simulating a sweep by stepping the
current) the second argument isn't the sweep step size but must be the
sweep rate in units of @code{A/s}.

For the @strong{Bruker ER032M} field controller for some combinations of
the start field and field step size deviations between the requested
field and the real field may result of up to @w{25 mG}. If the maximum
field deviation was larger than @w{5 mG} at the end of the test run as
well as the experiment the maximum field deviation is printed out. To
minimize these deviations use a start field that is a multiple of @w{50
mG} and avoid sweeps with more than about 2000 steps away from the start
field.


@anchor{magnet_fast_init}
@item magnet_fast_init()
@findex magnet_fast_init()
Calling this functions in the @code{PREPARATIONS} section will shorten
the time used for the calibration of the field sweep at the start of the
experiment for the @strong{AEG} magnet power supplies. Unfortunately,
this also reduces the precision of the field sweep. Whenever an
experiment is restarted (i.e.@: if no new @code{EDL} file has been
loaded in between) this shortened calibration is done anyways to check
that the parameters didn't change significantly since the last run.


@anchor{set_field}
@item set_field()
@findex set_field()
This function expects one floating point argument for the field value
and will set the magnetic field to this value. For the Keithley power
supply (@code{keithley228a}) and the @w{360 GHz} magnet (@code{ips20_4})
specify a current value.

The function returns the new value of the field (which, in some cases
might differ a bit from the requested value due to the properties of the
device, i.e.@: restrictions of the esolution).

For the @strong{AEG} magnets the function also accepts a second optional
parameter, the maximum acceptable deviation of the field from the value
to be set. For example by the call
@example
set_field( 3421.5 G, 0.2 G );
@end example
@noindent
the field will be set to a value between @w{3421.3 G} and @w{3421.7 G}.

If in the case of @strong{AEG} magnets this second parameter is missing
the precision of the gaussmeter used for measuring the field is used. If
the maximum deviation parameter is smaller than the precision of the
gaussmeter the precision of the gaussmeter is used instead. The function
can only be called in the @code{EXPERIMENT} section.

For the Oxford magnet sweep power supply (@code{ips20_4}) this function will
automatically stop a running sweep.

For the @strong{Bruker ER032M} field controller setting a field with
this function while also having initialized the magnet using
@code{magnet_setup()} may result in deviations between the requested
field and the real field of up to @w{25 mG}. If the maximum field
deviation was larger than @w{5 mG} at the end of the test run as well
as the experiment the maximum field deviation is printed out.


@anchor{sweep_up}
@item sweep_up()
@findex sweep_up()
The function can be called in the @code{EXPERIMENT} section, but only if
the function @code{magnet_setup()} (see above) has been called
before. It doesn't take an argument and will sweep up the magnet by the
field step size value set in the @code{magnet_setup()} function.  The
actual size of the step will @b{not} be controlled using the gaussmeter.

The function returns the new field value.

For the @strong{AEG} magnets the precision of the field sweep depends on
the step size. While the precision is usually quite good for step sizes
of up to @w{1 G}, for much larger step sizes it may deteriorate quite
significantly. It sometimes helps to add a short waiting time (use
function @code{wait()}) after a sweep step to allow the field to settle
at the new point. On the other hand, it then might be faster (and more
reliable) not to use the sweep function at all but @code{set_field()}
instead.

This function is not available for the Oxford sweep power supply, module
@code{ips20_4}. Use the function @code{magnet_sweep} instead.


@anchor{sweep_down}
@item sweep_down()
@findex sweep_down()
This is the exact analog to the function @code{sweep_up()} but will
sweep the magnetic field down instead of up by the field step size
defined in @code{magnet_setup()}. The function can only be called in the
@code{EXPERIMENT} section.

The function returns the new field value.

This function is not available for the Oxford magnet sweep power supply
(@code{ips20_4}). Use the function @code{magnet_sweep} instead.


@anchor{reset_field}
@item reset_field()
@findex reset_field()
This function resets the magnetic field to the start field value defined
in @code{magnet_setup()} (which has to be called before).

The function returns the new field value.

Please note that for the Oxford magnet sweep power supply
(@code{ips20_4}) calling this function also automatically stops a
running sweep.

The function can only be used in the @code{EXPERIMENT} section.


@anchor{get_field}
@item get_field()
@findex get_field()
For the @strong{AEG} magnets this is only a convenience function that
just calls a function supplied by the gaussmeter used together with the
magnet power supply to determine the current field.

In contrast, for the @strong{ER032M Field Controller} this function
returns the current field setting in Gauss. For both the Berlin W-band
magnet (@code{keithley228a}) and the @w{360 GHz} spectrometer magnet
(@code{ips20_4}) the actual current through the magnets sweep coil is
returned.

The function can only be used in the @code{EXPERIMENT} section.


@anchor{magnet_use_correction}
@item magnet_use_correction()
@findex magnet_use_correction()
This function is only defined for the Keithley power supply
(@code{keithley228a}) and accepts no more than one argument. If it is
called with no argument or a non-zero number or the string @code{"ON"}
corrections are applied to reduce the effects of certain inaccuracies of
the power supply. If called with either an agument of @code{0} or a
string @code{"OFF"} the use of these corrections is switched off.
Per default @strong{no} corrections are used.


@anchor{magnet_use_dac_port}
@item magnet_use_dac_port()
@findex magnet_use_dac_port()
This function is only defined for the Keithley power supply and tells
the driver which of the DAC ports of the lock-in amplifier is connected
(following a voltage divider) to the modulation input of the power
supply. The function expects a single integer value, the DAC port number
to be used -- for the SR510 and SR530 this can be @code{5} or @code{6},
while for the SR810 and SR830 all values in the range between @code{1}
and @code{4} may be used.

The function can only be used in the @code{PREPARATIONS} section.

@anchor{magnet_sweep}
@item magnet_sweep()
@findex magnet_sweep()
This function is only available for the Oxford magnet sweep power supply
(@code{ips20_4}) to control its continuous sweep. It can be called with
either an integer argument of @code{1} to start a sweep to higher field
and current values, an argument of @code{-1} to start a downward sweep
or, finally, an argument of @code{0} to stop a running sweep.

To be able to do a sweep a sweep rate must have been set. This can be
either done by a call of the function @code{magnet_setup()} (see above)
within the @code{PREPARATIONS} section or by calling
@code{magnet_sweep_rate()} (see below).

The function can also be called without an argument, in which case
either @code{1}, @code{-1} or @code{0} is returned if the magnet is
sweeping up or down or the sweep is stopped.

Sweeps will be automatically stopped when a current limit is reached. By
calling this function without an argument you may check if this has
happened.

The function can only be used in the @code{EXPERIMENT} section.


@anchor{magnet_sweep_rate}
@item magnet_sweep_rate()
@findex magnet_sweep_rate()
This function is only available for the Oxford magnet sweep power supply
(@code{ips20_4}) to set or query the sweep rate for continuous sweeps.
If no argument is passed to the function the currently set sweep rate is
returned. Otherwise a (positive) sweep rate in units of @code{A/s} must be
passed to the function.


@anchor{magnet_goto_field_on_end}
@item magnet_goto_field_on_end()
@findex magnet_goto_field_on_end()
This function is only available for the Oxford magnet sweep power supply
(@code{ips20_4}) and the S-band field drivers
@code{s_band_magnet_narrow} and @code{s_band_magnet_broad}. It allows to
set a target current that the magnet will be swept to @b{after} the
experiment has ended (per default the magnet would stay at the last
field position for the Oxford magnet supply or move to the middle of the
allowed field range for both the other drivers). This function can be
called in the @code{PREPARATION} as well the @code{EXPERIMENT} section
and returns the target current the magnet will sweep to after the end of
the experiment.  If called more than once the current of the last call
will be used.


@end table


@node Gaussmeter Functions, Lock-In Functions, Magnet Functions, Device Functions
@section Gaussmeter Functions
@cindex Gaussmeter Functions


Currently, three types of gaussmeters are implemented, the Bruker ER035M
NMR gaussmeter, the Bruker BH15 hall probe field controller and the
Metrolab PT2025 NMR gaussmeter. The range of fields that can be measured
with the Bruker ER035M NMR gaussmeter depends on the probe being
used. With the F0 probe (S-band) the range is @w{460 G} to @w{2390 G}
while with the F1 probe (X-band) a range between @w{1460 G} and @w{19900
G} can be measured.  With the BH15 field controller a range between
@w{-50 G} and @w{2300 G} can be used. Finally, for the Metrolab PT2025
it is currently assumed that a probe for the field range between @w{1.5
T} and @w{3.4 T} (W-band) is used.

The modules defining the gaussmeter functions (to be listed in the
@code{DEVICES} section) are:
@example
er035m
er035m_s
bh15
er035m_sa
er035m_sas
pt2025
@end example
@noindent
The modules with names starting with @code{er035m} are for the Bruker
ER035M NMR gaussmeter. @code{er035m} and @code{er035m_sa} are to be used
when the device is controlled via the GPIB bus while @code{er035m_s} and
@code{er035m_sas} expect the device to be connected to a serial port of
the computer. The @code{bh15} module is for the Hall controller used in
some setups. The last module, @code{pt2025}, is for the Metrolab NMR
gaussmeter from the Berlin W-Band spectrometer.

The first three gaussmeter modules, @code{er035m}, @code{er035m_s} and
@code{bh15}, are only to be used for controlling the sweep of a magnet
power supply. Thus only one of these gaussmeter drivers can be loaded,
and if other gaussmeters are also used it must be the first in the
@code{DEVICES} section and must be specified @b{before} the magnet
module (see above) which relies on its existence,

In contrast, the three other modules, @code{er035m_sa},
@code{er035m_sas} and @code{pt2025}, are only to be used for field
measurements but not for direct field control.


@table @samp
@anchor{gaussmeter_name}
@item gaussmeter_name()
@findex gaussmeter_name()
Returns a string with the name of the gaussmeter being used.


@anchor{find_field}
@item find_field()
@findex find_field()
This function is defined in the device modules @code{er035m} and
@code{er035m_s}. It returns the current value of the magnetic field in
Gauss.  The function can only be called in the @code{EXPERIMENT}
section.


@anchor{gaussmeter_resolution}
@item gaussmeter_resolution()
@findex gaussmeter_resolution()
This function is defined in the device drivers for the Bruker NMR
gaussmeters (@code{er035m}, @code{er035m_s}, @code{er035m_sa} and
@code{er035m_sas}) and for the Metrolab NMR gaussmeter, @code{pt2025}.
It can be used to set or query the resolution in Gauss used in
measurements of the magnetic field.

To set a resolution the values @code{0.1 G}, @code{0.01 G} and
@code{0.001 G} can be used for the Bruker NMR gaussmeter, while for the
Metrolab Gaussmeter only @code{0.01 G} and @code{0.001 G} are usable.

Please note that for the modules @code{er035m} and @code{er035m_s},
i.e.@: the modules for direct field control, the resolution will be
increased automatically from @code{0.1 G} to @code{0.01 G} at the
initialization (i.e.@: at the very start of the experiment) unless 
the low resolution has been set explicitely during the
@code{PREPARATIONS} section.


@anchor{measure_field}
@item measure_field()
@findex measure_field()
This function is defined in the device drivers @code{er035m_sa},
@code{er035m_sas} and @code{pt2025}. It measures the current field and
returns the value in Gauss. The function can only be called in the
@code{EXPERIMENT} section.


@anchor{gaussmeter_probe_orientation}
@item gaussmeter_probe_orientation()
@findex gaussmeter_probe_orientation()
This function is currently implemented for the Metrolab NMR gaussmeter
@code{pt2025} only. It allows to set or query the current probe
orientation relative to the field. To set an orientation a parameter of
@code{1} or @code{"+"} can be used to define an orientation parallel to
the field and an argument of @code{0} or @code{"-"} for the antiparallel
direction. On queries the function returns either @code{1} or @code{0}.
The function can only be called in the @code{EXPERIMENT} section for
queries.

@end table


@node Lock-In Functions, Digitizer Functions, Gaussmeter Functions, Device Functions
@section Lock-In Functions
@cindex Lock-In Functions

Modules for five different lock-in amplifiers are implemented. Most are
by Stanford Research and have the model names @strong{SR510},
@strong{SR530}, @strong{SR810} and @strong{SR830}. The fifth is the
@strong{ER023M Signal Channel} used in Bruker spectrometers of the ESP
series. The module names to be specified in the @code{DEVICES} section
are
@example
sr510
sr530
sr810
sr830
er023m
@end example
@noindent
Because the models have different capabilities, some of the functions
are either only defined for parts of the models or may expect slightly
different parameters.

Several of the following functions can be called both to query the
current settings of the lock-in amplifier and to set a new value. In the
first case the function usually has to be called with no argument, while
to set a parameter an argument has to be passed to the function. Because
of these different modes of calling the functions one should carefully
check the arguments to achieve the desired results.


@table @samp
@anchor{lockin_name}
@item lockin_name()
@findex lockin_name()
Returns a string with the name of the lock-in amplifier being used.


@anchor{lockin_get_data}
@item lockin_get_data()
@findex lockin_get_data()
This is a function only to be used in queries, i.e.@: to fetch measured
values from the lock-in amplifier. This function can only be called in
the @code{EXPERIMENT} section. The parameters that may be passed to the
function differ according to the model:
@table @samp
@item SR510
No argument is allowed -- the function returns the measured value of the
only channel as a floating point number (i.e.@: in Volts).

@item SR530
If no argument is specified the measured value at channel @code{1} is
returned. Alternatively, one parameter may be passed to the function
with a value of either @code{1} or @code{2}, in which case the measure
value from channel @code{1} or @code{2} is returned. Finally, two
arguments can be given, with values of @code{1} or @code{2}. In this
case a 1-dimensional array with two elements is returned, containing the
measured values of the corresponding channels.

@item SR810
@itemx SR830
If no argument is specified the 'X' signal is returned. If a parameter
is passed to the function the value at the corresponding channel is
returned. Possible channel numbers and their meaning are (please note
that some of these can only be used when in auto-acquisition mode, see
below in the explanation of the functions @code{lockin_auto_setup()} and
@code{lockin_auto_acquisition} and some even then with the
@strong{SR830} only):
@table @samp
@item 1
'X' signal
@item 2
'Y' signal - in auto-acquisition mode only available for the
@strong{SR830}
@item 3
Amplitude 'R' of data from X channel (@code{1}) and Y channel (@code{2})
in polar coordinates
@item 4
Phase 'theta' of data from channel @code{1} and @code{2} (relative to
reference) in polar coordinates - in auto-acquisition mode only
available for the @strong{SR830}
@item 5
Voltage at rear panel auxiliary ADC input 1
@item 6
Voltage at rear panel auxiliary ADC input 2
@item 7
Voltage at rear panel auxiliary ADC input 3 - in auto-acquisition mode
only available for the @strong{SR830}
@item 8
Voltage at rear panel auxiliary ADC input 4 - in auto-acquisition mode
only available for the @strong{SR830}
@item 9
X noise data - this is only allowed when the lock-in-amplifier is
running in auto-acquisition mode and the CH1 display is set to display X
noise.
@item 10
Y noise data - only available for the @strong{SR830} and only allowed
when the lock-in-amplifier is running in auto-acquisition mode and the
CH2 display is set to display Y noise.
@end table

A maximum 6 different channels can be passed to the function which must
all be different. If there is more than one argument a 1-dimensional
array is returned with as many data as there were arguments (in the
sequence corresponding to the one of the arguments).

@item ER023M
No argument is allowed -- the function returns a floating point value.
@end table


@anchor{lockin_auto_setup}
@item lockin_auto_setup()
@findex lockin_auto_setup()
This function is only available for the Stanford Research lock-in
amplifiers @strong{SR810} and @strong{SR830}. Both these lock-in
amplifiers have the capability to automatically acquire data at fixed
time intervals (or on receiving an external trigger) and store the data
into an internal buffer. Using this acquisition mode one can be sure
that the data have been sampled at well-defined times (in contrast to
normal measurements where the exact time interval can vary slightly
depending on how busy the computer is). Data can be acquired in this
mode only from the channel(s) displayed at the front side, which means
that the @code{SR810} can only sample only one data type in this mode
(because it only has one displayable channel) while the @code{SR830} can
sample two data types simultaneously.

@code{lockin_auto_setup()} must be used to setup the auto-acquisition
(if not called auto-acquisition can't be started). The first parameter
passed to the function is the sample time, i.e.@: the time interval at
which data are sampled. Sample times can range between @w{1.953125 ms}
(@w{512 Hz}) and @w{16 s}. Allowed values are powers of 2, multiplied by
the shortest sample time. As an alternative an @strong{integer} value
of @code{0} or @code{-1} can be passed to the function. If it is
@code{0} a sample time equal or larger than the lock-in's time constant
is used. If @code{-1} is passed to the function it is assumed that an
external trigger, applied to the rear trigger input, is going to be used
- the user has to take care that the trigger input rate is not larger
than @w{512 Hz}.

The next one or two parameter define which data type should be sampled
in auto-acquisition mode (the @code{SR810} only accepts one data type
arguments while the @code{SR830} accepts two). You may specify integer
numbers with exactly the same meaning as the arguments to the function
@code{lockin_get_data()}. This will also automatically switch the type
of data displayed on the front side channels to the specified values.
Not all combinations are possible, the following list shows which
values are allowed
@multitable @columnfractions 0.1 .35 .35
@item @tab 1st argument @tab 2nd argument
@item @tab @code{1} (X) @tab @code{2} (Y)
@item @tab @code{3} (R) @tab @code{4} (theta)
@item @tab @code{5} (ADC 1) @tab @code{6} (ADC 3)
@item @tab @code{7} (ADC 2) @tab @code{8} (ADC 4)
@item @tab @code{9} (X noise) @tab @code{10} (Y noise)
@end multitable
For the @code{SR810} only the first column is relevant.

Additionally, you also may specify a value of @code{0}, indicating that
the function to be displayed should not be changed, i.e.@: the data type
already set manually should be used.

This function can be used in all sections of an @code{EDL}
program. If the auto-acquisition setup is changed during an already
running auto-acquisition all data stored in the lock-in's internal
buffer are discarded before the measurement continues using the new
settings.


@anchor{lockin_auto_acquisition}
@item lockin_auto_acquisition()
@findex lockin_auto_acquisition()
This function is only available for the Stanford Research lock-in
amplifiers @strong{SR810} and @strong{SR830}. It allows to start or stop
the automatic acquisition of data at constant time intervals. Before
this function can be used auto-acquisition must be initialized by a call
of the function @code{lockin_auto_setup()}.

When called with an argument of @code{1} (or a string @code{"ON}")
auto-acquisition is started. If you now request data from one of the
channels configured to be used in @code{lockin_auto_setup()} via the
function @code{lockin_get_data()} the next data sample from the internal
buffer of the lock-in amplifier will be returned (instead of returning
the value at the moment of the call of the function).

When called with an argument of @code{0} (or a string @code{"OFF"})
auto-acquisition is stopped and the internal buffer of the lock-in is
cleared. Calls of @code{lockin_get_data()} will again return values
measured in the 'normal' way.

@strong{Important}: The sizes of the internal buffers of the lock-in
amplifiers are restricted: while the @code{SR830} can store up to 16383
data points for each of the two channel, the @code{SR810} can only store
a maximum of 8191 samples. If the program detects when fetching new
data that the maximum number of data have already been fetched from
the lock-in the internal buffer is cleared. In this case data which
should have been acquired between the time the lock-in's internal buffer
got filled up and the moment the program noticed that the buffers are
full will be lost and an error message will be printed. Thus prudence
dictates to stop auto-acquisition, thereby automatically clearing the
lock-in's internal buffers, whenever possible.


@anchor{lockin_get_adc_data}
@item lockin_get_adc_data()
@findex lockin_get_adc_data()
The function returns the voltage at one of the ADC ports at the back
side of the lock-in amplifier. Allowed values of the required argument
are between @code{1} and @code{4}, corresponding to the port numbering.

This function can only be used with the @strong{Stanford Research}
lock-in amplifiers and can only be called in the @code{EXPERIMENT} section.


@anchor{lockin_dac_voltage}
@item lockin_dac_voltage()
@findex lockin_dac_voltage()
The function can be used to set or query the voltage at one of the DAC
ports at the back side of the @strong{Stanford Research} lock-in
amplifier. While for the models @strong{SR510} and @strong{SR530} the
allowed values for the required arguments are @code{5} or @code{6}, for
the models @strong{SR810} and @strong{SR830} the values can range from
@code{1} to @code{4}, corresponding to the different numbers of DAC
ports and their numbering printed on the back side. If no further
argument is given the function returns the current voltage applied to
the DAC port (which is automatically set to @w{0 V} at the
initialization of the lock-in amplifier if no voltage has been set
previously in the @code{PREPARATIONS} section using this function). If a
second argument is given the DAC will be set to the corresponding
voltage. The function returns the voltage that has been set.

For the models @strong{SR510} and @strong{SR530} this voltage has to be
in the range between @w{-10.24 V} and @w{+10.24 V} while for the models
@strong{SR810} and @strong{SR830} the allowed voltage range is
@w{-10.5V} to @w{+10.5 V}.

This function can only be used with the @strong{Stanford Research}
lock-in amplifiers. 

In the @code{PREPARATIONS} section this function can only be called
with two argument, i.e@: to set the output voltage of one of the DACs
to be used in the initialization of the device.


@anchor{lockin_sensitivity}
@item lockin_sensitivity()
@findex lockin_sensitivity()
This function can be used to query or set the sensitivity of the lock-in
amplifier. If no argument is passed to the function the current
sensitivity is returned. For the models @strong{SR510} and
@strong{SR530} a 10 times higher sensitivity than the sensitivity set on
the front panel is returned when the @code{EXPAND} button is switched
on.

When called with a second argument the corresponding sensitivity is
set. This value has to be positive. If the argument does not coincide
with one of the possible sensitivity settings the sensitivity is set to
the nearest available sensitivity setting and a warning is printed. The
function will return the sensitivity that has been set.

Valid sensitivity settings for the @strong{SR510} and @strong{SR530} are
in the range between @w{10 nV} and @w{500 mV} in steps of about @w{3
dB}, i.e. you can use @w{10 uV}, @w{20 uV}, @w{50 uV}, @w{100 uV} etc.
To achieve the two highest sensitivity settings the @code{EXPAND} button
is automatically switched on.

For the @strong{SR810} and the @strong{SR810} vaid sensitivity setings
range from @w{2 nV} up to @w{1 V}, using the same system of steps as
the @strong{SR510} and @strong{SR530}.

For the @strong{ER023M Signal Channel} the function does not set the
sensitivity in units of the output voltage but sets the receiver
gain. Valid receiver gains are in the range between @code{2.0E+1} and
@code{1.0E+7} and in increments of @code{2 dB}. Thus in this range the
following multiplier steps can be used: @code{1.0}, @code{1.25},
@code{1.5}, @code{2.0}, @code{2.5}, @code{3.0}, @code{4.0}, @code{5.0},
@code{6.0} and @code{8.0}.

In the @code{PREPARATION} section this function can't be called in query
mode, i.e.@: without an argument.


@anchor{lockin_time_constant}
@item lockin_time_constant()
@findex lockin_time_constant()
The function queries or sets the time constant of the lock-in
amplifier. If no argument is passed to the function the current time
constant is returned. If there's an argument the time constant is set
accordingly.  The argument has to be positive. If there is no time
constant setting fitting the argument the nearest available setting is
used and a warning is printed. The function will return the time
constant setting that has been set.


For the @strong{SR510} and @strong{SR530} lock-ins valid time constant
settings are @w{1 ms} and @w{100 s} with steps of about a factor of 3,
i.e. you can use @w{10 ms}, @w{30 ms}, @w{100 ms} etc. The POST time
constant is set to a value equal or lower than the time constant.

For the @strong{SR810} and @strong{SR810} lock-ins vali time constants
range from @w{10 us} up to @w{30,000 s}, using the same system of steps
as the @strong{SR510} and the @strong{SR530}.

For the @strong{ER023M} the following (approximate) time constant
settings can be used: @code{2.5 ms}, @code{5 ms}, @code{10 ms}, @code{20
ms}, @code{40 ms}, @code{65 ms}, @code{130 ms}, @code{330 ms}, @code{650
ms}, @code{1.3 s}, @code{2.6 s} and @code{5.2 s}.

In the @code{PREPARATIONS} section this function can't be called as a
query, i.e.@: without an argument.


@anchor{lockin_phase}
@item lockin_phase()
@findex lockin_phase()
The function queries or sets the phase of the lock-in amplifier. If
called with no argument it will return the current phase setting in the
interval between 0 and 360 degrees. If called with an argument the phase
is set accordingly.

In the @code{PREPARATIONS} section this function can't be called without
an argument, i.e.@: as a query.


@anchor{lockin_ref_freq}
@item lockin_ref_freq()
@findex lockin_ref_freq()
The function can be used to query the modulation frequency and, for the
@strong{SR810}, @strong{SR830} and @strong{ER023M} to set the modulation
frequency (both the other models need an external modulation). If called
with no argument the current modulation frequency is returned. If called
with an argument the modulation frequency is set.

If for the @strong{SR810} and @strong{SR830} the frequency is not within
the admissible range an error message is printed and the experiment is
stopped. The admissible range depends on the harmonics setting, see
the manuals for full details.

For the @strong{ER023M} only certain modulation frequencies can be set,
these are @code{100 kHz}, @code{50 kHz}, @code{25 kHz}, @code{12.5 kHz},
@code{6.25 kHz} and @code{3.125 kHz}. If a modulation frequency is
specified that does not fit one of these values the nearest valid
frequency is used.

In the @code{PREPARATIONS} section this function can't be called in
query mode, i.e.@: without an argument.


@anchor{lockin_ref_level}
@item lockin_ref_level()
@findex lockin_ref_level()
This function can be only used with the models @strong{SR810},
@strong{SR830} and the @strong{ER023M}. It queries (if called with no
argument) or sets (if called with an argument) the level of the
modulation frequency. For the @strong{Stanford} lock-in amplifiers the
allowed levels are between @w{4 mV} and @w{5 V}, if the argument is not
within this range an error message is printed and the experiment is
stopped. For the @strong{Bruker ER023M} signal channel the range is (as
long as no calibration has been done) between @w{10 mG} and @w{100 G}
(but don't expect the values to have any real meaning without a
calibration).

In the @code{PREPARATIONS} section this function can't be called in query
mode, i.e.@: without an argument.


@anchor{lockin_ref_mode}
@item lockin_ref_mode()
@findex lockin_ref_mode()
This function can be only used with the models @strong{SR810},
@strong{SR830}. It returns the modulation mode, i.e.@: if the internal
modulation or an external modulation input is used. In the first case
the function returns an integer value of @code{1} while in the second
case @code{0} is returned.


@anchor{lockin_harmonic}
@item lockin_harmonic()
@findex lockin_harmonic()
SR8[13]0: 1-19999
ER023M:   1-2

@anchor{lockin_lock_keyboard}
@item lockin_lock_keyboard()
@findex lockin_lock_keyboard()
Usually, during an experiment the keyboard of the lock-in amplifier is
locked. But for situations where it would be useful to be able to control
the lock-in also via its keyboard it can be unlocked (and also re-locked)
from within the program. To unlock the keyboard call this function with
an argument of @code{0} or @code{"OFF"}, to re-lock the keyboard call it
again with a non-zero argument, @code{"ON"} or no argument at all.

This function can only be used with the @strong{Stanford Research}
lock-in amplifiers.


@anchor{lockin_conversion_time}
@item lockin_conversion_time()
@findex lockin_conversion_time()
This function exists for the @strong{Bruker ER023M} signal channel only
and either queries or sets the time that the built-in ADC takes to
convert a voltage into a binary data value. The voltage resolution is
higher for longer conversion times. Possible conversion times are
integer multiples of @w{320 us} in the range between 10 and 9999, thus
allowing conversion times between @code{3.2 ms} and ca.@: @code{3.2 s}.

Unfortunately, according to my tests, for conversion times between @w{40
ms} and @w{64 ms} the data the signal channels sends for large signal
amplitudes are garbled. For this reason the function will not accept
conversion times in this range but will instead set the nearest
conversion time for which correct data are delivered.

If no argument is supplied to the function the current conversion time
is returned. If there is an argument this is used as the new conversion
time. If the argument is not an integer multiple of @w{320 us} (within
the possible range) the nearest allowed conversion time is used.

In the @code{PREPARATIONS} section this function can't be called without
an argument, i.e.@: as a query.


@anchor{lockin_resonator}
@item lockin_resonator()
@findex lockin_resonator()
This function exists for the @strong{Bruker ER023M} signal channel only
and queries or returns the selected resonator. If called without an
argument it returns either @code{1} or @code{2} for the first or second
resonator. It accepts the same values as arguments to select a resonator.

In the @code{PREPARATIONS} section this function can't be called without
an argument, i.e.@: as a query.


@anchor{lockin_is_overload}
@item lockin_is_overload()
@findex lockin_is_overload()
This function exists for the @strong{Bruker ER023M} signal channel only
and can only be used as a query, i.e.@: it does not allows arguments. It
can be called before a new data value is fetched from the lock-in to
find out if an overload has occurred while the data value was measured
(where a return value of @code{1} indicates that an overload happened,
otherwise @code{0} is returned). Calling this function (or fetching the
data value) will reset the overload condition and calls of the function
will return @code{0} as long as no further overloads occur.

The function can only be used in the @code{EXPERIMENT} section.

@end table


@node Digitizer Functions, Pulser Functions, Lock-In Functions, Device Functions
@section Digitizer Functions
@cindex Digitizer Functions

The digitizing oscilloscopes currently implemented are the Tektronix
TDS520, TDS520A, TDS540, TDS744A and TDS754A. The corresponding module
names to be used in the @code{DEVICES} section are
@example
tds520
tds520a
tds540
tds744a
tds754a
@end example

When a digitizer channel or trigger input is used as an argument in
calls of one of the following functions the symbolic channel names can
be replaced by integer numbers:
@table @samp
@item CH1
@code{0} - First digitizer channel (all models)
@item CH2
@code{1} - Second digitizer channel (all models)
@item CH3
@code{2} - Third digitizer channel (Tektronix TDS540, TDS744A, TDS754A)
@item CH4
@code{3} - Fourth digitizer channel (Tektronix TDS540, TDS744A, TDS754A)
@item MATH1
@code{4} - First mathematic function channel (all Tektronix digitizers)
@item MATH2
@code{5} - Second mathematic function channel (all Tektronix digitizers)
@item MATH3
@code{6} - Third mathematic function channel (all Tektronix digitizers)
@item REF1
@code{7} - First reference channel (all Tektronix digitizers)
@item REF2
@code{8} - Second reference channel (all Tektronix digitizers)
@item REF3
@code{9} - Third reference channel (all Tektronix digitizers)
@item REF4
@code{10} - Fourth reference channel (all Tektronix digitizers)
@item AUX
@code{11} - Auxiliary channel (Tektronix TDS540, TDS744A, TDS754A)
@item AUX1
@code{12} - First auxiliary channel (Tektronix TDS520, TDS520A, TDS520C)
@item AUX2
@code{13} - Second auxiliary channel (Tektronix TDS520, TDS520A, TDS520C)
@item LINE
@code{14} - Line In for trigger (all models)
@item MEM_C
@code{15} - First memory channel (LeCroy 9400)
@item MEM_D
@code{16} - Second memory channel (LeCroy 9400)
@item FUNC_E
@code{17} - First function (averaging) channel (LeCroy 9400)
@item FUNC_F
@code{18} - second function (averaging) channel (LeCroy 9400)
@item EXT
@code{19} - External trigger input (LeCroy 9400)
@item EXT10
@code{20} - External amplified trigger input (LeCroy 9400)
@end table


@table @samp
@anchor{digitizer_name}
@item digitizer_name()
@findex digitizer_name()
Returns a string with the name of the digitizer being used.


@anchor{digitizer_timebase}
@item digitizer_timebase()
@findex digitizer_timebase()
The function queries (if called with no argument) or sets (if called
with an argument) the time base setting of the oscilloscope. The
possible time bases depend on the model, please check the manual.

The function can be called in query mode (i.e.@: without an argument)
in the @code{EXPERIMENT} section only.


@anchor{digitizer_time_per_point}
@item digitizer_time_per_point()
@findex digitizer_time_per_point()
The function (to be called in the @code{EXPERIMENT} section only)
returns the time difference (in seconds) between two data points
measured by the digitizer.


@anchor{digitizer_sensitivity}
@item digitizer_sensitivity()
@findex digitizer_sensitivity()
The function queries (if called with just one argument) or sets (if
called with two arguments) the sensitivity setting of one of the channels
of the oscilloscope. It needs at least one argument, the channel, either
symbolically or numerically. The channels that can be used as arguments
depend on the model of the oscilloscope:
@table @samp
@item TDS520
@itemx TDS520A
@itemx LECROY9400
@code{CH1} or @code{CH2}
@item TDS540
@itemx TDS744A
@itemx TDS754A
@code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@end table

If a second argument is given this is taken to be the new sensitivity
setting (in Volts per division). If the sensitivity value passed to the
function is not one of the available settings the nearest allowed value
is used instead. Please note that for some of the oscilloscopes the
range of admissible sensitivity settings depends on the input impedance
-- unfortunately this can only be checked for when the experiment has
already been started!

If no second argument is given the current sensitivity setting for the
channel is returned.

The function can be called in query mode (i.e.@: without a second
argument) only in the @code{EXPERIMENT} section.


@anchor{digitizer_num_averages}
@item digitizer_num_averages()
@findex digitizer_num_averages()
This function is intended for the @strong{Tektronix} digitizers, see at
the end on how to also use it with the @strong{LeCroy 9400}. It queries
(if called with no argument) or sets (if called with an argument) the
number of averages done by the oscilloscope.  If the number of averages
is passed to the function it must be at least 1 (which will switch the
oscilloscope into @code{SAMPLE} mode). If the argument is larger than
the maximum number of averages the maximum available number of averages
is used instead.

The function can be called in query mode (i.e.@: without an argument)
only in the @code{EXPERIMENT} section.

For the @strong{LeCroy 9400} this function can only be used in query
mode and returns the number of averages that has been set in a previous
call of @code{digitizer_averaging()}. It needs exactly one argument, the
the channel used to do the averaging, i.e.@: either @code{FUNC_E} or
@code{FUNC_F}.


@anchor{digitizer_averaging}
@item digitizer_averaging()
@findex digitizer_averaging()
This function only exists for the @strong{LeCroy 9400} and must be used
to set up averaging. It expects at least three arguments. The first
argument is the channel to be used to do the averaging, i.e.@: either
@code{FUNC_E} or @code{FUNC_F}. The second is the data source channel
for the curves to be averaged, i.e.@: either @code{CH1} or
@code{CH2}. The third required argument is the number of averages which
has to be either @code{10}, @code{20} or @code{50} or one of these
numbers multiplied by @code{10}, @code{100}, @code{1000}, @code{10000}
up to a number of @code{1000000}). The next, optional argument is either
an integer number, with a non-zero value representing truth and @code{0}
falsehood, or a string, either @code{"ON"} or @code{"OFF"}, that
determines if overflow rejection is switched on or off (if switched on
all traces that overflowed the ADC range will be rejected
automatically). The final optional argument is the number of points that
get included into the average. Usually it doesn't make too much sense to
set this value because the program will make sure automatically that at
least as many points of a curve as can be read from the digitizer are
included into the averaging. If the value is set only as many points as
have been set will be returned by a @code{digitizer_get_curve()}
command.


@anchor{digitizer_trigger_channel}
@item digitizer_trigger_channel()
@findex digitizer_trigger_channel()
The function queries or sets the channel of the digitizing oscilloscope
to be used as trigger input. Possible arguments or return values are,
depending on the type of the oscilloscope (return values are always
numeric!):
@table @samp
@item TDS520
@itemx TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{AUX1}, @code{AUX2} or @code{LINE}
(@code{LINE} can be abbreviated to @code{LIN})
@end itemize
@item TDS540
@itemx TDS744A
@itemx TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{AUX} or @code{LINE} (@code{LINE} can be abbreviated to @code{LIN})
@end itemize
@item LECROY9400
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{LINE}, @code{EXT} or @code{EXT10} (@code{LINE} can be
abbreviated to @code{LIN})
@end itemize
@end table
The function can be called in query mode (i.e.@: without an argument)
only if either it has already been called with an argument or in the
@code{EXPERIMENT} section.


@anchor{digitizer_record_length}
@item digitizer_record_length()
@findex digitizer_record_length()
The function queries (if called with no argument) or sets (if called
with an argument) the length of the traces measured by the
digitizer. Because the digitizer only allows certain record lengths
a value passed to the function will be rounded up to the next
allowed value if necessary.

The function can be called in query mode (i.e.@: without an argument)
only if either it has already been called with an argument or in the
@code{EXPERIMENT} section.


@anchor{digitizer_trigger_position}
@item digitizer_trigger_position()
@findex digitizer_trigger_position()
The function queries (if called with no argument) or sets (if called
with an argument) the amount of pre-trigger, i.e.@: the portion of the
trace shown with data before the trigger was detected. The function
accepts or returns values from the interval @w{[0, 1]} (where 0 means
that the trigger is at the very first point of the trace, i.e.@: no
pre-trigger is used, and 1 that it's at the last point, i.e.@: the
complete curve is recorded before the trigger).

The function can be called in query mode (i.e.@: without an argument)
only if either it has already been called with an argument or in the
@code{EXPERIMENT} section.


@anchor{digitizer_define_window}
@item digitizer_define_window()
@findex digitizer_define_window()
The function must be used to define a time window to be used in later
calls of the functions to measure an area, an amplitude or to fetch a
curve from the oscilloscope. Usually it is called with two arguments,
the starting point and the width of the window (both in seconds). If it
is called with no argument the window defined by the cursor pair on the
oscilloscopes screen is used. If no width is specified the distance
between the pair of cursors is used. In both cases the smallest possible
non-zero value for the distance is used if the cursors on the screen are
exactly on top of each other.

The function returns an integer number that can be used in later calls
to address the window. Thus, you need to store this number in an integer
variable to be able to use this window in further calls of digitizer
functions.

The allowed ranges of arguments for the start point and width of the
window depend on the time base setting of the oscilloscope as well as
the pre-trigger setting and the current record length. The time of the
trigger event itself corresponds to a cursor position of exactly
0. Times before the trigger are negative, times after the trigger
positive. If a window width is given it has to be positive and the
window must fit into the time interval measured by the oscilloscope. The
easiest way to find valid parameters is to position the two vertical
cursors at the borders of the interval to be measured and directly use
the values displayed in the upper right hand corner of the oscilloscope
for the starting point and width.

Because the data measured by the oscilloscope are discreet it is not
possible to specify arbitrary values for the starting point and window
width but they must fit with the current minimum time resolution. If the
specified values don't fit the requirement a warning is printed and the
position and width are adjusted to the nearest allowed values.


@anchor{digitizer_change_window}
@item digitizer_change_window()
@findex digitizer_change_window()
This function can be used to change the position and width of an already
existing window. As the first parameter the function expects a window
number as returned by @code{digitizer_define_window()}. The following
two arguments are the new position and width for this window. During the
experiment neither the position nor the width argument must be
specified.  If non of them are given the positions of the cursors
displayed on the screen is used to define the windows new start position
and width. If only a new start position is given the distance between the
cursors on the screen is used for the window width.


@anchor{digitizer_window_position}
@item digitizer_window_position()
@findex digitizer_window_position()
This function can be used to query the position or to set a new position
for an already defined window. It expects at least one argument, a window
number as returned by @code{digitizer_define_window()}. If there is no
further argument the position of the window is returned. Otherwise the
second parameter is taken to be the new window position.


@anchor{digitizer_window_width}
@item digitizer_window_width()
@findex digitizer_window_width()
This function can be used to query the width or to set a new width for
an already existing window. It expects at least one argument, a window
number as returned by @code{digitizer_define_window()}. If there is no
further argument the width of the window is returned. Otherwise the
second parameter is taken to be the new window width.


@anchor{digitizer_display_channel}
@item digitizer_display_channel()
@findex digitizer_display_channel()
This function can be used during the @code{PREPARATIONS} section to tell
the program that you want a certain channel or a set of channels to be
displayed in any case. It expects a channel name or number (or a comma
separated list of channel specifiers) as defined above. There are only
certain circumstances where this function is really needed. Normally,
the program will not switch off channels. Only if in the test run it is
found that some channels are needed for the experiment which aren't
switched on but there are already too many other channels displayed
which don't seem to be needed the program has to switch off some of
them. If in this case the program switches off a channel that you don't
want to be off (or that the program erroneously assumes to be useless)
you may have to use this function to make sure the channel stays
switched on.


@anchor{digitizer_start_acquisition}
@item digitizer_start_acquisition()
@findex digitizer_start_acquisition()
This function starts an acquisition sequence of the
oscilloscope. Previously measured curves are discarded and new data
are sampled until the requested number of averages has been reached.
The function can only be used in the @code{EXPERIMENT} section of the
@code{EDL} file.


@anchor{digitizer_get_area}
@item digitizer_get_area()
@findex digitizer_get_area()
The function returns the area under one of the measured curves. It
expects up to two arguments, the oscilloscopes channel the data are to
be taken from and, optionally, a window ID as returned by
@code{digitizer_define_window()} to specify the time interval the area
is computed from. The channel that can be used depend on the model of
the digitizer:
@table @samp
@item TDS520
@itemx TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@item TDS540
@itemx TDS744A
@itemx TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4} 
@end itemize
@item LECROY9400
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MEM_C} or @code{MEM_D}
@item @code{FUNC_E} or @code{FUNC_F}
@end itemize
@end table
Except for the models @code{TDS520} and @code{LECROY9400}, this function
positions the cursors at the start and end point of the specified window
(or the first and last point if no window as been specified) and uses
the function built into the digitizer to compute the area. For the
models @code{TDS520} and @code{LECROY9400}, that miss this built-in
function, the curve in the interval is fetched which is than used to
compute the area. To give some visual feedback also for the @code{TDS520}
the cursors are moved to the borders of the interval.

The function will automatically wait until a still running acquisition
sequence is finished before measuring the area. 

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} file.


@anchor{digitizer_get_area_fast}
@item digitizer_get_area_fast()
@findex digitizer_get_area_fast()
This function takes the same arguments as the function
@code{digitizer_get_area()} and also basically does the same. The only
difference is that instead of using the function built into the
digitizer to compute the area the curve in the specified interval is
fetched and the area is computed from these data. This function can be a
bit faster because it doesn't set the cursors (which also means that
there is no visual feedback).

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} file.


@anchor{digitizer_get_curve}
@item digitizer_get_curve()
@findex digitizer_get_curve()
The function fetches a curve from the digitizer. It expects up to two
arguments, the channel the data are to be fetched from and, optionally,
a window ID as returned by @code{digitizer_define_window()} to specify
the time interval. Valid choices of the data channel depend on the model
of the digitizer:
@table @samp
@item TDS520
@itemx TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@item TDS540
@itemx TDS744A
@itemx TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@end table

The function positions the cursors at the start and end point of the
specified window (or the first and last point if no window as been
specified) to give a visual feedback.

The function will automatically wait until a still running acquisition
sequence is finished before returning a curve. The data will be returned
as an array of floating point numbers and it's the users responsibility
to supply an array for storing the data. Usually, this will be an array
defined with an unspecified number of elements.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} file.


@anchor{digitizer_get_curve_fast}
@item digitizer_get_curve_fast()
@findex digitizer_get_curve_fast()
This function is nearly identical to the function
@code{digitizer_get_curve()} with the only difference that the cursors
are not positioned at the start and end point of the curve to be fetched.


@anchor{digitizer_get_amplitude}
@item digitizer_get_amplitude()
@findex digitizer_get_amplitude()
The function returns the amplitude, i.e.@: the difference between the
maximum and minimum voltage, from the digitizer. The function takes up
to two parameters, the channel the data are to be fetched from and, optionally,
a window ID as returned by @code{digitizer_define_window()} to specify
the time interval. Valid choices of the data channel depend on the model
of the digitizer:
@table @samp
@item TDS520
@itemx TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@item TDS540
@itemx TDS744A
@itemx TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@end table
Except for the model @code{TDS520}, this function positions the cursors
at the start and end point of the specified window (or the first and
last point if no window as been specified) and uses the function built
into the digitizer to compute the amplitude. For the model @code{TDS520}
that misses this built-in function the curve in the interval is fetched
which is than used to compute the amplitude. To give some visual
feedback also for this model the cursors are moved to the borders of the
interval.

The function will automatically wait until a still running acquisition
sequence is finished before measuring the amplitude.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} file.


@anchor{digitizer_get_amplitude_fast}
@item digitizer_get_amplitude_fast()
@findex digitizer_get_amplitude_fast()
This function is nearly identical to @code{digitizer_get_amplitude()}
except that the function to compute amplitudes built into the digitizer
isn't used and the cursors aren't positioned at the start and end of the
time interval.


@anchor{digitizer_run}
@item digitizer_run()
@findex digitizer_run()
Usually, during an experiment the digitizer starts to do the
acquisitions following a call of @code{digitizer_start_acquisition()}
and stops when it's done. To have the digitizer running constantly
following an acquisition (at least up to the next
@code{digitizer_start_acquisition()} command) use this function. It
accepts no arguments and can only be used in the @code{EXPERIMENT}
section.


@anchor{digitizer_lock_keyboard}
@item digitizer_lock_keyboard()
@findex digitizer_lock_keyboard()
Usually, during an experiment the keyboard of the digitizer is
locked. But for situations where it would be useful to be able to
control the digitizer also via its keyboard it can be unlocked (and also
re-locked) from within the program. To unlock the keyboard call this
function with an argument of @code{0} or @code{"OFF"}, to re-lock the
keyboard call it again with a non-zero argument, @code{"ON"} or no
argument at all.

@end table


@node Pulser Functions, Synthesizer Functions, Digitizer Functions, Device Functions
@section Pulser Functions
@cindex Pulser Functions

Currently, there are three pulser/spectrometer combinations implemented:
@itemize @bullet
@item Sony/Tektronix DG2020 (S-band spectrometer, Frankfurt/Main)
@item Sony/Tektronix DG2020 (X-band spectrometer, Berlin)
@item Tektronix HFS9003 (W-band spectrometer, Berlin)
@item Bruker EP385 Pulse Programmer (X-band spectrometer, Berlin)
@item Interface Technology RS690 (360 GHz spectrometer, Berlin)
@end itemize
To load the functions for one of these pulsers use in the @code{DEVICES}
section one of the lines
@example
dg2020_f;
dg2020_b;
hfs9003;
ep385;
rs690;
@end example

Pulsers are rather special and even the @code{EDL} syntax for dealing
with the pulsers differs slightly. Thus there is a whole chapter dealing
with pulsers and how to define and use pulses, see @ref{Using
Pulsers}. Several of the aspects of the following short descriptions of
the pulser functions will probably only become understandable after
reading the chapter about pulsers and pulses.

Please note: Most functions for changing pulses will @strong{not} lead
to an immediate change of the pulse sequence the pulser outputs. E.g.@:
calling the function @code{pulser_shift()} (for moving pulses) will not
shift the pulses immediately. Instead, all changes to pulses are
recorded and but only executed when the function @code{pulser_update()}
gets called.

The reason for this is twofold: Changes to only parts of the pulses
might lead to a pulse sequence, which can't be output, e.g.@: because
pulses would collide. Thus it is necessary to wait until all changes of
pulse parameters have been done before trying to create a new pulse
sequence. The second reason is that updating the pulser can be quite a
time-consuming activity and if it would be done whenever only parts of a
more complex change of the pulse sequence is finished might increase the
time needed to do an experiment a lot.

The only functions that immediately change the pulse sequence are
@code{pulser_update()}, @code{pulser_reset}, @code{pulser_next_phase()}
and @code{pulser_phase_reset()}. For all other functions the new state
of the pulse sequence has to be committed explicitely by calling
@code{pulser_update()}.



@table @samp
@anchor{pulser_name}
@item pulser_name()
@findex pulser_name()
Returns a string with the name of the digitizer being used.


@anchor{pulser_state}
@item pulser_state()
@findex pulser_state()
This function can be either used to determine if the pulser is running
when called without an argument, in which case either @code{1} (i.e.@:
the pulser is running) or @code{0} (pulser is stopped) is returned. if
called with either a numerical argument or a string of @code{"ON"} or
@code{"OFF"} the pulser will be started or stopped (a numerical argument
of @code{0} stops the pulser, a non-zero argument starts it).

This function can also be called during the @code{PREPARATIONS} section
e.g.@: to keep the pulser to get started immediately at the start of
the experiment.


@anchor{pulser_channel_state}
@item pulser_channel_state()
@findex pulser_channel_state()
For the @strong{Tektronix HFS9003} this function can be used to
determine or set the state of individual channels of the pulser. If
called with a single integer argument between @code{1} and @code{4} the
state of the corresponding channel is returned. If called with an
additional numeric argument or a string of @code{"ON"} or @code{"OFF"}
the channel can be switched on or off.


@anchor{pulser_lock_keyboard}
@item pulser_lock_keyboard()
@findex pulser_lock_keyboard()
Usually, during an experiment the keyboard of the pulser is locked. But
for situations where it would be useful to be able to control the pulser
also via its keyboard it can be unlocked (and also re-locked) from within
the program. To unlock the keyboard call this function with an argument
of @code{0} or @code{"OFF"}, to re-lock the keyboard call it again with
a non-zero argument, @code{"ON"} or no argument at all. This command is
only available for the @strong{Sony/Tektronix DG2020}.


@anchor{pulser_update}
@item pulser_update()
@findex pulser_update()
This function has to be called after changes have been applied to pulses
either via any of the following pulser functions or by changing a pulse
property directly. Before this function is called, all changes are only
done to the internal representation of the pulser, but not yet send to
the pulser. Only by calling the function these changes are committed and
the real pulses will change.


@anchor{pulser_shift}
@item pulser_shift()
@findex pulser_shift()
This function can be called with either no argument or with a list of
(comma separated) pulse identifiers (pulse numbers will also do). If no
argument is given the position of all pulses which have a
@code{DELTA_START} defined is shifted by their respective
@code{DELTA_START}. If there is only one argument or a list of pulses
only the start position of the listed pulses are changed.


@anchor{pulser_increment}
@item pulser_increment()
@findex pulser_increment()
This function can be called with either no argument or with a list of
(comma separated) pulse identifiers (pulse numbers will also do). If no
argument is given the length of all pulses which have a
@code{DELTA_LENGTH} defined is incremented by their respective
@code{DELTA_LENGTH}. If there is only one argument or a list of pulses
only the lengths of the listed pulses are changed.


@anchor{pulser_pulse_reset}
@item pulser_pulse_reset()
@findex pulser_pulse_reset()
This function can be called with either no argument or with a list of
(comma separated) pulse identifiers (pulse numbers will also do). If no
argument is given all pulses are reset to their initial states, i.e.@:
the states of the pulses set in the @code{PREPARATIONS} section. The
function also does a reset of all pulse phases, as done by
@code{pulser_phase_reset()}. It does @strong{not} update the pulser, if
you want to reset all pulses @strong{and} and also update the pulser use
the function @code{pulser_reset()} instead.

If called with one argument or a list of pulses only the pulses from the
list are set back to their initial states.


@anchor{pulser_next_phase}
@item pulser_next_phase()
@findex pulser_next_phase()
When the experiment starts the phases of all pulses are set to the first
phase of the phase sequence (defined in the @code{PHASE} section)
associated with the pulses. By calling this function the phases of the
pulses are switched to the next phase. By repeatedly calling the
function one can run through the complete list of phases for the pulses.
This function also immediately updates the pulse sequence, as it is done
by calling @code{pulser_update()}.


@anchor{pulser_phase_reset}
@item pulser_phase_reset()
@findex pulser_phase_reset()
This function can be called with either no argument or with a list of
@code{PULSE_SETUP}s numbers. A @code{PHASE_SETUP} (see also @ref{Phase
channel setup}) defines on which output connectors of the pulser the
pulses of a function with a certain phase will appear. I.e.@: if the
pulses of the @code{MICROWAVE} function are to be phase-cycled one has
to specify which of the connectors is to be used to output microwave
pulses with an @i{x}-phase, which one is to be used for microwave pulses
pulses with an @i{y}-phase etc. Pulses of not more than two functions
can be phase-cycled, so there's a maximum of two @code{PULSE_SETUP}s,
@code{PULSE_SETUP_1} and @code{PULSE_SETUP_2}. By specifying the number
@code{1} or @code{2} on can restrict resetting the phases of the pulses
of the function associated with either @code{PULSE_SETUP_1} or
@code{PULSE_SETUP_2}.

This function also immediately updates the pulse sequence, as it is done
by calling @code{pulser_update()}.

@anchor{pulser_reset}
@item pulser_reset()
@findex pulser_reset()
This function does not take any arguments at all. It switches the pulser
back to the initial state it was in at the start of the experiment. It
includes the complete functionality of @code{pulser_pulse_reset()} but
also immediately updates the pulser as it is done by calling
@code{pulser_update()}.


@anchor{pulser_stop_on_update}
@item pulser_stop_on_update()
@findex pulser_stop_on_update()
This function exists for the @strong{Tektronix HFS9003} only. While
doing updates of the pulser to set new pulse positions and length etc.@:
it usually gets switched off. By calling this function with an argument
of @code{0} you can tell to pulser to continue even while doing
updates. If called with an argument of @code{1} you may switch back to
the default behavior.


@anchor{pulser_shape_to_defense_minimum_distance}
@item pulser_shape_to_defense_minimum_distance()
@findex pulser_shape_to_defense_minimum_distance()
This function exists for the Berlin X-band pulser modules
@code{dg2020_b}, @code{ep385} and @code{rs690} only. It sets the minimum
allowed distance between the end of a pulse shaper pulse and the start
of a defense pulse to avoid destroying the detector by excessive
microwave power. The default minimum value for this distance is
intentionally set to an unreasonably long value and this function allows
to reduce (but also enlarge) the value. As another security measure the
function requires the user to explicitely confirm the new value before
an experiment is started.

This function can only be called during the @code{PREPARATIONS} section
of an @code{EDL} program.


@anchor{pulser_defense_to_shape_minimum_distance}
@item pulser_defense_to_shape_minimum_distance()
@findex pulser_defense_to_shape_minimum_distance()
This function exists for the Berlin X-band pulser modules
@code{dg2020_b}, @code{ep385} and @code{rs690} only. It sets the minimum
allowed distance between the end of a defense pulse and the start of a
pulse shaper pulse to avoid destroying the detector by excessive
microwave power. The function also makes sure that the time between the
last defense pulse in a sequence and the first shape pulse of the next
pulse sequence does not get too short when a very high repetition rate
is used.

The default minimum value for this distance is intentionally set to an
unreasonably long value and this function allows to reduce (but also
enlarge) the value. As another security measure the function requires
the user to explicitely confirm the new value before an experiment is
started.

This function can only be called during the @code{PREPARATIONS} section
of an @code{EDL} program.


@anchor{pulser_automatic_shape_pulses}
@item pulser_automatic_shape_pulses()
@findex pulser_automatic_shape_pulses()
This function exists for the Berlin X-band pulser modules
@code{dg2020_b}, @code{ep385} and @code{rs690} only. It tells
@code{fsc2} to automatically create pulse shaper pulses in the
@code{PULSE_SHAPE} function. Obviously, this requires that a pod or
channel has been assigned to the @code{PULSE_SHAPE} function. The first
(and required) argument is the function for which shape pulses are to be
created, typically this will be @code{MICROWAVE} in which case shape
pulses are created for all microwave pulses.

The shape pulses have exactly the same length as the pulses they are
created for. The pulses the shape pulses are created for in turn are
automatically lengthened a bit to make them start before their shape
pulses and also to last longer.

The amount of time the pulse a pulse with an automatically generated
shape pulse will start earlier than specified in the @code{EDL} program
("left padding") can be set by the second function argument, if it is
missing a default value (set in the configuration file for the pulser)
is used. In the same way the third argument specifies how much longer
the pulse lasts  ("right padding") than the shape pulse. (It is not a
problem if the pulses should become that long that they overlap, if
necessary they are shortened.)

To make this more clear an example. Let's assume that @code{MICROWAVE}
pulse has been set in the @code{EDL} script:
@example
P1:   FUNCTION = MICROWAVE,
      START    = 400 ns,
      LENGTH   = 600 ns;
@end example
@noindent
If now the @code{pulser_automatic_shape_pulses()} function is called as
@example
pulser_automatic_shape_pulses( MICROWAVE, 24 ns, 16 ns );
@end example
the automatically created shape pulse will start at @w{400 ns} and last
for @w{600 ns} but the microwave pulse @code{P1} will now start @code{24
ns} earlier, i.e.@: at @w{376 ns}, and will have a length of @w{640 ns}.

The function @code{pulser_automatic_shape_pulses()} can be called for
more than one function (e.g.@: for both the @code{MICROWAVE} and the
@code{OTHER_2} function) and also additional shape pulses can be created
manually. The only requirement is that the shape pulses (both
automatically and manually created ones) don't overlap during the
experiment.

This function can only be called during the @code{PREPARATIONS} section
of an @code{EDL} program.


@anchor{pulser_automatic_twt_pulses}
@item pulser_automatic_twt_pulses()
@findex pulser_automatic_twt_pulses()
This function exists for the Berlin X-band pulser modules
@code{dg2020_b}, @code{ep385} and @code{rs690} only. It tells
@code{fsc2} to automatically create in the @code{TWT}
function. Obviously, this requires that a pod or channel has been
assigned to the @code{TWT} function. The first (and required) argument
is the function for which TWT pulses are to be created, typically this
will be @code{MICROWAVE} in which case shape pulses are created for all
microwave pulses.

Usually, the TWT pulses will have to start before the pulse for which
they were created. The amount of time the TWT pulse starts before its
associated pulse can be specified as the second argument. If there is no
second argument a default value is used as defined in the configuration
file for the pulser. The third argument is the time the automatically
created TWT pulses last longer than the associated pulse. Again, if not
specified a default value is used.

The function @code{pulser_automatic_twt_pulses()} can be called for
more than one function (e.g.@: for both the @code{MICROWAVE} and the
@code{OTHER_2} function) and also additional TWT pulses can be created
manually. It isn't a problem if the TWT pulses would overlap, if
necessary they are shortenend.

Since TWTs often require a minimum distance between pulses the
automatically created pulses will automatically lengthened to cover too
short a distance between them. The minimum TWT pulse distance is a
compile time constant that can be adjusted in the configuration file for
the module.

This function can only be called during the @code{PREPARATIONS} section
of an @code{EDL} program.


@anchor{pulser_keep_all_pulses}
@item pulser_keep_all_pulses()
@findex pulser_keep_all_pulses()
This function only exists for the @strong{Sony/Tektronix DG2020} pulser
(both the @code{dg2020_b} and @code{dg2020_b} module) and the
@strong{Tektronix HFS9003} pulser.

Usually pulses that in the test run are found to be unused are deleted
and a warning message is printed indicating this. Any further reference
to or use of these deleted pulses leads to the immediate termination of
the experiment. But there are a few situations where it can't be
detected in the test run that a pulse is actually needed (e.g.@: if it
is only used in an untestable @code{IF} construct) and thus the pulse
gets deleted even though it is needed. In this case you have to force
the program to keep all pulses even if they seem to be unused by calling
this function (without an argument).


@anchor{pulser_maximum_pattern_length}
@item pulser_maximum_pattern_length()
@findex pulser_maximum_pattern_length()
This function only exists for the @strong{Sony/Tektronix DG2020} pulser
(both the @code{dg2020_b} and @code{dg2020_b} module) and the
@strong{Tektronix HFS9003} pulser. For the @strong{Bruker EP385} no
maximum pattern length can be specified, it is fixed to 32768 times the
clocks oscillation period (i.e.@: @w{262.144 us} when using the internal
clock). The @strong{Interface Technology RS690} uses a rather different
concept and, in principle, there is no maximum pattern length.

In most cases the program will be able to figure out automatically how
long the length of the longest pulse pattern in the experiment is going
to be when doing the test run. The longest pulse pattern length is
needed to set up the pulser correctly. Unfortunately, there are certain
syntax constructs that make it difficult or even impossible to find out
this maximum pattern length. These constructs are @code{FOREVER} loops
and sometimes cases, where changes of pulse positions or lengths are
done within @code{IF-ELSE} or @code{UNLESS-ELSE} constructs (please also
see the discussion of the problems introduced by @code{FOREVER} loops
and @code{IF} and @code{ELSE} constructs, @pxref{Control structures}).

Whenever there is a reason to suspect that these problems may occur one
can set the maximum pulse pattern length manually (i.e.@: the end point
of the last pulse when it has been set to its latest position in the
experiment by calling @code{pulser_maximum_pattern_length()} with the
the maximum pulse pattern length as the only argument.

Unless in the test run an even longer pattern length is found, this
value is used. It is not a problem to specify too long a maximum pattern
length, so a conservative guess will do. The only penalty incurred is
are longer times needed to set up the pulser at the start of the
experiment. On the other hand, too short a pattern length will lead to
the experiment being stopped with an error message when the actual
pattern length becomes larger than the one specified.


@anchor{pulser_phase_switch_delay}
@item pulser_phase_switch_delay()
@findex pulser_phase_switch_delay()
This function is only implemented for the Frankfurt version the
@strong{Sony/Tektronix DG2020} pulser, @code{dg2020_f}. It lets you
specify the time a phase pulse has to be set to a new phase before the
microwave pulses (or other phase cycled pulses) start (the phase switch
needs some small amount of time to settle).

The function takes two arguments, the first one is the phase function
the phase switch delay is to be applied to (i.e.@: either @code{PHASE_1}
(or @code{PHASE} for short) or @code{PHASE_2}). The second argument is
the amount of time.

When this function hasn't been called a default value of @w{20 ns} is
used for both Phase functions.

When the program does its tests it will always check if the distances
between the pulses are large enough to allow setting the phase
pulses. If the pulse distances get too short to set the phase switch
delays the program will abort with an error message.


@anchor{pulser_grace_period}
@item pulser_grace_period()
@findex pulser_grace_period()
This function is only implemented for the Frankfurt version the
@strong{Sony/Tektronix DG2020} pulser, @code{dg2020_f}. Like the time a
phase pulse must start before the pulse it was set for can be set via
the @code{pulser_phase_switch_delay()} function, you also may set how
much longer a phase pulse has to be set after the oiginal pulse ended.

The function takes only one argument, the time the phase pulses will last
longer. It applies automatically to both phase functions. 

If this function isn't called a default grace period of @w{10 ns} will
be used.

Here's a diagram that shows the phase switch delay and the grace period
(assuming that the microwave pulses are to be phase-cycled):
@example
                   ____________________________
                  |                            |
Phase pulse       |                            |
             _____|                            |_________
                           _________________
                          |                 |
Microwave pulse           |                 |
             _____________|                 |____________
         
                ->|       |<-             ->|  |<-
               phase switch delay        grace period
@end example


When the program does its tests it will always check if the distances
between the pulses are large enough to allow setting the phase
pulses. If the pulse distances get very small it may drop the grace
period.


@anchor{pulser_show_pulses}
@item pulser_show_pulses()
@findex pulser_show_pulses()
This function allows to view the pulses as they become set during the
test run. If this function is called an additional window pops up after
the end of the test run which shows the position of all pulses at the
start of the experiment. By using the (fast) forward and backward)
buttons, the @w{@code{<PAGE UP>}} and @w{@code{<PAGE DOWN>}} as well as
the @code{<HOME>} and @code{>END}> keys) you may view all pulse settings
during the experiment (as far as they can be determined during the test
run). Alternatively, the step number can be edited directly.

By using the @code{Show delays} button you can switch between a display
where the pulses are shown at their "logical" positions (as they would
be set if there would be no delays) and the positions at which they,
due to delays really will be set.

In an additional window the paramters of the pulse the mouse is currenty
positioned on are displayed. These include the pulse number (when the
pulse number is enclosed in parentheses it's an automatically created
pulse, the number itself is identical to the pulse number of the pulse
it was created for), the positions with and without delays (depending on
the current setting of the @code{Show delays} button, in parentheses the
value for the other button state is shown), the pulse length, its
function and the number of the pod or channel to which the pulse will be
routed.

Further informations are the edge-to-edge distance to the previous and
the next pulse (in parentheses the center-to center distance) is shown.

Finally, for automatically created pulses informations about the parent
pulse, i.e.@: the pulse for which this pulse was created for, are
displayed. 

The function uses the @code{fsc2_pulses} program to display the pulse
settings. @code{fsc2_pulses} only works if both Perl and Perl/Tk (in not
too ancient a version) is installed on the system.

This function can only be called during the @code{PREPARATIONS} section
of an @code{EDL} program.


@anchor{pulser_dump_pulses}
@item pulser_dump_pulses()
@findex pulser_dump_pulses()
This function requests the user to select a file name and then writes
all pulse settings during the test run into the file in a format
suitable to be used as input for the @code{fsc2_pulses} utility.

This function can only be called during the @code{PREPARATIONS} section
of an @code{EDL} program.

@end table



@node Synthesizer Functions, Temperature Controller Functions, Pulser Functions, Device Functions
@section Synthesizer Functions
@cindex Synthesizer Functions
The only implemented synthesizers so far are the @code{HP8647A} (but
also is works with the @code{HP8648B} synthesizer) and
@code{HP8672A}. Their modules are loaded by specifying
@example
hp8647a
hp8672a
@end example
@noindent
in the @code{DEVICES} section.


@table @samp
@anchor{synthesizer_name}
@item synthesizer_name()
@findex synthesizer_name()
Returns a string with the name of the synthesizer being used.


@anchor{synthesizer_state}
@item synthesizer_state()
@findex synthesizer_state()
The function queries or sets the output state of the synthesizer. i.e.@:
to switch output of RF on or off. If called to set the output state it
accepts one argument, either a non-zero value or the string @code{"ON"}
to switch output on, or zero or the string @code{"OFF"} to switch it
off. The synthesizer output is never switched on automatically!

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e.@: without an argument (unless the state has already been
set by calling the function with an argument). In query mode it either
returns either @code{1} or @code{0} to indicate the on/off state of the
RF output.


@anchor{synthesizer_frequency}
@item synthesizer_frequency()
@findex synthesizer_frequency()
The function queries or sets the RF output frequency. If called to set
the frequency it accepts a frequency as the only argument. For the
@code{HP8647A} the frequency must be in the range between @w{250 kHz}
and @w{1000 MHz}, for the @code{HP8672A} between @w{xxx MHz} and @w{18
GHz}. The frequency set by the very first call of this function is also
the function that is set automatically by a call of the function
@code{synthesizer_reset_frequency()} (see below).

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e.@: without an argument (unless the frequency has already
been set by calling the function with an argument). For the
@code{HP8672A} the function can be called in query mode only when the
frequency has been set previously.


@anchor{synthesizer_attenuation}
@item synthesizer_attenuation()
@findex synthesizer_attenuation()
The function queries or sets the output attenuation. If called to set
the attenuation it accepts one argument, the attenuation. For the
@code{HP8647A} the attenuation must be in the range between @w{+10 db}
and @w{-136 db} with a resolution of @w{0.1 db}, for the @code{HP8672A}
between @w{+3 db} and @w{-120 db} with a resolution of @w{1 db}.

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e.@: without an argument (unless the attenuation has already
been set by calling the function with an argument). For the
@code{HP8672A} the function can be called in query mode only when the
attenuation has been set previously.


@anchor{synthesizer_minimum_attenuation}
@item synthesizer_minimum_attenuation()
@findex synthesizer_minimum_attenuation()
The function can be used to restrict the minimum output attenuation to
avoid to inadvertently set too high output power levels. It can be
called to both query and sets the minimum output attenuation. If called
to set the attenuation it accepts one argument, the attenuation within
the allowed range of attenuations of the device. Calling the function
disables setting the attenuation by further calls of
@code{synthesizer_attenuation()} to ranges below the value set by this
function.


@anchor{synthesizer_step_frequency}
@item synthesizer_step_frequency()
@findex synthesizer_step_frequency()
The function queries or sets the RF step frequency to be used in calls
of the functions @code{synthesizer_sweep_up()} and
@code{synthesizer_sweep_down()} (see below). In order to set the step
frequency it expects one argument, the step frequency in Hz. The step
frequency can be set in the @code{PREPARATIONS} section only once, but
it can be changed later in the @code{EXPERIMENT} section.

Before the step frequency has been set by calling the function with an
argument the query form of the function (i.e.@: calling it without an
argument can't be used).


@anchor{synthesizer_sweep_up}
@item synthesizer_sweep_up()
@findex synthesizer_sweep_up()
If there has been set both a frequency and a step frequency the function
will increment the synthesizers frequency. It returns the newly set
frequency. The function can only be called in the @code{EXPERIMENT}
section.


@anchor{synthesizer_sweep_down}
@item synthesizer_sweep_down()
@findex synthesizer_sweep_down()
If there has been set both a frequency and a step frequency the function
will decrement the synthesizers frequency. It returns the newly set
frequency. The function can only be called in the @code{EXPERIMENT}
section.

@anchor{synthesizer_reset_frequency}
@item synthesizer_reset_frequency()
@findex synthesizer_reset_frequency()
If a frequency has been set at all the function will reset the
synthesizers frequency to the frequency that has been set at first. The
function can only be called in the @code{EXPERIMENT} section.


@anchor{synthesizer_use_table}
@item synthesizer_use_table()
@findex synthesizer_use_table()
This function tells the program to also adjust the attenuation when a
new frequency is set. To find out which attenuation has to be set for a
new frequency a table file is used. The name of this table file can be
passed to the function as a (string) argument. If no argument is given a
default table file is used (typically this is
@file{/usr/local/lib/fsc2/hp8647a.table} for the @code{HP8647A} and
@file{/usr/local/lib/fsc2/hp8672a.table} for the @code{HP8672A}, but it
may depend on the installation).

The table file must consist of pairs of entries, a frequency and a
corresponding attenuation in db. The attenuation is being added to the
'raw' attenuation, i.e.@: to achieve an higher attenuation and a lower
output power a negative attenuation has to be specified.  If no unit are
given in the table file (i.e.@: @code{MHz} and @code{db}) the first
member of an entry must be the frequency, the second the attenuation.
The entries in the file don't have to be sorted in any way, and
the frequencies don't have to spaced equally.

The items in the table file can be separated by spaces, commas,
semicolons, colons, tabs or newlines or any combination of these
characters (a unit will also work as a separator) and the entries don't
have to be separated by a newline. Thus all the following entries would
be valid:
@example
7.90000000 MHz,   -1.90000000 db
-2.10000000 db 8.00000000 MHz   
8.1E6 -2.2 8.20000000 MHz : -2.30000000 db 8300 kHz

   -2.4 db
8.70000000MHz-2.40000000db
@end example
@noindent
As you see also blank lines don't matter. Finally, all lines starting
with a hash character, `@code{#}', are treated as comments.

If a frequency is used that isn't in the table the attenuation to be used
is extrapolated from the next neighboring frequencies. If the frequency
isn't within the range of frequencies covered by the table a warning is
printed and the attenuation for the nearest frequency is used.


@anchor{synthesizer_att_ref_freq}
@item synthesizer_att_ref_freq()
@findex synthesizer_att_ref_freq()
When a table file is used there remains the question for which frequency
to use the attenuation has been set e.g.@: by
@code{synthesizer_attenuation()}. To set this reference frequency the
function @code{synthesizer_att_ref_freq()} can be used. If the function
isn't called a frequency of @w{14 MHz} is used for the @code{HP8647A}
and @w{2 GHz} for the @code{HP8672A}.


@anchor{synthesizer_modulation}
@item synthesizer_modulation()
@findex synthesizer_modulation()
Using this function for the @code{HP8647A} the type, source and
amplitude of the modulation can be set, for the @code{HP8672A} both type
and amplitude. It can set all of these parameters at once or only parts
of them.

For the @code{HP8647A} there are four possible types of modulation: FM,
AM and phase modulation. The modulation type is specified by a string,
either @code{"FM"}, @code{"AM"}, @code{"PHASE"} or, finally,
@code{"OFF"}. For the @code{HP8672A} @code{"FM"}, @code{"AM"} and
@code{"OFF"} can be used.

Please note that setting a modulation source or amplitude while the
modulation is off (i.e.@: when @code{"OFF"} has been specified as the
modulation type) is not possible and trying to do so will make the
program abort.

For the @code{HP8647A} the possible modulation sources are either
external AC coupled, external DC coupled, internal @w{1 kHz} or internal
@w{400 Hz}. For external AC or DC coupled modulation specify one the
strings @code{"EXT AC"}, @code{"AC"}, @code{"EXT DC"} or
@code{"DC"}. For internally generated modulation with @w{1 kHz} or
@w{400 Hz} use a string argument from the following list: @code{"INT
1kHz"}, @code{"INT 1 kHz"}, @code{"INT 1"}, @code{"1kHz"}, @code{"1
kHz"}, @code{"1"}, @code{"INT 400Hz"}, @code{"INT 400 Hz"}, @code{"INT
400"}, @code{"400Hz"}, @code{"400 Hz"} or @code{"400"}. But please note:
external DC coupled modulation source does not work with amplitude and
phase modulation@!

For the @code{HP8672A} no modulation source can be specified.

Finally you may specify the modulation amplitude, which has to be a
number (preferably a floating point number). For the @code{HP8647A} FM
modulation amplitudes have to be in the range between @w{0 Hz} and
@w{100 kHz}, AM modulation amplitudes between @w{0%} and @w{100%} and
phase modulation amplitudes between @w{0 degree} and @w{10 degree}.

For the @code{HP8672A} FM modulation can be set to either @w{30 kHz},
@w{100 kHz}, @w{300 kHz}, @w{1 MHz}, @w{3 MHz} or @w{10 MHz}. AM
modulation can only be set to either @w{30%} or @w{100%}.


Only in the first call of the function all two or three arguments,
i.e.@: the modulation type, amplitude and source (if applicable) should
be passed to the function. In further calls not all of the arguments
need to be given again. Instead, in further calls it is sufficient to
specify only for example a new amplitude. The same, of course, holds for
the modulation source.

If the modulation type becomes changed, the source and amplitude reverts
to the settings that were specified in previous calls of the function
when this modulation type was still active. I.e.@: if for the
@code{HP8647A} at first AM modulation using an external AC coupled
source and an amplitude of @w{50%} was set and then the modulation was
changed to FM with different settings for source and amplitude, another
call switching back to AM modulation will also restore the settings of
external AC coupled source and @w{50%} amplitude.


@anchor{synthesizer_mod_type}
@item synthesizer_mod_type()
@findex synthesizer_mod_type()
As an alternative the function @code{synthesizer_modulation()} the
modulation type can be also set via the function
@code{synthesizer_mod_type()}. It accepts one of three (for the
@code{HP8672A}) or four ( for the @code{HP8647} string arguments
@code{"FM"}, @code{"AM"}, @code{"PHASE"} (@code{HP8647A} only) or,
finally, @code{"OFF"}. (or the numbers @code{0} for FM, @code{1} for AM,
for the @code{HP8647A} @code{2} for phase modulation or @code{3} for
switching modulation off, and @code{2} for modulation off for the
@code{HP8672A})).

If called with no argument it will return the currently active modulation
type as an integer number.


@anchor{synthesizer_mod_source}
@item synthesizer_mod_source()
@findex synthesizer_mod_source()
This function is only available for the @code{HP8647A}.  If the
modulation type has been set before the modulation source can be set
directly via this function. It accepts one of the following strings:
@code{"INT 1kHz"}, @code{"INT 1 kHz"}, @code{"INT 1"}, @code{"1kHz"},
@code{"1 kHz"}, @code{"1"}, @code{"INT 400Hz"}, @code{"INT 400 Hz"},
@code{"INT 400"}, @code{"400Hz"}, @code{"400 Hz"} or
@code{"400"}. Alternatively, the number @code{0} can be specified for
external AC coupled modulation source, @code{1} for an external DC
coupled source, @code{2} for the internally generated @w{1 kHz} source
and @code{3} for the internal @w{400 Hz} source.

If the function is called with no argument it will return the modulation
source setting for the currently active modulation type as an integer number.
You can neither set nor obtain the modulation source as long as the
modulation is switched off, trying to do so will result in aborting the
program.


@anchor{synthesizer_mod_ampl}
@item synthesizer_mod_ampl()
@findex synthesizer_mod_ampl()

If the modulation type has been set this function can be used to set the
modulation amplitude. For the @code{HP8647A} the allowed range of FM
frequencies is from @w{0 Hz} to @w{100 kHz}, for AM amplitudes between
@w{0%} and @w{100%} are acceptable and for phase modulation values
between @w{0 degree} and @w{10 degree} are valid. 

For the @code{HP8672A} FM modulation can be set to either @w{30 kHz},
@w{100 kHz}, @w{300 kHz}, @w{1 MHz}, @w{3 MHz} or @w{10 MHz}. AM
modulation can only be set to either @w{30%} or @w{100%}.

If called with no argument, the function will return the amplitude
setting for the currently active modulation type. You can neither set
nor obtain the modulation amplitude as long as the modulation is
switched off, trying to do so will result in aborting the program.

@end table



@node Temperature Controller Functions, Voltmeter Functions, Synthesizer Functions, Device Functions
@section Temperature Controller Functions
@cindex Temperature Controller Functions
The only currently implemented temperature controller is the Lake Shore 330.
Its module is loaded by specifying
@example
lakeshore330
@end example
@noindent
in the @code{DEVICES} section. All functions for the temperature
controller can only be used in the @code{EXPERIMENT} section of
the @code{EDL} program.


@table @samp
@anchor{temp_contr_name}
@item temp_contr_name()
@findex temp_contr_name()
Returns a string with the name of the temperature controller being used.


@anchor{temp_contr_temperature}
@item temp_contr_temperature()
@findex temp_contr_temperature()
This function accepts no arguments and returns the temperature at the
currently active sample channel.

@anchor{temp_contr_sample_channel}
@item temp_contr_sample_channel()
@findex temp_contr_sample_channel()
This function returns, when called with no argument, the currently
selected sample channel. It returns @code{1} for channel @code{A} and
@code{2} for channel @code{B}. These values can also passed to the
function to set a new sample channel. Alternatively, one may also use
the strings @code{"A"} or @code{"B"}. Please take note that setting a
sample channel takes about half a second.


@anchor{temp_contr_sensor_unit}
@item temp_contr_sensor_unit()
@findex temp_contr_sensor_unit()
Function either returns or sets the units returned by the device on
temperature readings. If used to set a unit the function must be called
with the value @code{0} or @code{"K"} to set the unit to Kelvin,
@code{1} or @code{"C"} to set to degree Celsius or, finally, with
@code{2} or @code{"S"} to set to the unit appropriate for the sensor
(volts for diodes, Ohms for RTD or Millivolts for thermocouples). It
will always return the unit setting as an integer value with @code{1}
for Kelvin, @code{1} for degree Celsius, @code{2} for Volts, @code{3}
for Ohms or @code{4} for Millivolts.


@anchor{temp_contr_lock_keyboard}
@item temp_contr_lock_keyboard()
@findex temp_contr_lock_keyboard()
Usually, during an experiment the keyboard of the temperature controller
is locked. But for situations where it would be useful to be able to
control the device also via its keyboard it can be unlocked (and also
re-locked) from within the program. To unlock the keyboard call this
function with an argument of @code{0} or @code{"OFF"}, to re-lock the
keyboard call it again with a non-zero argument, @code{"ON"} or no
argument at all.

@end table



@node Voltmeter Functions, Boxcar Integrator Functions, Temperature Controller Functions, Device Functions
@section Voltmeter Functions
@cindex Voltmeter Functions
The only currently supported digital voltmeter is the @strong{Kontron 4060}.
Its module is loaded by specifying
@example
kontron4060
@end example
@noindent
in the @code{DEVICES} section.

@table @samp

@anchor{voltmeter_name}
@item voltmeter_name()
@findex voltmeter_name()
Returns a string with the name of the voltmeter being used.

@anchor{voltmeter_get_data}
@item voltmeter_get_data()
@findex voltmeter_get_data()
The function returns the current voltage measured by the voltmeter.


@anchor{voltmeter_ac_measurement}
@item voltmeter_ac_measurement()
@findex voltmeter_ac_measurement()
The function switches the voltmeter to doing AC measurements.

@anchor{voltmeter_dc_measurement}
@item voltmeter_dc_measurement()
@findex voltmeter_dc_measurement()
The function switches the voltmeter to doing DC measurements.

@end table



@node Boxcar Integrator Functions, Frequency Counter Functions, Voltmeter Functions, Device Functions
@section Boxcar Integrator Functions
@cindex Boxcar Integrator Functions
Currently there is only rudimentary support for one type of boxcar
integrator, the @strong{EG&G PARC 4402}. Its module is loaded by specifying
@example
egg4402
@end example
@noindent
in the @code{DEVICES} section. All functions for the boxcar integrator
can only be used in the @code{EXPERIMENT} section of the @code{EDL}
program.

@table @samp

@anchor{boxcar_name}
@item boxcar_name()
@findex boxcar_name()
Returns a string with the name of the boxcar integrator being used.

@anchor{boxcar_curve_length}
@item boxcar_curve_length()
@findex boxcar_curve_length()
Returns an integer variable with the length of curves to be sent by the
boxcar integrator.

@anchor{boxcar_get_curve}
@item boxcar_get_curve()
@findex boxcar_get_curve()
Fetches a curve from the boxcar integrator. Two first argument is either
a number, either @code{0} for a live curve or @code{1} for a memory
curve, or one of the strings @code{"LC"}, @code{"LIVECURVE"},
@code{"LIVE_CURVE} or @code{"MC"}, @code{"MEMORYCURVE"} or
@code{"MEMORY_CURVE"}. The second argument must be an integer specifying
the curve number, it must be @code{1} or @code{2} for live curves and
between @code{1} and @code{3} for memory curves.

@end table


@node Frequency Counter Functions, DAC Functions, Boxcar Integrator Functions, Device Functions
@section Frequency Counter Functions
@cindex Frequency Counter Functions
Currently only one frequency counter is supported, the HP5340A. Because
this is a very old device (even pre-dating the GPIB-standard) only two
functions are defined for the device. All settings have to be done
manually via the front panel. Its module is loaded by specifying
@example
hp5340a
@end example
@noindent
in the @code{DEVICES} section. 

@table @samp

@anchor{freq_counter_name}
@item freq_counter_name()
@findex freq_counter_name()
Returns a string with the name of the frequency counter being used.

@anchor{freq_counter_measure}
@item freq_counter_measure()
@findex freq_counter_measure()
Returns a floating point value with the measured frequency. The function
does not accept any parameters and can only by used in the
@code{EXPERIMENT} section.

@end table


@node DAC Functions, Event Counter Functions, Frequency Counter Functions, Device Functions
@section DAC Functions
@cindex DAC Functions
Currently, there's support for one type of digital-to-analog converter
cards, the @strong{Meilhaus Electronic GmbH} cards ME-6000 and ME-6100.
These cards have, depending on the model, either 4, 8 or 16 output
ports. The module for these cards is loaded by specifying
@example
me6000
@end example
@noindent
in the @code{DEVICES} section. 

Use of these cards requires that a kernel module and an additional
library (both coming with @code{fsc2}) have been successfully installed.

@table @samp

@anchor{dac_name}
@item dac_name()
@findex dac_name()
Returns a string with the name of the DAC being used.

@anchor{dac_voltage}
@item dac_voltage()
@findex dac_voltage()
This function has to be used to output a voltage at one of the output
ports. The first argument has to be the output port, specified by one of
the symbolic values between @code{CH0} and @code{CH15} (please
@strong{don't} use numbers directly, the mapping between the symbolic
values and channel numbers is non-trivial). The second argument is the
voltage (in the range between @w{-10 V} and @w{+10 V}) to be output.

If an output voltage has already been set for an output port the last
set voltage is returned when the function is called without a second
argument.

Please note that the latest set output voltage will still appear on the
ouput port after the program is finished. If it is required that the
output voltage reverts to a default value at the end of the experiment
please put a command for setting this voltage into the @code{ON_STOP}
section of the @code{EDL} script.

The function can be used in the @code{EXPERIMENT} as well as in the
@code{PREPARATIONS} section.

@end table


@node Event Counter Functions, Multi-Device Functions, DAC Functions, Device Functions
@section Event Counter Functions
@cindex Event Counter Functions
The only currently supported event counter is the @code{National
Instruments} GPCT 6601 card. It can be used for counting as well as for
creating pulses. The module for this card is loaded by specifying
@example
ni6601
@end example
@noindent
in the @code{DEVICES} section. 

Use of this card requires that a kernel module and an additional
library (both coming with @code{fsc2}) have been successfully installed.

@table @samp

@anchor{counter_name}
@item counter_name()
@findex counter_name()
Returns a string with the name of the event counter being used.

@anchor{counter_start_continuous_counter}
@item counter_start_continuous_counter()
@findex counter_start_continuous_counter()
This functions starts one of the counters of the card. The counter will
count until it is stopped by a call of the @code{EDL} function
@code{counter_stop_counter()}. It requires at least one argument, the
counter to be used, which needs to be specified by one of the symbolic
names between @code{CH0} and @code{CH3} (please @strong{don't} use
numbers directly, the mapping between the symbolic values and channel
numbers is non-trivial). If the requested counter is already running the
function will fail.

If called without a further argument the counter will count events on
its default input. Alternatively, as a second argument the source of
events to be counted can be specified by one of the following symbolic
names: @code{DEFAULT_SOURCE} (which is what would be used if no second
argument is specified), @code{SOURCE_0} to @code{SOURCE_3} (the default
input sources for channel @code{0} to @code{3}), @code{NEXT_GATE} (the
gate input for the adjacent counter, where the adjacent counter for
channel @code{0} is channel @code{1} and vice versa, and channels
@code{2} and @code{3} also make up a pair) and @code{TIMEBASE_1} and
@code{TIMEBASE_2} (the internal timebases of @w{20 MHz} and @w{100 kHz}).

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.

@anchor{counter_start_timed_counter}
@item counter_start_timed_counter()
@findex counter_start_timed_counter()
This function starts on of the counters of the card. The counter will
count for a specified time and then stops automatically. It requires at
least two arguments, the counter to be used, specified by a symbolic
name between @code{CH0} and @code{3}. If the requested counter is
already running the function will fail. The second required argument is
the length of time the counter is supposed to count. This time must be
between @w{100 ns} and about @w{214.748 s} and must be an integer
multiple of @w{50 ns}.

Please note: This function requires not only one counter channel, i.e.@:
the one passed to the function as the first argument, but also a second,
adjacent counter. If @code{CH0} is specified as the counter channel also
@code{CH1} will be needed and vice versa, and if @code{CH2} is specified
also @code{CH3} is required and vice versa. If the adjacent counter is
already in use for some other purpose the function fails.

If called without a further argument the counter will count events on
its default input. Alternatively, as a second argument, the source of
events to be counted can be specified by one of the following symbolic
names: @code{DEFAULT_SOURCE} (which is what would be used if no second
argument is specified), @code{SOURCE_1} to @code{SOURCE_3} (the default
input sources for channel @code{0} to @code{3}), @code{NEXT_GATE} (the
gate input for the adjacent counter, where the adjacent counter for
channel @code{0} is channel @code{1} and vice versa, and channels
@code{2} and @code{3} also make up a pair) and @code{TIMEBASE_1} and
@code{TIMEBASE_2} (the internal timebases of @w{20 MHz} and @w{100 kHz}).

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.

@anchor{counter_timed_count}
@item counter_timed_count()
@findex counter_timed_count()
This function is very similar to the previous function,
@code{counter_start_timed_counter()}, i.e.@: it runs a counter for a
specified of time, but in contrast it waits for the requested duration
of time and only then returns with the masured count. In every other
respect, e.g.@: the required arguments etc.@: it is identical to the
previous function.

The largest value that can be returned is @w{2147483647}, i.e. @w{2^31 -
1}.

@anchor{counter_intermediate_count}
@item counter_intermediate_count()
@findex counter_intermediate_count()
The function returns the current value of a counter. The counter may
still be running, in which case repeated calls of the function will
return an updated value according to the new number of events that
happened between invocations of the function. The function requires on
argument, the counter for which the current value is to be returned. It
must be specified by one of the symbolic names between @code{CH0} and
@code{CH3} (please @strong{don't} use numbers directly, the mapping
between the symbolic values and channel numbers is non-trivial).

The largest value that can be returned for a counter is @w{2147483647},
i.e. @w{2^31 - 1}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.

@anchor{counter_final_count}
@item counter_final_count()
@findex counter_final_count()
This function waits for an counter to stop and only then returns the
final value of the counter. Trying to call this function on a counter
that has been started by the function
@code{counter_start_continuous_counter()} and hasn't already been
stopped will fail, because such a counter will never stop by itself.

The function requires one argument, the counter for which the current
value is to be returned. It must be specified by one of the symbolic
names between @code{CH0} and @code{CH3} (please @strong{don't} use
numbers directly, the mapping between the symbolic values and channel
numbers is non-trivial).

The largest value that can be returned for a counter is @w{2147483647},
i.e. @w{2^31 - 1}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.

@anchor{counter_stop_counter}
@item counter_stop_counter()
@findex counter_stop_counter()
This function can be used to stop a counter independent of the purpose
(i.e.@: counting or pulse train creation) it was started. It requires
one argument, the counter for which the current value is to be
returned. It must be specified by one of the symbolic values between
@code{CH0} and @code{CH3} (please @strong{don't} use numbers directly,
the mapping between the symbolic values and channel numbers is
non-trivial).

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.

@anchor{counter_single_pulse}
@item counter_single_pulse()
@findex counter_single_pulse()
Beside being used as event counters the counters can also be used to
create pulses on its default output port. This function can be used to
create a single pulse on the output port. It requires two arguments, the
first being the counter to be used, specified by a symbolic value
between @code{CH0} and @code{3}. If the requested counter is already
running the function will fail. The second argument is the length of the
pulse, which must be between @w{100 ns} and about @w{214.748 s} and must
be an integer multiple of @w{50 ns}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.

@anchor{counter_continuous_pulses}
@item counter_continuous_pulses()
@findex counter_continuous_pulses()
This function allows to create a continuous train of pulses. It requires
at least two arguments, the first being the counter to be used,
specified by a symbolic value between @code{CH0} and @code{3}. If the
requested counter is already running the function will fail. The second
argument is the length of the pulse, which must be between @w{100 ns}
and about @w{214.748 s} and must be an integer multiple of @w{50 ns}.

If no third argument is specified the distance between pulses will be
identical to the pulse length. By specifying a third argument (with the
same restrictions as for the second argument) the distance between
pulses can be set.

To stop creation of pulses (and to free the counter for other uses) the
function @code{counter_stop_counter()} must be called.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.

@anchor{counter_dio_read}
@item counter_dio_read()
@findex counter_dio_read()
Beside counters the card also can do digital input and output. There are
8 lines that can be monitored or set. Using this function the current
state of any subset of these 8 lines can be determined. If the function
is called without an argument the state of all lines is returned, with
the lowest bit of the number returned being the state of the
lowest numbered DIO line, the seond-lowest bit of the number standing
for the second-lowest numbered DIO line etc. If all lines are set the
returned value is thus @code{255}.

If an integer argument gets passed to the function it is taken as a
mask, determining which of the DIO lines are to be treated as input
lines. The lowest bit of the mask stands for the lowest numbered DIO
line, the second-lowest bit of the mask for the second-lowest DIO line
etc. Thus, by specifying a mask of value of @code{1} the state of only
the DIO line numbered @code{0} would be returned, for a mask of value of
@code{2} the state of DIO line @code{1}, for @code{4} DIO line @code{2}
etc. By adding values for different DIO lines a subset of the DIO lines
can be specified. Simple arithmetics show that the value of the mask
must be between @code{0} (no DIO lines selected) and @code{255} (all DIO
lines selected, which is the default). All bits in the resulting return
value for which bits in the mask ae not set will be returned as being
set to @code{0}.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.

@anchor{counter_dio_write}
@item counter_dio_write()
@findex counter_dio_write()
The 8 DIO lines of the card can not only be monitored (see the previous
function, @code{counter_dio_read()}) but also set, which this function
is to be used for. The function requires at least one integer argument,
defining the states of the DIO lines to be set to. To output a high
voltage at one of the DIO lines the corresponding bit of the value must
be set.  The lowest bit of the value corresponds to the lowest numbered
DIO line, the second-lowest bit to the second-lowest numbered DIO line
etc. To only set the lowest numbered DIO line the value passed to the
function would have to be @code{1}, to set only the second-lowest
numbered DIO line the value would be @code{2}, to set only the
third-lowest numbered DIO line a value of @code{4} would be used. By
combining these values for the different DIO lines a certain output
pattern can be set for all DIO lines. Obviously, the allowed values are
restricted to the range between @code{0} (all DIO lines in low state) to
@code{255} (all DIO lines in high state).

Without a second argument all 8 DIO lines are switched to output mode
and the states of the lines set according to the value of the first
argument.  But by passing the function a mask value as the second
argument only a certain subset of the DIO lines will be set to output
mode, thus allowing to have some of the DIO lines for output, while the
can be used as input lines. Each set bit in the mask will switch the
corresponding lines to output state while not changing mode for the
lines for which no bit is set in the mask. Bits in the first argument
for which no bit is set in the second argument will be not used, i.e.@:
don't influence the state of the DIO lines.

The function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.

@end table


@node Multi-Device Functions, , Event Counter Functions, Device Functions
@section Multi-Device Functions
@cindex Multi-Device Functions

Currently, there is just one function that uses two devices at once. It
uses the single-device functions (and thus will print error messages if
the modules for the required devices aren't loaded or if the modules
don't support the needed functions). The module they are defined in is
automatically loaded, so it needs no special entry in the @code{DEVICES}
section.

@table @samp

@anchor{get_phase_cycled_area}
@item get_phase_cycled_area()
@findex get_phase_cycled_area()
This function is for doing a complete measurement sequence in a phase
cycled experiment. It goes through a complete phase cycle, setting the
pulser, fetching the data from the digitizer and finally returning the
measured data, i.e.@: the areas returned by the digitizer and added up
according to the setting of the @code{ACQUISITION_SEQUENCE}.

The function needs both a pulser and a digitizer. It is not possible to
use the function with more than one pulser or digitizer -- if more than
one pulser or digitizer is listed in the @code{DEVICES} section it will
always try to use the first pulser and digitizer listed.

The function can be used both for 1-dimensional and 2-dimensional
measurements. In the first case there is just one signal channel, in the
second two, e.g.@: a real and an imaginary part of a signal. Which kind
of measurement has to be done is determined by the number of acquisition
sequences. If there's only one it's a 1-dimensional measurement,
otherwise a 2-dimensional one.

The first argument the function expects is a digitizer channel to be
used for measuring the area of the signal, see above which channels can
be used for the different digitizers. If the @code{ACQUISITION_SEQUENCE}
is written in way that it is clear that two digitizer channels are
needed, i.e.@: you have a line in the @code{PHASES} section like
@example
ACQUISITION_SEQUENCE = +A, -B, -A, +B;
@end example
@noindent
also the second argument to the function must be a digitizer
channel. The first channel is used for fetching the @code{A} data, the
second for the @code{B} data. This is, of course, only relevant when you
have two different signals, e.g.@: the two outputs of a quadrature mixer
and the measured data consist of adding up signals from both channels.

The following arguments are as many window identifiers (as returned by
@code{digitizer_define_window()} as there are needed. If no window
argument is given always the area of the complete curve is returned!

The type of the return value depends on the number of window identifiers
passed to the function and the number of acquisition sequences. If there
is only one window identifier (or none) and only one acquisition
sequence a floating point value with the result of the measurement is
returned. If, on the other hand, there is more than one window
identifier and a single acquisition sequence an array will be returned
with as many elements as there are window identifiers, the first element
of the returned array containing the result for the first window, the
second element the value for the second window etc.

If, in contrast, there are two acquisition sequences an array of twice
the number of windows is returned. The first value in the array is the
result for the first acquistion sequence for the first window, the
second the result for the second acquistion sequence and the first
window, then follow the the results of both acquisition sequences for
the second window, etc.

As an example here parts of an @code{EDL} program for a 1-dimensional
stimulated echo experiment with phase cycling. The parts with the
definition of the pulses etc. are left out for sake of brevity.
@example
DEVICES:

dg2020_f;
tds754a;


VARIABLES:

Num_points = 256;
raw_data[ 2 ];
data[ Num_points ];
Win_ID_1;                // signal window
Win_ID_2;                // background window
I;

...

ASSIGNMENTS:

...

PHASES:

PHASE_SEQUENCE_1     = +x, -x, +x, -x;  // sequence for 2nd pulse
PHASE_SEQUENCE_2     = +x, +x, -x, -x;  // sequence for 3rd pulse

ACQUISITION_SEQUENCE =  +,  -,  -,  +;


PREPARATIONS:

init_1d( 1, Num_points );
Win_ID_1 = digitizer_define_window( 388 ns, 4 ns );
Win_ID_2 = digitizer_define_window( 620 ns, 4 ns );

...

EXPERIMENT:

FOR I = 1 : : Num_points @{
    raw_data = get_phase_cycled_area( CH1, Win_ID_1, Win_ID_2 );
    data[ I ] = raw_data[ 1 ] - raw_data[ 2 ];
    display( I, data[ I ] );
    pulser_shift( );
@}

...
@end example

The first thing the function does is to do a phase reset to be certain
the pulser starts with a pulse pattern for the first phase as defined in
the @code{PHASE_SEQUENCE} declarations. Then it will measure the signals
areas for both digitizer window areas. In the next step it switched the
pulser to the pulse pattern for the next phase and repeat the
measurement of both the signal areas and subtract them from the values
measured in the first step (because in the @code{ACQUISITION_SEQUNCE}
command requires subtraction of the data). Then, again the pulse pattern
is switched to the third phase and a third set of data for both windows
is measured. Also these data are subtracted according to the settings of
acquisition sequence. Finally, the fourth and last phase settings are
send to the pulser and a fourth set of signal areas is measured. These
data now must, according to the acquisition sequence, be added to the
previous accumulated data. The result, an array with two elements for
the first and second window is returned by the function.

You may note, that in this program @code{pulser_update()} isn't called
after @code{pulser_shift()}. This is possible because
@code{get_phase_cycled_area()} internally calls @code{pulser_update()}
before it starts doing the measurement.

Two acquisition sequences would, for example, be used in an inversion
recovery experiment with FID detection and phase cycling. Parts of the
@code{EDL} program would look like this:
@example
DEVICES:

dg2020_f;
tds754a;


VARIABLES:

Num_points = 256;
raw_data[ 4 ];
data[ Num_x_points, 2 ];
Win_ID_1;                // signal window
Win_ID_2;                // background window
I;

...

ASSIGNMENTS:

...

PHASES:

PHASE_SEQUENCE_1       = +x, +x, +x, +x, -x, -x, -x, -x;
PHASE_SEQUENCE_2       = +x, -x, +y, -y, +x, -x, +y, -y;

ACQUISITION_SEQUENCE_1 = +A, -A, +B, -B, +A, -A, +B, -B;
ACQUISITION_SEQUENCE_2 = +B, -B, -A, +A, +B, -B, -A, +A;


PREPARATIONS:

init_1d( 2, Num_points );
Win_ID_1 = digitizer_define_window( 388 ns, 4 ns );
Win_ID_2 = digitizer_define_window( 620 ns, 4 ns );

...

EXPERIMENT:

FOR I = 1 : Num_points @{
    raw_data = get_phase_cycled_area( CH1, CH2,
                                      Win_ID_1, Win_ID_2 );
    data[ I, 1 ] = raw_data[ 1 ] - raw_data[ 3 ];
    data[ I, 2 ] = raw_data[ 2 ] - raw_data[ 4 ];
    display( I, data[ I, 1 ], 1, I, data[ I, 2 ], 2 );
    pulser_shift( );
@}
@end example
@noindent
We have two acquisition sequences and two digitizer windows, so the
function returns an array with 4 elements. The first and third element
of the array are the results for the first acquisition sequence for
window 1 and 2, the second and fourth are the ones for the second
acquisition for both windows. Since the data are measured with baseline
correction, i.e.@: the result for the second, off-resonance window must
be subtracted from the first windows result, to obtain the value for the
first acquisition sequence from the first array element the third must
be subtracted, and for the second acquisition sequence the value if the
fourth array element from the second.


@end table
