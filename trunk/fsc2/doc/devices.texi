@c $Id$

@node Device Functions, Modules, Built-in Functions, Top
@chapter Device Functions

@ifinfo
@menu
* Introduction::            
* Magnet Functions::        Functions for controlling the magnet.
* Gaussmeter Functions::    Functions for meeasuring the magnetic field.
* Lock-In Functions::       Functions for accessing the lock-in amplifiers.
* Digitizer Functions::     Functions for accessing the oscilloscopes.
* Pulser Functions::
* Synthesizer Functions::
@end menu
@end ifinfo


@node Introduction, Magnet Functions, Device Functions, Device Functions
@section Introduction


The most simple approach would be to have a set of functions for each
individual device, i.e.@: to have a different function for e.g.@:
fetching data from each of a series of different digitizing
oscilloscopes.  But this would be a nuisance for someone writing
@acronym{EDL} programs because whenever for example the oscilloscope has
to be changed also all the programs have to be adjusted to the special
capabilities of the digitizer that's just using.

Thus it's reasonable to have generic functions for a similar devices
that usually have a lot in common. So one may write
@example
new_data = digitizer_get_curve( CH1 );    // get curve from channel 1
@end example
instead of
@example
new_data = tds754a_get_curve( 1 );        // get curve from channel 1
@end example
and does not have to change anything whenever someone else needs the
TDS754A oscilloscope for a few days and one has to do with the TDS520
oscilloscope in the mean time.

Of course, using generic functions has its limitations - when e.g.@: the
lock-in amplifier has only one channel no abstraction can make it have
two channels - but wait, actually, it can: whenever the program is asked
for data from channel 2 it may rotate the phase lock-in phase by 90
degrees, waits for another time constant, gets the value and you
basically have two channels, at least realized in software (of course,
there's a penality - measurements take at least twice the time needed
with a two-channel lock-in amplifier). But there can be real hard
limitations - if you've got a device with only 2 DACs no software
trickery will ever magically convert it into a device with 4 DACs
(additional hardware may, but that's a different topic...)

The gist is, that, while a lot of abstraction is possible, not all device
functions can be completely identical for all devices. Thus, while the
names of the functions remain identical, the arguments the functions are
called with may differ for different devices. But while this can be as
annoying as having different functions for each device, it at least
reduces the amount of differences to be taken into account considerably.



@node Magnet Functions, Gaussmeter Functions, Introduction, Device Functions
@section Magnet functions
@cindex Magnet functions


All the following functions may be used to control the magnetic field of
the magnet. Currently, AEG magnets (X-band and S-band) are
supported. The modules that have to be listed in the @code{DEVICES}
section to load the the functions are
@example
aeg_x_band
aeg_s_band
@end example
Because magnets are hardly ever changed (and if the program is set up
correctly for the experiment) one can use @code{magnet} as the module
name instead.

Since it is not possible to measure the field using just the magnet
power supply it is necessary also to specify a gaussmeter to enable
@acronym{fsc2} to control the magnet. The module name of the gaussmeter
has to appear @b{before} the magnet module entry in the @code{DEVICES}
section. See the next section for the implemented gaussmeters and the
related functions.

If a magnet module is listed in the @code{DEVICES} section the program
will try to calibrate the field sweep parameters at the start of the
experiment, i.e.@: it will sweep the field up and down for some
time. This may take some time. See below on how to reduce this time.


@table @samp
@item magnet_setup()
@findex magnet_setup()
The function can be called to set the start field and the field step
size used in sweeps. The function expects two floating point parameters,
i.e.@: the start field, e.g.@: @w{0.345 T}, and the step size, e.g.@:
@w{0.35 G}. The function can be called before the @code{EXPERIMENT}
section starts.

@item magnet_fast_init()
@findex magnet_fast_init()
Calling this functions in the @code{PREPARATIONS} section will shorten
the time @acronym{fsc2} uses for calibration of the field sweep at the
start of the experiment. Unfortunately, this also reduces the precision
of the field sweep. Whenever an experiment is restarted (i.e.@: if no
new @acronym{EDL} file is loaded in between) this shortened calibration
is done to check that the parameters didn't check significantly since
the last run.


@item set_field()
@findex set_field()
This function expects one floating point argument for the field value
and will set the magnetic field to this value. The function can only be
called in the @code{EXPERIMENT} section.

@item sweep_up()
@findex sweep_up()
The function can be called in the @code{EXPERIMENT} section, but only if
the function @code{magnet_setup()} (see above) has been called
previously. It doesn't take an argument and will sweep up the magnet by
the field step size value set in the @code{magnet_setup()} function.

The precision of the field sweep depends on the step size. While the
precision is usually quite good for step sizes of up to @w{1 G}, for much
larger step sizes it may deteriorate quite significantly. It sometimes
helps to add a short wait period (use function @code{wait()} after a
sweep step) to allow the field to settle at the new point. On the other
hand, it then might be faster (and more reliable) not to use the sweep
function at all but @code{set_field()} instead.

@item sweep_down()
@findex sweep_down()
Analog to @code{sweep_up()} but sweeping the magnetic field down by the
field step size defined in @code{magnet_setup()}. The function can only
be called in the @code{EXPERIMENT} section.

@item reset_field()
@findex reset_field()
This function resets the magnetic field to the start field value defined
in @code{magnet_setup()} (which has to be called before). The function
can only be used in the @code{EXPERIMENT} section.

@end table


@node Gaussmeter Functions, Lock-In Functions, Magnet Functions, Device Functions
@section Gaussmeter functions
@cindex Gaussmeter functions


Currently, two types of gaussmeters are implemented, the Bruker ER035M
NMR gaussmeter and the Bruker BH15 hall probe field controller. The
range of fields that can be measured with the Bruker ER035M NMR
gaussmeter depends on the probe being used. With the F0 probe (S-band)
the range is @w{460 G} to @w{2390 G} while with the F1 probe (X-band) a
range between @w{1460 G} and @w{19900 G} can be measured.  With the BH15
field controller a range between @w{-50 G} and @w{2300 G} can be used.

The modules defining the gaussmeter functions (to be listed in the
@code{DEVICES} section) are:
@example
er035m
er035m_s
er035m_sa
bh15
@end example
The first three modules are for the ER035M NMR gaussmeter, the first one
is to be used when it's controlled via the GPIB bus and the second if it
is connected using the serial port of the computer. The third module,
@code{er035m_sa}, is special in that it doesn't allow field control
(i.e@: it can't be used together with a magnet module) and was only
added to enable calibrations of the BH15 field controller using the
somewhat more precise ER035M NMR gaussmeter. If the program is correctly
installed the appropriate module is loaded by specifying
`@code{gaussmeter}' instead of one of the listed module names.

The gaussmeters are mainly used together with the magnet power supply
and have to be specified in the @code{DEVICES} section @b{before} the
magnet module.

There are only two functions for gaussmeters, both only to be used in
queries and in the @code{EXPERIMENT} section of the @acronym{EDL}
program only.

@table @samp
@item find_field()
@findex find_field()
The function returns the current value of the magnetic field in Gauss.
The function can only be called in the @code{EXPERIMENT} section.

@item field_resolution()
@findex field_resolution()
The function returns the resolution in Gauss used in measurements of the
magnetc field. The function can only be called in the @code{EXPERIMENT}
section.

@end table


@node Lock-In Functions, Digitizer Functions, Gaussmeter Functions, Device Functions
@section Lock-In functions
@cindex Lock-In functions

There are modules for four types of lock-in amplifiers implemented. All
of them are by Stanford Research and have the model names SR510, SR530,
SR810 and SR830. Not too surprisingly, the module names to be specified
in the @code{DEVICES} section are
@example
sr510
sr530
sr810
sr830
@end example

Because the models have different capabilities, some of the functions
are either only defined for parts of the models or may use slightly
different parameters.

Several of the following functions can be called to query settings of
the lock-in amplifier or to set a value. In the first case the function
usually has to be called with no argument, while to set a parameter an
argument has to be passed to the function. Because of these different
modes of calling the functions one should carefully check the arguments
to achieve the desired results.

@table @samp
@item lockin_get_data()
@findex lockin_get_data()
This function only allows queries, i.e.@: to fetch the measured value
from the lock-in amplifier. The parameters, that may be passed to the
function differ according to the model.
@table @samp
@item SR510
No argument is allowed -- the function returns the measured value of the
only channel as a floating point number (i.e.@: in Volts).

@item SR530
If no argument is specified the measured value at channel 1 is
returned. Alternatively, one parameter may be passed to the function
with a value of either @code{1} or @code{2}, in which case the measure
value from channel 1 or 2 is returned. Finally, two arguments can be
given, with values of @code{1} or @code{2}. In this case a 1-dimensional
array with two elements is returned, containing the measured values of
the corresponding channels.

@item SR810
@item SR830
If no argument is specified the measured value at channel 1 is returned.
If one parameter is passed to the function the value at the
corresponding channel is returned. Possible channel numbers and their
meaning are:
@table @samp
@item 1
channel 1
@item 2
channel 2
@item 3
amplitude of data from channel 1 and 2 in polar coordinates
@item 4
phase of data from channel 1 and 2 in polar coordinates
@end table
Finally, up to 4 arguments can be passed to the function with the
values given above. In this case a 1-dimensional array is returned with
as many data as there were arguments (in the sequence corresponding the
one of the arguments).
@end table
The function can only be called in the @code{EXPERIMENT} section.

@item lockin_get_adc_data()
@findex lockin_get_adc_data()
The function returns the voltage at one of the ADC ports numbered at the
back side of the lock-in amplifier. Allowed values of the required
argument are between 1 and 4, corresponding to the port numbering.

The function can only be called in the @code{EXPERIMENT} section.

@item lockin_dac_voltage()
@findex lockin_dac_voltage()
The function can be used to set or query the voltage at one of the DAC
ports at the back side of the the lock-in amplifier. While for the
models SR510 and SR530 the allowed values for the required arguments are
5 or 6, for models SR810 and SR830 the values can range from 1 to 4,
corresponding to the different numbers of DAC ports and their numbering
printed on the back side. If no further argument is given the function
returns the current voltage applied to the DAC port (which is
automatically set to @w{0 V} at the initialization of the lock-in
amplifier if no voltage has been set previous to the @code{EXPERIMENT}
section). If a second argument is given the DAC will be set to the
corresponding voltage. The function returns the voltage that has been
set.

For the models SR510 and SR530 this voltage has to be in the range
between @w{-10.24 V} and @w{+10.24 V} while for the models SR810 and
SR830 the allowed voltage range is @w{-10.V} to @w{+10.5 V}.

Before the @code{EXPERIMENT} section this function can't be called
without an argument, i.e as a query.

@item lockin_sensitivity()
@findex lockin_sensitivity()
This function can be used to query or set the sensitivity setting of the
lock-in amplifier. If no argument is passed to the function the current
sensitivity is returned. For the models SR510 and SR530 a 10 times
higher sensitivity than the maximum adjustable sensitivity of @w{100 nV} is
returned when the @code{EXPAND} button is switched on.

When called with a second argument the corresponding sensitivity is
set. This value has to be positive. If there is no sensitivity fitting
the argument the sensitivity is set to the nearest available sensitivity
setting and a warning is printed. The function will return the
sensitivity that has been set.

For the models SR510 and SR530 a sensitivity 10 times higher than the
maximum sensitivity can be specified, in which case the @code{EXPAND}
button is automatically swiched on.

Before the @code{EXPERIMENT} section this function can't be called
without an argument, i.e. as a query.

@item lockin_time_constant()
@findex lockin_time_constant()
The function queries or sets the time constant of the lock-in
amplifier. If no argument is passed to the function the current time
constant is returned. If there's an argument the time constant is set
accordingly.  The argument has to be positive. If the there is no time
constant setting fitting the argument the available nearest setting is
used and a warning is printed. The function will return the time
constant setting that has been set.

For models SR510 and SR530 also the POST time constant is set to lower
or equal the time constant.

Before the @code{EXPERIMENT} section this function can't be called
as a query, i.e without an argument.

@item lockin_phase()
@findex lockin_phase()
The function queries or sets the phase of the lock-in amplifier. If
called with no argument it will return the current phase setting in the
interval between 0 and 360 degrees. If called with an argument the phase
is set accordingly.

Before the @code{EXPERIMENT} section this function can't be called
without an argument, i.e. as a query.

@item lockin_ref_freq()
@findex lockin_ref_freq()
The function can be used to query the reference frequency and, for the
models SR810 and SR830, to set the reference frequency (both the other
models need an external reference frequency). If called with no argument
the current reference frequency is returned. If called with an argument
(models SR810 and SR830 only) the reference frequency is set. If the
frequency is not within the the admissible range an error message is
printed and the experiment is stopped) - the admissible range depends on
the harmonics setting, see the maual for more details.

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e. without an argument.

@item lockin_ref_level()
@findex lockin_ref_level()
This function can be only used with the models SR810 and SR830. It
queries (if called with no argument) or sets (if called with an
argument) the level of the reference frequency. The allowed levels are
between @w{4 mV} and @w{5 V}, if the argument is not within this range
an error message is printed and the experiment is stopped.

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e. without an argument.

@end table


@node Digitizer Functions, Pulser Functions, Lock-In Functions, Device Functions
@section Digitizer functions
@cindex Digitizer functions

The digitizing oscilloscopes currently implemented are the Thektronix
TDS520, TDS520A, TDS744A and TDS754A. The corresponding module names to
be used in the @code{DEVICES} section are
@example
tds520
tds520a
tds744a
tds754a
@end example

@table @samp
@item digitizer_timebase()
@findex digitizer_timebase()
The function queries (if called with no argument) or sets (if called
with an argument) the time base setting of the oscilloscope. The time
base of the oscilloscope can be only set once before the start of the
@code{EXPERIMENT} section. The admissible range of the time base depends
on the model, please check the manual.

The function can be called in query mode (i.e.@: without an argument)
only if either it has been already called with an argument or in the
@code{EXPERIMENT} section.

@item digitizer_num_averages()
@findex digitizer_num_averages()
The function queries (if called with no argument) or sets (if called
with an argument) the number of averages done by the oscilliscope.  The
function can be used in query mode only in the @code{EXPERIMENT}
section. The argument for the number of averages must be at least 1
(which will switch the oscilloscope into @code{SAMPLE} mode). If the
argument is larger than the maximum number of averages the maximum
number is used instead.

The function can be called in query mode (i.e.@: without an argument)
only if either it has been already called with an argument or in the
@code{EXPERIMENT} section.

@item digitizer_trigger_channel()
@findex digitizer_trigger_channel()
The function queries or sets the channel of the digitizing oscilloscope
to be used as trigger input. Possible arguments or return values are,
depending on the type of the oscilloscope:
@table @samp
@item TDS520
@item TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2} or, alternatively @code{0} or @code{1}
@item @code{AUX1}, @code{AUX2} or @code{LIN} or, alternatively @code{9},
@code{10} or @code{11}
@end itemize
@item TDS744A
@item TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4} or, alternatively
@code{0}, @code{1}, @code{2} or @code{3}
@item @code{AUX} or @code{LIN} or, alternatively, @code{11} or @code{12}
@end itemize
@end table
The function can be called in query mode (i.e.@: without an argument)
only if either it has been already called with an argument or in the
@code{EXPERIMENT} section.

@item digitizer_define_window()
@findex digitizer_define_window()
The function can be used to define a time window to be used in later
calls of the functions to measure an area, an amplituide or to fetch a
curve from the oscilloscope. It needs up to two arguments, the starting
point of the interval (in seconds) and, optionally, the width of the
window (also in sconds). If no width argument is passed to the function
the distance between the cursor pair shown on the oscilloscopes screen
is going to be used.

The allowed arguments of the function depend on the time base setting of
the oscilloscope as well as on the pre-trigger setting and the current
record length. The point in time defined by trigger event corresponds to
an argument of zero for the starting point of the window. Times before
the trigger are negative, times after the trigger are positive. If a
window width is given it has to be positive and the window must fit into
the time interval measured by the oscilloscope. The easiest way to find
valid parameters is to position the two vertical cursors at the borders
of the interval to be measured and directly use the values for the
starting point and width displayed in the upper right hand corner of the
oscilloscope.

Because the data measured by the oscilloscope are discreet it is not
possible to specify arbitrary values for the starting point and the
window width (they must be dividable by 1/50 of the oscilloscopes time
base). If the specified values don't fit the requirement a warning is
printed and the position an width are adjusted to the nearest allowed
value.

The function returns an integer window ID to be used to reference this
window in later funtions calls.

This function can only be used in the @code{PREPARATIONS} section of the
@acronym{EDL} file.

@item digitizer_start_acquisition()
@findex digitizer_start_acquisition()
This function starts an acqusistion sequence of the
oscilloscope. Previously measured curves are discarded and a new data
are sampled until the requested number of averages has been sampled.
The function can only be used in the @code{EXPERIMENT} section of the
@acronym{EDL} file.

@item digitizer_get_area()
@findex digitizer_get_area()
The function returns the area under one of the measured curves. It
expects up to two arguments, the oscilloscopes channel the data are to
be taken from and, optionally, a window ID as returned by
@code{digitizer_define_window()} to specify the time interval the area
is computed from. The channel that can be used depend on the model of
the digitizer:
@table @samp
@item TDS520
@item TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2} or, alternatively @code{0} or @code{1}
@item @code{MATH1}, @code{MATH2} or @code{MATH3} or, alternatively,
@code{2}, @code{3} or @code{4}
@item @code{REF1}, @code{REF2}, @code{REF3}, @code{REF4} or,
alternatively, @code{5}, @code{6}, @code{7} or @code{8}
@item
@end itemize
@item TDS744A
@item TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4} or, alternatively
@code{0}, @code{1}, @code{2} or @code{3}
@item @code{MATH1}, @code{MATH2} or @code{MATH3} or, alternatively,
@code{4}, @code{5} or @code{6} 
@item @code{REF1}, @code{REF2}, @code{REF3}, @code{REF4} or,
alternatively, @code{7}, @code{8}, @code{9}, or @code{10} 
@end itemize
@end table
Except for the model @code{TDS520}, this function positions the cursors
at the start and end point of the specified window (or the first and
last point if no window as been specified) and uses the function
built into the digitizer to compute the area. For the model @code{TDS520}
that misses this built-in function the curve in the interval is fetched
which is than used to compute the area. To give some visual feedback
also for this model the cursors are moved to the borders of the
interval.

The function will automatically wait until a still running acquistition
sequence is finished before measuring the area. 

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} file.


@item digitizer_get_area_fast()
@findex digitizer_get_area_fast()
This function takes exactly the same arguments as the function
@code{digitizer_get_area()} and also basically does the same. The only
difference is that instead of using the function built into the
digitizer to compute the area the curve in the specified interval is
fetched and the area is computed from these data. This function can be a
bit faster because it doesn't set the cursors (which also means that
there is no visual feedback).

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} file.

@item digitizer_get_curve()
@findex digitizer_get_curve()
The function fetches a curve from the digitizer. It expects up to two
arguments, the channel the data are to be fetched from and, optionally,
a window ID as returned by @code{digitizer_define_window()} to specify
the time interval. Valid choices of the data channel depend on the model
of the digitizer:
@table @samp
@item TDS520
@item TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2} or, alternatively @code{0} or @code{1}
@item @code{MATH1}, @code{MATH2} or @code{MATH3} or, alternatively,
@code{2}, @code{3} or @code{4}
@item @code{REF1}, @code{REF2}, @code{REF3}, @code{REF4} or,
alternatively, @code{5}, @code{6}, @code{7} or @code{8}
@item
@end itemize
@item TDS744A
@item TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or, alternatively @code{0},
@code{1}, @code{2} or @code{3}
or @code{CH4}
@item @code{MATH1}, @code{MATH2} or @code{MATH3} or, alternatively,
@code{4}, @code{5} or @code{6} 
@item @code{REF1}, @code{REF2}, @code{REF3}, @code{REF4} or,
alternatively, @code{7}, @code{8}, @code{9}, or @code{10}
@end itemize
@end table

The function positions the cursors at the start and end point of the
specified window (or the first and last point if no window as been
specified) to give a visual feedback.

The function will automatically wait until a still running acquistition
sequence is finished before returning a curve. The data will be returned
as an array of floating point numbers and it's the users responsibility
to supply an array for storing the data. Usually, this will we an array
with an unspecified number of elements.

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} file.

@item digitizer_get_curve_fast()
@findex digitizer_get_curve_fast()
This function is nearly identical to the function
@code{digitizer_get_curve()} with the only difference that the cursors
are not positioned at the start and end point of the curve to be fetched.

@item digitizer_get_amplitude()
@findex digitizer_get_amplitude()
The function returns the amplitude, i.e.@: the difference between the
maximum and minimum voltage, from the digitizer. The function takes up
to two parameters, the channel the data are to be fetched from and, optionally,
a window ID as returned by @code{digitizer_define_window()} to specify
the time interval. Valid choices of the data channel depend on the model
of the digitizer:
@table @samp
@item TDS520
@item TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2} or, alternatively @code{0} or @code{1}
@item @code{MATH1}, @code{MATH2} or @code{MATH3} or, alternatively,
@code{2}, @code{3} or @code{4}
@item @code{REF1}, @code{REF2}, @code{REF3}, @code{REF4} or,
alternatively, @code{5}, @code{6}, @code{7} or @code{8}
@item
@end itemize
@item TDS744A
@item TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or, alternatively @code{0},
@code{1}, @code{2} or @code{3}
or @code{CH4}
@item @code{MATH1}, @code{MATH2} or @code{MATH3} or, alternatively,
@code{4}, @code{5} or @code{6} 
@item @code{REF1}, @code{REF2}, @code{REF3}, @code{REF4} or,
alternatively, @code{7}, @code{8}, @code{9}, or @code{10}
@end itemize
@end table
Except for the model @code{TDS520}, this function positions the cursors
at the start and end point of the specified window (or the first and
last point if no window as been specified) and uses the function built
into the digitizer to compute the amplitude. For the model @code{TDS520}
that misses this built-in function the curve in the interval is fetched
which is than used to compute the amplitude. To give some visual
feedback also for this model the cursors are moved to the borders of the
interval.

The function will automatically wait until a still running acquistition
sequence is finished before measuring the amplitude.

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} file.

@item digitizer_get_amplitude_fast()
@findex digitizer_get_amplitude_fast()
This function is nearly identivcal to @code{digitizer_get_amplitude()}
except that the function to compute amplitudes built into the digitizer
isn't used and the cursors aren't positioned at the start and end of the
time interval.

@end table


@node Pulser Functions, Synthesizer Functions, Digitizer Functions, Device Functions
@section Pulser functions
@cindex Pulser functions

@table @samp

@item pulser_update()
@findex pulser_update()

@item pulser_shift()
@findex pulser_shift()

@item pulser_increment()
@findex pulser_increment()

@item pulser_pulse_reset()
@findex pulser_pulse_reset()

@item pulser_next_phase()
@findex pulser_next_phase()

@item pulser_phase_reset()
@findex pulser_phase_reset()

@end table



@node Synthesizer Functions, , Pulser Functions, Device Functions
@section Synthesizer functions
@cindex Synthesizer functions


@table @samp

@item synthesizer_state()
@findex synthesizer_state()

@item synthesizer_frequency()
@findex synthesizer_frequency()

@item synthesizer_attenuation()
@findex synthesizer_attenuation()

@item synthesizer_step_frequency()
@findex synthesizer_step_frequency()

@item synthesizer_sweep_up()
@findex synthesizer_sweep_up()

@item synthesizer_sweep_down()
@findex synthesizer_sweep_down()

@item synthesizer_reset_frequency()
@findex synthesizer_reset_frequency()

@item synthesizer_use_table()
@findex synthesizer_use_table()

@item synthesizer_att_ref_freq()
@findex synthesizer_att_ref_freq()

@item synthesizer_modulation()
@findex synthesizer_modulation()

@item synthesizer_mod_type()
@findex synthesizer_mod_type()

@item synthesizer_mod_source()
@findex synthesizer_mod_source()

@item synthesizer_mod_ampl()
@findex synthesizer_mod_ampl()

@end table
