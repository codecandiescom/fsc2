@c $Id$
@c
@c Copyright (C) 2001 Jens Thoms Toerring
@c
@c This file is part of fsc2.
@c
@c Fsc2 is free software; you can redistribute it and/or modify
@c it under the terms of the GNU General Public License as published by
@c the Free Software Foundation; either version 2, or (at your option)
@c any later version.
@c
@c Fsc2 is distributed in the hope that it will be useful,
@c but WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with fsc2; see the file COPYING.  If not, write to
@c the Free Software Foundation, 59 Temple Place - Suite 330,
@c Boston, MA 02111-1307, USA.


@node Device Functions, Using Pulsers, Built-in Functions, Top
@chapter Device Functions

@ifinfo
@menu
* Introduction::            
* Magnet Functions::        Functions for controlling the magnet.
* Gaussmeter Functions::    Functions for measuring the magnetic field.
* Lock-In Functions::       Functions for accessing the lock-in amplifiers.
* Digitizer Functions::     Functions for accessing the oscilloscopes.
* Pulser Functions::
* Synthesizer Functions::
* Temperature Controller Functions::
* Multi-Device Functions::
@end menu
@end ifinfo


@node Introduction, Magnet Functions, Device Functions, Device Functions
@section Introduction


The most simple approach would be to have a set of functions for each
individual device, i.e.@: to have a different function for e.g.@:
fetching data from each of a series of different digitizing
oscilloscopes.  But this would be a nuisance for someone writing
@acronym{EDL} programs because whenever for example the oscilloscope has
to be changed also all the programs would have to be adjusted to reflect
the names of the functions for the new digitizer.

Thus it's reasonable to have generic functions for similar devices
that usually have a lot in common. It's not only much more convenient
to write
@example
new_data = digitizer_get_curve( CH1 );    // get curve from channel 1
@end example
@noindent
instead of
@example
new_data = tds754a_get_curve( 1 );        // get curve from channel 1
@end example
@noindent
but one doesn't has to change dozens of references to the TDS754A
oscilloscope in each and every @acronym{EDL} program when someone else
needs just this oscilloscope for a few days and one has to do with the
TDS520 oscilloscope in between.

Of course, using generic functions has its limitations - if e.g.@: the
new lock-in amplifier has only one channel while the previously used one
had two no abstraction will make the new lock-in it have two
channels. This means that, while a lot of abstraction is possible, not
all device functions can be completely identical for all devices of the
same type. Thus, while the names of the functions remain identical, the
arguments the functions are called with may differ sometimes for
different devices. But while this can be annoyingly enough it at least
reduces the amount of changes to be done to the @acronym{EDL} program
considerably.

But what if you need to use for example two lock-in amplifiers
simultaneously? When the names of the functions for accessing both the
lock-ins are identical how does one specify which one to use for a
command? Actually, it's quite simple. In the @code{DEVICES} section the
two lock-in amplifiers will be listed:
@example
sr510;         // first lock-in amplifier
sr830;         // second lock-in amplifier
@end example
@noindent
If now data from the first lock-in amplifier are needed one simply uses
the normal way to get data, i.e.@: the usual function name:
@example
data_from_1st_lockin = lockin_get_data( );
@end example
@noindent
But to get data from the second only the string @code{"#2"} needs to
be appended to the function name:
@example
data_from_2nd_lockin = lockin_get_data#2( );
@end example
@noindent
and @code{fsc2} will automatically know that now the second of the
lock-in amplifiers from the list of devices is meant.

Of course, if there are three lock-ins listed in the DEVICE section for
the third one would have to append @code{"#3"} to the function name
etc. (One could also append the string @code{"#1"} to the name of the
function for the first lock-in amplifier, but that's optional.)


In situations where only the module of the second of two similar devices
defines a function (e.g.@: because the first device doesn't has the
necessary capabilities) the function can be used without and with
appending the @code{"#2"} to the function name. To remind about this
a short message is printed.


The only situation that still is a bit more problematical are cases
where two identical devices are to be used simultaneously. Due to
limitations not only of @acronym{fsc2} but also to the way the libraries
used for accessing the GPIB bus works you can't simply list the same
device twice in the @code{DEVICES} section and then use these as
outlines above. Instead, two device modules with different names have to
be created for the identical devices and made known to the program.
Fortunately, there's a Perl script that will automatically deal with
this problem, please see one of the later chapters (@pxref{Cloning
Devices})


@node Magnet Functions, Gaussmeter Functions, Introduction, Device Functions
@section Magnet Functions
@cindex Magnet Functions


All the following functions may be used to control the magnetic field of
the magnet. Currently, @strong{AEG} magnets (X-band and S-band) and the
Bruker @strong{ER032M Field Controller} are supported. The modules that
have to be listed in the @code{DEVICES} section to load the functions
are
@example
aeg_x_band
aeg_s_band
er032m
keithley228a
@end example
@noindent
Because magnets hardly ever get changed (and if the program is set up
correctly for the experiment) one can use @code{magnet} as the module
name instead after a proper installation of the program.

Since it is not possible for the @strong{AEG} magnets to measure the
field using just the magnet power supply it is necessary also to specify
a gaussmeter to enable @acronym{fsc2} to control the magnet. The module
name of the gaussmeter has to appear @b{before} the magnet module entry
in the @code{DEVICES} section. See the next section for the implemented
gaussmeter and the related functions.

If a @strong{AEG} magnet module is listed in the @code{DEVICES} section
the program will try to calibrate the field sweep parameters at the
start of the experiment, i.e.@: it will sweep the field up and down for
some time, please be patient. See below on how to reduce the amount of
time spent with field calibration.

The Keithley 228A power supply is used for the sweep coil of Berlin
W-band magnet. Because there is no well-defined relationship between the
current produced by the power supply and the total magnetic field and
because the magnetic field can't be measured directly during
measurements for this device the following functions expect arguments in
current units (i.e. Ampere) instead of field units (i.e. Gauss) as the
other devices.

Because the nomal current resolution of the Keithley power supply is not
sufficient an additional device is needed supplying DC voltages in the
range between @w{-10 V} and @w{+10 V} to the modulation input of the
power supply. Currently the DAC ports of one of the Stanford Research
lock-in amplfiers (SR510, SR530, SR810 or SR830)) are used for this
purpose. Which of the lock-ins is used can be specified during
compilation by a corresponding entry in the configuration file for the
Keithley driver, usually the @code{SR510} lock-in amplifier. Alternatively,
if no lock-in has been set in the configuration file the
@code{keithley228a} module will assume that the first lock-in listed in
the devices section is to be used.

In the configuration file it also can be defined which of the DAC ports
of the lock-in ampliers is to be used. If not defined, port 6 will be
used for the SR510 and SR530 and port 4 for the SR810 and SR830 lock-in
amplifier. But there exists also a function to directly select the DAC
port to be used, see below.


@table @samp
@item magnet_name()
@findex magnet_name()
Returns a string with the name of the magnet that is being used.


@item magnet_setup()
@findex magnet_setup()
The function can be called to set the start field and the field step
size used in sweeps. The function expects two floating point parameters,
the start field, e.g.@: @w{0.345 T}, and the step size, e.g.@: @w{0.35
G}. Use curent instead of field units for the Keithley 228A powre supply
@code{keithley228a}. The function can only be called before the
@code{EXPERIMENT} section starts.

@item magnet_fast_init()
@findex magnet_fast_init()
Calling this functions in the @code{PREPARATIONS} section will shorten
the time used for the calibration of the field sweep at the start of the
experiment for the @strong{AEG} magnet power supplies. Unfortunately,
this also reduces the precision of the field sweep. Whenever an
experiment is restarted (i.e.@: if no new @acronym{EDL} file has been
loaded in between) this shortened calibration is done anyways to check
that the parameters didn't change significantly since the last run.


@item set_field()
@findex set_field()
This function expects one floating point argument for the field value
and will set the magnetic field to this value. For the Keithley power
supply @code{keithley228a} specify a current value. 

For the @strong{AEG} magnets the function also accepts a second optional
parameter, the maximum acceptable deviation of the field from the value
to be set. For example by the call
@example
set_field( 3421.5 G, 0.2 G );
@end example
@noindent
the field will be set to a value between @w{3421.3 G} and @w{3421.7 G}.

If in the case of @strong{AEG} magnets this second parameter is missing
the precision of the gaussmeter used for measuring the field is used. If
the maximum deviation parameter is smaller than the precision of the
gaussmeter the precision of the gaussmeter is used instead. The function
can only be called in the @code{EXPERIMENT} section.


@item sweep_up()
@findex sweep_up()
The function can be called in the @code{EXPERIMENT} section, but only if
the function @code{magnet_setup()} (see above) has been called
before. It doesn't take an argument and will sweep up the magnet by the
field step size value set in the @code{magnet_setup()} function.  The
actual size of the step will @b{not} be controlled using the gaussmeter.

For the @strong{AEG} magnets the precision of the field sweep depends on
the step size. While the precision is usually quite good for step sizes
of up to @w{1 G}, for much larger step sizes it may deteriorate quite
significantly. It sometimes helps to add a short waiting time (use
function @code{wait()}) after a sweep step to allow the field to settle
at the new point. On the other hand, it then might be faster (and more
reliable) not to use the sweep function at all but @code{set_field()}
instead.

@item sweep_down()
@findex sweep_down()
This is the exact analog to the function @code{sweep_up()} but will
sweep the magnetic field down instead of up by the field step size
defined in @code{magnet_setup()}. The function can only be called in the
@code{EXPERIMENT} section.


@item reset_field()
@findex reset_field()
This function resets the magnetic field to the start field value defined
in @code{magnet_setup()} (which has to be called before). The function
can only be used in the @code{EXPERIMENT} section.

@item get_field()
@findex get_field()
For the @strong{AEG} magnets this is only a convenience function that
just calls a function supplied by the gaussmeter used together with the
magnet power supply to determine the current field. In contrast, for the
@strong{ER032M Field Controller} this function returns the current field
setting in Gauss. The function can only be used in the @code{EXPERIMENT}
section.

@item magnet_use_correction()
@findex magnet_use_correction()
This function is only defined for the Keithley power supply and accepts
no arguments. If it is called corrections are applied to reduce
the effects of certain inaccuracies of the power supply.


@item magnet_use_dac_port()
@findex magnet_use_dac_port()
This function is only defined for the Keithley power supply and tells
the driver which of the DAC ports of the lock-in amplifier is connected
(following a voltage divider) to the modulation input of the power
supply. The function expects a single integer value, the DAC port number
to be used -- for the SR510 and SR530 this can be @code{5} or @code{6},
while for the SR810 and SR830 all values in the range between @code{1}
and @code{4} may be used.


@end table


@node Gaussmeter Functions, Lock-In Functions, Magnet Functions, Device Functions
@section Gaussmeter Functions
@cindex Gaussmeter Functions


Currently, three types of gaussmeters are implemented, the Bruker ER035M
NMR gaussmeter, the Bruker BH15 hall probe field controller and the
Metrolab PT2025 NMR gaussmeter. The range of fields that can be measured
with the Bruker ER035M NMR gaussmeter depends on the probe being
used. With the F0 probe (S-band) the range is @w{460 G} to @w{2390 G}
while with the F1 probe (X-band) a range between @w{1460 G} and @w{19900
G} can be measured.  With the BH15 field controller a range between
@w{-50 G} and @w{2300 G} can be used. Finally, for the Metrolab PT2025
it is currently assumed that a probe for the field range between @w{1.5
T} and @w{3.4 T} (W-band) is used.

The modules defining the gaussmeter functions (to be listed in the
@code{DEVICES} section) are:
@example
er035m
er035m_s
bh15
er035m_sa
er035m_sas
pt2025
@end example
@noindent
The modules with names starting with @code{er035m} are for the Bruker
ER035M NMR gaussmeter. @code{er035m} and @code{er035m_sa} are to be used
when the device is controlled via the GPIB bus while @code{er035m_s} and
@code{er035m_sas} expect the device to b connected to a serial port of
the computer. The @code{bh15} module is for the Hall controller used in
some setups. The last module, @code{pt2025}, is for the Metrolab NMR
gaussmeter from the Berlin W-Band spectrometer.

The first three gaussmeter modules, @code{er035m}, @code{er035m_s} and
@code{bh15}, are only to be used for controlling the sweep of a magnet
power supply. Thus only one of these gaussmeter drivers can be loaded,
if other gaussmeters are also used, it must be the first in the
@code{DEVICES} ection and must be specified @b{before} the magnet
module (see above) which relies on its existence,

In contrast, the three other modules, @code{er035m_sa},
@code{er035m_sas} and @code{pt2025}, are only to be used for field
measurements but not for direct field control.


@table @samp
@item gaussmeter_name()
@findex gaussmeter_name()
Returns a string with the name of the gaussmeter being used.


@item find_field()
@findex find_field()
This function is defined in the device modules @code{er035m} and
@code{er035m_s}. It returns the current value of the magnetic field in
Gauss.  The function can only be called in the @code{EXPERIMENT}
section.


@item gaussmeter_resolution()
@findex gaussmeter_resolution()
This function is defined in the device drivers for the Bruker NMR
gaussmeters (@code{er035m}, @code{er035m_s}, @code{er035m_sa} and
@code{er035m_sas}) and for the Metrolab NMR gaussmeter, @code{pt2025}.
It can be used to set or query the resolution in Gauss used in
measurements of the magnetic field.

To set a resolution the values @code{0.1 G}, @code{0.01 G} and
@code{0.001 G} can be used for the Bruker NMR gaussmeter, while for the
Metrolab Gaussmeter only @code{0.01 G} and @code{0.001 G} are usuable.

Please note that for the modules @code{er035m} and @code{er035m_s},
i.e.@: the modules for direct field control, the resolution will be
increased automatically from @code{0.1 G} to @code{0.01 G} at the
initialization (i.e.@: at the very start of the experiment) unless 
the low resolution has been set explicitely during the
@code{PREPARATIONS} section.


@item measure_field()
@findex measure_field()
This function is defined in the device drivers @code{er035m_sa},
@code{er035m_sas} and @code{pt2025}. It measures the current field and
returns the value in Gauss. The function can only be called in the
@code{EXPERIMENT} section.

@item gaussmeter_probe_orientation()
@findex gaussmeter_probe_orientation()
This function is currently implemented for the Metrolab NMR gausmeter
@code{pt2025} only. It allows to set or query the current probe
orientation relative to the field. To set an orientation a parameter of
@code{1} or @code{"+"} can be used to define an orientation parallel to
the field and an argument of @code{0} or @code{"-"} for the antiparallel
direction. On queries the function returns either @code{1} or @code{0}.
The function can only be called in the @code{EXPERIMENT} section for
queries.

@end table


@node Lock-In Functions, Digitizer Functions, Gaussmeter Functions, Device Functions
@section Lock-In Functions
@cindex Lock-In Functions

Modules for five different lock-in amplifiers are implemented. Most are
by Stanford Research and have the model names @strong{SR510},
@strong{SR530}, @strong{SR810} and @strong{SR830}. The fifth is the
@strong{ER023M Signal Channel} used in Bruker spectrometers of the ESP
series. The module names to be specified in the @code{DEVICES} section
are
@example
sr510
sr530
sr810
sr830
er023m
@end example
@noindent
Because the models have different capabilities, some of the functions
are either only defined for parts of the models or may expect slightly
different parameters.

Several of the following functions can be called both to query the
current settings of the lock-in amplifier and to set a new value. In the
first case the function usually has to be called with no argument, while
to set a parameter an argument has to be passed to the function. Because
of these different modes of calling the functions one should carefully
check the arguments to achieve the desired results.


@table @samp
@item lockin_name()
@findex lockin_name()
Returns a string with the name of the lock-in amplifier being used.


@item lockin_get_data()
@findex lockin_get_data()
This is a function only to be used in queries, i.e.@: to fetch measured
values from the lock-in amplifier. This function can only be called in
the @code{EXPERIMENT} section. The parameters that may be passed to the
function differ according to the model:
@table @samp
@item SR510
No argument is allowed -- the function returns the measured value of the
only channel as a floating point number (i.e.@: in Volts).

@item SR530
If no argument is specified the measured value at channel @code{1} is
returned. Alternatively, one parameter may be passed to the function
with a value of either @code{1} or @code{2}, in which case the measure
value from channel @code{1} or @code{2} is returned. Finally, two
arguments can be given, with values of @code{1} or @code{2}. In this
case a 1-dimensional array with two elements is returned, containing the
measured values of the corresponding channels.

@item SR810
@itemx SR830
If no argument is specified the measured value at channel 1 is returned.
If one parameter is passed to the function the value at the
corresponding channel is returned. Possible channel numbers and their
meaning are:
@table @samp
@item 1
Channel @code{1}
@item 2
Channel @code{2}
@item 3
Amplitude of data from channel @code{1} and @code{2} in polar coordinates
@item 4
Phase of data from channel @code{1} and @code{2} in polar coordinates
@item 5
Voltage at rear panel auxiliary ADC input 1
@item 6
Voltage at rear panel auxiliary ADC input 2
@item 7
Voltage at rear panel auxiliary ADC input 3
@item 8
Voltage at rear panel auxiliary ADC input 4
@item 9
X noise data - this is only allowed when the lock-in-amplifier is
running in auto-acquisition mode (see below) and the CH1 display is set
to display X noise.
@item 10
Y noise data - this is only allowed when the lock-in-amplifier is
running in auto-acquisition mode (see below) and the CH2 display is set
to display Y noise.
@end table
Of these values up to 6 can be passed to the function. If there is more
than one argument a 1-dimensional array is returned with as many data as
there were arguments (in the sequence corresponding to the one of the
arguments).

@item ER023M
No argument is allowed -- the function returns a floating point value.
@end table



@item lockin_get_adc_data()
@findex lockin_get_adc_data()
The function returns the voltage at one of the ADC ports at the back
side of the lock-in amplifier. Allowed values of the required argument
are between @code{1} and @code{4}, corresponding to the port numbering.

This function can only be used with the @strong{Stanford Research}
lock-in amplifiers and can only be called in the @code{EXPERIMENT} section.


@item lockin_dac_voltage()
@findex lockin_dac_voltage()
The function can be used to set or query the voltage at one of the DAC
ports at the back side of the @strong{Stanford Research} lock-in
amplifier. While for the models @strong{SR510} and @strong{SR530} the
allowed values for the required arguments are @code{5} or @code{6}, for
the models @strong{SR810} and @strong{SR830} the values can range from
@code{1} to @code{4}, corresponding to the different numbers of DAC
ports and their numbering printed on the back side. If no further
argument is given the function returns the current voltage applied to
the DAC port (which is automatically set to @w{0 V} at the
initialization of the lock-in amplifier if no voltage has been set
previously in the @code{PREPARATIONS} section using this function). If a
second argument is given the DAC will be set to the corresponding
voltage. The function returns the voltage that has been set.

For the models @strong{SR510} and @strong{SR530} this voltage has to be
in the range between @w{-10.24 V} and @w{+10.24 V} while for the models
@strong{SR810} and @strong{SR830} the allowed voltage range is
@w{-10.5V} to @w{+10.5 V}.

This function can only be used with the @strong{Stanford Research}
lock-in amplifiers. 

In the @code{PREPARATIONS} section this function can only be called
with two argument, i.e@: to set the output voltage of one of the DACs
to be used in the initialization of the device.


@item lockin_sensitivity()
@findex lockin_sensitivity()
This function can be used to query or set the sensitivity of the lock-in
amplifier. If no argument is passed to the function the current
sensitivity is returned. For the models @strong{SR510} and
@strong{SR530} a 10 times higher sensitivity than the sensitivity set on
the front panel is returned when the @code{EXPAND} button is switched
on.

When called with a second argument the corresponding sensitivity is
set. This value has to be positive. If the argument does not coincide
with one of the possible sensitivity settings the sensitivity is set to
the nearest available sensitivity setting and a warning is printed. The
function will return the sensitivity that has been set.

For the models @strong{SR510} and @strong{SR530} a sensitivity 10 times
higher than the maximum sensitivity can be specified, in which case the
@code{EXPAND} button is automatically switched on.

For the @strong{ER023M Signal Channel} the function does not set the
sensitivity in units of the output voltage but sets the receiver
gain. Valid receiver gains are in the range between @code{2.0E+1} and
@code{1.0E+7} and in increments of @code{2 dB}. Thus in this range the
following multiplier steps can be used: @code{1.0}, @code{1.25},
@code{1.5}, @code{2.0}, @code{2.5}, @code{3.0}, @code{4.0}, @code{5.0},
@code{6.0} and @code{8.0}.

In the @code{PREPARATION} section this function can't be called in query
mode, i.e.@: without an argument.


@item lockin_time_constant()
@findex lockin_time_constant()
The function queries or sets the time constant of the lock-in
amplifier. If no argument is passed to the function the current time
constant is returned. If there's an argument the time constant is set
accordingly.  The argument has to be positive. If there is no time
constant setting fitting the argument the nearest available setting is
used and a warning is printed. The function will return the time
constant setting that has been set.

For models @strong{SR510} and @strong{SR530} also the POST time constant
is set to a value equal or lower than the time constant.

For the @strong{ER023M} the following (approximate) time constant
settings can be used: @code{2.5 ms}, @code{5 ms}, @code{10 ms}, @code{20
ms}, @code{40 ms}, @code{65 ms}, @code{130 ms}, @code{330 ms}, @code{650
ms}, @code{1.3 s}, @code{2.6 s} and @code{5.2 s}.

In the @code{PREPARATIONS} section this function can't be called as a
query, i.e.@: without an argument.


@item lockin_phase()
@findex lockin_phase()
The function queries or sets the phase of the lock-in amplifier. If
called with no argument it will return the current phase setting in the
interval between 0 and 360 degrees. If called with an argument the phase
is set accordingly.

In the @code{PREPARATIONS} section this function can't be called without
an argument, i.e.@: as a query.


@item lockin_ref_freq()
@findex lockin_ref_freq()
The function can be used to query the modulation frequency and, for the
@strong{SR810}, @strong{SR830} and @strong{ER023M} to set the modulation
frequency (both the other models need an external modulation). If called
with no argument the current modulation frequency is returned. If called
with an argument the modulation frequency is set.

If for the @strong{SR810} and @strong{SR830} the frequency is not within
the admissible range an error message is printed and the experiment is
stopped. The admissible range depends on the harmonics setting, see
the manuals for full details.

For the @strong{ER023M} only certain modulation frequencies can be set,
these are @code{100 kHz}, @code{50 kHz}, @code{25 kHz}, @code{12.5 kHz},
@code{6.25 kHz} and @code{3.125 kHz}. If a modulation frequency is
specified that does not fit one of these values the nearest valid
frequency is used.

In the @code{PREPARATIONS} section this function can't be called in
query mode, i.e.@: without an argument.


@item lockin_ref_level()
@findex lockin_ref_level()
This function can be only used with the models @strong{SR810},
@strong{SR830} and the @strong{ER023M}. It queries (if called with no
argument) or sets (if called with an argument) the level of the
modulation frequency. For the @strong{Stanford} lock-in amplifiers the
allowed levels are between @w{4 mV} and @w{5 V}, if the argument is not
within this range an error message is printed and the experiment is
stopped. For the @strong{Bruker ER023M} signal channel the range is (as
long as no calibration has been done) between @w{10 mG} and @w{100 G}
(but don't expect the values to have any real meaning without a
calibration).

In the @code{PREPARATIONS} section this function can't be called in query
mode, i.e.@: without an argument.


@item lockin_lock_keyboard()
@findex lockin_lock_keyboard()
Usually, during an experiment the keyboard of the lock-in amplifier is
locked. But for situations where it would be useful to be able to control
the lock-in also via its keyboard it can be unlocked (and also re-locked)
from within the program. To unlock the keyboard call this function with
an argument of @code{0} or @code{"OFF"}, to re-lock the keyboard call it
again with a non-zero argument, @code{"ON"} or no argument at all.

This function can only be used with the @strong{Stanford Research}
lock-in amplifiers.


@item lockin_conversion_time()
@findex lockin_conversion_time()
This function exists for the @strong{Bruker ER023M} signal channel only
and either queries or sets the time that the built-in ADC takes to
convert a voltage into a binary data value. The voltage resolution is
higher for longer conversion times. Possible conversion times are
integer multiples of @w{320 us} in the range between 10 and 9999, thus
allowing conversion times between @code{3.2 ms} and ca.@: @code{3.2 s}.

Unfortunately, according to my tests, for conversion times between @w{40
ms} and @w{64 ms} the data the signal channels sends for large signal
amplitudes are garbled. For this reason the function will not accept
conversion times in this range but will instead set the nearest
conversion time for which correct data are delivered.

If no argument is supplied to the function the current conversion time
is returned. If there is an argument this is used as the new conversion
time. If the argument is not an integer multiple of @w{320 us} (within
the possible range) the nearest allowed conversion time is used.

In the @code{PREPARATIONS} section this function can't be called without
an argument, i.e.@: as a query.


@item lockin_resonator()
@findex lockin_resonator()
This function exists for the @strong{Bruker ER023M} signal channel only
and queries or returns the selected resonator. If called without an
argument it returns either @code{1} or @code{2} for the first or second
resonator. It accepts the same values as arguments to select a resonator.

In the @code{PREPARATIONS} section this function can't be called without
an argument, i.e.@: as a query.


@item lockin_is_overload()
@findex lockin_is_overload()
This function exists for the @strong{Bruker ER023M} signal channel only
and can only be used as a query, i.e.@: it does not allows arguments. It
can be called before a new data value is fetched from the lock-in to
find out if an overload has occurred while the data value was measured
(where a return value of @code{1} indicates that an overload happened,
otherwise @code{0} is returned). Calling this function (or fetching the
data value) will reset the overload condition and calls of the function
will return @code{0} as long as no further overloads occur.

The function can only be used in the @code{EXPERIMENT} section.

@end table


@node Digitizer Functions, Pulser Functions, Lock-In Functions, Device Functions
@section Digitizer Functions
@cindex Digitizer Functions

The digitizing oscilloscopes currently implemented are the Tektronix
TDS520, TDS520A, TDS540, TDS744A and TDS754A. The corresponding module
names to be used in the @code{DEVICES} section are
@example
tds520
tds520a
tds540
tds744a
tds754a
@end example

When a digitizer channel or trigger input is used as an argument in
calls of one of the following functions the symbolic channel names can
be replaced by integer numbers:
@table @samp
@item CH1
@code{0} - First digitizer channel (all models)
@item CH2
@code{1} - Second digitizer channel (all models)
@item CH3
@code{2} - Third digitizer channel (Tektronix TDS540, TDS744A, TDS754A)
@item CH4
@code{3} - Fourth digitizer channel (Tektronix TDS540, TDS744A, TDS754A)
@item MATH1
@code{4} - First mathematic function channel (all Tektronix digitizers)
@item MATH2
@code{5} - Second mathematic function channel (all Tektronix digitizers)
@item MATH3
@code{6} - Third mathematic function channel (all Tektronix digitizers)
@item REF1
@code{7} - First reference channel (all Tektronix digitizers)
@item REF2
@code{8} - Second reference channel (all Tektronix digitizers)
@item REF3
@code{9} - Third reference channel (all Tektronix digitizers)
@item REF4
@code{10} - Fourth reference channel (all Tektronix digitizers)
@item AUX
@code{11} - Auxiliary channel (Tektronix TDS540, TDS744A, TDS754A)
@item AUX1
@code{12} - First auxiliary channel (Tektronix TDS520, TDS520A, TDS520C)
@item AUX2
@code{13} - Second auxiliary channel (Tektronix TDS520, TDS520A, TDS520C)
@item LINE
@code{14} - Line In for trigger (all models)
@item MEM_C
@code{15} - First memory channel (LeCroy 9400)
@item MEM_D
@code{16} - Second memory channel (LeCroy 9400)
@item FUNC_E
@code{17} - First function (averaging) channel (LeCroy 9400)
@item FUNC_F
@code{18} - second function (averaging) channel (LeCroy 9400)
@item EXT
@code{19} - External trigger input (LeCroy 9400)
@item EXT10
@code{20} - External amplified trigger input (LeCroy 9400)
@end table


@table @samp
@item digitizer_name()
@findex digitizer_name()
Returns a string with the name of the digitizer being used.


@item digitizer_timebase()
@findex digitizer_timebase()
The function queries (if called with no argument) or sets (if called
with an argument) the time base setting of the oscilloscope. The time
base of the oscilloscope can be only set once before the start of the
@code{EXPERIMENT} section. The admissible range of the time base depends
on the model, please check the manual.

The function can be called in query mode (i.e.@: without an argument)
in the @code{EXPERIMENT} section only.


@item digitizer_time_per_point()
@findex digitizer_time_per_point()
Function returns (to be called in the @code{EXPERIMENT} section only)
the time difference (in seconds) between two points measured by the
digitizer.


@item digitizer_sensitivity()
@findex digitizer_sensitivity()
The function queries (if called with just one argument) or sets (if
called with two arguments) the sensitivity setting of on of the channels
of the oscilloscope. It needs at least on argument, the channel, either
symbolically or numerically. The channels that can be used as arguments
depend on the model of the oscilloscope:
@table @samp
@item TDS520
@itemx TDS520A
@itemx LECROY9400
@code{CH1} or @code{CH2}
@item TDS540
@itemx TDS744A
@itemx TDS754A
@code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@end table

If a second argument is given this is taken to be the new sensitivity
setting in Volts. If the sensitivity value passed to the function is not
one of the available settings the nearest allowed value is used
instead. Please note that for some of the oscilloscopes the range of
admissible sensitivity settings depends on the input impedance --
unfortunately this can only be checked for when the experiment has
already been started!

If no second argument is given the current sensitivity setting for the
channel is returned.

The function can be called in query mode (i.e.@: without a second
argument) only in the @code{EXPERIMENT} section.


@item digitizer_num_averages()
@findex digitizer_num_averages()
This function is intended for the @strong{Tektronix} digitizers, see at
the end on how to use it with the @strong{LeCroy 9400}. It queries (if
called with no argument) or sets (if called with an argument) the number
of averages done by the oscilloscope.  If the number of averages is
passed to the function it must be at least 1 (which will switch the
oscilloscope into @code{SAMPLE} mode). If the argument is larger than
the maximum number of averages the maximum available number of averages
is used instead.

The function can be called in query mode (i.e.@: without an argument)
only in the @code{EXPERIMENT} section.

For the @strong{LeCroy 9400} this function can only be used in query
mode and returns the number of averages that has been set in a previous
call of @code{digitizer_averaging()}. It needs exactly one argument, the
number of channel used to do the averaging, i.e.@: either @code{FUNC_E}
or @code{FUNC_F}.


@item digitizer_averaging()
@findex digitizer_averaging()
This function only exists for the @strong{LeCroy 9400} and must be used to
set up averaging. It expects at least three arguments. The first
argument is the channel to be used to do the averaging, i.e.@: either
@code{FUNC_E} or @code{FUNC_F}. The second is the data source channel
for the curves to be averaged, i.e.@: either @code{CH1} or
@code{CH2}. The third required argument is the number of averages which
as to be either @code{10}, @code{20} or @code{50} or one of these
numbers multiplied by @code{10}, @code{100}, @code{1000}, @code{10000}
(the maximum possible number of averages that can be done is
@code{1000000}). The next, optional argument is either an integer
number, with a non-zero value representing truth and @code{0} falsehood,
or a string, either @code{"ON"} or @code{"OFF"}, that determines if
overflow rejection is switched on or off (if switched on all traces that
overflowed the ADC range will be rejected automatically). The final
optional argument is the number of points that get included into the
average. Usually it doesn't make too much sense to set this value
because the program will make sure automatically that at least as many
points of curve as can be read from the digitizer are included into the
averaging. If the value is set only as many points as have been set will
be returned by a @code{digitizer_get_curve()} command.


@item digitizer_trigger_channel()
@findex digitizer_trigger_channel()
The function queries or sets the channel of the digitizing oscilloscope
to be used as trigger input. Possible arguments or return values are,
depending on the type of the oscilloscope (return values are always
numeric!):
@table @samp
@item TDS520
@itemx TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{AUX1}, @code{AUX2} or @code{LINE}
(@code{LINE} can be abbreviated to @code{LIN})
@end itemize
@item TDS540
@itemx TDS744A
@itemx TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{AUX} or @code{LINE} (@code{LINE} can be abbreviated to @code{LIN})
@end itemize
@item LECROY9400
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{LINE}, @code{EXT} or @code{EXT10} (@code{LINE} can be
abbreviated to @code{LIN})
@end itemize
@end table
The function can be called in query mode (i.e.@: without an argument)
only if either it has already been called with an argument or in the
@code{EXPERIMENT} section.


@item digitizer_record_length()
@findex digitizer_record_length()
The function queries (if called with no argument) or sets (if called
with an argument) the length of the traces measured by the
digitizer. Because the digitizer only allows certain record lengths
a value passed to the function will be rounded up to the next
allowed value if necessary.

The function can be called in query mode (i.e.@: without an argument)
only if either it has already been called with an argument or in the
@code{EXPERIMENT} section.


@item digitizer_trigger_position()
@findex digitizer_trigger_position()
The function queries (if called with no argument) or sets (if called
with an argument) the amount of pre-trigger, i.e.@: the portion of the
trace shown with data before the trigger was detected. The function
accepts or returns values from the interval @w{[0, 1]} (where 0 means
that the trigger is at the very first point of the trace and 1 that it's
at the last point).

The function can be called in query mode (i.e.@: without an argument)
only if either it has already been called with an argument or in the
@code{EXPERIMENT} section.


@item digitizer_define_window()
@findex digitizer_define_window()
The function must be used to define a time window to be used in later
calls of the functions to measure an area, an amplitude or to fetch a
curve from the oscilloscope. Usually it is called with two arguments,
the starting point and the width of the window (both in seconds). If it
is called with no argument the window defined by the cursor pair on the
oscilloscopes screen is used. If no width argument is passed to the
function the distance between the cursor pair is used.

The function returns an integer number that can be used in later calls
to address the window. Thus, you need to store this number in a variable
to be able to use this window in further calls of digitizer functions.

The allowed range of arguments for the start point and width of the
window depends on the time base setting of the oscilloscope as well as
the pre-trigger setting and the current record length. The time of the
trigger event corresponds to an argument of zero for the starting point
of the window. Times before the trigger are negative, times after the
trigger are positive. If a window width is given it has to be positive
and the window must fit into the time interval measured by the
oscilloscope. The easiest way to find valid parameters is to position
the two vertical cursors at the borders of the interval to be measured
and directly use the values for the starting point and width displayed
in the upper right hand corner of the oscilloscope.

Because the data measured by the oscilloscope are discreet it is not
possible to specify arbitrary values for the starting point and the
window width but must fit with the current minimum time resolution. If
the specified values don't fit the requirement a warning is printed and
the position and width are adjusted to the nearest allowed value.

This function can only be used in the @code{PREPARATIONS} section of the
@acronym{EDL} file.

@item digitizer_start_acquisition()
@findex digitizer_start_acquisition()
This function starts an acquisition sequence of the
oscilloscope. Previously measured curves are discarded and new data
are sampled until the requested number of averages has been reached.
The function can only be used in the @code{EXPERIMENT} section of the
@acronym{EDL} file.


@item digitizer_get_area()
@findex digitizer_get_area()
The function returns the area under one of the measured curves. It
expects up to two arguments, the oscilloscopes channel the data are to
be taken from and, optionally, a window ID as returned by
@code{digitizer_define_window()} to specify the time interval the area
is computed from. The channel that can be used depend on the model of
the digitizer:
@table @samp
@item TDS520
@itemx TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@item TDS540
@itemx TDS744A
@itemx TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4} 
@end itemize
@item LECROY9400
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MEM_C} or @code{MEM_D}
@item @code{FUNC_E} or @code{FUNC_F}
@end itemize
@end table
Except for the models @code{TDS520} and @code{LECROY9400}, this function
positions the cursors at the start and end point of the specified window
(or the first and last point if no window as been specified) and uses
the function built into the digitizer to compute the area. For the
models @code{TDS520} and @code{LECROY9400}, that miss this built-in
function, the curve in the interval is fetched which is than used to
compute the area. To give some visual feedback also for the @code{TDS520}
the cursors are moved to the borders of the interval.

The function will automatically wait until a still running acquisition
sequence is finished before measuring the area. 

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} file.


@item digitizer_get_area_fast()
@findex digitizer_get_area_fast()
This function takes the same arguments as the function
@code{digitizer_get_area()} and also basically does the same. The only
difference is that instead of using the function built into the
digitizer to compute the area the curve in the specified interval is
fetched and the area is computed from these data. This function can be a
bit faster because it doesn't set the cursors (which also means that
there is no visual feedback).

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} file.


@item digitizer_get_curve()
@findex digitizer_get_curve()
The function fetches a curve from the digitizer. It expects up to two
arguments, the channel the data are to be fetched from and, optionally,
a window ID as returned by @code{digitizer_define_window()} to specify
the time interval. Valid choices of the data channel depend on the model
of the digitizer:
@table @samp
@item TDS520
@itemx TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@item TDS540
@itemx TDS744A
@itemx TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@end table

The function positions the cursors at the start and end point of the
specified window (or the first and last point if no window as been
specified) to give a visual feedback.

The function will automatically wait until a still running acquisition
sequence is finished before returning a curve. The data will be returned
as an array of floating point numbers and it's the users responsibility
to supply an array for storing the data. Usually, this will be an array
defined with an unspecified number of elements.

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} file.


@item digitizer_get_curve_fast()
@findex digitizer_get_curve_fast()
This function is nearly identical to the function
@code{digitizer_get_curve()} with the only difference that the cursors
are not positioned at the start and end point of the curve to be fetched.


@item digitizer_get_amplitude()
@findex digitizer_get_amplitude()
The function returns the amplitude, i.e.@: the difference between the
maximum and minimum voltage, from the digitizer. The function takes up
to two parameters, the channel the data are to be fetched from and, optionally,
a window ID as returned by @code{digitizer_define_window()} to specify
the time interval. Valid choices of the data channel depend on the model
of the digitizer:
@table @samp
@item TDS520
@itemx TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@item TDS540
@itemx TDS744A
@itemx TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4}
@item @code{MATH1}, @code{MATH2} or @code{MATH3}
@item @code{REF1}, @code{REF2}, @code{REF3} or @code{REF4}
@end itemize
@end table
Except for the model @code{TDS520}, this function positions the cursors
at the start and end point of the specified window (or the first and
last point if no window as been specified) and uses the function built
into the digitizer to compute the amplitude. For the model @code{TDS520}
that misses this built-in function the curve in the interval is fetched
which is than used to compute the amplitude. To give some visual
feedback also for this model the cursors are moved to the borders of the
interval.

The function will automatically wait until a still running acquisition
sequence is finished before measuring the amplitude.

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} file.


@item digitizer_get_amplitude_fast()
@findex digitizer_get_amplitude_fast()
This function is nearly identical to @code{digitizer_get_amplitude()}
except that the function to compute amplitudes built into the digitizer
isn't used and the cursors aren't positioned at the start and end of the
time interval.


@item digitizer_run()
@findex digitizer_run()
Usually, during an experiment the digitizer starts to do the
acquisitions following a call of @code{digitizer_start_acquisition()}
and stops when it's done. To have the digitizer running constantly
following an acquisition (at least up to the next
@code{digitizer_start_acquisition()} command) use this function. It
accepts no arguments and can only be used in the @code{EXPERIMENT}
section.


@item digitizer_lock_keyboard()
@findex digitizer_lock_keyboard()
Usually, during an experiment the keyboard of the digitizer is
locked. But for situations where it would be useful to be able to
control the digitizer also via its keyboard it can be unlocked (and also
re-locked) from within the program. To unlock the keyboard call this
function with an argument of @code{0} or @code{"OFF"}, to re-lock the
keyboard call it again with a non-zero argument, @code{"ON"} or no
argument at all.

@end table


@node Pulser Functions, Synthesizer Functions, Digitizer Functions, Device Functions
@section Pulser Functions
@cindex Pulser Functions

Currently, there are three pulser/spectrometer combinations implemented:
@itemize @bullet
@item Sony/Tektronix DG2020 with S-band spectrometer in Frankfurt/Main
@item Sony/Tektronix DG2020 with X-band spectrometer in Berlin
@item Tektronix HFS9003 with W-band spectrometer in Berlin
@end itemize
To load the functions for one of these pulsers use in the @code{DEVICES}
section one of the lines
@example
dg2020_f;
dg2020_b;
hfs9003;
@end example

Pulsers are rather special and even the @acronym{EDL} syntax for dealing
with the pulsers differs slightly. Thus there is a whole chapter dealing
with pulsers and how to define and use pulses, see @ref{Using
Pulsers}. Several of the aspects of the following short descriptions of
the pulser functions will probably only become understandable after
reading the chapter about pulsers and pulses.

@table @samp
@item pulser_name()
@findex pulser_name()
Returns a string with the name of the digitizer being used.


@item pulser_state()
@findex pulser_state()
This function can be either used to determine if the pulser is running
when called without an argument, in which case either @code{1} (i.e.@:
the pulser is running) or @code{0} (pulser is stopped) is returned. if
called with either a numerical argument or a string of @code{"ON"} or
@code{"OFF"} the pulser will be started or stopped (a numerical argument
of @code{0} stops the pulser, a non-zero argument starts it).


@item pulser_channel_state()
@findex pulser_channel_state()
For the @strong{Tektronix HFS9003} this function can be used to
determine or set the state of individual channels of the pulser. If
called with a single integer argument between @code{1} and @code{4} the
state of the corresponding channel is returned. If called with an
additional numeric argument or a string of @code{"ON"} or @code{"OFF"}
the channel can be switched on or off.


@item pulser_lock_keyboard()
@findex pulser_lock_keyboard()
Usually, during an experiment the keyboard of the pulser is locked. But
for situations where it would be useful to be able to control the pulser
also via its keyboard it can be unlocked (and also re-locked) from within
the program. To unlock the keyboard call this function with an argument
of @code{0} or @code{"OFF"}, to re-lock the keyboard call it again with
a non-zero argument, @code{"ON"} or no argument at all. This command is
only available for the Sony/Tektronix DG2020.


@item pulser_update()
@findex pulser_update()
This function has to be called after changes have been applied to pulses
either via any of the following pulser functions or by changing a pulse
property directly. Before this function is called, all changes are only
done to the internal representation of the pulser, but not yet send to
the pulser. Only by calling the function these changes are committed and
the real pulses will change.

@item pulser_shift()
@findex pulser_shift()
This function can be called with either no argument or with a list of
(comma separated) pulse identifiers (pulse numbers will also do). If no
argument is given the position of all pulses which have a
@code{DELTA_START} defined is shifted by their respective
@code{DELTA_START}. If there is only one argument or a list of pulses
only the start position of the listed pulses are changed.

@item pulser_increment()
@findex pulser_increment()
This function can be called with either no argument or with a list of
(comma separated) pulse identifiers (pulse numbers will also do). If no
argument is given the length of all pulses which have a
@code{DELTA_LENGTH} defined is incremented by their respective
@code{DELTA_LENGTH}. If there is only one argument or a list of pulses
only the lengths of the listed pulses are changed.

@item pulser_pulse_reset()
@findex pulser_pulse_reset()
This function can be called with either no argument or with a list of
(comma separated) pulse identifiers (pulse numbers will also do). If no
argument is given all pulses are reset to their initial state, i.e.@:
the state of the pulses set in the @code{PREPARATIONS} section.  If
called with one argument or a list of pulses only the pulses from the
list are reset back to their initial state.

@item pulser_next_phase()
@findex pulser_next_phase()
When the experiment starts the phases of all pulses are set to the first
phase of the phase sequence (defined in the @code{PHASE} section)
associated with the pulses. By calling this function the phases of the
pulses are switched to the next phase. By repeatedly calling the
function one can run through the complete list of phases for the pulses.

@item pulser_phase_reset()
@findex pulser_phase_reset()
This function can be called with either no argument or with a list of
(comma separated) pulse identifiers (pulse numbers will also do). If no
argument is given the phases of all pulses are reset to their initial
phase, i.e.@: the first phase of the phase sequence (defined in the
@code{PHASE} section) associated with the pulses. If one or more pulses
are passed to the function the phases of only these pulses are reset.


@item pulser_stop_on_update()
@findex pulser_stop_on_update()
This function exists for the HFS9003 only. While doing updates of the
pulser to set new pulse positions and length etc.@: it usually gets
switched off. By calling this function with an argument of @code{0} you
can tell to pulser to continue even while doing updates. If called with
an argument of @code{1} you may switch back to the default behavior.

@end table



@node Synthesizer Functions, Temperature Controller Functions, Pulser Functions, Device Functions
@section Synthesizer Functions
@cindex Synthesizer Functions
The only implemented synthesizer so far is the HP8647A. Its module is
loaded by specifying
@example
hp8647a
@end example
@noindent
in the @code{DEVICES} section.


@table @samp
@item synthesizer_name()
@findex synthesizer_name()
Returns a string with the name of the synthesizer being used.


@item synthesizer_state()
@findex synthesizer_state()
The function queries or sets the output state of the synthesizer. i.e.@:
to switch output of RF on or off. If called to set the output state it
accepts one argument, either a non-zero value or the string @code{"ON"}
to switch output on, or zero or the string @code{"OFF"} to switch it
off. The synthesizer output is never switched on automatically!

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e.@: without an argument (unless the state has already been
set by calling the function with an argument). In query mode it either
returns either @code{1} or @code{0} to indicate the on/off state of the
RF output.


@item synthesizer_frequency()
@findex synthesizer_frequency()
The function queries or sets the RF output frequency. If called to set
the frequency it accepts one argument, the frequency in the range
between @w{250 kHz} and @w{1000 MHz}. The frequency set by the very
first call of this function is also the function that is set
automatically by a call of the function
@code{synthesizer_reset_frequency()} (see below).

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e.@: without an argument (unless the frequency has already
been set by calling the function with an argument).


@item synthesizer_attenuation()
@findex synthesizer_attenuation()
The function queries or sets the output attenuation. If called to set
the attenuation it accepts one argument, the attenuation in the range
between @w{+10 db} and @w{-136 db}.

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e.@: without an argument (unless the attenuation has already
been set by calling the function with an argument).


@item synthesizer_minimum_attenuation()
@findex synthesizer_minimum_attenuation()
The function queries or sets the minimum output attenuation. If called to set
the attenuation it accepts one argument, the attenuation in the range
between @w{+10 db} and @w{-136 db}. Calling the function restricts
setting the attenuation to ranges below the value set by this function.


@item synthesizer_step_frequency()
@findex synthesizer_step_frequency()
The function queries or sets the RF step frequency to be used in calls
of the functions @code{synthesizer_sweep_up()} and
@code{synthesizer_sweep_down()} (see below). In order to set the step
frequency it expects one argument, the step frequency in Hz. The step
frequency can be set in the @code{PREPARATIONS} section only once, but
it can be changed later in the @code{EXPERIMENT} section.

Before the step frequency has been set by calling the function with an
argument the query form of the function (i.e.@: calling it without an
argument can't be used).

@item synthesizer_sweep_up()
@findex synthesizer_sweep_up()
If there has been set both a frequency and a step frequency the function
will increment the synthesizers frequency. It returns the newly set
frequency. The function can only be called in the @code{EXPERIMENT}
section.

@item synthesizer_sweep_down()
@findex synthesizer_sweep_down()
If there has been set both a frequency and a step frequency the function
will decrement the synthesizers frequency. It returns the newly set
frequency. The function can only be called in the @code{EXPERIMENT}
section.

@item synthesizer_reset_frequency()
@findex synthesizer_reset_frequency()
If a frequency has been set at all the function will reset the
synthesizers frequency to the frequency that has been set at first. The
function can only be called in the @code{EXPERIMENT} section.

@item synthesizer_use_table()
@findex synthesizer_use_table()
This function tells the program to also adjust the attenuation when a
new frequency is set. To find out which attenuation has to be set for a
new frequency a table file is used. The name of this table file can be
passed to the function as a (string) argument. If no argument is given a
default table file is used (typically this is
@file{/usr/local/lib/fsc2/hp8647a.table}, but it may depend on the
installation).

The table file must consist of pairs of entries, a frequency and a
corresponding attenuation in db. The attenuation is being added to the
'raw' attenuation, i.e.@: to achieve an higher attenuation and a lower
output power a negative attenuation has to be specified.  If no unit are
given in the table file (i.e.@: @code{MHz} and @code{db}) the first
member of an entry must be the frequency, the second the attenuation.
The entries in the file don't have to be sorted in any way, and
the frequencies don't have to spaced equally.

The items in the table file can be separated by spaces, commas,
semicolons, colons, tabs or newlines or any combination of these
characters (a unit will also work as a separator) and the entries don't
have to be separated by a newline. Thus all the following entries would
be valid:
@example
7.90000000 MHz,   -1.90000000 db
-2.10000000 db 8.00000000 MHz   
8.1E6 -2.2 8.20000000 MHz : -2.30000000 db 8300 kHz

   -2.4 db
8.70000000MHz-2.40000000db
@end example
@noindent
As you see also blank lines don't matter. Finally, all lines starting
with a hash character, `@code{#}', are treated as comments.

If a frequency is used that isn't in the table the attenuation to be used
is extrapolated from the next neighboring frequencies. If the frequency
isn't within the range of frequencies covered by the table a warning is
printed and the attenuation for the nearest frequency is used.


@item synthesizer_att_ref_freq()
@findex synthesizer_att_ref_freq()
When a table file is used there remains the question for which frequency
to use the attenuation has been set e.g.@: by
@code{synthesizer_attenuation()}. To set this reference frequency the
function @code{synthesizer_att_ref_freq()} can be used. If the function
isn't called a frequency of @w{14 MHz} is used.


@item synthesizer_modulation()
@findex synthesizer_modulation()
This function is used to set the type, source and amplitude of the
modulation. It can set all of these parameters at once or only parts.

There are three possible types of modulation FM, AM and phase
modulation. The modulation type is specified by a string, either
@code{"FM"}, @code{"AM"}, @code{"PHASE"} or, finally, @code{"OFF"}.

Please note that setting a modulation source or amplitude while the
modulation is off (i.e.@: when @code{"OFF"} has been specified as the
modulation type) is not possible and trying to do so will make the
program abort.

The possible modulation sources are either external AC coupled, external
DC coupled, internal @w{1 kHz} or internal @w{400 Hz}. For external AC
or DC coupled modulation specify one the strings @code{"EXT AC"},
@code{"AC"}, @code{"EXT DC"} or @code{"DC"}. For internally generated
modulation with @w{1 kHz} or @w{400 Hz} use a string argument from the
following list: @code{"INT 1kHz"}, @code{"INT 1 kHz"}, @code{"INT 1"},
@code{"1kHz"}, @code{"1 kHz"}, @code{"1"}, @code{"INT 400Hz"},
@code{"INT 400 Hz"}, @code{"INT 400"}, @code{"400Hz"}, @code{"400 Hz"}
or @code{"400"}. But please note: external DC coupled modulation source
does not work with amplitude and phase modulation@!

Finally you may specify the modulation amplitude, which has to be a
number (preferably a floating point number). FM modulation amplitudes
have to be in the range between @w{0 Hz} and @w{100 kHz}, AM modulation
amplitudes between @w{0 %} and @w{100 %} and phase modulation amplitudes
between @w{0 degree} and @w{10 degree}.

Only in the first call of the function all three arguments, i.e.@: the
modulation type, source and amplitude, should be passed to the
function. In further calls not all of the arguments have to be given
again. Instead, in further calls it is sufficient to specify only for
example a new amplitude. The same, of course, holds for the modulation
source.

If the modulation type becomes changed, the source and amplitude reverts
to the settings that were specified in previous calls of the function
when this modulation type was still active. I.e.@: if at first AM
modulation using an external AC coupled source and an amplitude of
@w{50 %} was set and then the modulation was changed to FM with
different settings for source and amplitude, another call switching back
to AM modulation will also restore the settings of external AC coupled
source and @w{50 %} amplitude.


@item synthesizer_mod_type()
@findex synthesizer_mod_type()
As an alternative the function @code{synthesizer_modulation()} the
modulation type can be also set via the function
@code{synthesizer_mod_type()}. It accepts on of the three string
arguments @code{"FM"}, @code{"AM"}, @code{"PHASE"} or, finally,
@code{"OFF"} (or the numbers @code{0} for FM, @code{1} for AM, @code{2}
for phase modulation or @code{3} for switching modulation off).

If called with no argument it will return the currently active modulation
type as an integer number.


@item synthesizer_mod_source()
@findex synthesizer_mod_source()
If the modulation type has been set before the modulation source can be
set directly via this function. It accepts one of the following strings:
@code{"INT 1kHz"}, @code{"INT 1 kHz"}, @code{"INT 1"}, @code{"1kHz"},
@code{"1 kHz"}, @code{"1"}, @code{"INT 400Hz"}, @code{"INT 400 Hz"},
@code{"INT 400"}, @code{"400Hz"}, @code{"400 Hz"} or
@code{"400"}. Alternatively, the number @code{0} can be specified for
external AC coupled modulation source, @code{1} for an external DC
coupled source, @code{2} for the internally generated @w{1 kHz} source
and @code{3} for the internal @w{400 Hz} source.

If the function is called with no argument it will return the modulation
source setting for the currently active modulation type as an integer number.
You can neither set nor obtain the modulation source as long as the
modulation is switched off, trying to do so will result in aborting the
program.


@item synthesizer_mod_ampl()
@findex synthesizer_mod_ampl()

If the modulation type has been set this function can be used to set the
modulation amplitude. For FM the allowed range of frequencies is from
@w{0 Hz} to @w{100 kHz}, for AM amplitudes between @w{0 %} and @w{100 %}
are acceptable and for phase modulation values between @w{0 degree} and
@w{10 degree} are valid.

If called with no argument, the function will return the amplitude
setting for the currently active modulation type. You can neither set
nor obtain the modulation amplitude as long as the modulation is
switched off, trying to do so will result in aborting the program.

@end table



@node Temperature Controller Functions, Multi-Device Functions, Synthesizer Functions, Device Functions
@section Temperature Controller Functions
@cindex Temperature Controller Functions
The only currently implemented temperature controller is the Lake Shore 330.
Its module is loaded by specifying
@example
lakeshore330
@end example
@noindent
in the @code{DEVICES} section. All functions for the temperature
controller can only be used in the @code{EXPERIMENT} section of
the @acronym{EDL} program.


@table @samp
@item temp_contr_name()
@findex temp_contr_name()
Returns a string with the name of the temperature controller being used.


@item temp_contr_temperature()
@findex temp_contr_temperature()
This function accepts no arguments and returns the temperature at the
currently active sample channel.

@item temp_contr_sample_channel()
@findex temp_contr_sample_channel()
This function returns, when called with no argument, the currently
selected sample channel. It returns @code{1} for channel @code{A} and
@code{2} for channel @code{B}. These values can also passed to the
function to set a new sample channel. Alternatively, one may also use
the strings @code{"A"} or @code{"B"}. Please take note that setting a
sample channel takes about half a second.


@item temp_contr_sensor_unit()
@findex temp_contr_sensor_unit()
Function either returns or sets the units returned by the device on
temperature readings. If used to set a unit the function must be called
with the value @code{0} or @code{"K"} to set the unit to Kelvin,
@code{1} or @code{"C"} to set to degree Celsius or, finally, with
@code{2} or @code{"S"} to set to the unit appropriate for the sensor
(volts for diodes, Ohms for RTD or Millivolts for thermocouples). It
will always return the unit setting as an integer value with @code{1}
for Kelvin, @code{1} for degree Celsius, @code{2} for Volts, @code{3}
for Ohms or @code{4} for Millivolts.


@item temp_contr_lock_keyboard()
@findex temp_contr_lock_keyboard()
Usually, during an experiment the keyboard of the temperature controller
is locked. But for situations where it would be useful to be able to
control the device also via its keyboard it can be unlocked (and also
re-locked) from within the program. To unlock the keyboard call this
function with an argument of @code{0} or @code{"OFF"}, to re-lock the
keyboard call it again with a non-zero argument, @code{"ON"} or no
argument at all.

@end table


@node Multi-Device Functions, , Temperature Controller Functions, Device Functions
@section Multi-Device Functions
@cindex Multi-Device Functions

There are a few convenience functions that use two or more devices. They
use the single-device functions (and thus will print error messages if
the modules for the required devices aren't loaded or don't if the
modules don't support the needed functions). The module they are defined
in is automatically loaded, so it needs no special entry in the
@code{DEVICES} section.


@table @samp

@item get_phase_cycled_area()
@findex get_phase_cycled_area()
This function is for doing a complete measurement sequence in a phase
cycled experiment, It goes through a complete phase cycle, setting the
pulser, fetching the data from the digitizer and finally returning the
measured data, i.e.@: the areas returned by the digitizer and added up
according to the setting of the @code{ACQUISITION_SEQUENCE}.

This function is for cases where there's only one
@code{ACQUISITION_SEQUENCE}, if there are two use the function
@code{get_phase_cycled_area()} instead.

The first argument the function expects is a digitizer channel to be
used for measuring the area of the signal, see above which channels can
be used for the different digitizers. If the @code{ACQUISITION_SEQUENCE}
is written in way that it is clear that two digitizer channels are
needed, i.e.@: you have a line in the @code{PHASES} section like
@example
ACQUISITION_SEQUENCE = +A, -B, -A, +B;
@end example
@noindent
also the second argument to the function must be a digitizer
channel. The first channel is used for fetching the @code{A} data, the
second for the @code{B} data. This is, of course, only relevant when you
have two different signals, e.g.@: the two outputs of a quadrature mixer
and the measured data consist of adding up signals from both channels.

The following arguments are as many window identifiers (as returned by
@code{digitizer_define_window()} as there are needed. If no window
argument is given always the area of the complete curve is returned!

The type of the return value depends on the number of window identifiers
passed to the function. If there is only one window identifier (or none)
a floating point value with the result of the measurement is returned. If,
on the other hand, there is more than one window identifier an array
will be returned with as many elements as there are window identifiers,
the first element of the returned array containing the result for the
first window, the second element the value for the second window etc.

As an example here parts of an @code{EDL} program for a 1-dimensional
stimulated echo experiment with phase cycling. The parts with the
definition of the pulses etc. are left out for sake of brevity.

@example
DEVICES:

dg2020_f;
tds754a;


VARIABLES:

Num_points = 256;
raw_data[ 2 ];
data[ Num_points ];
Win_ID_1;                // signal window
Win_ID_2;                // background window
I;

...

ASSIGNMENTS:

...

PHASES:

PHASE_SEQUENCE_1     = +x, -x, +x, -x;  // sequence for 1st pulse
PHASE_SEQUENCE_2     = +x, +x, -x, -x;  // sequence for 2nd pulse
ACQUISITION_SEQUENCE =  +,  -,  -,  +;


PREPARATIONS:

init_1d( 1, Num_points );
Win_ID_1 = digitizer_define_window( 388 ns, 4 ns );
Win_ID_2 = digitizer_define_window( 620 ns, 4 ns );

...

EXPERIMENT:

FOR I = 1 : : Num_points @{
    raw_data = get_phase_cycled_area( CH1, Win_ID_1, Win_ID_2 );
    data[ I ] = raw_data[ 1 ] - raw_data[ 2 ];
    display( I, data[ I ] );
    pulser_shift( );
@}

...
@end example
@noindent
You may note, that in this program @code{pulser_update()} isn't called
after @code{pulser_shift()}. This is possible because
@code{get_phase_cycled_area()} internally calls @code{pulser_update()}
before it starts doing the measurement.




@item get_phase_cycled_area_2()
@findex get_phase_cycled_area_2()

This function is very similar to the previous one,
@code{get_phase_cycled_area()}. The main difference is that instead of
just one value for each window two are returned, usually the real and
the imaginary part of a signal. The arguments of the function are
identical to the one of @code{get_phase_cycled_area()}. But when only
one window identifier (or none) was passe to the function it returns
an array with two elements and if there were more window identifiers it
returns and array with twice as many elements. To be able to use this
function two @code{ACQUISITION_SEQUENCE}s must have been defined in the
@code{PHASES} section of the @code{EDL} program and you need quadrature
detection.

This function would for example be used in an inversion recovery
experiment with FID detection and phase cycling. Parts of the program
would look like this:
@example
DEVICES:

dg2020_f;
tds754a;


VARIABLES:

Num_points = 256;
raw_data[ 4 ];
data[ Num_x_points, 2 ];
Win_ID_1;                // signal window
Win_ID_2;                // background window
I;

...

ASSIGNMENTS:

...

PHASES:

PHASE_SEQUENCE_1       = +x, +x, +x, +x, -x, -x, -x, -x;
PHASE_SEQUENCE_2       = +x, -x, +y, -y, +x, -x, +y, -y;
ACQUISITION_SEQUENCE_1 = +A, -A, +B, -B, +A, -A, +B, -B;
ACQUISITION_SEQUENCE_2 = +B, -B, -A, +A, +B, -B, -A, +A;


PREPARATIONS:

init_1d( 2, Num_points );
Win_ID_1 = digitizer_define_window( 388 ns, 4 ns );
Win_ID_2 = digitizer_define_window( 620 ns, 4 ns );

...

EXPERIMENT:

FOR I = 1 : : Num_points @{
    raw_data = get_phase_cycled_area_2( CH1, CH2,
                                        Win_ID_1, Win_ID_2 );
    data[ I, 1 ] = raw_data[ 1 ] - raw_data[ 3 ];
    data[ I, 2 ] = raw_data[ 2 ] - raw_data[ 4 ];
    display( I, data[ I, 1 ], 1, I, data[ I, 2 ], 2 );
    pulser_shift( );
@}
@end example

@end table
