@c $Id$

@node Device Functions, Modules, Built-in Functions, Top
@chapter Device Functions

@ifinfo
@menu
* Introduction::            
* Magnet Functions::        Functions for controlling the magnet.
* Gaussmeter Functions::    Functions for measuring the magnetic field.
* Lock-In Functions::       Functions for accessing the lock-in amplifiers.
* Digitizer Functions::     Functions for accessing the oscilloscopes.
* Pulser Functions::
* Synthesizer Functions::
* Multi-Device Functions::
@end menu
@end ifinfo


@node Introduction, Magnet Functions, Device Functions, Device Functions
@section Introduction


The most simple approach would be to have a set of functions for each
individual device, i.e.@: to have a different function for e.g.@:
fetching data from each of a series of different digitizing
oscilloscopes.  But this would be a nuisance for someone writing
@acronym{EDL} programs because whenever for example the oscilloscope has
to be changed also all the programs have to be adjusted to the special
capabilities of the digitizer that's just using.

Thus it's reasonable to have generic functions for a similar devices
that usually have a lot in common. So one may write
@example
new_data = digitizer_get_curve( CH1 );    // get curve from channel 1
@end example
instead of
@example
new_data = tds754a_get_curve( 1 );        // get curve from channel 1
@end example
and does not have to change anything whenever someone else needs the
TDS754A oscilloscope for a few days and one has to do with the TDS520
oscilloscope in the mean time.

Of course, using generic functions has its limitations - when e.g.@: the
lock-in amplifier has only one channel no abstraction can make it have
two channels - but wait, actually, it can: whenever the program is asked
for data from channel 2 it may rotate the phase lock-in phase by 90
degrees, waits for another time constant, gets the value and you
basically have two channels, at least realized in software (of course,
there's a penalty - measurements take at least twice the time needed
with a two-channel lock-in amplifier). But there can be real hard
limitations - if you've got a device with only 2 DACs no software
trickery will ever magically convert it into a device with 4 DACs
(additional hardware may, but that's a different topic...)

The gist is, that, while a lot of abstraction is possible, not all device
functions can be completely identical for all devices. Thus, while the
names of the functions remain identical, the arguments the functions are
called with may differ for different devices. But while this can be as
annoying as having different functions for each device, it at least
reduces the amount of differences to be taken into account considerably.



@node Magnet Functions, Gaussmeter Functions, Introduction, Device Functions
@section Magnet functions
@cindex Magnet functions


All the following functions may be used to control the magnetic field of
the magnet. Currently, AEG magnets (X-band and S-band) are
supported. The modules that have to be listed in the @code{DEVICES}
section to load the functions are
@example
aeg_x_band
aeg_s_band
@end example
Because magnets are hardly ever changed (and if the program is set up
correctly for the experiment) one can use @code{magnet} as the module
name instead.

Since it is not possible to measure the field using just the magnet
power supply it is necessary also to specify a gaussmeter to enable
@acronym{fsc2} to control the magnet. The module name of the gaussmeter
has to appear @b{before} the magnet module entry in the @code{DEVICES}
section. See the next section for the implemented gaussmeter and the
related functions.

If a magnet module is listed in the @code{DEVICES} section the program
will try to calibrate the field sweep parameters at the start of the
experiment, i.e.@: it will sweep the field up and down for some
time. This may take some time. See below on how to reduce this time.


@table @samp
@item magnet_setup()
@findex magnet_setup()
The function can be called to set the start field and the field step
size used in sweeps. The function expects two floating point parameters,
the start field, e.g.@: @w{0.345 T}, and the step size, e.g.@: @w{0.35
G}. The function can be called before the @code{EXPERIMENT} section
starts.

@item magnet_fast_init()
@findex magnet_fast_init()
Calling this functions in the @code{PREPARATIONS} section will shorten
the time used for the calibration of the field sweep at the start of the
experiment. Unfortunately, this also reduces the precision of the field
sweep. Whenever an experiment is restarted (i.e.@: if no new
@acronym{EDL} file is loaded in between) this shortened calibration is
done anyways to check that the parameters didn't check significantly
since the last run.


@item set_field()
@findex set_field()
This function expects one floating point argument for the field value
and will set the magnetic field to this value. It also accepts a second
optional paramter, the maximum acceptable deviation of the field from
the value to be set. For example by the call
@example
set_field( 3421.5 G, 0.2 G );
@end example
@noindent
the field will be set to a value between @w{3421.3 G} and @w{3421.7 G}.

If this second paramter is missing the precision of the gaussmeter used
for measuring the field is used. If the maximum deviation paramter is
smaller than the precision of the gaussmeter the precision of the
gaussmeter is used instead. The function can only be called in the
@code{EXPERIMENT} section.


@item sweep_up()
@findex sweep_up()
The function can be called in the @code{EXPERIMENT} section, but only if
the function @code{magnet_setup()} (see above) has been called
before. It doesn't take an argument and will sweep up the magnet by
the field step size value set in the @code{magnet_setup()} function.

The precision of the field sweep depends on the step size. While the
precision is usually quite good for step sizes of up to @w{1 G}, for much
larger step sizes it may deteriorate quite significantly. It sometimes
helps to add a short wait period (use function @code{wait()}) after a
sweep step to allow the field to settle at the new point. On the other
hand, it then might be faster (and more reliable) not to use the sweep
function at all but @code{set_field()} instead.

@item sweep_down()
@findex sweep_down()
Analog function to @code{sweep_up()} but sweeping the magnetic field
down by the field step size defined in @code{magnet_setup()}. The
function can only be called in the @code{EXPERIMENT} section.

@item reset_field()
@findex reset_field()
This function resets the magnetic field to the start field value defined
in @code{magnet_setup()} (which has to be called before). The function
can only be used in the @code{EXPERIMENT} section.

@end table


@node Gaussmeter Functions, Lock-In Functions, Magnet Functions, Device Functions
@section Gaussmeter functions
@cindex Gaussmeter functions


Currently, two types of gaussmeter are implemented, the Bruker ER035M
NMR gaussmeter and the Bruker BH15 hall probe field controller. The
range of fields that can be measured with the Bruker ER035M NMR
gaussmeter depends on the probe being used. With the F0 probe (S-band)
the range is @w{460 G} to @w{2390 G} while with the F1 probe (X-band) a
range between @w{1460 G} and @w{19900 G} can be measured.  With the BH15
field controller a range between @w{-50 G} and @w{2300 G} can be used.

The modules defining the gaussmeter functions (to be listed in the
@code{DEVICES} section) are:
@example
er035m
er035m_s
er035m_sa
er035m_sas
bh15
@end example
The first four modules are for the ER035M NMR gaussmeter. The first and
third one are to be used when the device is controlled via the GPIB bus
while the second and fourth if it's connected using the serial port of
the computer. The third and fourth module, @code{er035m_sa} and
@code{er035m_sas}, are special in that they don't allow field control
(i.e@: can't be used together with a magnet module). If the program is
correctly installed the appropriate module is loaded by specifying
`@code{gaussmeter}' instead of one of the listed module names.

The gaussmeter are mainly used together with the magnet power supply
and have to be specified in the @code{DEVICES} section @b{before} the
magnet module.

All functions for gaussmeters can only be used in queries and in the
@code{EXPERIMENT} section of the @acronym{EDL} program..

@table @samp
@item find_field()
@findex find_field()
This function is defined in the device drivers @code{er035m} and
@code{er035m_s}. It returns the current value of the magnetic field in
Gauss.  The function can only be called in the @code{EXPERIMENT}
section.


@item field_resolution()
@findex field_resolution()
This function is defined in the device drivers @code{er035m} and
@code{er035m_s}. It returns the resolution in Gauss used in measurements
of the magnetic field. The function can only be called in the
@code{EXPERIMENT} section.


@item measure_field()
@findex measure_field()
This function is defined in the device drivers @code{er035m_sa} and
@code{er035m_sas}. It measures the current field and returns the value
in Gauss. The function can only be called in the @code{EXPERIMENT}
section.

@end table


@node Lock-In Functions, Digitizer Functions, Gaussmeter Functions, Device Functions
@section Lock-In functions
@cindex Lock-In functions

There are modules for four types of lock-in amplifiers implemented. All
of them are by Stanford Research and have the model names SR510, SR530,
SR810 and SR830. Not too surprisingly, the module names to be specified
in the @code{DEVICES} section are
@example
sr510
sr530
sr810
sr830
@end example

Because the models have different capabilities, some of the functions
are either only defined for parts of the models or may use slightly
different parameters.

Several of the following functions can be called to query settings of
the lock-in amplifier or to set a value. In the first case the function
usually has to be called with no argument, while to set a parameter an
argument has to be passed to the function. Because of these different
modes of calling the functions one should carefully check the arguments
to achieve the desired results.

@table @samp
@item lockin_get_data()
@findex lockin_get_data()
This function only allows queries, i.e.@: to fetch the measured value
from the lock-in amplifier. The parameters, that may be passed to the
function differ according to the model.
@table @samp
@item SR510
No argument is allowed -- the function returns the measured value of the
only channel as a floating point number (i.e.@: in Volts).

@item SR530
If no argument is specified the measured value at channel 1 is
returned. Alternatively, one parameter may be passed to the function
with a value of either @code{1} or @code{2}, in which case the measure
value from channel 1 or 2 is returned. Finally, two arguments can be
given, with values of @code{1} or @code{2}. In this case a 1-dimensional
array with two elements is returned, containing the measured values of
the corresponding channels.

@item SR810
@item SR830
If no argument is specified the measured value at channel 1 is returned.
If one parameter is passed to the function the value at the
corresponding channel is returned. Possible channel numbers and their
meaning are:
@table @samp
@item 1
channel 1
@item 2
channel 2
@item 3
amplitude of data from channel 1 and 2 in polar coordinates
@item 4
phase of data from channel 1 and 2 in polar coordinates
@end table
Finally, up to 4 arguments can be passed to the function with the
values given above. In this case a 1-dimensional array is returned with
as many data as there were arguments (in the sequence corresponding the
one of the arguments).
@end table
The function can only be called in the @code{EXPERIMENT} section.

@item lockin_get_adc_data()
@findex lockin_get_adc_data()
The function returns the voltage at one of the ADC ports numbered at the
back side of the lock-in amplifier. Allowed values of the required
argument are between 1 and 4, corresponding to the port numbering.

The function can only be called in the @code{EXPERIMENT} section.

@item lockin_dac_voltage()
@findex lockin_dac_voltage()
The function can be used to set or query the voltage at one of the DAC
ports at the back side of the lock-in amplifier. While for the
models SR510 and SR530 the allowed values for the required arguments are
5 or 6, for models SR810 and SR830 the values can range from 1 to 4,
corresponding to the different numbers of DAC ports and their numbering
printed on the back side. If no further argument is given the function
returns the current voltage applied to the DAC port (which is
automatically set to @w{0 V} at the initialization of the lock-in
amplifier if no voltage has been set previous to the @code{EXPERIMENT}
section). If a second argument is given the DAC will be set to the
corresponding voltage. The function returns the voltage that has been
set.

For the models SR510 and SR530 this voltage has to be in the range
between @w{-10.24 V} and @w{+10.24 V} while for the models SR810 and
SR830 the allowed voltage range is @w{-10.V} to @w{+10.5 V}.

Before the @code{EXPERIMENT} section this function can't be called
without an argument, i.e as a query.

@item lockin_sensitivity()
@findex lockin_sensitivity()
This function can be used to query or set the sensitivity setting of the
lock-in amplifier. If no argument is passed to the function the current
sensitivity is returned. For the models SR510 and SR530 a 10 times
higher sensitivity than the maximum adjustable sensitivity of @w{100 nV} is
returned when the @code{EXPAND} button is switched on.

When called with a second argument the corresponding sensitivity is
set. This value has to be positive. If there is no sensitivity fitting
the argument the sensitivity is set to the nearest available sensitivity
setting and a warning is printed. The function will return the
sensitivity that has been set.

For the models SR510 and SR530 a sensitivity 10 times higher than the
maximum sensitivity can be specified, in which case the @code{EXPAND}
button is automatically switched on.

Before the @code{EXPERIMENT} section this function can't be called
without an argument, i.e.@: as a query.

@item lockin_time_constant()
@findex lockin_time_constant()
The function queries or sets the time constant of the lock-in
amplifier. If no argument is passed to the function the current time
constant is returned. If there's an argument the time constant is set
accordingly.  The argument has to be positive. If there is no time
constant setting fitting the argument the available nearest setting is
used and a warning is printed. The function will return the time
constant setting that has been set.

For models SR510 and SR530 also the POST time constant is set to lower
or equal the time constant.

Before the @code{EXPERIMENT} section this function can't be called
as a query, i.e without an argument.

@item lockin_phase()
@findex lockin_phase()
The function queries or sets the phase of the lock-in amplifier. If
called with no argument it will return the current phase setting in the
interval between 0 and 360 degrees. If called with an argument the phase
is set accordingly.

Before the @code{EXPERIMENT} section this function can't be called
without an argument, i.e.@: as a query.

@item lockin_ref_freq()
@findex lockin_ref_freq()
The function can be used to query the reference frequency and, for the
models SR810 and SR830, to set the reference frequency (both the other
models need an external reference frequency). If called with no argument
the current reference frequency is returned. If called with an argument
(models SR810 and SR830 only) the reference frequency is set. If the
frequency is not within the admissible range an error message is
printed and the experiment is stopped) - the admissible range depends on
the harmonics setting, see the manual for more details.

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e.@: without an argument.

@item lockin_ref_level()
@findex lockin_ref_level()
This function can be only used with the models SR810 and SR830. It
queries (if called with no argument) or sets (if called with an
argument) the level of the reference frequency. The allowed levels are
between @w{4 mV} and @w{5 V}, if the argument is not within this range
an error message is printed and the experiment is stopped.

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e.@: without an argument.


@item lockin_lock_keyboard()
@findex lockin_lock_keyboard()
Usually, during an experiment the keyboard of the lock-in amplifier is
locked. But for situations where it would be useful to be able to control
the lock-in also via its keyboard it can be unlocked (and also re-locked)
from within the program. To unlock the keyboard call this function with
an argument of @code{0}, to re-lock the keyboard call it again with a
non-zero argument or no argument at all.

@end table


@node Digitizer Functions, Pulser Functions, Lock-In Functions, Device Functions
@section Digitizer functions
@cindex Digitizer functions

The digitizing oscilloscopes currently implemented are the Tektronix
TDS520, TDS520A, TDS540, TDS744A and TDS754A. The corresponding module
names to be used in the @code{DEVICES} section are
@example
tds520
tds520a
tds540
tds744a
tds754a
@end example

@table @samp
@item digitizer_timebase()
@findex digitizer_timebase()
The function queries (if called with no argument) or sets (if called
with an argument) the time base setting of the oscilloscope. The time
base of the oscilloscope can be only set once before the start of the
@code{EXPERIMENT} section. The admissible range of the time base depends
on the model, please check the manual.

The function can be called in query mode (i.e.@: without an argument)
only if either it has already been called with an argument or in the
@code{EXPERIMENT} section.


@item digitizer_sensitivity()
@findex digitizer_sensitivity()
The function queries (if called with just one argument) or sets (if
called with two arguments) the sensitivity setting of on of the channels
of the oscilloscope. It needs at least on argument, the channel, either
symbolically or numerically. The channels that can be used as arguments
depend on the model of the oscilloscope:
@table @samp
@item TDS520
@item TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2} or, alternatively @code{0} or @code{1}
@end itemize
@item TDS540
@item TDS744A
@item TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4} or, alternatively
@code{0}, @code{1}, @code{2} or @code{3}
@end itemize
@end table

If a second argument is given this is taken to be the new sensitivity
setting in Volts. If the sensitivity value passed to the function is not
one of the available settings the nearest allowed value is used
instead. Please note that for some of the oscilloscopes the range of
admissible sensitivity settings depends on the input impedance --
unfortunmately this can only be checked for when the experiment has
already been started!

If no second argument is given the current sensitivity setting for the
channel is returned.

The function can be called in query mode (i.e.@: without a second
argument) only if either the sensitivity has already been set or in the
@code{EXPERIMENT} section.


@item digitizer_num_averages()
@findex digitizer_num_averages()
The function queries (if called with no argument) or sets (if called
with an argument) the number of averages done by the oscilloscope.  If
the number of averages is passed to the function it must be at least 1
(which will switch the oscilloscope into @code{SAMPLE} mode). If the
argument is larger than the maximum number of averages the maximum
available number of averages is used instead.

The function can be called in query mode (i.e.@: without an argument)
only if either it has already been called with an argument or in the
@code{EXPERIMENT} section.


@item digitizer_trigger_channel()
@findex digitizer_trigger_channel()
The function queries or sets the channel of the digitizing oscilloscope
to be used as trigger input. Possible arguments or return values are,
depending on the type of the oscilloscope (return values are always
numeric!):
@table @samp
@item TDS520
@item TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2} or, alternatively @code{0} or @code{1}
@item @code{AUX1}, @code{AUX2} or @code{LIN} or, alternatively @code{9},
@code{10} or @code{11}
@end itemize
@item TDS540
@item TDS744A
@item TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4} or, alternatively
@code{0}, @code{1}, @code{2} or @code{3}
@item @code{AUX} or @code{LIN} or, alternatively, @code{11} or @code{12}
@end itemize
@end table
The function can be called in query mode (i.e.@: without an argument)
only if either it has already been called with an argument or in the
@code{EXPERIMENT} section.


@item digitizer_record_length()
@findex digitizer_record_length()
The function queries (if called with no argument) or sets (if called
with an argument) the length of the traces measured by the
digitizer. Because the digitizer only allows certain record lengths
a value passed to the function will be rounded up to the next
allowed value if necessary.

The function can be called in query mode (i.e.@: without an argument)
only if either it has already been called with an argument or in the
@code{EXPERIMENT} section.


@item digitizer_trigger_position()
@findex digitizer_trigger_position()
The function queries (if called with no argument) or sets (if called
with an argument) the amount of pre-trigger, i.e.@: the portion of the
trace shown with data before the trigger was detected. The function
accepts or returns values from the interval @w{[0, 1]} (where 0 means
that the trigger is at the very first point of the trace and 1 that it's
at the last point).

The function can be called in query mode (i.e.@: without an argument)
only if either it has already been called with an argument or in the
@code{EXPERIMENT} section.


@item digitizer_define_window()
@findex digitizer_define_window()
The function can be used to define a time window to be used in later
calls of the functions to measure an area, an amplitude or to fetch a
curve from the oscilloscope. It needs at least one arguments, the
starting point of the interval (in seconds). Optionally, there can be a
second argument with the width of the window (also in seconds). If no
width argument is passed to the function the distance between the cursor
pair shown on the oscilloscopes screen is going to be used.

The function returns an integer number that can be used in later calls
to address the window. Thus, you need to store this number in a variable
to be able to use this window in further calls of digitizer functions.

The allowed range of arguments for the start point and width of the
window depends on the time base setting of the oscilloscope as well as
the pre-trigger setting and the current record length. The time of the
trigger event corresponds to an argument of zero for the starting point
of the window. Times before the trigger are negative, times after the
trigger are positive. If a window width is given it has to be positive
and the window must fit into the time interval measured by the
oscilloscope. The easiest way to find valid parameters is to position
the two vertical cursors at the borders of the interval to be measured
and directly use the values for the starting point and width displayed
in the upper right hand corner of the oscilloscope.

Because the data measured by the oscilloscope are discreet it is not
possible to specify arbitrary values for the starting point and the
window width (they must be dividable by 1/50 of the oscilloscopes time
base). If the specified values don't fit the requirement a warning is
printed and the position an width are adjusted to the nearest allowed
value.

This function can only be used in the @code{PREPARATIONS} section of the
@acronym{EDL} file.

@item digitizer_start_acquisition()
@findex digitizer_start_acquisition()
This function starts an acquisition sequence of the
oscilloscope. Previously measured curves are discarded and new data
are sampled until the requested number of averages has been reached.
The function can only be used in the @code{EXPERIMENT} section of the
@acronym{EDL} file.


@item digitizer_get_area()
@findex digitizer_get_area()
The function returns the area under one of the measured curves. It
expects up to two arguments, the oscilloscopes channel the data are to
be taken from and, optionally, a window ID as returned by
@code{digitizer_define_window()} to specify the time interval the area
is computed from. The channel that can be used depend on the model of
the digitizer:
@table @samp
@item TDS520
@item TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2} or, alternatively @code{0} or @code{1}
@item @code{MATH1}, @code{MATH2} or @code{MATH3} or, alternatively,
@code{2}, @code{3} or @code{4}
@item @code{REF1}, @code{REF2}, @code{REF3}, @code{REF4} or,
alternatively, @code{5}, @code{6}, @code{7} or @code{8}
@end itemize
@item TDS540
@item TDS744A
@item TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4} or, alternatively
@code{0}, @code{1}, @code{2} or @code{3}
@item @code{MATH1}, @code{MATH2} or @code{MATH3} or, alternatively,
@code{4}, @code{5} or @code{6} 
@item @code{REF1}, @code{REF2}, @code{REF3}, @code{REF4} or,
alternatively, @code{7}, @code{8}, @code{9}, or @code{10} 
@end itemize
@end table
Except for the model @code{TDS520}, this function positions the cursors
at the start and end point of the specified window (or the first and
last point if no window as been specified) and uses the function
built into the digitizer to compute the area. For the model @code{TDS520}
that misses this built-in function the curve in the interval is fetched
which is than used to compute the area. To give some visual feedback
also for this model the cursors are moved to the borders of the
interval.

The function will automatically wait until a still running acquisition
sequence is finished before measuring the area. 

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} file.


@item digitizer_get_area_fast()
@findex digitizer_get_area_fast()
This function takes the same arguments as the function
@code{digitizer_get_area()} and also basically does the same. The only
difference is that instead of using the function built into the
digitizer to compute the area the curve in the specified interval is
fetched and the area is computed from these data. This function can be a
bit faster because it doesn't set the cursors (which also means that
there is no visual feedback).

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} file.


@item digitizer_get_curve()
@findex digitizer_get_curve()
The function fetches a curve from the digitizer. It expects up to two
arguments, the channel the data are to be fetched from and, optionally,
a window ID as returned by @code{digitizer_define_window()} to specify
the time interval. Valid choices of the data channel depend on the model
of the digitizer:
@table @samp
@item TDS520
@item TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2} or, alternatively @code{0} or @code{1}
@item @code{MATH1}, @code{MATH2} or @code{MATH3} or, alternatively,
@code{2}, @code{3} or @code{4}
@item @code{REF1}, @code{REF2}, @code{REF3}, @code{REF4} or,
alternatively, @code{5}, @code{6}, @code{7} or @code{8}
@end itemize
@item TDS540
@item TDS744A
@item TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4} or, alternatively
@code{0}, @code{1}, @code{2} or @code{3}
@item @code{MATH1}, @code{MATH2} or @code{MATH3} or, alternatively,
@code{4}, @code{5} or @code{6} 
@item @code{REF1}, @code{REF2}, @code{REF3}, @code{REF4} or,
alternatively, @code{7}, @code{8}, @code{9}, or @code{10}
@end itemize
@end table

The function positions the cursors at the start and end point of the
specified window (or the first and last point if no window as been
specified) to give a visual feedback.

The function will automatically wait until a still running acquisition
sequence is finished before returning a curve. The data will be returned
as an array of floating point numbers and it's the users responsibility
to supply an array for storing the data. Usually, this will be an array
defined with an unspecified number of elements.

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} file.


@item digitizer_get_curve_fast()
@findex digitizer_get_curve_fast()
This function is nearly identical to the function
@code{digitizer_get_curve()} with the only difference that the cursors
are not positioned at the start and end point of the curve to be fetched.

@item digitizer_get_amplitude()
@findex digitizer_get_amplitude()
The function returns the amplitude, i.e.@: the difference between the
maximum and minimum voltage, from the digitizer. The function takes up
to two parameters, the channel the data are to be fetched from and, optionally,
a window ID as returned by @code{digitizer_define_window()} to specify
the time interval. Valid choices of the data channel depend on the model
of the digitizer:
@table @samp
@item TDS520
@item TDS520A
@itemize @bullet
@item @code{CH1} or @code{CH2} or, alternatively @code{0} or @code{1}
@item @code{MATH1}, @code{MATH2} or @code{MATH3} or, alternatively,
@code{2}, @code{3} or @code{4}
@item @code{REF1}, @code{REF2}, @code{REF3}, @code{REF4} or,
alternatively, @code{5}, @code{6}, @code{7} or @code{8}
@end itemize
@item TDS540
@item TDS744A
@item TDS754A
@itemize @bullet
@item @code{CH1}, @code{CH2}, @code{CH3} or @code{CH4} or, alternatively
@code{0}, @code{1}, @code{2} or @code{3}
@item @code{MATH1}, @code{MATH2} or @code{MATH3} or, alternatively,
@code{4}, @code{5} or @code{6} 
@item @code{REF1}, @code{REF2}, @code{REF3}, @code{REF4} or,
alternatively, @code{7}, @code{8}, @code{9}, or @code{10}
@end itemize
@end table
Except for the model @code{TDS520}, this function positions the cursors
at the start and end point of the specified window (or the first and
last point if no window as been specified) and uses the function built
into the digitizer to compute the amplitude. For the model @code{TDS520}
that misses this built-in function the curve in the interval is fetched
which is than used to compute the amplitude. To give some visual
feedback also for this model the cursors are moved to the borders of the
interval.

The function will automatically wait until a still running acquisition
sequence is finished before measuring the amplitude.

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} file.

@item digitizer_get_amplitude_fast()
@findex digitizer_get_amplitude_fast()
This function is nearly identical to @code{digitizer_get_amplitude()}
except that the function to compute amplitudes built into the digitizer
isn't used and the cursors aren't positioned at the start and end of the
time interval.

@item digitizer_lock_keyboard()
@findex digitizer_lock_keyboard()
Usually, during an experiment the keyboard of the digitizer is
locked. But for situations where it would be useful to be able to
control the digitizer also via its keyboard it can be unlocked (and also
re-locked) from within the program. To unlock the keyboard call this
function with an argument of @code{0}, to re-lock the keyboard call it
again with a non-zero argument or no argument at all.

@end table


@node Pulser Functions, Synthesizer Functions, Digitizer Functions, Device Functions
@section Pulser functions
@cindex Pulser functions

@table @samp

@item pulser_update()
@findex pulser_update()

@item pulser_shift()
@findex pulser_shift()

@item pulser_increment()
@findex pulser_increment()

@item pulser_pulse_reset()
@findex pulser_pulse_reset()

@item pulser_next_phase()
@findex pulser_next_phase()

@item pulser_phase_reset()
@findex pulser_phase_reset()

@item pulser_lock_keyboard()
@findex pulser_lock_keyboard()
Usually, during an experiment the keyboard of the pulser is locked. But
for situations where it would be useful to be able to control the pulser
also via its keyboard it can be unlocked (and also re-locked) from within
the program. To unlock the keyboard call this function with an argument
of @code{0}, to re-lock the keyboard call it again with a non-zero
argument or no argument at all.

@end table



@node Synthesizer Functions, Multi-Device Functions, Pulser Functions, Device Functions
@section Synthesizer functions
@cindex Synthesizer functions
The only implemented synthesizer so far is the HP8647A. Its module is
loaded by specifying
@example
hp8647a;
@end example
@noindent
in the @code{DEVICES} section.


@table @samp

@item synthesizer_state()
@findex synthesizer_state()
The function queries or sets the output state of the synthesizer. i.e.@:
to switch output of RF on or off. If called to set the output state it
accepts one argument, either a non-zero value or the string @code{"ON"}
to switch output on, or zero or the string @code{"OFF"} to switch it
off. The synthesizer output is never switched on automatically!

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e.@: without an argument (unless the state has already been
set by calling the function with an argument). In query mode it either
returns either @code{1} or @code{0} to indicate the on/off state of the
RF output.


@item synthesizer_frequency()
@findex synthesizer_frequency()
The function queries or sets the RF output frequency. If called to set
the frequency it accepts one argument, the frequency in the range
between @w{250 kHz} and @w{1000 MHz}. The frequency set by the very
first call of this function is also the function that is set
automatically by a call of the function
@code{synthesizer_reset_frequency()} (see below).

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e.@: without an argument (unless the frequency has already
been set by calling the function with an argument).


@item synthesizer_attenuation()
@findex synthesizer_attenuation()
The function queries or sets the output attenuation. If called to set
the attenuation it accepts one argument, the attenuation in the range
between @w{+10 db} and @w{-136 db}.

Before the @code{EXPERIMENT} section this function can't be called in
query mode, i.e.@: without an argument (unless the attenuation has already
been set by calling the function with an argument).

@item synthesizer_step_frequency()
@findex synthesizer_step_frequency()
The function queries or sets the RF step frequency to be used in calls
of the functions @code{synthesizer_sweep_up()} and
@code{synthesizer_sweep_down()} (see below). In order to set the step
frequency it expects one argument, the step frequency in Hz. The step
frequency can be set in the @code{PREPARATIONS} section only once, but
it can be changed later in the @code{EXPERIMENT} section.

Before the step frequency has been set by calling the function with an
argument the query form of the function (i.e.@: calling it without an
argument can't be used).

@item synthesizer_sweep_up()
@findex synthesizer_sweep_up()
If there has been set both a frequency and a step frequency the function
will increment the synthesizers frequency. It returns the newly set
frequency. The function can only be called in the @code{EXPERIMENT}
section.

@item synthesizer_sweep_down()
@findex synthesizer_sweep_down()
If there has been set both a frequency and a step frequency the function
will decrement the synthesizers frequency. It returns the newly set
frequency. The function can only be called in the @code{EXPERIMENT}
section.

@item synthesizer_reset_frequency()
@findex synthesizer_reset_frequency()
If a frequency has been set at all the function will reset the
synthesizers frequency to the frequency that has been set at first. The
function can only be called in the @code{EXPERIMENT} section.

@item synthesizer_use_table()
@findex synthesizer_use_table()
This function tells the program to also adjust the attenuation when a
new frequency is set. To find out which attenuation has to be set for a
new frequency a table file is used. The name of this table file can be
passed to the function as a (string) argument. If no argument is given a
default table file is used (typically this is
@file{/usr/local/lib/fsc2/hp8647a.table}, but it may depend on the
installation).

The table file must consist of pairs of entries, a frequency and a
corresponding attenuation in db. The attenuation is being added to the
'raw' attenuation, i.e.@: to achieve an higher attenuation and a lower
output power a negative attenuation has to be specified.  If no unit are
given in the table file (i.e.@: @code{MHz} and @code{db}) the first
member of an entry must be the frequency, the second the attenuation.
The entries in the file don't have to be sorted in any way, and
the frequencies don't have to spaced equally.

The items in the table file can be separated by spaces, commas,
semicolons, colons, tabs or newlines or any combination of these
characters (a unit will also work as a separator) and the entries don't
have to be separated by a newline. Thus all the following entries would
be valid:
@example
7.90000000 MHz,   -1.90000000 db
-2.10000000 db 8.00000000 MHz   
8.1E6 -2.2 8.20000000 MHz : -2.30000000 db 8300 kHz

   -2.4 db
8.70000000MHz-2.40000000db
@end example
@noindent
As you see also blank lines don't matter. Finally, all lines starting
with a hash character, `@code{#}', are treated as comments.

If a frequency is used that isn't in the table the attenuation to be used
is extrapolated from the next neighboring frequencies. If the frequency
isn't within the range of frequencies covered by the table a warning is
printed and the attenuation for the nearest frequency is used.


@item synthesizer_att_ref_freq()
@findex synthesizer_att_ref_freq()
When a table file is used there remains the question for which frequency
to use the attenuation has been set e.g.@: by
@code{synthesizer_attenuation()}. To set this reference frequency the
function @code{synthesizer_att_ref_freq()} can be used. If the function
isn't called a frequency of @w{14 MHz} is used.


@item synthesizer_modulation()
@findex synthesizer_modulation()
This function is used to set the type, source and amplitude of the
modulation. It can set all of these parameters at once or only parts.

There are three possible types of modulation FM, AM and phase
modulation. The modulation type is specified by a string, either
@code{"FM"}, @code{"AM"}, @code{"PHASE"} or, finally, @code{"OFF"}.

Please note that setting a modulation source or amplitude while the
modulation is off (i.e.@: when @code{"OFF"} has been specified as the
modulation type) is not possible and trying to do so will make the
program abort.

The possible modulation sources are either external AC coupled, external
DC coupled, internal @w{1 kHz} or internal @w{400 Hz}. For external AC
or DC coupled modulation specify one the strings @code{"EXT AC"},
@code{"AC"}, @code{"EXT DC"} or @code{"DC"}. For internally generated
modulation with @w{1 kHz} or @w{400 Hz} use a string argument from the
following list: @code{"INT 1kHz"}, @code{"INT 1 kHz"}, @code{"INT 1"},
@code{"1kHz"}, @code{"1 kHz"}, @code{"1"}, @code{"INT 400Hz"},
@code{"INT 400 Hz"}, @code{"INT 400"}, @code{"400Hz"}, @code{"400 Hz"}
or @code{"400"}. But please note: external DC coupled modulation source
does not work with amplitude and phase modulation@!

Finally you may specify the modulation amplitude, which has to be a
number (preferably a floating point number). FM modulation amplitudes
have to be in the range between @w{0 Hz} and @w{100 kHz}, AM modulation
amplitudes between @w{0 %} and @w{100 %} and phase modulation amplitudes
between @w{0 degree} and @w{10 degree}.

Only in the first call of the function all three arguments, i.e.@: the
modulation type, source and amplitude, should be passed to the
function. In further calls not all of the arguments have to be given
again. Instead, in further calls it is sufficient to specify only for
example a new amplitude. The same, of course, holds for the modulation
source.

If the modulation type becomes changed, the source and amplitude reverts
to the settings that were specified in previous calls of the function
when this modulation type was still active. I.e.@: if at first AM
modulation using an external AC coupled source and an amplitude of
@w{50 %} was set and then the modulation was changed to FM with
different settings for source and amplitude, another call switching back
to AM modulation will also restore the settings of external AC coupled
source and @w{50 %} amplitude.


@item synthesizer_mod_type()
@findex synthesizer_mod_type()
As an alternative the function @code{synthesizer_modulation()} the
modulation type can be also set via the function
@code{synthesizer_mod_type()}. It accepts on of the three string
arguments @code{"FM"}, @code{"AM"}, @code{"PHASE"} or, finally,
@code{"OFF"} (or the numbers @code{0} for FM, @code{1} for AM, @code{2}
for phase modulation or @code{3} for switching modulation off).

If called with no argument it will return the currently active modulation
type as an integer number.


@item synthesizer_mod_source()
@findex synthesizer_mod_source()
If the modulation type has been set bedore the modulation source can be
set directly via this function. It accepts one of the following strings:
@code{"INT 1kHz"}, @code{"INT 1 kHz"}, @code{"INT 1"}, @code{"1kHz"},
@code{"1 kHz"}, @code{"1"}, @code{"INT 400Hz"}, @code{"INT 400 Hz"},
@code{"INT 400"}, @code{"400Hz"}, @code{"400 Hz"} or
@code{"400"}. Alternatively, the number @code{0} can be specified for
external AC coupled modulation source, @code{1} for an external DC
coupled source, @code{2} for the internally generated @w{1 kHz} source
and @code{3} for the internal @w{400 Hz} source.

If the function is called with no argument it will return the modulation
source setting for the currently active modulation type as an integer number.
You can neither set nor obtain the modulation source as long as the
modulation is switched off, trying to do so will result in aborting the
program.


@item synthesizer_mod_ampl()
@findex synthesizer_mod_ampl()

If the modulation type has been set this function can be used to set the
modulation amplitude. For FM the allowed range of frequencies is from
@w{0 Hz} to @w{100 kHz}, for AM amplitudes between @w{0 %} and @w{100 %}
are acceptable and for phase modulation values between @w{0 degree} and
@w{10 degree} are valid.

If called with no argument, the function will return the amplitude
setting for the currently active modulation type. You can neither set
nor obtain the modulation amplitude as long as the modulation is
switched off, trying to do so will result in aborting the program.



@end table

@node Multi-Device Functions, , Synthesizer Functions, Device Functions
@section Multi-Device functions
@cindex Multi-Device functions

There are a few convenience functions that use two or more devices. They
use the single-device functions (and thus will print error messages if
the modules for the required devices aren't loaded or don't if the
modules don't support the needed functions). The module they are defined
in is automatically loaded, so it needs no special entry in the
@code{DEVICES} section.


@table @samp

@item get_phase_cycled_area_1d()
@findex get_phase_cycled_area_1d()


@item get_phase_cycled_area_2d()
@findex get_phase_cycled_area_2d()

@end table
