@c $Id$
@c
@c Copyright (C) 1999-2003 Jens Thoms Toerring
@c
@c This file is part of fsc2.
@c
@c Fsc2 is free software; you can redistribute it and/or modify
@c it under the terms of the GNU General Public License as published by
@c the Free Software Foundation; either version 2, or (at your option)
@c any later version.
@c
@c Fsc2 is distributed in the hope that it will be useful,
@c but WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with fsc2; see the file COPYING.  If not, write to
@c the Free Software Foundation, 59 Temple Place - Suite 330,
@c Boston, MA 02111-1307, USA.


@node Overview, GUI, Top, Top
@chapter Overview
@cindex Overview


@code{fsc2} is a program for remotely controlling spectrometers,
currently still with a strong bias toward cw- and pulsed EPR
spectrometers. But the design of @code{fsc2} should make it also easy to
use it to a broad range of experiments not releated to EPR. Its central
component is an interpreter that executes a script describing the
experiment in a language which in the following will be called
@code{EDL}
@cindex @code{EDL}
(@b{E}xperiment @b{D}escription @b{L}anguage). Making the execution of
the experiment completely controllable by the user via a script is quite
different from the approach usually taken in programs for remote
spectrometer control which tend to have a graphical user interface where
just the experimental parameters can be set and then one of a set of
hard-coded experiments is started.

The obvious drawback with the traditional approach is that there is
always only a fixed set of experiments that can be done. The problems
start when one needs to do an experiment the program was not written
for. Either one has to find some ways to trick the program into doing
something it wasn't intended for or, if this fails, to change the
program itself. This not only tends to take a lot of time (especially if
the person who wrote the program isn't around anymore) but often also
leads to the introduction of new bugs or even the realization that the
program has not written in a way that allows it to be adapted to the new
requirements, in which case the old program becomes useless and has to
be rewritten from scratch.

@code{fsc2} is different in this respect because it wasn't developed
with a certain set of experiments in mind but is intended to make it as
easy as possible to do all kinds of experiments. Of course, this comes
with a small price: one has to specify clearly how the experiment is to
be done by writing a (usually rather short) script. @code{fsc2} will
interpret this script and do the experiment accordingly. Writing a
script may sound difficult, but the @code{EDL} language that is used to
define an experiment isn't very hard to learn. And when this hurdle has
been taken you will have complete control over the way the experiment is
done. Just to give a few trivial examples: sometimes signals are
distributed over a large field range with nothing of interest in
between, so it would be rather useful to skip these regions. Most normal
programs won't allow this and one has to either record also the
uninteresting field regions (thus losing lots of time) or to manually
restart the experiments for each of the regions of interest. In
contrast, with @code{fsc2} it shouldn't take more than a few minutes to
write an @code{EDL} script consisting of just a few lines of code that
can not only skip these regions but also repeat the experiment as often
as needed, and if necessary do different numbers of accumulations of the
different parts (if, for example, the signals are huge in some of the
regions while in others they are hardly detectable above the noise
floor) or with automatically changing the lock-in amplifiers sensitivity
or time constant in between.

But one does not have to write a new script for every experiment one is
going to do -- for the standard experiments, once such a script has
been written, only the relevant parameters have to be changed. And
because one can use variables in the script it's easy to have a block
for defining the parameters somewhere at the start of the script and
change only these if necessary. If this is still too much hassle it is
even possible to automatically create from the (slightly modified)
@code{EDL} script a script which allows to set the parameters via a
graphical user interface and then have the script generate the
@code{EDL} script which in turn is passed directly to @code{fsc2}
without any further user interaction. Of course, you don't have to use
the conversion tools but also can write such scripts yourself using
@code{fsc2} built-in interface to accept @code{EDL} scripts from
external sources. Once such a script has been created the users don't
even have to learn how to write @code{EDL} scripts and have all the
convenience of the traditional type of programs without sacrificing the
flexibility of @code{fsc2}.

Another common problem with the traditional type of programs is the use
of different devices or the integration of new ones. Usually, a fixed
set of devices is hard-coded into the program and changing just one
device requires a major rewrite. In contrast, @code{fsc2} has a strictly
modular approach to the handling of devices. For each device a separate
module exists that only gets loaded if it is listed explicitely in the
@code{EDL} script. Thus changing the experiment to work with e.g.@: a
different lock-in amplifier or digitizer usually does not require more
than changing one line of the @code{EDL} script (at least as long as
the devices aren't too different in their capabilities). Moreover, this
is also a major advantage when a new device has to be integrated.
Instead of changing the whole program that controls the experiment only
a module for the new device has to be written. Writing such a module
does not even require a thorough understanding of the way @code{fsc2}
works but only some knowledge about a few conventions (which are
explained in detail in one of the later parts of this manual). This also
allows the module to be tested independently of the main program and
there is no danger of introducing new bugs into @code{fsc2} itself.

The advantages of the approach taken in @code{fsc2} have made it
possible to use it successfully to control spectrometers in S-, X- and
W-band and at 360 GHz, using completely different hardware, and for
all kinds of experiments, ranging from cw-EPR, ENDOR, EPR on transient
signals to experiments with pulsed microwave excitation and phase
cycling.

The manual is organized along the following lines: the next chapter
(@pxref{GUI}) explains in detail the graphical user interface used for
starting an @code{EDL} script and displaying the measured data. The
following chapter (@pxref{EDL}) explains how to monitor @code{fsc2}'s
progress via the internet, using a browser. Then follows a chapter
(@pxref{EDL}) that explains all about the @code{EDL} language. To
give you an expression how easy writing an @code{EDL} script is you
may have a look at the first example (@pxref{Basics}) which discusses a
script for doing a simple cw-detected EPR-experiment.

The next chapter (@pxref{Built-in Functions}) lists all functions that
are already built into @code{fsc2}. These include functions for
displaying data, storing the measured data in one or more files,
functions to extend the graphical user interface used during the
experiment and, finally, mathematical and other useful utility
functions. The following chapter (@pxref{Device Functions}) discusses
the functions that can be used to deal with the devices for which
modules are already exist (at the time of writing this there are 29
different modules to choose from).

Experiments with pulsed microwave or RF excitation play an ever
increasing role in modern EPR and @code{fsc2} has an extensive set
of commands and functions for dealing with pulses and pulse generators.
These are explained in the chapter following the functions for other
devices (@pxref{Using Pulsers}).

The next chapter (@pxref{Command Line Options}) lists all the command
line options that can be passed to @code{fsc2} and the following chapter
(@pxref{GUI-fying}) explains in detail how to convert an @code{EDL} into
a script with a graphical user interface for editing the relevant
paramters. The remaining chapters (@pxref{Cloning Devices},
@pxref{Internals}, @pxref{Modules}) explain in detail everything there
is to know about writing new modules, including a short overview about
how @code{fsc2} works internally, which may also be helpful when writing
a new module.
