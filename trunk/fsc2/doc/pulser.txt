Here are some typical entries in an ASSIGNMENTS section:

ASSIGNMENTS:

TIMEBASE: 200 ns;     /* always default to minimum possible time */

TRIGGER_MODE: EXTERNAL, LEVEL = 150 mV, SLOPE = POS;
or
TRIGGER_MODE: INTERNAL, REPEAT_TIME = repeat_time;
or
TRIGGER_MODE: INTERNAL, REPEAT_FREQUENCY = repeat_frequency;

Function: POD = 2,             e.g. for a DG2020
		  CHANNEL = 4, 5, 6,
		  INV,
		  DELAY = 210 ns,
		  V_HIGH = 3.5 V,
		  V_LOW = -0.5 V;

or

Function: CHANNEL = 4,         e.g. for a HFS900, that has no pods
		  INV,
		  DELAY = 210 ns,
		  V_HIGH = 3.5 V,
		  V_LOW = -0.5 V;



   Drivers for pulse generators have to be a bit different from drivers for
   all other devices. This results from fsc2 having built in some special
   syntax elements for the handling of pulsers, i.e. the ASSIGNMENTS section
   and the extra commands for setting pulse parameters. In order not to make
   it necessary to code information about the type of the pulse generator into
   the program the pulser driver must be much more `cooperative' then the
   other device drivers.  /* only for EXTERNAL mode */

   First of all, this means that the pulser driver has to define a set of
   functions and make the addresses of these functions known to the main
   program in the init_hook() function. To do so there is a global structure
   in the main program called `pulser_struct' that has to be filled in in
   the init_hook() function. It contains mostly entries for the addresses of
   the functions needed by the main program plus a few extra variables for
   special features of the pulsers. Here is the typedef of this structure:


    typedef struct {

		char *name;
    	bool is_trigger_out;
    	long trigger_out_channel_number;

    	bool ( *assign_function )( int function, long connector );
    	bool ( *assign_channel_to_function )( int function, long channel );
    	bool ( *invert_function )( int function );
    	bool ( *set_delay_function )( int function, double delay );
    	bool ( *set_function_high_level )( int function, double high_voltage );
		bool ( *set_function_low_level )( int function, double low_voltage );
    	bool ( *set_timebase )( double timebase );
		bool ( *set_trigger_mode )( int mode );
    	bool ( *set_repeat_time )( double time );
		bool ( *set_trig_in_level )( double voltage );
		bool ( *set_trig_in_slope )( int slope );
		bool ( *set_trig_in_impedance )( int state );

		bool ( *set_phase_reference )( int phase, int function );

		bool ( *new_pulse )( long pulse_number );
    	bool ( *set_pulse_function )( long pulse_number, int function );
    	bool ( *set_pulse_position )( long pulse_number, double time );
    	bool ( *set_pulse_length )( long pulse_number, double time );
    	bool ( *set_pulse_position_change )( long pulse_number, double time );
    	bool ( *set_pulse_length_change )( long pulse_number, double time );
		bool ( *set_pulse_phase_cycle )( long pulse_number, long cycle );

    	bool ( *get_pulse_function )( long pulse_number, int *function );
    	bool ( *get_pulse_position )( long pulse_number, double *time );
    	bool ( *get_pulse_length )( long pulse_number, double *time );
    	bool ( *get_pulse_position_change )( long pulse_number, double *time );
    	bool ( *get_pulse_length_change )( long pulse_number, double *time );
		bool ( *get_pulse_phase_cycle )( long pulse_number, long *cycle );

		bool ( *phase_setup_prep )( int func, int type, int pod, long val,
									long protocol);
		bool ( *phase_setup )( int function );
		bool ( *set_phase_switch_delay )( int function, double time );
		bool ( *set_grace_period )( double time );

    } Pulser_Struct;


   If one of the functions can't be defined for the pulser its entry in the
   structure must not be set. Before the init_hook() function is called all
   addresses will be initialised to NULL and not setting one of them tells the
   main program that the corresponding function isn't available. In this case
   an appropriate error message can be printed by fsc2 if the function found
   to be needed in the interpretation of the EDL file.

   Each function may return either `OK' or `FAIL', where `FAIL' means that an
   error happened that's recoverable. On errors that make the driver think
   that it's impossible to continue it should throw an exception instead, thus
   stopping the interpretation of the EDL file.

   With the exception of the four functions

		set_pulse_position(),
		set_pulse_length(),
		set_pulse_position_change() and
		set_pulse_length_change()

   and the six functions that return pulse properties these functions will
   only called before the experiment is started, i.e. in the time between the
   calls of the init_hook() and the test_hook() function. All these functions
   also don't show up in the Functions' data base - fsc2 expects them to exist
   and can find out if they do via the addresses in the pulser structure.

   In the time, i.e. the time beween the calls of the init_hook() and
   test_hook() function, the driver has to create an internal representation
   of the pulser state and check its consistency, throwing an exception the
   moment inconsistent settings are detected. In the test_hook() function the
   driver should make a final check on the consistency of the settings.

   In the test_hook() the driver should store away the initial state of all
   pulses, so that the state of the pulser before the start of the experiment
   can be reconstructed later.

   During the test run. i.e. between the test_hook() and the exp_hook()
   function call, when the global variable TEST_RUN is set, functions to
   change pulse positions and lengths will be called. In this functions the
   internal representation of the pulser state has to be updated and the
   consistency of the state has to be checked (i.e. do the pulses stay
   separated, don't they overtake each other, do the lengths remain larger
   than zero, do the positions stay larger than zero and don't exceed the
   maximum channel length, etc.). The driver also has to store the longest
   duration of a pulse sequence during the test run to be used later in the
   calculation of the padding needed to set a fixed repeat time for the
   experiment.

   Finally, in the exp_hook() the driver has to set up the pulser to the
   initial state as it was stored in the test_hook().

   In the following the diverse functions and variables from the pulser
   structure are discussed. Wherever times are involved they are meant to be
   in seconds and are passed as doubles. They are guaranteed to be multiples
   of 1 ns, i.e. multiplying by 1e9 and applying lround() leeds to a valid
   time in ns. Voltages are always in Volts.


   name:
   ====

   This defines the name of the pulser to be used in error messages. Setting
   the name also indicates to fsc2 that a pulser driver has been loaded. If no
   name is set, fsc2 will conclude that there is no pulser and will reject all
   commands that need a pulser (i.e. everything from the ASSIGNMENTS section
   as well as commands for setting or changing pulses). If a pulser driver
   finds that a name has already been set (i.e. `name' is not NULL) it has to
   abstain from resetting it but has to quit the init handler function
   immediately with a return value that indicates an unrecoverable error.


   is_trigger_out  and  trigger_out_channel_number:
   ==============	    ==========================

   Some pulsers (e.g. the Tektronix HFS900) have a special trigger out channel
   as an additional connector. If such a trigger out channel exists, the
   boolean variable `is_trigger_out' in the `pulser_struct' structure should
   be set and a special connector number be assigned to this connector and
   stored in `trigger_out_channel_number' (this number will in turn be used
   for assignments of the DETECTION TRIGGER without a channel or pod number in
   the EDL file).


   assign_function:
   ===============

   Much of the handling of the pulser is centred around the concept of the
   function of pulses. For example, the function of some of the pulses is to
   switch the microwave power or to create a detection trigger etc. The pulser
   driver does not have to know about the meaning of these functions, for it
   these functions are simply numbers, starting at `PULSER_CHANNEL_FUNC_MIN'
   and running up to (and including) `PULSER_CHANNEL_FUNC_MAX', i.e. there are
   `PULSER_CHANNEL_NUM_FUNC' different functions. All the pulser driver has to
   care about is that all the pulses assigned to the same function will go to
   the same output connector.

   One of the functions the pulser driver has to supply assigns an output
   connector to one of the functions. This function should have the form

       bool assign_function( int function, long connector )

   `connector' is the number of the POD channel (e.g. for the DG2020 pulser)
   or the channel number (for the HFS900) the pulses with the function defined
   by the first argument will appear on. The connector numbers should be
   identical to the numbers given on the instruments panel to avoid confusion
   for the users.


   assign_channel_to_function:
   ==========================

   Some pulsers have more internal channels than output connectors, e.g. the
   DG2020, that has 36 internal channels of which only some are connected to
   the POD outputs and that has a special command to assign a certain internal
   channel to one of the (usually 12) POD channels. While a function is
   directly mapped onto one of the POD channels, the internal channel to POD
   channel assignment can be made adjustable by the user by the function:

      assign_channel_to_function( int function, long channel )

   The second argument is the internal channel number and the first the
   function the channel is to be assigned to. It should be possible to map
   several internal channels to one function to allow fast switching for phase
   patterns or setting of replacement pulses.

   Drivers for pulsers that don't have this feature should either leave the
   entry in the `pulser_struct' structure unchanged or set it to NULL.

   If no channel to function assignment is done for a pulser that has channels
   and pods the driver is free to pick an assignment by itself. It is probably
   reasonable to use the channels with the highest numbers since most users
   will tend to use the low number channels for storing test pulse sequences
   that they don't like too much being overwritten just because they forgot to
   set a channel to function assignment in their EDL program.


   invert_function:
   ===============

   Some devices connected to the pulser use inverted logic, i.e. for the
   pulse-off state a high voltage has to be used while the pulse-on state
   should have a negative (or at least lower) voltage. When the function

      invert_function( int function )

   is called the output channel assigned to the function given as argument has
   to be deliver inverted output voltages. How this is be done internally,
   i.e. either by setting pulses for just the times where no pulses are
   required by the EDL program, or by exchanging the high and low output
   voltage is up to the driver.


   set_delay_function:
   ==================

   To eliminate effects due to different cable lengths etc. for each pulse
   function a (positive) delay may be set. This is done by the function

      set_delay_function( int function, double delay )

   with the first argument as the function (mapped to one of the output
   connectors) and the second argument the delay time in seconds. The delay
   time the function receives is guaranteed to be positive.


   set_function_high_level:
   =======================

   Using the function 

      set_function_high_level( int function, double high_voltage )

   the high voltage level for the output connector mapped to the function
   given as the first argument is set.


   set_function_low_level:
   =======================

   Using the function 

      set_function_low_level( int function, double low_voltage )

   the low voltage level for the output connector mapped to the function given
   as the first argument is set.


   set_timebase:
   ============

   To set the time base of the pulser the function

      set_timebase( double timebase )

   is called. The argument is the time base in seconds. All pulse positions
   and lengths will have to be integral multiples of this time base (within a
   resolution of 1 nanosecond). If the function isn't called the pulser should
   be set to the smallest available time base with an integer number of
   seconds. The timebase passed to the function is guaranteed to be at least
   1 ns and a integral multiple of 1 ns,

   
   set_trigger_mode:
   ================

   This function sets the way the pulser is started - if the argument `mode'
   is `EXTERNAL' the pulser sequences should be started due to an external
   trigger event while for `INTERNAL' the pulse sequence has to be started the
   moment the pulser gets a RUN command.

      set_trigger_mode( int mode )

   The function will only receive the values `EXTERNAL' and `INTERNAL' as
   arguments.


   set_repeat_time:
   ===============

   If the pulser mode set by the previous function is INTERNAL the pulse
   sequence is repeated as long as no STOP command is send to the pulser.
   Often, the repetition rate of the pulser is much too high either for the
   sample (due to the relaxation times) or the detection device has a
   comparatively long re-arming time constant. To slow down the pulser, the
   pulse sequence can be lengthened to be as long as the argument to the
   function

      set_repeat_time( double time )

   were time is the total time in seconds of a pulse sequence including
   the additional padding. If the pulse sequences are externally triggered
   this function (as well as the following one) has no effect and calling it
   should be construed as an error. The repeat time the function gets passed
   is garanteed to be at least 1 nanosecond.


   set_trig_in_level:
   =====================

   If the pulser is triggered by an external event using the function

      set_trig_in_level( double voltage )

   the trigger threshold level (in Volt) for the detection of the external
   trigger can be set.


   set_trig_in_slope:
   =================

   If the pulser is triggered by an external event the function

      set_trig_in_slope( int slope )

   sets the slope for the detection of the external trigger. The argument is
   guaranteed to be either `POSITIVE' or `NEGATIVE'.




   Now follow the functions that are concerned with setting pulse properties:
   -------------------------------------------------------------------------


   set_pulse_function:
   ==================

   Each pulse needs to be assigned to one of the functions (see above) and
   thus mapped to one of the output connectors. The function to do this is

      set_pulse_function( long pulse_number, int function )

   with the pulse number and the function as argument. As for the following
   functions it holds that if a pulse of this number does not exist yet it is
   created by the call to the function.


   set_pulse_position:
   ==================

   While the test_hook() function hasn't been called yet this function sets
   the start position of a pulse:

      set_pulse_position( long pulse_number, double time )

   with the pulse number and the start position in seconds as the argument.
   When the test_hook() function has been run the function has a different
   purpose: It sets a new position for a pulse. In this case it's an fatal
   error if the pulse has not been defined before. How this is realized,
   either by setting a flag in the function test_hook() and checking it or
   assigning a new address to the functions entry in the `pulser_struct'
   structure is up to the driver.


   set_pulse_length:
   ================

   As in the case of the previous function, before test_hook() the function
   run it sets the initial length of a pulse:

      set_pulse_length( long pulse_number, double time )

   where the second argument is the length of the pulse in seconds. After
   test_hook() has been run it just changes the length of an already existing
   pulse.


   set_pulse_position_change:
   =========================

   This function sets the default change of the position of a pulse when
   functions to move the pulse are called (e.g. `shift_pulse()').

      set_pulse_position_change( long pulse_number, double time )

   The second argument is the position change in seconds. 


   set_pulse_length_change:
   =======================

   This function sets the default change of the length of a pulse when
   functions to change the pulse are called (e.g. `incr_pulse()').

      set_pulse_length_change( long pulse_number, double time )

   The second argument is the length change in seconds. 


   set_pulse_maxlen:
   ================

   This function sets a maximum length for a pulse, if this length gets
   exceeded, the driver has to automatically switch to the replacement pulses
   for this pulse by switching the assignment to the output connector from the
   channel the pulse is created with to the channel the replacement pulses are
   defined in.

		set_pulse_maxlen( long pulse_number, double time )

	Obviously, this command is only available for digitizers like the DG2020
	that have more internal channels than output connectors (PODs).


	set_pulse_replacements:
	======================

	This function defines a group of replacement pulses for a pulse with a
	maxlen (see previous function). The arguments beside the pulse numer are
	the number of replacement pulses (probably it will always be 2, but don't
	count on it...) and an array of pulse numbers of the replacement pulse.

		set_pulse_replacements( long pulse_number,
		                        long number_of_replacement_pulses,
								long *list_of_replacement_pulses );

	Again, as in the case of the set_pulse_maxlen() function, this function
	only makes sense for pulsers that have more internal channels than output
	connectors (PODs).


   get_pulse_function:
   ==================

   The driver should be prepared to return the function of a pulse on a call
   to the function 

        get_pulse_function( long pulse_number, int *function )

	'pulse_number' is obviously the number of the pulse thats function is to
	be returned and the second argument is a pointer in which the function is
	to be stored.


   get_pulse_position:
   ==================

   This function should return the position of a pulse

	    get_pulse_position( long pulse_number, double *time )

	It always has to return the actual position, not the initial position.


   get_pulse_length:
   ================

   This function should return the length of a pulse

	    get_pulse_length( long pulse_number, double *time )

	It always has to return the actual length, not the initial length.


   get_pulse_position_change:
   =========================

   This function returns the actual position change of a pulse:

      get_pulse_position_change( long pulse_number, double *time )


   get_pulse_length_change:
   =======================

   This function returns the actual length change value of a pulse:

      get_pulse_length_change( long pulse_number, double *time )


   get_pulse_maxlen:
   ================

   This function returns the maximum length of a pulse:

		get_pulse_maxlen( long pulse_number, double *time )

	Obviously, this command is only available for digitizers like the DG2020
	that have more internal channels than output connectors (PODs).





###############################################################################

typedef struct {
	bool ( *assign_function )( long, long );
	bool ( *assign_channel_to_function )( long, long );   /* only DG20202 */
	bool ( *invert_function )( long );
	bool ( *set_delay_function )( long, long );
	bool ( *set_function_low_level )( long, double );
	bool ( *set_function_high_level )( long, double );
	bool ( *set_timebase )( long );
	bool ( *set_trigger_mode )( long );
	bool ( *set_repeat_rate )( long );
	bool ( *set_repeat_frequency )( double );

	bool ( *set_pulse_function )( long, long );
	bool ( *set_pulse_position )( long, long );
	bool ( *set_pulse_length )( long, long );
	bool ( *set_pulse_position_change )( long, long );	
	bool ( *set_pulse_length_change )( long, long );
	bool ( *set_pulse_maxlen )( long, long );
	bool ( *set_pulse_replacements )( long, long, long * );

	char *name;
	bool is_trigger_out;
	long trigger_out_number;
} Pulser_Functions;
	







Ein Pulser-Treiber muss folgende Funktionen zur Verfuegung stellen:

ASSIGNMENT Functions

1. assign_function

   Zuweisung einer Funktion entweder zu einem POD oder einem Channel,
   je nach dem, was vorhanden ist.

   (Beim HFS900 ist der Detection-Trigger automatisch zugewiesen, ausser
    wenn sie explizit anders gesetzt wird)

2. assign_channel_to_function

   Nur, wenn PODs vorhanden sind um Channel->POD Assignment vorzunehmen,
   anderenfalls Fehlermeldung ausgeben.
   Wenn nicht aufgerufen erfolgt Zuweisung automatisch.

3. invert_function

   Invertiert den POD oder Channel

4. set_function_delay

   Setzt Delay fuer POD oder Channel

5. set_function_level

   Setzt die Level fuer POD oder Channel.

6. set_timebase

   Setzt timebase des Pulsers

7. set_repeat_rate /set_repeat_frequency


PULSE Functions


1. set_pulse_function

2. set_pulse_pos

3. set_pulse_len

4. set_pulse_dpos

5. set_pulse_dlen

6. set_pulse_mlen

7. set_pulse_repl


Grundlegende Vorgehensweise:

Bis zur EXPERIMENT section nur Abbild im Speicher und Kontrolle, dass Grenzen
nicht ueberschritten werden.

