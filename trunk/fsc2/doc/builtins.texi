@c $Id$

@node Built-in Functions, Device Functions, EDL, Top
@chapter Built-in Functions

@ifinfo
@menu
* Output functions::        Functions for printing, drawing and storing.
* Interaction functions::   Functions buttons and sliders.
* Mathematical functions::  Function for doing mathematics.
* Auxiliary functions::     All other functions.
@end menu
@end ifinfo


@node Output functions, Interaction functions, Built-in Functions, Built-in Functions
@section Output functions
@cindex output functions

@table @samp
@item print()
@anchor{print}
@findex print()
This function prints text into the output browser in the main form of
@acronym{fsc2}.  It needs a @i{format string}
@cindex format string
as its very first argument. The @i{format string} can contain any text
as well as a special character, @code{#},
@findex # @r{(in @code{print()} function)}
that works as a placeholder for data to be printed in its place.  Here's
a first simple example: You want to print the value of a variable called
@code{I}, that has been assigned a value of 3. Now,
@example
print( "The value of I is #.\n", I );
@end example
@noindent
will print, when the program is interpreted,
@example
The value of I is 3.
@end example
@noindent
But you can have not only one but as many placeholder characters in the
@i{format string} as you need. Of course, the number of placeholder
characters has to match the number of variables (or data) following the
@i{format string}. If the number of @code{#}'s and the number of
variables to be printed doesn't fit a warning is printed. If there are
too many @code{#}'s the superfluous ones are simply printed, if
there are not enough only as many variables as there are @code{#}'s are
printed, the rest is discarded.

You may use @code{print()} to print integer or floating point values
(that includes the return values of functions) and variables and strings
(i.e.@: text enclosed in double quotes, @code{"}).  Here's a longer,
somewhat contrived example:
@example
print( "The # of # is: #\n", "sine", x, sin( x ) );
@end example
@noindent
This will print (assuming @code{x} equals 0.5):
@example
The sine of 0.500000 is: 0.479426
@end example

There are special sequences allowed in the @i{format string}. They all
start with an @i{escape character}, the backslash, @code{\}. Here's a
list of all recognized special sequences:
@table @samp
@cindex escape characters (in @code{print()} function)
@item \n
Linefeed character: Ends a line, everything following starts on a new
line. Thus several lines can be printed at once by one call of
@code{print()}. @code{print()} does not automatically add a linefeed.
@item \t
Embed a tabulator character, tab stops are set at every eighth character.
@item \\
Prints a backslash, @code{\}, thus switching off the special meaning of the
backslash as an escape character.
@item \"
Prints a quote - use it to embed quotes into the @i{format
string}.
@item \#
Prints a @code{#}, thus switching off the special meaning of the
@code{#} character as a placeholder for variables to be printed.
@item \T
While normally nothing is printed while a test of the @code{EXPERIMENT}
experiment section of an @acronym{EDL} file is run, if the @i{format
string} starts with this escape sequence the @code{print()} function
will produce output already in the test run.
@end table


@item init_1d()
@anchor{init_1d}
@findex init_1d()
Initializes the display for one-dimensional experiments - without a call to
this function no data will be displayed. The function takes up to six
arguments but all of them are optional. They are:
@enumerate
@item
Number of curves to be displayed, maximum is currently 4 curves. If not given
it defaults to 1.
@item
Number of points, if missing or zero or negative it will be treated as
unknown and default to 64 points. If the specified or the default value
turns out to be too small it is adjusted automatically in the experiment
so that all data fit into the display.
@item
Start value of the @i{x}-axis. If missing (or undefined, see next point)
point numbers are printed, starting with 1 (if @acronym{FORTRAN} style
array offsets are used, for C style arrays the starting value is 0).
@item
Increment for data along the @i{x}-axis (thus restricting the display to
equally spaced data). Setting it to zero implies that the start value
and the increment are undefined and point numbers are shown
instead. Negative increments are handled correctly.
@item
String variable with label to be shown at the @i{x}-axis.
@item
String variable with label to be shown at the @i{y}-axis.
@end enumerate

Formally, the function with its arguments can be written as

@example
init_1d( [ n_curves [ , n_points [ , start, increment ] ], ]
         [ x_label [ , y_label ] ] )
@end example
@noindent
This means that the function can be called in all of the following ways:

@example
init_1d( n_curves, n_points, start, increment, x_label, y_label )
init_1d( n_curves, n_points, start, increment, x_label )
init_1d( n_curves, n_points, x_label, y_label )
init_1d( n_curves, n_points, x_label )
init_1d( n_curves, n_points )
init_1d( n_curves, x_label, y_label )
init_1d( n_curves, x_label )
init_1d( n_curves )
init_1d( x_label, y_label )
init_1d( x_label )
init_1d( )
@end example
@noindent
In error messages the start value and the increment of the data
displayed at the @i{x}-axis are (in contrast to the point numbers)
referred to as `real world coordinates'.


@item init_2d()
@anchor{init_2d}
@findex init_2d()
Initializes the display for two-dimensional experiments - without a call to
this function no data will be displayed. The function takes up to nine
arguments but all of them are optional. They are:
@enumerate
@item
Number of data sets to be displayed, maximum is currently 4. If not
given it defaults to 1.
@item
Number of points in @i{x}-direction, if missing or less than 1 it will be
treated as unknown and default to 64. If the specified or the default value
turns out to be too small it is adjusted automatically in the experiment
so that all data fit into the display.
@item
Number of points in @i{y}-direction, if missing or less than 1 it will
be treated as unknown and default to 32. If the specified or the default
value turns out to be too small it is adjusted automatically in the
experiment so that all data fit into the display.
@item
Start value of the @i{x}-axis. If missing (or undefined, see next entry)
point numbers are printed, starting with 1 (or 0, depending on the
setting for array start-offsets).
@item
Increment for data along the @i{x}-axis (thus restricting the display to
equally spaced data). Setting it to zero implies that the start value
and the increment are undefined and point numbers are shown instead.
@item
Start value of the @i{y}-axis. The same rules as for the @i{x}-axis apply
for missing or undefined values.
@item
Increment for data along the @i{y}-axis. The same rules as for the
@i{x}-axis apply for missing or undefined values.
@item
String variable with label to be shown at the @i{x}-axis.
@item                
String variable with label to be shown at the @i{y}axis.
@item
String variable with label to be shown at the @i{z}-axis.
@end enumerate
Formally, the function with its arguments can be written as
@example
init_2d( [ n_data_sets [ , n_x_points [ , n_y_points, 
         [ , x-start, x-increment, y-start, y-increment ] ,
         ]  ]  ] [ x-label [ , y-label [ , z-label ] ] ] )
@end example


@item display( )
@anchor{display}
@findex display()
This function has to be called to display data in 1-dimensional as well as
2-dimensional experiments. It takes the following arguments:

@enumerate
@item
The (@i{x}) point number of the data point (if only a single number is
given as the third argument) or the point number of the first data point
in the data array passed as third argument.
@item
Only in 2D-experiments: The @i{y}-point number of the data point or the
point number of the first data point in the data array.
@item
The data point or an (one-dimensional) array of data.
@item
Number of the curve or data set the data are to be displayed in. If missing it
defaults to the first curve, 1. If there is more than one data set given
in the @code{display()} command the curve number @strong{can't} be left out.
@end enumerate
These arguments can be repeated as many times as there are data to be
displayed simultaneously (but in this case none of the arguments may be left
out!).

Formally, the function with its arguments can be written for 1D-experiments as
@example
display( n_x_point, data [ , n_curve [ , ... ] ] )
@end example
@noindent
while for 2D-experiments it is
@example
display( n_x_point, n_y_point, data [ , n_curve [ , ... ] ] )
@end example


@item change_scale()
@anchor{change_scale}
@findex change_scale()
This function allows it to change the scale settings (originally set in
the call of @w{@code{init_1d()}} or @w{@code{init_2d()}}) after an
experiment has been started. With a one-dimensional display the function
can be passed a maximum of two arguments, the new start value of the
@i{x}-axis and the new @i{x}-increment. For two-dimensional display the
function also accepts a new start value for the @i{y}-axis as well as
the @i{y}-increment. If one of these velues should remain unchanged
instead of a value a string (e.g.@ @code{"keep"}) can be passed as the
argument.


@item clear_curve()
@anchor{clear_curve}
@findex clear_curve()
Removes one or more curves from the display. As many arguments as there
are curves can be used. No arguments at all implies the first
curve. Invalid arguments are discarded and an error message is printed.


@item get_file( )
@anchor{get_file}
@findex get_file()
Opens a new file and returns a unique identifier for the file that can
be stored in an integer variable and is to be used in calls to functions
of the @w{@code{save_xxx()}}-family. If no argument is given a file selector
is shown and lets the user choose a file. If opening the selected file
fails the user is asked to select a different file name. If the user
cancels the selection of a file (s)he is asked for confirmation since
data may get lost. If the user decided not to select a file the function
returns an (invalid) file identifier of @code{-1}.

The function accepts up to four arguments, all of them optional. The
first one is usually the prompt string to be printed in the file
selector. If it is missing or is the empty string (use `@code{""}' to
create an empty string) it defaults to `@i{Please enter a file
name:}'. The second argument is a pattern for the file name, defaulting
to `@i{*.dat}'. You may use all the usual wildcard characters you're
used to from the shell. The third argument is the directory the search
for the file name should start from. Finally, as the fourth and last
argument you may pass a file name to the function as the default file
that appears in the entry for the selected file.

But there's also an alternative. If the very first string (that is
usually used for the prompt string) starts with a backslash `@code{\}'
the following characters (i.e.@: everything except the leading
backslash) are taken as the name of the file to be used automatically.
The file selector will not be shown and instead the hard-coded file name
will be used. Only if opening this file fails the remaining parameters
will be used when asking for an alternative file (except the prompt
string, the default will be used).

If @code{get_file()} is never called, on the first call to a function
from the @code{save_xxx()}-family the user is asked to select a file and
this file is used exclusively in further @code{save_xxx()}-calls.
I.e.@: either @code{get_file()} is called before any save-operation or
never at all!


@item save()
@anchor{save}
@findex save()
Writes one or more data or complete arrays to a file. But some care has
to be used: If @w{@code{get_file()}} has been called before the first
argument has to be the file number returned by the call to tell
@acronym{fsc2} which file to use. If, on the other hand,
@code{get_file()} hasn't been called before, the user is asked to select
a file now and all further calls of functions of the
@w{@code{save_xxx()}} type will use this one file and the first argument
will be assumed to be a value to be written to this file!

All arguments (following the file identifier if there's one) are
data. The types of these data may be

@itemize @bullet
@item
Integer data
@item
Floating point data
@item
Strings (with no interpretation of escape sequences, see also @code{fsave()})
@item
One-dimensional arrays (or slices of arrays) of integer or floating point
type
@item
Complete more-dimensional arrays
@end itemize

The function saves data in an unformatted fashion, i.e.@: each data
value is written on a new line. The only exception is more-dimensional
arrays - here an empty line is output between the individual slices of
the array. Here's an example: The array

@example
X[ 3, 2 ] = @{ 1, 2, 3, 4, 5, 6 @}
@end example
@noindent
will be printed as

@example
1
2

3
4

5
6
@end example


@item fsave()
@anchor{fsave}
@findex fsave()
This function may be used to write data in a formated way into a
file. As in the case of the @code{save()} function the first argument
may be a file identifier. The next argument must be a @i{format string}
with exactly he same syntax as in the @code{print()} function,
i.e.@: there must be one @code{#} character for each data item. In
contrast to the @code{save()} function this function can not be used to
print array slices or complete arrays, but only simple data types. On
the other hand, printing of complete arrays can be done using loops,
i.e.@: as in the following example:

@example
VARIABLES:

FILE_ID;
I; J;
X[ 3, 2 ] = @{ 1, 2, 3, 4, 5, 6 @};

EXPERIMENT:

FILE_ID = get_file( );

for I = 1 : 3 @{
    for J = 1 : 2 @{
        fsave( FILLE_ID, "X[ #, # ] = #\n", I, J, X[ I, J ] );
    @}
@}
@end example
@noindent
This will print:

@example
X[ 1, 1 ] = 1
X[ 1, 2 ] = 2
X[ 2, 1 ] = 3
X[ 2, 2 ] = 4
X[ 3, 1 ] = 5
X[ 3, 2 ] = 6
@end example


@item save_program()
@anchor{save_program}
@findex save_program()
This functions writes the currently run @acronym{EDL} program into a
file. As usual, the first argument may be a file identifier - the same
rules apply as for @code{save()} and @code{fsave()}. The second argument
can be a string that is prepended to each line of the program, i.e.@: a
comment character to make other programs like @acronym{MATHLAB} or
@acronym{octave} skip these lines.


@item save_output()
@anchor{save_output}
@findex save_output()
This function has the same arguments as @code{save_program()} but prints
the content of the output window (i.e.@: the bottom browser window in
the main form) into the file.


@item save_comment()
@anchor{save_comment}
@findex save_comment()
This function is used to print comments into the file. When it is called a
small editor is shown and the user may enter comments. These will be then
written into the file.

The first argument may as usual be a file identifier (or may be missing
if @w{@code{get_file()}} hasn't been called). The second argument is
again a string to be prepended to each line of the comment. The third
argument is a preset string that appears in the comment editor when it is
opened - use "@code{\n}" to separate the lines of a multi-line text. The
last argument is the label string to be shown on top of the editor - it
defaults to "Please enter a comment:".
@end table


@node Interaction functions, Mathematical functions, Output functions, Built-in Functions
@section Interaction functions
@cindex interaction functions

These functions allow the creation and handling of buttons and sliders
that allow the user to influence the experiment when it is already
running. If they are used it is not more possible to check the complete
experiment before it is run because it is impossible to forsee which
buttons or sliders are used at what moment. Therefore, these functions
should only be used where it is really necessary, i.e.@: when trying to
find the optimum parameters for an experiment but not in the final
experiment.

To display the buttons and sliders a new window is created on the first
call of either the @code{button_create()} or @code{slider_create()}
function. It will be automatically deleted when either all buttons and
sliders are deleted again or at the end of an experiment. The functions
can only be used within the @code{EXPERIMENT} section of the program.

When the program is tested before the experiment is started it is
assumed that all buttons are not pressed and switched off (unless they
have been set by the function @code{button_state()}, and all sliders are
assumed to be in the middle posiotion unless a different value has been
set via the function @code{slider_value()}.


@table @samp
@item layout()
@anchor{layout}
@findex layout()
The functions tells the program how to layout the buttons and sliders in
the window, either vertically or horizontally. The function must be
called either with the strings @code{"VERT"}, @code{"VERTICAL"},
@code{"HORI"} or @code{"HORIZONTAL"} (the case of the letters doesn't
matter). The numbers @code{0} and @code{1} can be used alternatively for
vertical or horizontal layout.


@item button_create()
@anchor{button_create}
@findex button_create()
The function creates a new button and returns a unique integer number
that has to be used in later calls to identify this button. There are
three types of buttons, normal buttons that can be just pressed to
create an event, push buttons that stay on or off, and finally radio
buttons, that are also some kind of push buttons but that belong to a
group of buttons of which only one button can be switched on at once,
i.e.@: if a radio button gets pressed all the other radio buttons
belonging to the group become automatically unset.

Normal buttons are drawn as large rectangular buttons with the label
within the button, push buttons are drawn as squares, standing on a
corner, that become yellow when pressed and radio buttons as round
buttons, that become red when activated.

The first argument the function needs is the type of the button, i.e.@:
on of the strings @code{"NORMAL_BUTTON"}, @code{"PUSH_BUTTON"} or
@code{RADIO_BUTTON"} (the case of the letters doesn't matter).

For a radio button it must be specified which group it belongs to. Each
group has a button functioning as the group leader which is always the
first button of the group. For all other members of this group the
identifier of the group leader button must be specified as the second
argument. I.e.@: to create a group of three rdio buttons you would use
@example
B_ID_1 = button_create( "RADIO_BUTTON", "Label 1" );
B_ID_2 = button_create( "RADIO_BUTTON", B_ID_1, "Label 2" );
B_ID_3 = button_create( "RADIO_BUTTON", B_ID_1, "Label 3" );
@end example

For all buttons except radio buttons the second (optional) argument is
the string that is to appear as the label of the button. The final (also
optional) argument is a further string that is an additional help text
that will appear when the mouse remains for some time over the button.
Both label and help text may contain some escape sequences, namely
`@code{\n}', standing for a line break (to create a multi-line label or
help text) and `@code{\\}', standing for the backslash character to
allow a backslash in front of an `n'.

All buttons start as unpressed and in the unset state.


@item button_delete()
@anchor{button_delete}
@findex button_delete()
Using this function one or more buttons can be deleted. It expects one
or more button identifiers as returned by the function
@code{button_create()}.

If the group leader (i.e.@: the first button) of a group of radio
buttons is deleted, the next button of the group becomes the new group
leader automatically.


@item button_state()
@anchor{button_state}
@findex button_state()
The function returns or sets the state of a button, depending on the
number of argument. The first argument is the identifier of the button
as returned by the function @code{button_create()}. If there are no more
arguments the state of the button is returned. There is a difference
between normal buttons and push and radio buttons. For normal buttons
the number of times the button was pressed since the last call of the
function is returned. For push and radio butoons the state of the
button, i.e.@: either @code{0} for off or @code{1} for on is returned.

If there is a second argument the state of push and radio buttons can be
set. This argument must be either a string (@code{"ON"} or @code{"OFF"})
or a number with @code{0} standing for off and a non-zero number for
on. The state of normal buttons cannot be set.


@item slider_create()
@anchor{slider_create}
@findex slider_create()
Sliders are for setting values in a predefined range. There are two
types of sliders, normal sliders and value sliders. The only difference
is that for value sliders there's an additional field showing the
currently set value while for normal sliders there isn't such a visual
feedback. As the function @code{button_create()} also this function
returns a unique integer number to be used to identify the slider.

The first argument the function expects is a string, either
@code{""NORMAL_SLIDER"} or @code{"VALUE_SLIDER"} (the case of the
letters doesn't matter). The second argument must be the minimum value
the slider can be adjusted to and the third argument is the maximum
value. The minimum value must always be smaller than the maximum value.

As in the case of buttons there are to more (optional) arguments, the
label to be shown below the slider and a help text. The same escape
sequences as for button labels and help texts can be used for sliders.

All labels start of as set to the middle of the defined range.

@item slider_delete()
@anchor{slider_delete}
@findex slider_delete()
The function deletes on or more sliders. It expects one or more slider
identifiers as returned by the function @code{slider_create()}.


@item slider_value()
@anchor{slider_value}
@findex slider_value()
This function returns or sets the value of a slider. The first argument
must be a slider identifier as returned by the function
@code{slider_create()}. If this is the only argument the value the
slider is set to is returned. If there's a second value the slider is
set to this value. Obviously, the value must be within the range of the
slider as defined by the minimum and maximum value set in
@code{slider_create()}, otherwise an error message is printed and the
slider value is set to the next value still within the allowed range.


@end table


@node Mathematical functions, Auxiliary functions, Interaction functions, Built-in Functions
@section Mathematical functions
@cindex mathematical functions

@table @samp
@item int()
@anchor{int}
@findex int()
Converts a number (or the elements of an array) to integer type by
truncating all digits following the decimal point.


@item float()
@anchor{float}
@findex float()
Converts a number (or the elements of an array) to floating point type.


@item round()
@anchor{round}
@findex round()
Converts a floating point number (or the elements of an array) to the
nearest integer, i.e.@:

@example
round( 8.5 ) = 9    round( 8.49 ) = 8    round( -1.75 ) = -2
@end example


@item floor()
@anchor{floor}
@findex floor()
Converts a floating point number (or the elements of an array) to the
largest integer that is not larger than the argument, i.e.@:

@example
floor( 8.6 ) = 8    floor( -8.6 ) = -9
@end example


@item ceil()
@anchor{ceil}
@findex ceil()
Converts a floating point number (or the elements of an array) to the
smallest integer that is not less than the argument, i.e.@:

@example
round( 8.6 ) = 9     round( -8.6 ) = -8
@end example


@item abs()
@anchor{abs}
@findex abs()
Returns the absolute value of an integer or floating point number (or
the elements of an array) .


@item mean()
@anchor{mean}
@findex mean()
Expects an one-dimensional array as input and returns the mean value of
the array elements. Optionally, it accepts up to two more integer
arguments, the start index of the first element of the array top be
included into the calculation and the number of elements to use. If the
length parameter is missingall elements up to the end of the array are
used.


@item rms()
@anchor{rms}
@findex rms()
Expects an one-dimensional array as input and returns the square root of
the sum of the squared array elements, divided by the number of elements.


@item sqrt()
@anchor{sqrt}
@findex sqrt()
Returns the square root of an integer or floating point number (or the
elements of an array). The argument must be a positive number.


@item random()
@anchor{random}
@findex random()
Returns a pseudo-random number in the interval @w{[0, 1]}.


@item set_seed()
@anchor{set_seed}
@findex set_seed()
Sets a seed for the random number generator used in the function
@code{random()} function. The argument has to be a positive integer.


@item sin()
@anchor{sin}
@findex sin()
Returns the sine of the argument (simple number or elements of an
array), with the argument interpreted as the angle in radian.


@item cos()
@anchor{cos}
@findex cos()
Returns the cosine of the argument (simple number or elements of an
array), with the argument interpreted as the angle in radian.


@item tan()
@anchor{tan}
@findex tan()
Returns the tangent of the argument (simple number or elements of an
array), with the argument interpreted as the angle in radian.


@item asin()
@anchor{asin}
@findex asin()
Returns the inverse of the sine function of the argument (simple number
or elements of an array) as an angle in radian. The argument must be in
the interval @w{[-1, 1]}, the result an element of the interval
@w{[-pi/2, pi/2]}.


@item acos()
@anchor{acos}
@findex acos()
Returns the inverse of the cosine function of the argument (simple
number or elements of an array) as an angle in radian. The argument must
be in the interval @w{[-1, 1]}, the result an element of the interval
@w{[0, pi]}.


@item atan()
@anchor{atan}
@findex atan()
Returns the inverse of the tangent function of the argument (simple
number or elements of an array) as an angle in radian, the result an
element of the interval @w{[-pi, pi]}.


@item sinh()
@anchor{sinh}
@findex sinh()
Returns the hyperbolic sine of the argument (simple number or elements
of an array).


@item cosh()
@anchor{cosh}
@findex cosh()
Returns the hyperbolic cosine of the argument (simple number or elements
of an array).


@item tanh()
@anchor{tanh}
@findex tanh()
Returns the hyperbolic tangent of the argument (simple number or
elements of an array).

@end table



@node Auxiliary functions, , Mathematical functions, Built-in Functions
@section Auxiliary functions
@cindex auxiliary functions


@table @samp
@item date()
@anchor{date}
@findex date()
Returns a string with the current date in a form like @code{Sun Jun 17, 2000}.


@item time()
@anchor{time}
@findex time()
Returns a string with the current time in the form @code{hh:mm:ss}.


@item delta_time()
@anchor{delta_time}
@findex delta_time()
This function (that can only be used in the @code{EXPERIMENT} section of
the program) returns the time (in seconds) since the last call of the
functions as a floating point value. When called for the very first time
it returns the time since the start of the experiment. The time
returned by the function has micro-second resolution.


@item wait()
@anchor{wait}
@findex wait()
Waits for the specified time. Times are always to be given in seconds or
alternatively with a unit, e.g.@: @w{100 ms}. Unfortunately, the time
resolution of @code{wait()} is in the @w{10 ms} range and may even be
less precise. If the argument is negative the function will print an
error message and return immediately. The maximum time the function
accepts is more than 2.1 billion seconds (or about 68 years).


@item slice()
@anchor{slice}
@findex slice()
The function returns a part (slice) of an one-dimensional array. It
expects at least two arguments, the array the values are to be taken
from and the number of the start element of the slice to be returned.
Usually, you also will pass it a third argument, the length of the slice
to be returned. If this argument is missing an array made up from all
elements from the start element to the end of the array is returned.

For an array defined as
@example
X[ 8 ] = @{ 1, 2, 3, 4, 5, 6, 7, 8 @}
@end example
@noindent
the call of @code{slice}
@example
slice( X, 3, 4 );
@end example
@noindent
will return an array with 4 elements containing the data
@example
3, 4, 5, 6
@end example


@item dim()
@anchor{dim}
@findex dim()
The function returns the dimension of the array passed to it as
argument. I.e.@: for the array

@example
X[ 4, 2, 5 ]
@end example
@noindent
it will return 3.


@item size()
@anchor{size}
@findex size()
The function takes two arguments, an array and one of the dimensions of the
array, and returns the size of this dimension. I.e.@: for an array defined as
@example
@code{X[ 4, 2, 5 ]}
@end example
@noindent
@code{size( X, 3 )} will return 5.


@item sizes()
@anchor{sizes}
@findex sizes()
This function is similar to @code{size()} but only takes an array as
argument an returns a new one-dimensional array with the sizes of the
different dimensions. I.e.@: use it the following way:

@example
X[ 4, 2, 5 ]
Dim_X[ * ];

Dim_X = size( X );
@end example
@end table
