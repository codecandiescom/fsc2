@c $Id$
@c
@c Copyright (C) 1999-2002 Jens Thoms Toerring
@c
@c This file is part of fsc2.
@c
@c Fsc2 is free software; you can redistribute it and/or modify
@c it under the terms of the GNU General Public License as published by
@c the Free Software Foundation; either version 2, or (at your option)
@c any later version.
@c
@c Fsc2 is distributed in the hope that it will be useful,
@c but WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with fsc2; see the file COPYING.  If not, write to
@c the Free Software Foundation, 59 Temple Place - Suite 330,
@c Boston, MA 02111-1307, USA.


@node Built-in Functions, Device Functions, EDL, Top
@chapter Built-in Functions

@ifinfo
@menu
* Output functions::        Functions for printing, drawing and storing.
* Interaction functions::   Functions buttons and sliders.
* Mathematical functions::  Function for doing mathematics.
* Auxiliary functions::     All other functions.
@end menu
@end ifinfo

In this chapter all functions built into @acronym{fsc2} are discussed in
detail. These functions are available even when no device modules have
been specified in the @code{DEVICES} section (or this section is
missing). Many functions can be used in the @code{VARIABLES},
@code{PREPARATIONS} as well as the @code{EXPERIMENT} section of an
@acronym{EDL} program, but there are some that can be used only either
before the @code{EXPERIMENT} section starts or within the
@code{EXPERIMENT} section.

The built-in functions can be roughly divided into four classes. The
first class of functions are functions for drawing the measured data
onto the screen, i.e.@: the main area of the display window (including
functions for changing the axis scaling and labels etc.@:), functions
for dealing with the output of the program, either by writing text to
the browser in the lower half of the main window or by writing data
etc.@: into files (including functions for specifying the files to be
used).

The second class of functions are interaction functions, functions that
allow to deal with additional graphical objects like buttons, sliders and
in- and output fields. These functions control the creation, setting,
query and deletion of these objects.

The third class of functions are mathematical functions that one would
expect to find in most programming languages like (i.e.@: trigonometric
functions, logarithms etc.@:). Finally, the fourth class are auxiliary
functions that can't be assigned to one of the other classes and
consists of functions for dealing with time or date issues or for
determining the sizes of arrays and other.


@node Output functions, Interaction functions, Built-in Functions, Built-in Functions
@section Output functions
@cindex output functions

Before delving into the details of the functions for drawing measured
data into the main display window a short explanation of the basic ideas
probably is in order. You have to distinguish between 1D- and
2D-display. In 1D-display to display a new data point you have to
specify the @i{x}- and the @i{y}-coordinate of the point. The
@i{x}-coordinate is always an integer number, where @code{1} indicates
the left-most point in the window. For the @i{y}-coordinate you simply
specify the measured value. To be able to draw a meaningful @i{x}-axis
the program needs another piece of information: the starting point of
the @i{x}-axis and the difference between the points drawn at the
@i{x}-axis. For example, if you do an cw-EPR experiment, starting with a
field of @w{3400 G} and with spacing of @w{0.5 G} between the data
points you will have to tell the program about this in the graphic
initialization. If you now specify, when drawing a new point, an
@i{x}-coordinate of @code{11} the point will appear at an axis position
of @w{3410 G} because the point numbered @code{1} is drawn at @w{3400
G}, the point numbered @code{2} at @w{3400.5 G} etc.@:, so the point
numbered @code{11} will appear at @w{3410 G}.

In contrast, for a 2D-display you have to specify three coordinates for
a new data point. Here both the @i{x}- and @i{y}-coordinate are
integers, both starting at @code{1}. The point with both the @i{x}- and
@i{y}-coordinate set to @code{1} is the left-most point at the bottom of
the window. The third coordinate is the measured value, which usually
will be a floating point number. As already in the case of 1D-displays
the program needs some more information to be able to draw meaningful
axis. Here not only the starting point and increment for the @i{x}-axis
must be given but also values for the @i{y}-axis.

Finally, another point: If you have not only one data point to draw but
a whole array you can do this without having to draw each point on its
own. Instead, when in the function for drawing you enter a
(one-dimensional) array instead of a value (as the @i{y}-coordinate for
1D-display or the @i{z}-coordinate for 2D-display) all the points of the
array will be drawn, starting at the place you specified and from there
to the right, i.e.@: always in @i{x}-direction.


@table @samp
@anchor{init_1d}
@item init_1d()
@findex init_1d()
Initializes the display for one-dimensional experiments -- without a
call to this function (or @code{init_2d()}, see below) no data can be
displayed. The function accepts up to six arguments, all of them being
optional. These are:
@enumerate
@item
The number of curves to be displayed, the maximum is currently 4
curves. If not given it defaults to 1.
@item
Number of points, if missing, zero or negative it will be treated as
unknown and default to 64 points. If the specified value (or the default
value) turns out to be too small it is adjusted automatically in the
experiment so that all data again fit into the display (as long as the
@code{FS} button is switched on).
@item
Start value of the @i{x}-axis. If missing (or undefined, see next point)
point numbers are printed, starting with @code{1}.
@item
Increment for data along the @i{x}-axis (thus restricting the display to
equally spaced data). Setting it to zero implies that the start value
and the increment are undefined and point numbers are shown
instead. Negative increments are handled correctly.
@item
String variable with the label to be shown at the @i{x}-axis.
@item
String variable with the label to be shown at the @i{y}-axis.
@end enumerate

Formally, the function with its arguments can be written as
@example
init_1d( [ n_curves [ , n_points [ , start, increment ] ], ]
         [ x_label [ , y_label ] ] )
@end example
@noindent
This means that the function can be called in all of the following ways:
@example
init_1d( n_curves, n_points, start, increment, x_label, y_label )
init_1d( n_curves, n_points, start, increment, x_label )
init_1d( n_curves, n_points, x_label, y_label )
init_1d( n_curves, n_points, x_label )
init_1d( n_curves, n_points )
init_1d( n_curves, x_label, y_label )
init_1d( n_curves, x_label )
init_1d( n_curves )
init_1d( x_label, y_label )
init_1d( x_label )
init_1d( )
@end example
@noindent
In error messages the start value and the increment of the data
displayed at the @i{x}-axis are (in contrast to the point numbers)
referred to as `real world coordinates'.

This function can only be used in the @code{PREPARATIONS} section of an
@acronym{EDL} program.


@anchor{init_2d}
@item init_2d()
@findex init_2d()
Initializes the display for two-dimensional experiments. The function
accepts up to nine arguments, all of them optional. The arguments are:
@enumerate
@item
Number of data sets to be displayed, maximum is currently 4. If not
given it defaults to 1.
@item
Number of points in @i{x}-direction, if missing or less than 1 it will
be treated as unknown and default to 64. If the specified value (or the
default value) turns out to be too small it is adjusted automatically in
the experiment so that all data fit into the display.
@item
Number of points in @i{y}-direction, if missing or less than 1 it will
be treated as unknown and default to 32. If the specified or the default
value turns out to be too small it is adjusted automatically in the
experiment so that all data fit into the display.
@item
Start value of the @i{x}-axis. If missing (or undefined, see also next
entry) point numbers are printed, starting with @code{1}.
@item
Increment for data along the @i{x}-axis (thus restricting the display to
equally spaced data). Setting it to zero implies that the start value
and the increment are undefined and point numbers are shown instead.
@item
Start value of the @i{y}-axis. The same rules as for the @i{x}-axis apply
for missing or undefined values.
@item
Increment for data along the @i{y}-axis. The same rules as for the
@i{x}-axis apply for missing values or when zero is specified.
@item
String variable with label to be shown at the @i{x}-axis.
@item                
String variable with label to be shown at the @i{y}axis.
@item
String variable with label to be shown at the @i{z}-axis.
@end enumerate
Formally, the function with its arguments can be written as
@example
init_2d( [ n_data_sets [ , n_x_points [ , n_y_points, 
         [ , x-start, x-increment, y-start, y-increment ] ,
         ]  ]  ] [ x-label [ , y-label [ , z-label ] ] ] )
@end example

This function can only be used in the @code{PREPARATIONS} section of an
@acronym{EDL} program.


@anchor{display}
@item display( )
@findex display()
This function is used called to display data in 1-dimensional as well as
in 2-dimensional experiments. It takes the following arguments:
@enumerate
@item
The (@i{x}) point number (coordinate) where the data point (if only a
single number is given as the third argument) or the coordinate where
the first data point of an data array passed as the third argument is to
be shown.
@item
Only in 2D-experiments: The @i{y}-point number (coordinate) of the data
point or the coordinate for the first data point of an data array
(arrays are always drawn to the right from the specified coordinate,
i.e.@: in @i{x}-direction).
@item
The data point or a (one-dimensional) array of data.
@item
Number of the curve or data set the data are to be displayed belong
to. If missing it defaults to the first curve, 1. If there is more than
one data set given in the @code{display()} command the curve number
must be specified.
@end enumerate
These arguments can be repeated as many times as there are data to be
displayed simultaneously (but in this case none of the arguments may be
left out!).

Formally, the function with its arguments can be written for 1D-experiments as
@example
display( n_x_point, data [ , n_curve [ , ... ] ] )
@end example
@noindent
while for 2D-experiments it is
@example
display( n_x_point, n_y_point, data [ , n_curve [ , ... ] ] )
@end example

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} program.


@anchor{change_scale}
@item change_scale()
@findex change_scale()
This function allows to change the scale settings (originally set in the
call of @w{@code{init_1d()}} or @w{@code{init_2d()}}) after an
experiment has been started. With a one-dimensional display the function
can be passed a maximum of two arguments, the new start value of the
@i{x}-axis and the new @i{x}-increment. For two-dimensional display the
function also accepts a new start value for the @i{y}-axis as well as
the @i{y}-increment. If one of these values should remain unchanged
instead of a value a string (e.g.@ @code{"keep"}) can be passed as the
argument.

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} program.


@anchor{change_label}
@item change_label()
@findex change_label()
Using this function the labels at the axis of the display window (and, if
shown, of the cross section window) can be changed from within as
@acronym{EDL} program. For 1D-display it accepts up to two strings for
the @i{x}- and @i{y}-axis labels, for 2D-display up to three, the third
for the @i{z}-axis label. To leave a label unchanged pass the function
an empty string, i.e.@ @code{""}. If no label should be drawn pass it
a string that just contains one (or more) space characters, i.e.@:
@code{" "}.

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} program.

@anchor{rescale}
@item rescale()
@findex rescale()
In the function @code{init_1d()} or @code{init_2d()} the number of points
in @i{x}- (and @i{y}-) direction can be set. If, during the experiment
more points are displayed then set in the initialization, the scaling of
the axis (or axis in the 2D-case) will be changed automatically. Using
the function @code{rescale()} one can change the number of points from
within the @acronym{EDL} program. In the 1D-case the function accepts
one argument, the new number of points in @i{x}-direction. If this value
is @code{0} the number of points is adjusted to the number of points
currently displayed. Exceptions are when either the new number of
points is smaller than the default number, in which case the default
number is used, or the number is smaller than the number of points
currently displayed which is then used as the new number of
points. Passing the function a value of @code{-1} means that the number
of points should remain unchanged.

In the 2D-case the function accepts two arguments, one for the number of
points to be displayed in @i{x}-direction and the second for the number
of points in @i{y}-direction. As in the 1D-case a @code{-1} means not to
do any changes to the axis and @code{0} sets the number of points to the
number of points currently displayed along this axis.

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} program.

@anchor{clear_curve}
@item clear_curve()
@findex clear_curve()
Removes one or more curves from the display. As many curve numbers as
there are curves can be used. No arguments at all implies the first
curve. Invalid arguments are discarded and an error message is printed.

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} program.


@anchor{draw_marker}
@item draw_marker()
@findex draw_marker()
This function is only available for 1D graphics and draws a vertical
dashed line on the display window. It expects at least one argument, an
integer number defining the @i{x}-position of the marker to be drawn. A
second, optional argument is the color of the marker, here one may
specify either an integer number or a string:
@multitable @columnfractions 0.15 .35 .35
@item Number @tab String @tab Color
@item @code{1} @tab @code{"WHITE"} @tab white
@item @code{2} @tab @code{"RED"} @tab red
@item @code{3} @tab @code{"GREEN"} @tab green
@item @code{4} @tab @code{"YELLOW"} @tab yellow
@item @code{5} @tab @code{"BLUE"} @tab blue
@item @code{6} @tab @code{"BLACK"} @tab black
@end multitable
@noindent
The last color, black, is invisible on the background and can be used to
make an already drawn marker invisible (markers set at the same
@i{x}-position are drawn on top of each other, with the latest set
marker drawn last).


@anchor{clear_marker}
@item clear_marker()
@findex clear_marker()
This function is only available for 1D graphics and deletes all
previously set markers. It accepts no arguments.


@anchor{print}
@item print()
@findex print()
This function prints text into the output browser in the main form of
@acronym{fsc2}.  It needs a @i{format string}
@cindex format string
as its very first argument. The @i{format string} can contain any text
as well as a special character, @code{#},
@findex # @r{(in @code{print()} function)}
that works as a placeholder for data to be printed in its place.  Here's
a first simple example: You want to print the value of a variable called
@code{I}, that has been assigned a value of 3. Now,
@example
print( "The value of I is #.\n", I );
@end example
@noindent
will print, when the program is interpreted,
@example
The value of I is 3.
@end example
@noindent
But you can have not only one but as many placeholder characters in the
@i{format string} as you need. Of course, the number of placeholder
characters has to match the number of variables (or data) following the
@i{format string}. If the number of @code{#}'s and the number of
variables to be printed doesn't fit a warning is printed. If there are
too many @code{#}'s the superfluous ones are simply printed out, but if
there are not enough only as many variables as there are @code{#}'s are
printed, the remaining data are discarded.

You may use @code{print()} to print integer or floating point values
(that includes the return values of functions) and variables and strings
(i.e.@: text enclosed in double quotes, @code{"}).  Here's a longer,
somewhat contrived example:
@example
print( "The # of # is #\n", "sine", x, sin( x ) );
@end example
@noindent
This will print (assuming @code{x} equals @code{0.5}):
@example
The sine of 0.500000 is 0.479426
@end example

There are special sequences allowed in the @i{format string}. They all
start with an @i{escape character}, the backslash @code{\}. Here's a
list of all recognized special sequences:
@table @samp
@cindex escape characters (in @code{print()} function)
@item \n
Linefeed character: Ends a line, everything following it starts on a new
line. Thus several lines can be printed at once by one call of
@code{print()}. @code{print()} does not automatically add a linefeed by
itself.
@item \t
Embeds a tabulator character in the text, tab stops are set at every
eighth character position.
@item \\
Prints a backslash, @code{\}, thus switching off the special meaning of the
backslash as an escape character.
@item \"
Prints a quote -- use it to embed quotes into the @i{format
string}.
@item \#
Prints a @code{#}, thus switching off the special meaning of the
@code{#} character as a placeholder for variables to be printed.
@item \T
While normally nothing is printed during the test run of the
@code{EXPERIMENT} section of an @acronym{EDL} program, if the @i{format
string} starts with this escape sequence the @code{print()} function
will produce output already in the test run (the @code{T} is never
printed).
@end table


@anchor{get_file}
@item get_file( )
@findex get_file()
Opens a new file and returns a unique identifier for the file that can
be stored in an integer variable and is to be used in calls to functions
of the @w{@code{save_xxx()}}-family. Usually, a file selector is shown
that lets the user choose a file. If opening the selected file fails the
user is asked to select a different file name. If the user cancels the
selection of a file (s)he is asked for confirmation since data may get
lost. If the user decided not to select a file the function returns an
(invalid) file identifier of @code{-1}.

The function accepts up to five arguments, all of them optional. The
first one is usually the prompt string to be printed in the file
selector. If it is missing or is the empty string (use `@code{""}' to
create an empty string) it defaults to `@i{Please select a file
name:}'. The second argument is a pattern for the file name, per default
`@i{*.dat}'. You may use all the usual wildcard characters you're used
to from the shell. The third argument is the directory the search for
the file name should start in. As the fourth argument you may pass a
file name to the function as the default file that appears in the entry
for the selected file. Finally, the fifth and last argument can be a
default extension for the file. This extension will be appended
automatically to the name of the file the user selects unless the file
name already has this extension. This way one can enforce an extension
for the file name.

But there's also an alternative. If the very first string (that is
usually used for the prompt string) starts with a backslash `@code{\}'
the following characters (i.e.@: everything except the leading
backslash) are taken as the name of the file to be used automatically.
The file selector will not be shown and instead the hard-coded file name
will be used. Only if opening this file fails the remaining parameters
will be used when asking for an alternative file (except the prompt
string, the default will be used).

If @code{get_file()} has never been called on the first call to a
function from the @code{save_xxx()}-family the user is asked to select a
file and this file is used exclusively in further
@code{save_xxx()}-calls.  That means that calling @code{get_file()}
after the default file has already been opened is not allowed, call it
either before the first save-operation or never at all!

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} program.


@anchor{clone_file}
@item clone_file( )
@findex clone_file()
Sometimes two output files are needed that should only differ in their
extension but not in the filename. In this case the function
@code{clone_file()} can be useful. It expects exactly three
arguments. The first one is an identifier for an already existing file as
returned by the function @code{get_file()}. (If in the call of
@code{get_file()} the user did @b{not} to choose a file, i.e.@: pressed
the @code{Cancel}-button, it is silently assumed that also the second
file to be created by @code{clone_file()} is @b{not} to be used.)

The second and third arguments both have to be strings. The second
argument is the expected extension of the file that was selected via the
previous call of @code{get_file()}. And the third argument is the
replacement for the extension of the previously selected file. If the
second argument does not fit with the extension of the file the user had
chosen, the new extension from the third argument is appended to the
file name (instead of replacing the extension).

A typical piece of code to open two files, the first with the extension
@code{dat} and the second with the same name but the extension
@code{list} would be:
@example
FILE1 = get_file( "", "*.dat", "", "", "dat" );
FILE2 = clone_file( FILE1, "dat", "list" );
@end example
@noindent
If the user chooses @code{experiment.dat} as the first file, a second
file with the name @code{experiment.list} will be opened automatically.

The function also takes care that no files will be overwritten
accidentally. If the second file already exists the user is asked to
select different file. The program enforces that the extension of the
new file is identical to the one passed to it as the third argument.

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} program.


@anchor{save}
@item save()
@findex save()
Writes one or more data or complete arrays to a file. But some care has
to be used: If @w{@code{get_file()}} has been called before the first
argument has to be the file number returned by the call to tell
@acronym{fsc2} which file to use. If, on the other hand,
@code{get_file()} hasn't been called before, the user is asked to select
a file now and all further calls of functions of the
@w{@code{save_xxx()}} type will use this one file and the first argument
will be assumed to be a value to be written to this file!

All arguments (following the file identifier if there's one) are
data. The types of these data may be

@itemize @bullet
@item
Integer data
@item
Floating point data
@item
Strings (with interpretation of escape sequences, see @code{fsave()})
@item
One-dimensional arrays (or slices of more-dimensional arrays) of integer
or floating point type
@item
Complete more-dimensional arrays
@end itemize

The function saves data in an unformatted fashion, i.e.@: each data
value is written on a new line. The only exception are more-dimensional
arrays -- here an empty line is output between the individual slices of
the array. Here's an example: The array

@example
X[ 3, 2 ] = @{ 1, 2, 3, 4, 5, 6 @}
@end example
@noindent
will be printed as

@example
1
2

3
4

5
6
@end example

The function returns the total number of characters that have been
written to the file and can only be used in the @code{EXPERIMENT}
section of an @acronym{EDL} program.


@anchor{fsave}
@item fsave()
@findex fsave()
This function (the name stands for 'formated save') can be used to write
data to a file in a formated way. As in the case of the @code{save()}
function the first argument may be a file identifier. The next argument
must be a @i{format string} with a syntax remotely similar to the one
for the @code{C} @code{print()} function. The format string can contain
arbitrary text and conversion specifiers, a @code{#} character for each
data item from the remaining argument list. In contrast to the
@code{save()} function this function can not be used to print array
slices or complete arrays, but only simple data types. On the other
hand, printing of complete arrays can be done using loops, i.e.@: as in
the following example:

@example
VARIABLES:

FILE_ID;
I; J;
X[ 3, 2 ] = @{ 1, 2, 3, 4, 5, 6 @};

EXPERIMENT:

FILE_ID = get_file( );

for I = 1 : 3 @{
    for J = 1 : 2 @{
        fsave( FILLE_ID, "X[ #, # ] = #\n", I, J, X[ I, J ] );
    @}
@}
@end example
@noindent
This will print:

@example
X[ 1, 1 ] = 1
X[ 1, 2 ] = 2
X[ 2, 1 ] = 3
X[ 2, 2 ] = 4
X[ 3, 1 ] = 5
X[ 3, 2 ] = 6
@end example

Within the format string and the argument strings escape sequences, all
starting with a backslash character @code{\}, can be used to print
otherwise unprintable characters. These are
@table @samp
@item \a
prints an alert (bell) character (@code{0x07})
@item \b
prints a backspace character (@code{0x08})
@item \f
prints a formfeed character (@code{0x0C})
@item \n
prints a newline character (@code{0x0A})
@item \r
prints a carriage return character (@code{0x0D})
@item \t
prints a horizontal tab character (@code{0x09})
@item \v
prints a vertical tab character (@code{0x0B})
@item \\
prints a backslash @code{\}
@item \?
prints a question mark @code{?}
@item \'
prints a single quote @code{'}
@item \"
prints a double quote @code{"}
@item \@i{ooo}
replaces the octal number @i{ooo} by the corresponding character (as
many octal digits are used as long as the resulting number is less
then 255)
@item \x@i{hh}
replaces the hexadecimal number @i{hh} by the corresponding character
(there must be one or two hexadecimal digits)

@item \#
prints a @code{#} (this is a special escape sequence to be used with
@code{fsave()} only)
@end table

The function returns the total number of characters that have been written to
the file.

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} program.

@anchor{ffsave}
@item ffsave()
@findex ffsave()
This function can also be used to write data into a file using a format
string. In comparison to the @code{fsave()} function it gives you even
more control over the format that is used by accepting a format string
that is nearly identical to the one of the @code{C} @code{printf()} family
of functions, missing only some elements that wouldn't make sense here.
As in the case of the @code{save()} and @code{fsave()} function the
first argument can be a file identifier.

The format string may contain two types of objects: ordinary characters,
which are copied to the file, and conversion specifications, each of
which conversion and printing of the next successive argument. Each
conversion specifier begins with the character @code{%} and ends with
a conversion character. In between there may first a flag, which
modifies the specification:
@itemize
@item @code{-} which specifies left adjustment of the converted argument
      in its field,
@item @code{+} which specifies that a number will always printed with a
      sign,
@item @i{space}: if the first character is not a sign, a space will be
      prefixed,
@item @code{0}: for numeric conversions, specifies padding the field
      with leading zeros,
@item @code{#}, which specifies an alternate output form: for @code{e},
      @code{E}, @code{f}, @code{g} and @code{G}, the output will always
      have a decimal point, for @code{f} and @code{G}, trailing zeros
      will not be removed.
@end itemize

Following the flags the minimum field width as well as the precision can
be specified. If the (optional) flags are followed by a number it is
taken as the minimum field width. The converted argument will be printed
in a field at least this wide, and wider if necessary. If the converted
argument has fewer characters than the field width it will be padded on
the left (or on the right, if left adjustment has been requested) to
make up for the field with. The padding character normally is the space
character except and only @code{0} if the zero padding flag is present.

The next character can be a period, which separates the field width from
the precision, followed by another number, the precision, that specifies
the maximum number of characters to be printed from a string, or the
number of digits to be printed after the decimal point for @code{e},
@code{E}, or @code{f} conversion, or the number of significant digits
for @code{g} or @code{G} conversion, or the minimum number of digits to
be printed for an integer (leading @code{0}s will be added to make up
the necessary width).

Width or precision or both may be specified as @code{*}, in which case
the value is computed by converting the next arguments(s), which must be
an integer values.

In contrast to the @code{printf()} format string no length modifier can
be used - @acronym{fsc2} has no different short, long or long long
variable types.

The following table lists all conversion characters. If the character
found in the format string is not a valid conversion specifier the
function will abort and print an error message.
@table @samp
@item d, i
Integer value, if the argument is not an integer but a floating point
number its value is rounded to the next integer.
@item f
floating point value, if the argument is an integer it is converted to a
floating point value; decimal notation of the form @i{[-]mmm.ddd}, where
the number of @i{d}'s is specified by the precision. The default
precision is 6; a precision of @code{0} suppresses the decimal point
@item e, E
floating point value, if the argument is an integer it is converted to a
floating point value; decimal notation in either the form
@w{@i{[-]mmm.dddddd}@code{e}@i{[+-]xx}} or
@w{@i{[-]mmm.dddddd}@code{E}@i{[+-]xx}}, where the number of @i{d}'s is
specified by the precision. The default precision is 6, a precision of
@code{0} suppresses the decimal point.
@item g, G
floating point value, if the argument is an integer it is converted to a
floating point value; @code{%e} or @code{%E} is used if the exponent is
less than -4 or greater than or equal to the precision, otherwise
@code{%f} is used. Trailing zeros and a trailing decimal point are not
printed.
@item %
no argument is converted, prints a @code{%}
@end table

The format string as well as argument strings may contain escape
sequences, starting with a backslash @code{\}, see @code{fsave()} for
the complete list.


The function returns the total number of characters that have been written to
the file.

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} program.

@anchor{save_program}
@item save_program()
@findex save_program()
This functions writes the currently run @acronym{EDL} program into a
file. As usual, the first argument may be a file identifier - the same
rules apply as for @code{save()} and @code{fsave()}. The second argument
can be a string that is prepended to each line of the program, i.e.@: a
comment character to make other programs like @acronym{MATHLAB} or
@acronym{octave} skip these lines.

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} program.


@anchor{save_output}
@item save_output()
@findex save_output()
This function has the same arguments as @code{save_program()} but prints
the content of the output window (i.e.@: the bottom browser window in
the main form) into the file.

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} program.


@anchor{save_comment}
@item save_comment()
@findex save_comment()
This function is used to print comments into the file. When it is called a
small editor is shown and the user may enter comments. These will be then
written into the file.

The first argument may as usual be a file identifier (or may be missing
if @w{@code{get_file()}} hasn't been called). The second argument is
again a string to be prepended to each line of the comment. The third
argument is a preset string that appears in the comment editor when it is
opened - use "@code{\n}" to separate the lines of a multi-line text. The
last argument is the label string to be shown on top of the editor - it
defaults to "Please enter a comment:".

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} program.


@anchor{is_file}
@item is_file()
@findex is_file()
This function expects a file handle as returned by @code{get_file()} and
checks if it is valid and the associated file is open for writing.
@end table


@node Interaction functions, Mathematical functions, Output functions, Built-in Functions
@section Interaction functions
@cindex interaction functions

The following functions are for creating, handling and deleting of
buttons, sliders and input and output fields. When such an object is
created for the first time a new window with the title "Toolbox" gets
created.  The objects (i.e.@: buttons, sliders and input and output
fields) displayed in this toolbox window allow the user to influence the
experiment when it is already running. The toolbox window will vanish
automatically when all objects have been deleted. The toolbox with its
objects can only be used during the experiment, i.e.@: the functions for
creating, handling and deleting of objects can only be used within the
@code{EXPERIMENT} section of the program.

Please note that when the objects in the toolbox are used it usually
isn't possible anymore to check the complete experiment before it is run
because it is impossible to forsee which buttons, sliders or input
fields are going to be used at what moment in time (the only exception
is when only output fields are used). Therefore, these functions should
only be used where it is really necessary, e.g.@: when you're trying to
find the optimum parameters for an experiment but not in the final
experiment.

When the program is tested before the experiment is started it is
assumed that all buttons are not pressed and switched off (unless their
state has been set explicitly by the function @code{button_state()}, all
sliders are assumed to be in the middle position unless a different
value has been set via the function @code{slider_value()} and all input
and output fields are initialized to @code{0} unless an initial value
has been passed to the functions @code{input_create()} or
@code{output_create()}.

For all the objects to be created a label string to be drawn with the
object can be defined. Normally this will be a simple text, indicating
the meaning of the object. But in some cases it might be useful also to
be able to draw some symbols instead of text. This can be done by
starting the label string by the @code{'@@'} character. Immediately
after the @code{'@@'} one of the following texts can be used to draw a
symbol:
@table @samp
@item ->
Normal arrow pointing to the right.
@item <-
Normal arrow pointing to the left.
@item >
Triangular arrow pointing to the right.
@item <
Triangular arrow pointing to the left.
@item >>
Double triangle pointing to the right.
@item <<
Double triangle pointing to the left.
@item <->
Arrow pointing left and right.
@item ->|
Normal arrow pointing to the right and ending in a vertical bar.
@item >|
Triangular arrow pointing to the right and ending in a vertical bar.
@item |>
Triangular arrow pointing to the right and starting in a vertical bar.
@item -->
Thin arrow pointing to the right.
@item =
Three embossed lines.
@item arrow
Same as @code{-->}.
@item returnarrow
@code{<Return>} key symbol.
@item square
A square.
@item circle
A circle.
@item line
A horizontal line.
@item plus
A plus sign (rotate to get a cross).
@item UpLine
An embossed vertical line.
@item DnLine
An engraved vertical line.
@item UpArrow
An embossed triangular arrow pointing to the right.
@item DnArrow
An engraved triangular arrow pointing to the right.
@end table

It is also possible to rotate most of the symbols. When a symbol name is
preceeded by a digit between @code{1} and @code{9} (except @code{5}) the
symbol is rotated like on the numerical keypad, i.e. @: @code{6}
indicates no rotation, @code{9} a rotation by 45 degrees
anti-clockwise,8 a rotation by 90 degrees, etc. Hence the order is
@code{6,9,8,7,4,1,2,3} (just think of the keypad as consisting of arrow
keys). So to get an arrow pointing to the left top use a label string of
@code{"@@7->"}. To rotate the symbols in other directions not fitting
into this 45 degrees scheme put a @code{0} directly after the
@code{'@@'}, followed by exactly three digits that indicate the angle
(counter-clockwise). E.g.@: to get an arrow at an angle of 30 degrees
use the label string @code{"@@0030->"}.

The symbols are designed for labels with a square bounding box. But in
most cases the labels bounding box will not be square and the symbol is
scaled differently in @i{x}- and @i{y}-direction. If keeping the aspect
ration is desired, put a @code{'#'} character immediately after the
@code{'@@'}, e.g.@: @code{"@@#9->"}.

Two additional prefixes, @code{'+'} and @code{'-'}, followed by a single
digit, can be used to make small size adjustments. These prefixes must
either follow immediately after the @code{'@@'} or the @code{'#'}. The
@code{'+'} indicates an increase of the symbol size while @code{'-'}
will decrease the size. The digit following the prefix indicates the
increment or decrement in pixels. For example, to draw a circle that is 3
pixels smaller than the default size use the label string
@code{"@@-3circle"}.


@subsection List of Interaction Functions

All the following functions can only be used in the @code{EXPERIMENT}
section of an @acronym{EDL} program.

@table @samp
@anchor{layout}
@item layout()
@findex layout()
The functions tells the program how to layout the buttons and sliders in
the window, either vertically or horizontally. The function must be
called either with the strings @code{"VERT"}, @code{"VERTICAL"},
@code{"HORI"} or @code{"HORIZONTAL"} (the case of the letters doesn't
matter). The numbers @code{0} and @code{1} can be used alternatively for
vertical or horizontal layout.

Of course this function has to be called @b{before} a function to create
an object (button, slider or in- or output field) has been invoked.


@anchor{button_create}
@item button_create()
@findex button_create()
The function creates a new button and returns a unique integer number
that has to be used in later calls to identify this button. There are
three types of buttons, normal buttons that can be just pressed to
create an event, push buttons that stay on or off, and finally radio
buttons, that are also some kind of push buttons but that belong to a
group of buttons of which only one button can be switched on at once,
i.e.@: if a radio button gets pressed all the other radio buttons
belonging to the same group (which has to be specified when the button
is created) become automatically unset.

Normal buttons are drawn as large rectangular boxes with the label in
the middle, push buttons are drawn as squares, standing on a corner,
that become yellow when pressed, and radio buttons as round buttons,
that become red when activated.

The first argument the function expects is the type of the button,
i.e.@: on of the strings @code{"NORMAL_BUTTON"}, @code{"PUSH_BUTTON"} or
@code{"RADIO_BUTTON"} (the case of the letters doesn't matter).

For a radio button it must be specified which group it belongs to. Each
group has a button functioning as the group leader which is always the
first button of the group. For all other members of this group the
identifier of the group leader button must be specified as the second
argument. I.e.@: to create a group of three radio buttons use
@example
B_ID_1 = button_create( "RADIO_BUTTON", "Label 1" );
B_ID_2 = button_create( "RADIO_BUTTON", B_ID_1, "Label 2" );
B_ID_3 = button_create( "RADIO_BUTTON", B_ID_1, "Label 3" );
@end example

For all buttons except radio buttons the second (optional) argument is
the string that is to appear as the label of the button. The final (also
optional) argument is another string that is the help text that will
appear when the mouse hoovers over the button for some time. Both label
and help text may contain two different escape sequences, namely
`@code{\n}', standing for a line break (to create a multi-line label or
help text) and `@code{\\}', standing for the backslash character to
allow a backslash in front of an `n'.

All buttons start in the deactivated state except the 'leader' of a
group of radio buttons.


@anchor{button_delete}
@item button_delete()
@findex button_delete()
Using this function one or more buttons can be deleted. It expects one
or a list of button identifiers (separated by commas) as returned by
the function @code{button_create()}.

If the group leader (i.e.@: the first button) of a group of radio
buttons is deleted, the next button of the group becomes the new group
leader automatically. Please also note that when deleting the radio
button that is currently active, none of the radio buttons will be
active. In this case it is your responsibility to switch on one of the
remaining radio buttons of the group (unless all the others are also
deleted immediately afterwards).


@anchor{button_state}
@item button_state()
@findex button_state()
This function returns or sets the state of a button, depending on the
number of arguments passed to the function. The non-optional first
argument is the identifier of the button as it was returned by the
function @code{button_create()}. If there are no more arguments the
state of the button is returned. There is a difference between the
values returned for normal buttons on the one side and push and radio
buttons on he other. For normal buttons a counter is maintained that
counts the number of times the button was pressed and its value is
returned and the counter is set back to zero at the same time. In
contrast, for push and radio buttons the state of the button, i.e.@:
either @code{0}, meaning off, or @code{1} for on is returned.

If for push and radio buttons there is a second argument the state of
the button will be be set. This argument must be either a string
(@code{"ON"} or @code{"OFF"}) or a number with @code{0} standing for off
and a non-zero number for on. If the radio button is currently active
and it is about to be switched off, an error message will be printed and
the button will remain active. To switch an active radio button off
activate another button from its group instead. The state of normal
buttons cannot be set.


@anchor{slider_create}
@item slider_create()
@findex slider_create()
Sliders are useful for setting values within a predefined range. There
are two types of sliders, normal sliders and value sliders. The
difference between these types is that for value sliders there is an
additional field showing the currently set value while for normal
sliders there isn't such a visual feedback. As already the function
@code{button_create()} also this function returns a unique integer
number to be used to identify the slider.

The first argument the function expects is a string, either
@code{"NORMAL_SLIDER"} or @code{"VALUE_SLIDER"} (the case of the
letters doesn't matter). "Normal" sliders are just sliders without any
decoration while "value" sliders have an extra field showing the current
value set via the slider.

The second argument must be the minimum value the slider can be adjusted
to and the third argument is the maximum value. The minimum value must
always be smaller than the maximum value.

A fourth, optional parameter is the step size to be used, i.e.@: the
minimum increment the slider value can be changed. Of course, this value
has to be larger than zero and smaller than the difference between the
minimum and maximum value of the slider.

As in the case of buttons there are two more (optional) arguments, the
label to be shown below the slider and a help text. The same escape
sequences as for button labels and help texts.

All sliders start of set to the middle of their range. If a step size is
given for the slider the allowed value nearest to the middle value is
used as the sliders initial value.


@anchor{slider_delete}
@item slider_delete()
@findex slider_delete()
The function deletes on or more sliders. It expects one or a list of
slider identifiers as returned by the function @code{slider_create()}.


@anchor{slider_value}
@item slider_value()
@findex slider_value()
This function returns or sets the value of a slider. The first argument
must be a slider identifier as returned by the function
@code{slider_create()}. If this is the only argument the value the
slider is currently set to is returned. If there's a second value the
slider is set to this value. Obviously, the value must be within the
range of the slider as defined by the minimum and maximum value set in
@code{slider_create()}, otherwise an error message is printed and the
slider value is set to the next value still within the allowed range.
If a step size is set for the slider and the new value does not fit with
the step size the nearest allowed value is set.


@anchor{input_create}
@item input_create()
@findex input_create()
Using input fields numerical values can be entered. There are two
different types of input fields, one, that will only accept integer
values, while the other also allows input of floating point numbers. The
first argument of the function for creating an input field,
@code{input_create()}, is the type of the input field. If the first
argument is @code{"INT_INPUT"} the input field will only accept integer
numbers, while with an argument of @code{"FLOAT_INPUT"} also floating
point numbers can be entered. (@code{"INT_INPUT"} can be replaced by the
numerical argument @code{0} and @code{"FLOAT_INPUT"} by 1.)

If the second argument is a number it is taken to be the initial value
in the input field. If there is either no second argument or the second
argument is not a number but a string, the input field will be
initialized to @code{0}.

As in the case of buttons and sliders there are two more (optional)
arguments, the label to be shown below the input field and a help
text. The same escape sequences as for button and slider labels and help
texts can be used for buttons and sliders.

The final, optional field for an input object is a format string that is
used when printing the value. The format string is a simplified version
of a C format string. It must start with @code{%}, optionally followed
by the minimum field width, a dot, the precision and finally
(non-optionally) either @code{f}, @code{e} or @code{g} (or @code{F},
@code{E} or @code{G}). For more information please read the manual page
for @code{C}'s @code{printf(3)}.


@anchor{input_delete}
@item input_delete()
@findex input_delete()
The function deletes on or more input field. It expects one or a list of
input field identifiers as returned by the function @code{input_create()}.


@anchor{input_value}
@item input_value()
@findex input_value()
This function returns or sets the value of an input field. The first
argument must be an input field identifier as returned by the function
@code{input_create()}. If this is the only argument the value the input
field is set to is returned. If there's a second value the input field
is set to this value. Obviously, the value must be number.


@anchor{output_create}
@item output_create()
@findex output_create()
In contrast to input objects output objects can be used to display a
value but the user can't change the value. As in the case of input
objects there are two different types of output fields, one, that will
only accept integer values, while the other also allows output of
floating point numbers. The first argument of the function for creating
an output field, @code{output_create()}, is the type of the output
field. If the first argument is @code{"INT_OUTPUT"} the output field
will only show integer numbers, while with an argument of
@code{"FLOAT_OUTPUT"} also floating point numbers can be
displayed. (@code{"INT_OUTPUT"} can be replaced by the numerical
argument 2 and @code{"FLOAT_OUTPUT"} by 3.)

If the second argument is a number it is taken to be the initial value
in the output field. If there is either no second argument or the second
argument is not a number but a string, the output field will be
initialized to @code{0}.

As in the case of buttons and sliders there are two more (optional)
arguments, the label to be shown below the input field and a help
text. The same escape sequences as for button and slider labels and help
texts can be used for buttons and sliders.

The final, optional field for an output object is a format string that is
used when printing the value. The format string is a simplified version
of a C format string. It must start with @code{%}, optionally followed
by the minimum field width, a dot, the precision and finally
(non-optionally) either @code{f}, @code{e} or @code{g} (or @code{F},
@code{E} or @code{G}). For more information please read the manual page
for @code{C}'s @code{printf(3)}.


@anchor{output_delete}
@item output_delete()
@findex output_delete()
The function deletes on or more output field. It expects one or a list of
output field identifiers as returned by the function @code{input_create()}.


@anchor{output_value}
@item output_value()
@findex output_value()
This function sets a new value for an output field or returns the
current value. The first argument must be an output field identifier as
returned by the function @code{output_create()}. If this is the only
argument the value the output field is set to is returned. If there's a
second value the output field is set to this value. Obviously, the value
must be number.


@anchor{menu_create}
@item menu_create()
@findex menu_create()
This function creates a popup-menu button to allow the selection of one
of two or more alternatives. The first argument must be a label string,
followed by as many strings as necessary (but at least two) for the
items shown when the popup-menu button gets pressed. This widget does
not allow setting a help string.

As usual, the value returned is an integer ID for the popup-menu button
that has to be used in further commands dealing with the widget.


@anchor{menu_delete}
@item menu_delete()
@findex menu_delete()
This function deletes one or more popup-menu buttons. It expects one or
a list of popup-menu button identifiers as returned by the function
@code{menu_create()}.


@anchor{menu_choice}
@item menu_choice()
@findex menu_choice()
This function either selects a new item from the list of items of the
popup-menu button or returns the number of the currently selected item.
The first argument must be a valid popup-menu button identifiers as
returned by the function @code{menu_create()}. If there is no second
argument the currently selected item is returned, an integer number
between @code{1}, indicating that the first item is selected, and the
total number of items, indicating that the last item is selected.

If called with a second argument this must be an integer number between
@code{1} and the total number of items of the popup-menu button. The
number indicates which of the items has to become marked as selected
(where, obviously, @code{1} will select the first item, @code{2} the
second etc.).


@anchor{object_delete}
@item object_delete()
@findex object_delete()
The function deletes on or more objects from the toolbox. It expects one
or a comma separated list of object identifiers as returned by the
functions @code{button_create()}, @code{slider_create()} and
@code{input_create()}.


@anchor{hide_toolbox}
@item hide_toolbox()
@findex hide_toolbox()
This function can be used to hide and later redraw the toolbox. This
can, for example, be used to avoid multiple redraws when creating or
deleting several objects. The function can even be used before the
toolbox has been drawn for the first time. It expects exactly one
boolean argument (either @code{1} or @code{"ON"} to hide the toolbox or
@code{0} or @code{"OFF"} to redisplay it).



@end table



@node Mathematical functions, Auxiliary functions, Interaction functions, Built-in Functions
@section Mathematical functions
@cindex mathematical functions

The following mathematical function can be used in all section of an
@acronym{EDL} program that allow the use of functions.

@table @samp
@anchor{int}
@item int()
@findex int()
Converts a number (or all the elements of an array) to integer type by
truncating all digits following the decimal point.


@anchor{float}
@item float()
@findex float()
Converts a number (or all the elements of an array) to floating point type.


@anchor{round}
@item round()
@findex round()
Converts a floating point number (or all the elements of an array) to the
nearest integer, i.e.@:

@example
round( 8.5 ) = 9    round( 8.49 ) = 8    round( -1.75 ) = -2
@end example


@anchor{floor}
@item floor()
@findex floor()
Converts a floating point number (or all the elements of an array) to the
largest integer that is not larger than the argument, i.e.@:

@example
floor( 8.6 ) = 8    floor( -8.6 ) = -9
@end example


@anchor{ceil}
@item ceil()
@findex ceil()
Converts a floating point number (or all the elements of an array) to the
smallest integer that is not less than the argument, i.e.@:

@example
round( 8.6 ) = 9     round( -8.6 ) = -8
@end example


@anchor{abs}
@item abs()
@findex abs()
Returns the absolute value of an integer or floating point number (or
all the elements of an array) .


@anchor{mean}
@item mean()
@findex mean()
Expects an one-dimensional array as input and returns the mean value of
the array elements. Optionally, it accepts up to two more integer
arguments, the start index of the first element of the array to be
included into the calculation and the number of elements to be used. If
the length parameter is missing all elements up to the end of the array
are used.


@anchor{rms}
@item rms()
@findex rms()
Expects an one-dimensional array as input and returns the square root of
the sum of the squared array elements, divided by the number of
elements.  Optionally, it accepts up to two more integer arguments, the
index of the first element of the array to be included into the
calculation and the number of elements to be used. If the length
parameter is missing all elements up to the end of the array are used.

@anchor{sqrt}
@item sqrt()
@findex sqrt()
Returns the square root of an integer or floating point number (or all
the elements of an array). The argument must be a positive number.


@anchor{random}
@item random()
@findex random()
If called with no argument the function returns a single pseudo-random
number in the interval @w{[0, 1]}. If called with a non-zero, positive
argument it returns an array of random numbers where the argument
specifies the size of the array.


@anchor{grandom}
@item grandom()
@findex grandom()
If called without an argument the function returns one of a set of
pseudo-random number with Gaussian distribution, a mean of zero and a
variance of 1. If called with a non-zero, positive argument it returns
an array of Gaussian distributed random numbers where the argument
specifies the size of the array. These random numbers are probably
better suited for simulating noise than the ones returned by
@code{random()}.


@anchor{set_seed}
@item set_seed()
@findex set_seed()
Sets a seed for the random number generator used in the functions
@code{random()} and @code{grandom()}. The argument has to be a positive
integer. Alternatively, when no argument is given, the time in seconds
since 00:00:00 UTC, January 1, 1970 is used as the seed.


@anchor{sin}
@item sin()
@findex sin()
Returns the sine of the argument (simple number or all elements of an
array), with the argument interpreted as the angle in radian.


@anchor{cos}
@item cos()
@findex cos()
Returns the cosine of the argument (simple number or all elements of an
array), with the argument interpreted as the angle in radian.


@anchor{tan}
@item tan()
@findex tan()
Returns the tangent of the argument (simple number or all elements of an
array), with the argument interpreted as the angle in radian.


@anchor{asin}
@item asin()
@findex asin()
Returns the inverse of the sine function of the argument (simple number
or all elements of an array) as an angle in radian. The argument must be in
the interval @w{[-1, 1]}, the result an element of the interval
@w{[-pi/2, pi/2]}.


@anchor{acos}
@item acos()
@findex acos()
Returns the inverse of the cosine function of the argument (simple
number or all elements of an array) as an angle in radian. The argument
must be in the interval @w{[-1, 1]}, the result an element of the
interval @w{[0, pi]}.


@anchor{atan}
@item atan()
@findex atan()
Returns the inverse of the tangent function of the argument (simple
number or all elements of an array) as an angle in radian, the result an
element of the interval @w{[-pi, pi]}.


@anchor{sinh}
@item sinh()
@findex sinh()
Returns the hyperbolic sine of the argument (simple number or all elements
of an array).


@anchor{cosh}
@item cosh()
@findex cosh()
Returns the hyperbolic cosine of the argument (simple number or all elements
of an array).


@anchor{tanh}
@item tanh()
@findex tanh()
Returns the hyperbolic tangent of the argument (simple number or all
elements of an array).


@anchor{asinh}
@item asinh()
@findex asinh()
Returns the inverse of the hyperbolic sine function of the argument
(simple number or all elements of an array).


@anchor{acosh}
@item acosh()
@findex acosh()
Returns the inverse of the hyperbolic cosine function of the argument
(simple number or all elements of an array).


@anchor{atanh}
@item atanh()
@findex atanh()
Returns the inverse of the hyperbolic tangent function of the argument
(simple number or all elements of an array).

@end table



@node Auxiliary functions, , Mathematical functions, Built-in Functions
@section Auxiliary functions
@cindex auxiliary functions


@table @samp
@anchor{end}
@item end()
@findex end()
The function simulates the user clicking onto the @code{Stop} button in
the display window. If there is an @code{ON_STOP} label flow of control
will be transfered to the code following the @code{ON_STOP} label,
otherwise the program will be stopped immediately. This function can be
used in the @code{EXPERIMENT} section only and not after the
@code{ON_STOP} label.


@anchor{abort}
@item abort()
@findex abort()
The function will abort the currently running program immediately
without even running the code following the @code{ON_STOP} label, so it
is a kind of an emergency exit when nothing better will do. When called it
displays a message box on the screen to inform the user. This function
can only be used in the @code{EXPERIMENT} section


@anchor{date}
@item date()
@findex date()
Returns a string with the current date in a form like @code{Sun Jun 17, 2000}.


@anchor{time}
@item time()
@findex time()
Returns a string with the current time in the form @code{hh:mm:ss}.


@anchor{delta_time}
@item delta_time()
@findex delta_time()
This function (that can only be used in the @code{EXPERIMENT} section of
the program) returns the time (in seconds) since the last call of the
functions as a floating point value. When called for the very first time
it returns the time since the start of the experiment (i.e.@: the time
the start of the @code{EXPERIMENT} section was processed). The time
returned by the function has micro-second resolution.


@anchor{wait}
@item wait()
@findex wait()
Waits for the specified time. Times are always to be given in seconds or
alternatively with a unit, e.g.@: @w{100 ms}. Unfortunately, the time
resolution of @code{wait()} is in the @w{10 ms} range and may even be
less precise. If the argument is negative the function will print an
error message and return immediately. The maximum time the function
accepts is more than 2.1 billion seconds (or about 68 years).

This function can only be used in the @code{EXPERIMENT} section of an
@acronym{EDL} program.

@anchor{slice}
@item slice()
@findex slice()
The function returns a part (slice) of an one-dimensional array. It
expects at least two arguments, the array the values are to be taken
from and the number of the start element of the slice to be returned.
Usually, you also will pass it a third argument, the length of the slice
to be returned. If this argument is missing an array made up from all
elements from the start element to the end of the array is returned.

For an array defined as
@example
X[ 8 ] = @{ 1, 2, 3, 4, 5, 6, 7, 8 @}
@end example
@noindent
the call of @code{slice()}
@example
slice( X, 3, 4 );
@end example
@noindent
will return an array with 4 elements containing the data
@example
3, 4, 5, 6
@end example


@anchor{ int_slice }
@item int_slice()
@findex int_slice()
Creates an integer array of the size of the first and only argument
with every element set to @code{0} that can be assigned to an integer
array of variable length.

@anchor{ float_slice }
@item float_slice()
@findex float_slice()
Creates an float array of the size of the first and only argument with
every element set to @code{0.0} that can be assigned to a float array
of variable length.


@anchor{dim}
@item dim()
@findex dim()
The function returns the dimension of the array passed to it as
argument. I.e.@: if applied to the array
@example
X[ 4, 2, 5 ]
@end example
@noindent
it will return @code{3}.


@anchor{size}
@item size()
@findex size()
The function normally takes two arguments, an array and one of the
dimensions of the array, and returns the size of this dimension. I.e.@:
for an array defined as
@example
@code{X[ 4, 2, 5 ]}
@end example
@noindent
@code{size( X, 3 )} will return @code{5}.
Only for one-dimensional arrays a single argument, the name of the
array, is sufficient (i.e.@: the only possible value of @code{1} for
the second parameter can be omitted) and the function returns the length
of the one-dimensional array.


@anchor{sizes}
@item sizes()
@findex sizes()
This function is similar to @code{size()} but only takes an array as
argument and returns a new one-dimensional array with the sizes of the
different dimensions of the input array.
@example
X[ 4, 2, 5 ]
Dim_X[ * ];

Dim_X = size( X );
@end example
@noindent
will set the array @code{Dim_X} to @code{4, 2, 5}.


@end table
