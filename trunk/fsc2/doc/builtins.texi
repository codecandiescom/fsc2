@c $Id$
@c
@c Copyright (C) 2001 Jens Thoms Toerring
@c
@c This file is part of fsc2.
@c
@c Fsc2 is free software; you can redistribute it and/or modify
@c it under the terms of the GNU General Public License as published by
@c the Free Software Foundation; either version 2, or (at your option)
@c any later version.
@c
@c Fsc2 is distributed in the hope that it will be useful,
@c but WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with fsc2; see the file COPYING.  If not, write to
@c the Free Software Foundation, 59 Temple Place - Suite 330,
@c Boston, MA 02111-1307, USA.


@node Built-in Functions, Device Functions, EDL, Top
@chapter Built-in Functions

@ifinfo
@menu
* Output functions::        Functions for printing, drawing and storing.
* Interaction functions::   Functions buttons and sliders.
* Mathematical functions::  Function for doing mathematics.
* Auxiliary functions::     All other functions.
@end menu
@end ifinfo


@node Output functions, Interaction functions, Built-in Functions, Built-in Functions
@section Output functions
@cindex output functions

@table @samp
@anchor{print}
@item print()
@findex print()
This function prints text into the output browser in the main form of
@acronym{fsc2}.  It needs a @i{format string}
@cindex format string
as its very first argument. The @i{format string} can contain any text
as well as a special character, @code{#},
@findex # @r{(in @code{print()} function)}
that works as a placeholder for data to be printed in its place.  Here's
a first simple example: You want to print the value of a variable called
@code{I}, that has been assigned a value of 3. Now,
@example
print( "The value of I is #.\n", I );
@end example
@noindent
will print, when the program is interpreted,
@example
The value of I is 3.
@end example
@noindent
But you can have not only one but as many placeholder characters in the
@i{format string} as you need. Of course, the number of placeholder
characters has to match the number of variables (or data) following the
@i{format string}. If the number of @code{#}'s and the number of
variables to be printed doesn't fit a warning is printed. If there are
too many @code{#}'s the superfluous ones are simply printed, if
there are not enough only as many variables as there are @code{#}'s are
printed, the rest is discarded.

You may use @code{print()} to print integer or floating point values
(that includes the return values of functions) and variables and strings
(i.e.@: text enclosed in double quotes, @code{"}).  Here's a longer,
somewhat contrived example:
@example
print( "The # of # is: #\n", "sine", x, sin( x ) );
@end example
@noindent
This will print (assuming @code{x} equals 0.5):
@example
The sine of 0.500000 is: 0.479426
@end example

There are special sequences allowed in the @i{format string}. They all
start with an @i{escape character}, the backslash, @code{\}. Here's a
list of all recognized special sequences:
@table @samp
@cindex escape characters (in @code{print()} function)
@item \n
Linefeed character: Ends a line, everything following starts on a new
line. Thus several lines can be printed at once by one call of
@code{print()}. @code{print()} does not automatically add a linefeed.
@item \t
Embed a tabulator character, tab stops are set at every eighth character.
@item \\
Prints a backslash, @code{\}, thus switching off the special meaning of the
backslash as an escape character.
@item \"
Prints a quote - use it to embed quotes into the @i{format
string}.
@item \#
Prints a @code{#}, thus switching off the special meaning of the
@code{#} character as a placeholder for variables to be printed.
@item \T
While normally nothing is printed while a test of the @code{EXPERIMENT}
experiment section of an @acronym{EDL} file is run, if the @i{format
string} starts with this escape sequence the @code{print()} function
will produce output already in the test run.
@end table


@anchor{init_1d}
@item init_1d()
@findex init_1d()
Initializes the display for one-dimensional experiments - without a call to
this function no data will be displayed. The function takes up to six
arguments but all of them are optional. They are:
@enumerate
@item
Number of curves to be displayed, maximum is currently 4 curves. If not given
it defaults to 1.
@item
Number of points, if missing or zero or negative it will be treated as
unknown and default to 64 points. If the specified or the default value
turns out to be too small it is adjusted automatically in the experiment
so that all data fit into the display.
@item
Start value of the @i{x}-axis. If missing (or undefined, see next point)
point numbers are printed, starting with 1 (if @acronym{FORTRAN} style
array offsets are used, for C style arrays the starting value is 0).
@item
Increment for data along the @i{x}-axis (thus restricting the display to
equally spaced data). Setting it to zero implies that the start value
and the increment are undefined and point numbers are shown
instead. Negative increments are handled correctly.
@item
String variable with label to be shown at the @i{x}-axis.
@item
String variable with label to be shown at the @i{y}-axis.
@end enumerate

Formally, the function with its arguments can be written as

@example
init_1d( [ n_curves [ , n_points [ , start, increment ] ], ]
         [ x_label [ , y_label ] ] )
@end example
@noindent
This means that the function can be called in all of the following ways:

@example
init_1d( n_curves, n_points, start, increment, x_label, y_label )
init_1d( n_curves, n_points, start, increment, x_label )
init_1d( n_curves, n_points, x_label, y_label )
init_1d( n_curves, n_points, x_label )
init_1d( n_curves, n_points )
init_1d( n_curves, x_label, y_label )
init_1d( n_curves, x_label )
init_1d( n_curves )
init_1d( x_label, y_label )
init_1d( x_label )
init_1d( )
@end example
@noindent
In error messages the start value and the increment of the data
displayed at the @i{x}-axis are (in contrast to the point numbers)
referred to as `real world coordinates'.


@anchor{init_2d}
@item init_2d()
@findex init_2d()
Initializes the display for two-dimensional experiments - without a call to
this function no data will be displayed. The function takes up to nine
arguments but all of them are optional. They are:
@enumerate
@item
Number of data sets to be displayed, maximum is currently 4. If not
given it defaults to 1.
@item
Number of points in @i{x}-direction, if missing or less than 1 it will be
treated as unknown and default to 64. If the specified or the default value
turns out to be too small it is adjusted automatically in the experiment
so that all data fit into the display.
@item
Number of points in @i{y}-direction, if missing or less than 1 it will
be treated as unknown and default to 32. If the specified or the default
value turns out to be too small it is adjusted automatically in the
experiment so that all data fit into the display.
@item
Start value of the @i{x}-axis. If missing (or undefined, see next entry)
point numbers are printed, starting with 1 (or 0, depending on the
setting for array start-offsets).
@item
Increment for data along the @i{x}-axis (thus restricting the display to
equally spaced data). Setting it to zero implies that the start value
and the increment are undefined and point numbers are shown instead.
@item
Start value of the @i{y}-axis. The same rules as for the @i{x}-axis apply
for missing or undefined values.
@item
Increment for data along the @i{y}-axis. The same rules as for the
@i{x}-axis apply for missing or undefined values.
@item
String variable with label to be shown at the @i{x}-axis.
@item                
String variable with label to be shown at the @i{y}axis.
@item
String variable with label to be shown at the @i{z}-axis.
@end enumerate
Formally, the function with its arguments can be written as
@example
init_2d( [ n_data_sets [ , n_x_points [ , n_y_points, 
         [ , x-start, x-increment, y-start, y-increment ] ,
         ]  ]  ] [ x-label [ , y-label [ , z-label ] ] ] )
@end example


@anchor{display}
@item display( )
@findex display()
This function has to be called to display data in 1-dimensional as well as
2-dimensional experiments. It takes the following arguments:

@enumerate
@item
The (@i{x}) point number of the data point (if only a single number is
given as the third argument) or the point number of the first data point
in the data array passed as third argument.
@item
Only in 2D-experiments: The @i{y}-point number of the data point or the
point number of the first data point in the data array.
@item
The data point or an (one-dimensional) array of data.
@item
Number of the curve or data set the data are to be displayed in. If missing it
defaults to the first curve, 1. If there is more than one data set given
in the @code{display()} command the curve number @strong{can't} be left out.
@end enumerate
These arguments can be repeated as many times as there are data to be
displayed simultaneously (but in this case none of the arguments may be left
out!).

Formally, the function with its arguments can be written for 1D-experiments as
@example
display( n_x_point, data [ , n_curve [ , ... ] ] )
@end example
@noindent
while for 2D-experiments it is
@example
display( n_x_point, n_y_point, data [ , n_curve [ , ... ] ] )
@end example


@anchor{change_scale}
@item change_scale()
@findex change_scale()
This function allows it to change the scale settings (originally set in
the call of @w{@code{init_1d()}} or @w{@code{init_2d()}}) after an
experiment has been started. With a one-dimensional display the function
can be passed a maximum of two arguments, the new start value of the
@i{x}-axis and the new @i{x}-increment. For two-dimensional display the
function also accepts a new start value for the @i{y}-axis as well as
the @i{y}-increment. If one of these values should remain unchanged
instead of a value a string (e.g.@ @code{"keep"}) can be passed as the
argument.


@anchor{change_label}
@item change_label()
@findex change_label()
Using this function the labels at the axis of te display window (and, if
shown, of the cross section window) can be changed from within as
@acronym{EDL} program. For 1D-display it accepts up to two strings for
the @i{x}- and @i{y}-axis labels, for 2D-display up to three, the third
for the @i{z}-axis label. To leave a label unchanged pass the function
an empty string, i.e.@ @code{""}. If no label should be drawn pass it
a string that just contains one (or more) space characters, i.e.@:
@code{" "}.


@anchor{rescale}
@item rescale()
@findex rescale()
In the funtion @code{init_1d()} or @code{init_2d()} the number of points
in @i{x}- (and @i{y}-) direction can be set. If, during the experiment
more points are displayed then set in the initialization, the scaling of
the axis (or axis in the 2D-case) will be changed automatically. Using
the function @code{rescale()} one can change the number of points from
within the @acronym{EDL} program. In the 1D-case the function accepts
one argument, the new number of points in @i{x}-direction. If this value
is @code{0} the number of points is adjusted to the number of points
currently displayed. Exceptions are when either the new number of
points is smaller than the default number, in which case the default
number is used, or the number is smaller than the number of points
currently displayed which is then used as the new number of
points. Passing the function a value of @code{-1} means that the number
of points should remain unchanged.

In the 2D-case the function accepts two arguments, one for the number of
points to be displayed in @i{x}-direction and the second for the number
of points in @i{y}-direction. As in the 1D-case a @code{-1} means not to
do any changes to the axis and @code{0} sets the number of points to the
number of points currently displayed alog this axis.


@anchor{clear_curve}
@item clear_curve()
@findex clear_curve()
Removes one or more curves from the display. As many arguments as there
are curves can be used. No arguments at all implies the first
curve. Invalid arguments are discarded and an error message is printed.


@anchor{get_file}
@item get_file( )
@findex get_file()
Opens a new file and returns a unique identifier for the file that can
be stored in an integer variable and is to be used in calls to functions
of the @w{@code{save_xxx()}}-family. If no argument is given a file selector
is shown and lets the user choose a file. If opening the selected file
fails the user is asked to select a different file name. If the user
cancels the selection of a file (s)he is asked for confirmation since
data may get lost. If the user decided not to select a file the function
returns an (invalid) file identifier of @code{-1}.

The function accepts up to five arguments, all of them optional. The
first one is usually the prompt string to be printed in the file
selector. If it is missing or is the empty string (use `@code{""}' to
create an empty string) it defaults to `@i{Please enter a file
name:}'. The second argument is a pattern for the file name, defaulting
to `@i{*.dat}'. You may use all the usual wildcard characters you're
used to from the shell. The third argument is the directory the search
for the file name should start from. As the fourth argument you may pass
a file name to the function as the default file that appears in the
entry for the selected file. Finally, the fifth and last argument can be
a default extension for the file. This extension will be appended
automatically to the name of the file the user selected unless the name
has already this extension. This way one can enforce an extension for
the filename.

But there's also an alternative. If the very first string (that is
usually used for the prompt string) starts with a backslash `@code{\}'
the following characters (i.e.@: everything except the leading
backslash) are taken as the name of the file to be used automatically.
The file selector will not be shown and instead the hard-coded file name
will be used. Only if opening this file fails the remaining parameters
will be used when asking for an alternative file (except the prompt
string, the default will be used).

If @code{get_file()} is never called, on the first call to a function
from the @code{save_xxx()}-family the user is asked to select a file and
this file is used exclusively in further @code{save_xxx()}-calls.
I.e.@: either @code{get_file()} is called before any save-operation or
never at all!


@anchor{clone_file}
@item clone_file( )
@findex clone_file()
Sometimes two output files are needed that should only differ in their
extension but not in the filename. In this case the function
@code{clone_file()} can be useful. It expects exactly three
arguments. The first one is an identifier for an already existing file as
returned by the function @code{get_file()}. (If in the call of
@code{get_file()} the user did @b{not} to choose a file, i.e. pressed
the @code{Cancel}-button, it is silently assumed that also the second
file is @b{not} to be used.)

The second and third arguments both have to be strings. The second
argument is the expected extension of the file that was selected via the
previous call of @code{get_file()}. And the third argument is the
replacement for the extension of the previously selected file. If the
second argument does not fit with the extension of the file the user had
choosen, the new extension from the third argument is appended to the
file name (instead of replacing the extension).

A typical piece of code to open two files, the first with the extension
@code{dat} and the second with the same name but the extension
@code{list} would be:
@example
FILE1 = get_file( "", "*.dat", "", "", "dat" );
FILE2 = clone_file( FILE1, "dat", "list" );
@end example
If the user chooses @code{experiment.dat} as the first file, a second
file with the name @code{experiment.list} will be opened automatically.

The function also takes care that no files will be overwritten
accidentally. If the second file already exists the user gets asked to
select different file. The program enforces that the extension of the
new file is identical to the one passed as the third argument.


@anchor{save}
@item save()
@findex save()
Writes one or more data or complete arrays to a file. But some care has
to be used: If @w{@code{get_file()}} has been called before the first
argument has to be the file number returned by the call to tell
@acronym{fsc2} which file to use. If, on the other hand,
@code{get_file()} hasn't been called before, the user is asked to select
a file now and all further calls of functions of the
@w{@code{save_xxx()}} type will use this one file and the first argument
will be assumed to be a value to be written to this file!

All arguments (following the file identifier if there's one) are
data. The types of these data may be

@itemize @bullet
@item
Integer data
@item
Floating point data
@item
Strings (with no interpretation of escape sequences, see also @code{fsave()})
@item
One-dimensional arrays (or slices of arrays) of integer or floating point
type
@item
Complete more-dimensional arrays
@end itemize

The function saves data in an unformatted fashion, i.e.@: each data
value is written on a new line. The only exception is more-dimensional
arrays - here an empty line is output between the individual slices of
the array. Here's an example: The array

@example
X[ 3, 2 ] = @{ 1, 2, 3, 4, 5, 6 @}
@end example
@noindent
will be printed as

@example
1
2

3
4

5
6
@end example


@anchor{fsave}
@item fsave()
@findex fsave()
This function may be used to write data in a formated way into a
file. As in the case of the @code{save()} function the first argument
may be a file identifier. The next argument must be a @i{format string}
with exactly he same syntax as in the @code{print()} function,
i.e.@: there must be one @code{#} character for each data item. In
contrast to the @code{save()} function this function can not be used to
print array slices or complete arrays, but only simple data types. On
the other hand, printing of complete arrays can be done using loops,
i.e.@: as in the following example:

@example
VARIABLES:

FILE_ID;
I; J;
X[ 3, 2 ] = @{ 1, 2, 3, 4, 5, 6 @};

EXPERIMENT:

FILE_ID = get_file( );

for I = 1 : 3 @{
    for J = 1 : 2 @{
        fsave( FILLE_ID, "X[ #, # ] = #\n", I, J, X[ I, J ] );
    @}
@}
@end example
@noindent
This will print:

@example
X[ 1, 1 ] = 1
X[ 1, 2 ] = 2
X[ 2, 1 ] = 3
X[ 2, 2 ] = 4
X[ 3, 1 ] = 5
X[ 3, 2 ] = 6
@end example


@anchor{save_program}
@item save_program()
@findex save_program()
This functions writes the currently run @acronym{EDL} program into a
file. As usual, the first argument may be a file identifier - the same
rules apply as for @code{save()} and @code{fsave()}. The second argument
can be a string that is prepended to each line of the program, i.e.@: a
comment character to make other programs like @acronym{MATHLAB} or
@acronym{octave} skip these lines.


@anchor{save_output}
@item save_output()
@findex save_output()
This function has the same arguments as @code{save_program()} but prints
the content of the output window (i.e.@: the bottom browser window in
the main form) into the file.


@anchor{save_comment}
@item save_comment()
@findex save_comment()
This function is used to print comments into the file. When it is called a
small editor is shown and the user may enter comments. These will be then
written into the file.

The first argument may as usual be a file identifier (or may be missing
if @w{@code{get_file()}} hasn't been called). The second argument is
again a string to be prepended to each line of the comment. The third
argument is a preset string that appears in the comment editor when it is
opened - use "@code{\n}" to separate the lines of a multi-line text. The
last argument is the label string to be shown on top of the editor - it
defaults to "Please enter a comment:".


@anchor{is_file}
@item is_file()
@findex is_file()
This function expects a file handle as returned by @code{get_file()} and
checks if it is valid and if the associated file is open for writing.
@end table


@node Interaction functions, Mathematical functions, Output functions, Built-in Functions
@section Interaction functions
@cindex interaction functions

These functions are for creating, handling and deleting of buttons,
sliders and input fields. When such an object is created for the first
time a new window with the title "Toolbox" opens up. The objects (i.e.@:
buttons, sliders and input and output fields) displayed in the toolbox
allow the user to influence the experiment when it is already
running. The toolbox window will vanish automatically when all objects
have been deleted. The toolbox with its objects can only be used while
the experiment, i.e.@: the functions for creating, handling and deleting
of objects can only be used within the @code{EXPERIMENT} section of the
program.

Please note that if the objects in the toolbox are used it is
not possible anymore to check the complete experiment before it is run
because it is impossible to forsee which buttons, sliders or input
fields are used at what moment. Therefore, these functions should only
be used where it is really necessary, i.e.@: when trying to find the
optimum parameters for an experiment but not in the final experiment.

When the program is tested before the experiment is started it is
assumed that all buttons are not pressed and switched off (unless they
have been set by the function @code{button_state()}, all sliders are
assumed to be in the middle position unless a different value has been
set via the function @code{slider_value()} and all input and output
fields are initialized to 0 unless an initial value has been passed to
the functions @code{input_create()} or @code{output_create()}.


@table @samp
@anchor{layout}
@item layout()
@findex layout()
The functions tells the program how to layout the buttons and sliders in
the window, either vertically or horizontally. The function must be
called either with the strings @code{"VERT"}, @code{"VERTICAL"},
@code{"HORI"} or @code{"HORIZONTAL"} (the case of the letters doesn't
matter). The numbers @code{0} and @code{1} can be used alternatively for
vertical or horizontal layout.

Of course this function has to be called @b{before} a function to create
an object (button, slider or in- or output field) has been invoked.


@anchor{button_create}
@item button_create()
@findex button_create()
The function creates a new button and returns a unique integer number
that has to be used in later calls to identify this button. There are
three types of buttons, normal buttons that can be just pressed to
create an event, push buttons that stay on or off, and finally radio
buttons, that are also some kind of push buttons but that belong to a
group of buttons of which only one button can be switched on at once,
i.e.@: if a radio button gets pressed all the other radio buttons
belonging to the group become automatically unset.

Normal buttons are drawn as large rectangular boxes with the label in
thwe middle, push buttons are drawn as squares, standing on a corner,
that become yellow when pressed, and radio buttons as round buttons,
that become red when activated.

The first argument the function needs is the type of the button, i.e.@:
on of the strings @code{"NORMAL_BUTTON"}, @code{"PUSH_BUTTON"} or
@code{RADIO_BUTTON"} (the case of the letters doesn't matter).

For a radio button it must be specified which group it belongs to. Each
group has a button functioning as the group leader which is always the
first button of the group. For all other members of this group the
identifier of the group leader button must be specified as the second
argument. I.e.@: to create a group of three rdio buttons you would use
@example
B_ID_1 = button_create( "RADIO_BUTTON", "Label 1" );
B_ID_2 = button_create( "RADIO_BUTTON", B_ID_1, "Label 2" );
B_ID_3 = button_create( "RADIO_BUTTON", B_ID_1, "Label 3" );
@end example

For all buttons except radio buttons the second (optional) argument is
the string that is to appear as the label of the button. The final (also
optional) argument is a further string that is an additional help text
that will appear when the mouse remains for some time over the button.
Both label and help text may contain some escape sequences, namely
`@code{\n}', standing for a line break (to create a multi-line label or
help text) and `@code{\\}', standing for the backslash character to
allow a backslash in front of an `n'.

All buttons start in the deactivated state except the 'leader' of a
group of radio buttons.


@anchor{button_delete}
@item button_delete()
@findex button_delete()
Using this function one or more buttons can be deleted. It expects one
or a list of button identifiers (separated by commata) as returned by
the function @code{button_create()}.

If the group leader (i.e.@: the first button) of a group of radio
buttons is deleted, the next button of the group becomes the new group
leader automatically.


@anchor{button_state}
@item button_state()
@findex button_state()
The function returns or sets the state of a button, depending on the
number of argument. The first argument is the identifier of the button
as returned by the function @code{button_create()}. If there are no more
arguments the state of the button is returned. There is a difference
between normal buttons and push and radio buttons. For normal buttons
the number of times the button was pressed since the last call of the
function is returned. For push and radio buttons the state of the
button, i.e.@: either @code{0} for off or @code{1} for on is returned.

If there is a second argument the state of push and radio buttons can be
set. This argument must be either a string (@code{"ON"} or @code{"OFF"})
or a number with @code{0} standing for off and a non-zero number for
on. The state of normal buttons cannot be set.


@anchor{slider_create}
@item slider_create()
@findex slider_create()
Sliders are for setting values in a predefined range. There are two
types of sliders, normal sliders and value sliders. The only difference
is that for value sliders there's an additional field showing the
currently set value while for normal sliders there isn't such a visual
feedback. As the function @code{button_create()} also this function
returns a unique integer number to be used to identify the slider.

The first argument the function expects is a string, either
@code{"NORMAL_SLIDER"} or @code{"VALUE_SLIDER"} (the case of the
letters doesn't matter). "Normal" sliders are just sliders without any
decoration while "value" sliders have an extra field showing the current
value set via the slider.

The second argument must be the minimum value the slider can be adjusted
to and the third argument is the maximum value. The minimum value must
always be smaller than the maximum value.

A third, optional paramter is the step size to be used, i.e.@: the
minimum increment the slider value can be changed. Of course, this value
has to be larger than zero and smaller than the differenece between the
minimum and maximum value of the slider.

As in the case of buttons there are two more (optional) arguments, the
label to be shown below the slider and a help text. The same escape
sequences as for button labels and help texts.

All sliders start of as set to the middle of the defined range. If a
step size is given for the slider the allowed value nearest to the
middle value is used as the sliders initial value.


@anchor{slider_delete}
@item slider_delete()
@findex slider_delete()
The function deletes on or more sliders. It expects one or a list of
slider identifiers as returned by the function @code{slider_create()}.


@anchor{slider_value}
@item slider_value()
@findex slider_value()
This function returns or sets the value of a slider. The first argument
must be a slider identifier as returned by the function
@code{slider_create()}. If this is the only argument the value the
slider is currently set to is returned. If there's a second value the
slider is set to this value. Obviously, the value must be within the
range of the slider as defined by the minimum and maximum value set in
@code{slider_create()}, otherwise an error message is printed and the
slider value is set to the next value still within the allowed range.
If a step size is set for the slider and the new value does not fit with
the step size the nearest allowed value is set.


@anchor{input_create}
@item input_create()
@findex input_create()
Using input fields numerical values can be entered. There are two
different types of input fields, one, that will only accept integer
values, while the other also allows input of floating point numbers. The
first argument of the function for creating an input field,
@code{input_create()}, is the type of the input field. If the first
argument is @code{"INT_INPUT"} the input field will only accept interger
numbers, while with an argument of @code{"FLOAT_INPUT"} also floating
point numbers can be entered. (@code{"INT_INPUT"} can be replaced by the
numerical argument 0 and @code{"FLOAT_INPUT"} by 1.)

If the second argument is a number it is taken to be the initial value
in the input field. If there is either no second argument or the second
argument is not a number but a string, the input field will be
initialized to 0.

As in the case of buttons and sliders there are two more (optional)
arguments, the label to be shown below the input field and a help
text. The same escape sequences as for button and lider labels and help
texts can be used for buttons and sliders.

The final, optional field for an input object is a format string that is
used when printing the value. The format string is a simplified version
of a C format string. It must start with @code{%}, optionally followed
by the minimum field width, a dot, the precision and finally
(non-optionally) either @code{f}, @code{e} or @code{g} (or @code{F},
@code{E} or @code{G}). For more information please read the manual page
for C's printf(3).


@anchor{input_delete}
@item input_delete()
@findex input_delete()
The function deletes on or more input field. It expects one or a list of
input field identifiers as returned by the function @code{input_create()}.


@anchor{input_value}
@item input_value()
@findex input_value()
This function returns or sets the value of an input field. The first
argument must be an input field identifier as returned by the function
@code{input_create()}. If this is the only argument the value the input
field is set to is returned. If there's a second value the input field
is set to this value. Obviously, the value must be number.


@anchor{output_create}
@item output_create()
@findex output_create()
In contrast to input objects output objects can be used to display a
value but the user can't change the value. As in the case of input
objects there are two different types of output fields, one, that will
only accept integer values, while the other also allows output of
floating point numbers. The first argument of the function for creating
an output field, @code{output_create()}, is the type of the output
field. If the first argument is @code{"INT_OUTPUT"} the output field
will only show interger numbers, while with an argument of
@code{"FLOAT_OUTPUT"} also floating point numbers can be
displayed. (@code{"INT_OUTPUT"} can be replaced by the numerical
argument 2 and @code{"FLOAT_OUTPUT"} by 3.)

If the second argument is a number it is taken to be the initial value
in the output field. If there is either no second argument or the second
argument is not a number but a string, the output field will be
initialized to 0.

As in the case of buttons and sliders there are two more (optional)
arguments, the label to be shown below the input field and a help
text. The same escape sequences as for button and lider labels and help
texts can be used for buttons and sliders.

The final, optional field for an output object is a format string that is
used when printing the value. The format string is a simplified version
of a C format string. It must start with @code{%}, optionally followed
by the minimum field width, a dot, the precision and finally
(non-optionally) either @code{f}, @code{e} or @code{g} (or @code{F},
@code{E} or @code{G}). For more information please read the manual page
for C's printf(3).


@anchor{output_delete}
@item output_delete()
@findex output_delete()
The function deletes on or more output field. It expects one or a list of
output field identifiers as returned by the function @code{input_create()}.


@anchor{output_value}
@item output_value()
@findex output_value()
This function sets a new value for an output field or returns the
current value. The first argument must be an output field identifier as
returned by the function @code{output_create()}. If this is the only
argument the value the output field is set to is returned. If there's a
second value the output field is set to this value. Obviously, the value
must be number.


@anchor{object_delete}
@item object_delete()
@findex object_delete()
The function deletes on or more objects from the toolbox. It expects one
or a comma separated list of object identifiers as returned by the
functions @code{button_create()}, @code{slider_create()} and
@code{input_create()}.


@end table



@node Mathematical functions, Auxiliary functions, Interaction functions, Built-in Functions
@section Mathematical functions
@cindex mathematical functions

@table @samp
@anchor{int}
@item int()
@findex int()
Converts a number (or all the elements of an array) to integer type by
truncating all digits following the decimal point.


@anchor{float}
@item float()
@findex float()
Converts a number (or all the elements of an array) to floating point type.


@anchor{round}
@item round()
@findex round()
Converts a floating point number (or all the elements of an array) to the
nearest integer, i.e.@:

@example
round( 8.5 ) = 9    round( 8.49 ) = 8    round( -1.75 ) = -2
@end example


@anchor{floor}
@item floor()
@findex floor()
Converts a floating point number (or all the elements of an array) to the
largest integer that is not larger than the argument, i.e.@:

@example
floor( 8.6 ) = 8    floor( -8.6 ) = -9
@end example


@anchor{ceil}
@item ceil()
@findex ceil()
Converts a floating point number (or all the elements of an array) to the
smallest integer that is not less than the argument, i.e.@:

@example
round( 8.6 ) = 9     round( -8.6 ) = -8
@end example


@anchor{abs}
@item abs()
@findex abs()
Returns the absolute value of an integer or floating point number (or
all the elements of an array) .


@anchor{mean}
@item mean()
@findex mean()
Expects an one-dimensional array as input and returns the mean value of
the array elements. Optionally, it accepts up to two more integer
arguments, the start index of the first element of the array top be
included into the calculation and the number of elements to use. If the
length parameter is missingall elements up to the end of the array are
used.


@anchor{rms}
@item rms()
@findex rms()
Expects an one-dimensional array as input and returns the square root of
the sum of the squared array elements, divided by the number of elements.


@anchor{sqrt}
@item sqrt()
@findex sqrt()
Returns the square root of an integer or floating point number (or all
the elements of an array). The argument must be a positive number.


@anchor{random}
@item random()
@findex random()
Returns a pseudo-random number in the interval @w{[0, 1]}.


@anchor{grandom}
@item grandom()
@findex grandom()
Returns pseudo-randoms number with gaussian distribution, a mean of zero
and a variance of 1. These numbers are probably better suited for
simulating noise than the ones returned by @code{random()}.


@anchor{set_seed}
@item set_seed()
@findex set_seed()
Sets a seed for the random number generator used in the functions
@code{random()} and @code{grandom()}. The argument has to be a positive
integer. Alternatively, when no argument is given, the time in seconds
since 00:00:00 UTC, January 1, 1970 is used as the seed.


@anchor{sin}
@item sin()
@findex sin()
Returns the sine of the argument (simple number or all elements of an
array), with the argument interpreted as the angle in radian.


@anchor{cos}
@item cos()
@findex cos()
Returns the cosine of the argument (simple number or all elements of an
array), with the argument interpreted as the angle in radian.


@anchor{tan}
@item tan()
@findex tan()
Returns the tangent of the argument (simple number or all elements of an
array), with the argument interpreted as the angle in radian.


@anchor{asin}
@item asin()
@findex asin()
Returns the inverse of the sine function of the argument (simple number
or all elements of an array) as an angle in radian. The argument must be in
the interval @w{[-1, 1]}, the result an element of the interval
@w{[-pi/2, pi/2]}.


@anchor{acos}
@item acos()
@findex acos()
Returns the inverse of the cosine function of the argument (simple
number or all elements of an array) as an angle in radian. The argument
must be in the interval @w{[-1, 1]}, the result an element of the
interval @w{[0, pi]}.


@anchor{atan}
@item atan()
@findex atan()
Returns the inverse of the tangent function of the argument (simple
number or all elements of an array) as an angle in radian, the result an
element of the interval @w{[-pi, pi]}.


@anchor{sinh}
@item sinh()
@findex sinh()
Returns the hyperbolic sine of the argument (simple number or all elements
of an array).


@anchor{cosh}
@item cosh()
@findex cosh()
Returns the hyperbolic cosine of the argument (simple number or all elements
of an array).


@anchor{tanh}
@item tanh()
@findex tanh()
Returns the hyperbolic tangent of the argument (simple number or all
elements of an array).

@end table



@node Auxiliary functions, , Mathematical functions, Built-in Functions
@section Auxiliary functions
@cindex auxiliary functions


@table @samp
@anchor{abort}
@item abort()
@findex abort()
The function will abort the currently running program immediately, so
it's kind of an emergency exit when nothing else will do. When called
it displays a message box on the screen to inform the user.


@anchor{date}
@item date()
@findex date()
Returns a string with the current date in a form like @code{Sun Jun 17, 2000}.


@anchor{time}
@item time()
@findex time()
Returns a string with the current time in the form @code{hh:mm:ss}.


@anchor{delta_time}
@item delta_time()
@findex delta_time()
This function (that can only be used in the @code{EXPERIMENT} section of
the program) returns the time (in seconds) since the last call of the
functions as a floating point value. When called for the very first time
it returns the time since the start of the experiment. The time
returned by the function has micro-second resolution.


@anchor{wait}
@item wait()
@findex wait()
Waits for the specified time. Times are always to be given in seconds or
alternatively with a unit, e.g.@: @w{100 ms}. Unfortunately, the time
resolution of @code{wait()} is in the @w{10 ms} range and may even be
less precise. If the argument is negative the function will print an
error message and return immediately. The maximum time the function
accepts is more than 2.1 billion seconds (or about 68 years).


@anchor{slice}
@item slice()
@findex slice()
The function returns a part (slice) of an one-dimensional array. It
expects at least two arguments, the array the values are to be taken
from and the number of the start element of the slice to be returned.
Usually, you also will pass it a third argument, the length of the slice
to be returned. If this argument is missing an array made up from all
elements from the start element to the end of the array is returned.

For an array defined as
@example
X[ 8 ] = @{ 1, 2, 3, 4, 5, 6, 7, 8 @}
@end example
@noindent
the call of @code{slice}
@example
slice( X, 3, 4 );
@end example
@noindent
will return an array with 4 elements containing the data
@example
3, 4, 5, 6
@end example


@anchor{dim}
@item dim()
@findex dim()
The function returns the dimension of the array passed to it as
argument. I.e.@: for the array

@example
X[ 4, 2, 5 ]
@end example
@noindent
it will return 3.


@anchor{size}
@item size()
@findex size()
The function takes two arguments, an array and one of the dimensions of the
array, and returns the size of this dimension. I.e.@: for an array defined as
@example
@code{X[ 4, 2, 5 ]}
@end example
@noindent
@code{size( X, 3 )} will return 5.


@anchor{sizes}
@item sizes()
@findex sizes()
This function is similar to @code{size()} but only takes an array as
argument an returns a new one-dimensional array with the sizes of the
different dimensions. I.e.@: use it the following way:

@example
X[ 4, 2, 5 ]
Dim_X[ * ];

Dim_X = size( X );
@end example
@end table
