#
# $Id$
#

 NI_DAQ Library Manual
 =====================

The maximum number of PCI E Series boards that can be used is controlled
via the 'NI_DAQ_MAX_PCI_E_BOARDS' macro, which is currently set to 4.
This isn't defined by the library but by the kernel module - if you want
to use more boards you must change the define in the header file for the
kernel module 'ni_daq_drv.h' and recompile and re-install both the kernel
module and the library.

To use the library you will have to include the header file 'ni_daq.h'.

The library supplies the following groups of functions:

A) Administrative and miscellaneous functions:

    ni_daq_open()
    ni_daq_close()
    ni_daq_perror()
    ni_daq_strerror()

    ni_daq_msc_set_clock_speed()
    ni_daq_msc_set_clock_output()
    ni_daq_msc_get_clock_state()
	ni_daq_msc_set_trigger()

B) Functions for analog input (AI):

    ni_daq_ai_set_speed()
    ni_daq_ai_get_speed()
    ni_daq_ai_channel_configuration()
    ni_daq_ai_acq_setup()
    ni_daq_ai_start_acq()
    ni_daq_ai_get_acq_data()

C) Functions for analog output (AO):

    ni_daq_ao_channel_configuration()
    ni_daq_ao()

D) Counter/pulser functions (GPCT):

    ni_daq_gpct_set_speed()
    ni_daq_gpct_get_speed()
    ni_daq_gpct_start_counter()
    ni_daq_gpct_start_gated_counter()
    ni_daq_gpct_stop_counter()
    ni_daq_gpct_get_count()
    ni_daq_gpct_single_pulse()
    ni_daq_gpct_continuous_pulses()
    ni_daq_gpct_stop_pulses()
    ni_daq_gpct_state()

E) DIO functions (DIO):

    ni_daq_dio_write()
    ni_daq_dio_read()


Most of these functions return an integer, indicating success or failure.
On success, 'NI_DAQ_OK' (which is just 0) is returned. On failure a
negative number is returned, indicating the type of failure. The
following values can be expected:

    NI_DAQ_OK            Success
    NI_DAQ_ERR_NSB       No such board
    NI_DAQ_ERR_CBS       Counter is busy
    NI_DAQ_ERR_IVA       Invalid argument
    NI_DAQ_ERR_WFC       Can't wait for continuous counter to stop
    NI_DAQ_ERR_BBS       Board is busy
    NI_DAQ_ERR_IVS       Source argument invalid
    NI_DAQ_ERR_BNO       Board not open
    NI_DAQ_ERR_NDV       No driver loaded for board
    NI_DAQ_ERR_NCB       Neighbouring counter is busy
    NI_DAQ_ERR_ITR       Interrupted by signal
    NI_DAQ_ERR_ACS       No permissions to open device file
    NI_DAQ_ERR_DFM       Device file does not exist
    NI_DAQ_ERR_DFP       Unspecified error when opening device file
    NI_DAQ_ERR_INT       Internal driver or library error
    NI_DAQ_ERR_NAO       Board is missing AO capabilities
    NI_DAQ_ERR_NCS       Missing channel setup
    NI_DAQ_ERR_NAS       Missing AI acquisition setup
    NI_DAQ_ERR_NEM       Not enough memory
    NI_DAQ_ERR_NPT       Timing impossible to realize
	NI_DAQ_ERR_NER		 External reference for AO not available
	NI_DAQ_ERR_UAO		 Only bipolar AO available
	NI_DAQ_ERR_NAT       No analog trigger available
	NI_DAQ_ERR_INT       Pulser to be started not initialized

The absolute value of the error code can be used as an index into a an
array of short descriptions of the error encountered, which is defined as

extern const char *ni_daq_errlist[ ];

The length of this array is given by the (constant) global variable

extern const int ni_daq_nerr;

i.e. the largest  message number provided by the array of error messages
is ni_daq_nerr - 1.


The timings possible with the board take a bit of getting used to.
Basically, the board has two clocks, a fast one running at 20 MHz
and a slow clock, running at 200 kHz.

The fast clock can be used by all subsystems (i.e. AI, AO and GPCT)
and each subsystem can individually slow down the fast clock rate it
sees by a factor of 2. Thus, e.g. the AI system can use the 20 MHz
clock while the GPCT subsystem at the same time can use the fast clock
at half its normal rate, i.e. 10 MHz.

Also the slow clock can be slowed down by a factor of 2. But in contrast
to the fast clock, the speed of slow clock is common to all subsystems.
Therefore it's important to take into consideration which speed it is
currently running at when programming a subsystem, and when a subsystem
needs to change the clock rate the programmer must be aware that this
change also applies to the slow clock rate for all the other subsystems.

Beside the clocks seen by the subsystem there's also a FREQ_OUT pin
of the board that can output one of the clocks. The speed of both
clocks, when output at the FREQ_OUT pin, can be reduced by an
integer factor between 1 and 16 (without influencing the speed seen
by the subsystems). Furthermore the frequencies can be further
divided by a factor of 2 (but only both of them at once). When this
additional divider is used the speed of the fast clock as seen by the
subsystems does not change, but the slow speed clock encountered by
the subsystems is changed.


A. Administrative and miscellaneous functions
---------------------------------------------

======================================================================

int ni_daq_open( const char *name, int flag )

This function must be called before the card can be used. It expects
two arguments, the first being the name of the device file for the board.
This will usually be '/dev/pci_e_series_0' to /dev/pci_e_series_4' for the
PCI E Series boards and '/dev/at_mio_series_0' to '/dev/at_mio_series_4'
for the AT MIO Series boards. The second agument is an additional flag to
be passed to the open(2) call, the only useful value being O_NONBLOCK
or O_NODELAY in order to open the boards device file in non-blocking
mode (in this case a return value of NI_DAQ_ERR_BBS can also mean that
opening the device file without any delay wasn't possible).

When successful the function returns an integer to be used as a handle
for the board in all futher calls of functions for the board.

The function may fail for several reasons. The board may not be installed
at all, the driver for the board could be unloadable, the device file (i.e.
the file name passed to the function) may not exist, the user may have
no permission to open the board, the board could already be opened by
a different process, a signal may have been received while trying to open
the board, an unspecified error may occur when opening the file, or,
finally, an internal error in the driver might get triggered. In these
cases a negative number is returned, with the following error codes:

    NI_DAQ_ERR_NSB   NI_DAQ_ERR_NDV   NI_DAQ_ERR_DFM   NI_DAQ_ERR_ACS
    NI_DAQ_ERR_BBS   NI_DAQ_ERR_DFP   NI_DAQ_ERR_INT   NI_DAQ_ERR_ITR


Please note: processes that inherit the file descriptor for the device
file via a call to the exec-family of functions won't be able to access
the board, the close-on-exec flag gets set for the file handle used
for accessing the board.


======================================================================

int ni_daq_close( int board )

This function should be called when the coard isn't used anymore (but
also gets called automatically when the program exits and the device
file is still open).

The function can only fail for two reasons, either the board handle
passed to the function is invalid or the board isn't open, in which
case the following error codes are returned:

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO


======================================================================

int ni_daq_perror( const char *s )

The function prints out a string to stderr, consisting of a string
pased to it as the argument, a colon, a blank and a short descriptive
text of the error encountered in the last invocation of one of the
functions for the board, followed by a new-line. If the argument is
NULL or an empty string only the error message is printed.

The function returns the number of characters printed to stderr.


======================================================================

const char *ni_daq_strerror( void )

The function returns a string with a short descriptive text of the
error encountered in the last invocation of one of the functions for
the board (or "Success" if the last function call was successful).
The returned pointer points to some memory belonging to the library
and the string gets overwritten on each invocation of the function.


======================================================================

int ni_daq_msc_set_clock_speed( int board, NI_DAQ_CLOCK_SPEED_VALUE speed,
                                int divider )

Function for setting the frequency divider the output at the FREQ_OUT
pin. Beside the usual argument with the handle of the board, the speed
of both clocks that can be output at the pin can be switched between
full and half speed. Thus the second argument must be either

    NI_DAQ_FULL_SPEED   or   NI_DAQ_HALF_SPEED

Please note that a change is also immediately applies to all subsystems
using the slow clock!

The third argument is a further divider to apply to the clock rate (only
applied to the output at the FREQ_OUT pin) and has to be an integer
between 1 and 16.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_IVA   NI_DAQ_ERR_INT


======================================================================

int ni_daq_msc_set_clock_output( int board, NI_DAQ_CLOCK_TYPE daq_clock,
                                 NI_DAQ_STATE on_off )

This function is for selecting one of the two clocks and enabling (or
disabling) of the frequency output at the FREQ_OUT pin. The first
argument is as usual the board handle. The second is the clock to
output, use

    NI_DAQ_FAST_CLOCK   or   NI_DAQ_SLOW_CLOCK

to select one of the clocks. The third argument allows to enable or
disable output, use the constants

    NI_DAQ_ENABLED    and    NI_DAQ_DISABLED

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_IVA   NI_DAQ_ERR_INT


======================================================================

int ni_daq_msc_get_clock_state( int board, NI_DAQ_CLOCK_TYPE *daq_clock,
                                NI_DAQ_STATE *on_off,
                                NI_DAQ_CLOCK_SPEED_VALUE *speed,
                                int *divider )

This function can be used to find out about all current settings for
the clock and the output at the FREQ_OUT pin. The first argument is
as usual the board handle. The second argument is a pointer to a
variable of type 'NI_DAQ_CLOCK_TYPE' and after a successful call
it will be set to either 

    NI_DAQ_FAST_CLOCK   or   NI_DAQ_SLOW_CLOCK

telling which clock is selected for output at the FREQ_OUT pin.

The second argument is a pointer to a variable of type 'NI_DAQ_STATE'
and will be set to either 

    NI_DAQ_ENABLED   or    NI_DAQ_DISABLED

telling if output at the FREQ_OUT pin is enabled or disabled.

The next to arguments are for returning the current speed settings for
the clocks. The first one is a pointer to a variable of type
'NI_DAQ_CLOCK_SPEED_VALUE' and can have the values 

    NI_DAQ_FULL_SPEED   or   NI_DAQ_HALF_SPEED

and the last is an integer pointer, through which the current value of
the divider for both clocks is returned.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_IVA


======================================================================

int ni_daq_msc_set_trigger( int board, NI_DAQ_TRIG_TYPE trigger_type,
							double trigger_high, double trigger_low )

This function is for setting up the PFI0/TRIG1 input pin. It is used
as a trigger input for timing the analog input (AI) and can be used
in several modes. Please note that some boards don't allow analog
triggering and always expect a TTL level signal. In these cases
calling the function will return the error code 'NI_DAQ_ERR_NAT'.

The 'trigger_type' argument can be set to one of the following values:

	NI_DAQ_TRIG_TTL
	NI_DAQ_TRIG_LOW_WINDOW
	NI_DAQ_TRIG_HIGH_WINDOW
	NI_DAQ_TRIG_MIDDLE_WINDOW
	NI_DAQ_TRIG_HIGH_HYSTERESIS
	NI_DAQ_TRIG_LOW_HYSTERESIS

For 'NI_DAQ_TRIG_TTL' a TTL level trigger input is expected.

For 'NI_DAQ_TRIG_LOW_WINDOW' a trigger input signal gets raised when
the when the input voltage drops below the value specified as the
fourth, final argument of the function, 'trigger_low', which has to
be a voltage between -10 V and +10 V. The trigger input signal is
lowered when the input voltage again increases above this value.

For 'NI_DAQ_TRIG_HIGH_WINDOW' a trigger input signal gets raised when
the when the input voltage is increased above the value specified as
the third argument of the function, 'trigger_high', which has to be
a voltage between -10 V and +10 V. The trigger input signal is lowered
when the input voltage again drops below this value.

For 'NI_DAQ_TRIG_MIDDLE_WINDOW' a trigger input signal gets raised
whenever the input voltage drops below the voltage specified by
'trigger_high', coming from above, and when the input voltage
increases above the voltage specified by 'trigger_low', coming
from below. It gets switched off again when dropping below
'trigger_low' or increasing beyond 'trigger_high'. Thus, the
trigger input signal is lowered when the input voltage leaves the
interval defined by 'trigger_low' and 'trigger_high' and gets
raised when the input voltage again enters this window.

For 'NI_DAQ_TRIG_HIGH_HYSTERESIS' the trigger input signal gets
raised when the input voltage starts to excced 'trigger_high'
and and is lowered when the input voltage drops below 'trigger_low'.

Finally, for 'NI_DAQ_TRIG_LOW_HYSTERESIS' the trigger input signal
gets raised when the input voltage drops below 'trigger_low' and
gets lowered again when the input voltage exceeds 'trigger_high'.

Using these settings, together with selecting if a trigger should
happen on the raising or falling edge of the trigger input signal
makes it possible to realize all kinds of trigger methods.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_IVA
    NI_DAQ_ERR_INT    NI_DAQ_ERR_NAT


======================================================================


B. Functions for analog input (AI)
----------------------------------

======================================================================

int ni_daq_ai_set_speed( int board, NI_DAQ_CLOCK_SPEED_VALUE speed )

This function allows to set the speed of the fast clock as seen by the
analog input (AI) subsystem. The first argument is as usual the board
handle, while the second arguments determines the speed divider for
the fast clock. It can have two values, either

    NI_DAQ_FULL_SPEED   or   NI_DAQ_HALF_SPEED

When NI_DAQ_FAST_CLOCK is used, the clock speed is set to 20 MHz, otherwise
to 10 MHz.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_IVA   NI_DAQ_ERR_INT


======================================================================

int ni_daq_ai_get_speed( int board, NI_DAQ_CLOCK_SPEED_VALUE *speed )

The function can be used to find out the current divider setting for
the fast clock as seen by the AI subsystem. The first argument is as
usual the board handle, while the second arguments is a pointer to
a variable of type 'NI_DAQ_CLOCK_SPEED_VALUE'. If successful the
value of the variable pointed to will be set to either

    NI_DAQ_FULL_SPEED   or   NI_DAQ_HALF_SPEED

indicating if the clock is running at either 20 MHz or 10 MHz.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_IVA   NI_DAQ_ERR_INT


======================================================================

int ni_daq_ai_channel_configuration( int board, int num_channels,
                                     int *channels, NI_DAQ_AI_TYPE *types,
                                     NI_DAQ_BU_POLARITY *polarities,
                                     double *ranges,
                                     NI_DAQ_STATE *dither_enables )

This function must be called before doing analog input to set the
number of channels to be used and their properties.

Beside the usual first argument with the board handle the function
expects several arguments. The 'num_channels' argument is the number
of channels to be sampled at once and 'channels' is an array of
'num_channels' channel numbers (between 0 and one less than the
maximum number of analog input channels of the card).

The 'types' argument is an array of 'num_channels' values of type
'NI_DAQ_AI_TYPE'. These can habe the following values:

    NI_DAQ_AI_TYPE_NRSE
    NI_DAQ_AI_TYPE_RSE
    NI_DAQ_AI_TYPE_Differential
    NI_DAQ_AI_TYPE_Calibration
    NI_DAQ_AI_TYPE_Aux
    NI_DAQ_AI_TYPE_Ghost

'NI_DAQ_AI_TYPE_NRSE' is for single-ended nonreferenced measurements,
i.e. where the ground of the signal is defined by the ground input line
(i.e. for free floating ground measurements, like on a battery).

'NI_DAQ_AI_TYPE_RSE' is for single-ended ground-referenced measurements,
where the signal ground is connected to a common ground of the card and
the ground of the instrument creating the voltage.

'NI_DAQ_AI_TYPE_Differential' is for differential voltage measurements.
These use use two AI channels and return the voltage differene between
the channels. For these setting the channel number specicfied in the
'channels' argument must be between 0 and 7, 16 and 23, 32 and 39 or
48 and 55 (of course depending on the number of AI channels the board
has). As the second channel the channel with the the number of the first
channel plus 8 is than automatically used.

The 'NI_DAQ_AI_TYPE_Calibration' setting is used for calibration of the
board and shouldn't be needed in normal programms.

'NI_DAQ_AI_TYPE_Aux' is for measuring the output voltage of a onboard
temperature sensor (+100 mV = -40 degree Celsius and +1.25 V = 125 degree
Celsius). Not all boards have an onboard temperature sensor.

'NI_DAQ_AI_TYPE_Ghost' is a setting where *no* data is returned for the
channel, the setting can be useful when different channels are to be
sampled at different rates.

The fifth argument, '*polarities', is an array of 'num_channels' values
of type 'NI_DAQ_BU_POLARITY'. These can have the values

   NI_DAQ_BIPOLAR   or   NI_DAQ_UNIPOLAR

When set to NI_DAQ_BIPOLAR an bipolar acquisitionis done (i.e. the
input voltages are expected in a range symmetric with respect to 0V),
otherwise they have to be unipolar, i.e. all input voltages must be
between 0V and the upper limit of the measurement range (to be set by
the next argument.

The 'ranges' argument is an array of 'num_channels' floating point
values. Each value represents the upper limit of the voltage range
to be measured by the input channel and must be identical to one of
the possible settings for the card (different cards have different
allowed ranges).

The final argument, 'dither_enables', is an array of 'num_channels'
values of type 'NI_DAQ_STATE' and can assume the values 

    NI_DAQ_ENABLED   or  NI_DAQ_DISABLED

using these values hardware dithering can be enabled or disabled on a
channel-by-channel basis. Hardware dithering means that approximately
0.5 LSBrms of white Gaussian noise gets added to the signal to be
converted by the ADC. This addition is useful for applications
involving averaging to increase the resolution. In such applications,
noise modulation is decreased and differential linearity is improved
by the addition of the dither.

On success the function returns the number of data points that will
be returned for each conversion of all channels. Unless you specified
one more channels to be of type 'NI_DAQ_AI_TYPE_Ghost', this number
will be identical to the number of channels passed to the function
as the second argument.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO    NI_DAQ_ERR_IVA    NI_DAQ_ERR_INT
    NI_DAQ_ERR_NEM


======================================================================

int ni_daq_ai_acq_setup( int board, NI_DAQ_INPUT start,
                         NI_DAQ_POLARITY start_polarity,
                         NI_DAQ_INPUT scan_start,
                         NI_DAQ_POLARITY scan_polarity,
                         double scan_duration,
                         NI_DAQ_INPUT conv_start,
                         NI_DAQ_POLARITY conv_polarity,
                         double conv_duration,
                         size_t num_scans )

This functions needs to be called before doing analog input in order
to determine after which triggers and when data are to be acquired.
It reuqires that ni_daq_ai_channel_configuration() has already been
successfully called.

The most basic element of an analog input sequence is a single conversion,
i.e. the conversion of an input voltage into a corresponding data value by
the ADC. When more than a single channel is to be measured a set of
conversions makes what is called a scan. During a scan the voltages at
several analog input channels are converted, one after each other (there's
only a single AD converter on the board). Finally, a set of scans constitutes
a complete acquisition.

An acquisition can be started either immediately or on receipt of a trigger
event. The scans making up the acquisiton can be started according to a
certain timing (e.g. a new scan is started every 10 ms) or can be externally
triggered. And, finally, the moment each individual conversion of a scan
is done can be controlled by the internal clock or an external event.

The way the acquisition is started is controlled by the 'start' and
'start_polarity' arguments of the function. 'start' is a variable of
type 'NI_DAQ_INPUT' and can have one of the following values:

   NI_DAQ_INTERNAL
   NI_DAQ_NOW
   NI_DAQ_PFI0 - NI_DAQ_PFI9
   NI_DAQ_NI_DAQ_RTSI_0 - NI_DAQ_NI_DAQ_RTSI_6
   NI_DAQ_GOUT_0

For NI_DAQ_INTERNAL the acquisition is started when either the function
ni_daq_ai_start_acq() (see below) is called or when data are requested
for the first time by a call of the function ni_daq_ai_get_acq_data()
(also see below).

For NI_DAQ_NOW the acquisition is started immediately before the function
returns.

For NI_DAQ_PFI0 to NI_DAQ_PFI9 the acquisition is started when a trigger
is received on the corresponding PFI0 to PFI9 input line of the board.

For NI_DAQ_NI_DAQ_RTSI_0 to NI_DAQ_NI_DAQ_RTSI_6 a trigger on the
RTSI0 to RTSI6 inputs starts the acquisition.

Finally, for NI_DAQ_GOUT_0 the acquisition is started on a trigger from
the output of counter 0 (see the documentation for the GPCT functions).

The 'start_polarity' argument is of type 'NI_DAQ_POLARITY' and can have
the values

    NI_DAQ_NORMAL   or    NI_DAQ_INVERTED

It's value is only evaluated when the acquisition is to be started by an
external trigger. In this case NI_DAQ_NORMAL stands for a trigger on the
raising edge of the input, while NI_DAQ_INVERTED detects the trigger on
the falling edge of the input.

The 'scan_start', 'scan_polarity' and 'scan_duration' control how a scan
is started. 'scan_start' can have one of the following values:

   NI_DAQ_INTERNAL:
   NI_DAQ_PFI0 - NI_DAQ_PFI9
   NI_DAQ_NI_DAQ_RTSI_0 - NI_DAQ_NI_DAQ_RTSI_6
   NI_DAQ_GOUT_0

When set to NI_DAQ_INTERNAL scans are started automatically and repeatedly
with a time spacing given by the value of 'scan_duration'. 'scan_duration'
is then a time in seconds - the timing is controlled by the internal clocks
of the board. There is a hard restrictions converning this timing:
'scan_duration' must be at least as long as the time resolution of the
board multiplied by the number of conversions in a scan. A soft restriction
comes into play when using different gains for different channels involved
in the conversions. The switching times of the pre-amplifier is often
longer than the time resolution of the board. Using a scan duration that
does not allow for these switching times will result in unreliable data.

For all other settings of 'scan_start' the 'scan_duration' argument isn't
evaluated and instead the 'scan_polarity' argument is used to determine if
a scan has to be triggered by the raising or falling edge of the trigger
input.

As for scans also conversions can be started according to an adjustable
timing or by an external trigger signal. This is controlled by the
'conversion_start' argument, which can have the same values as the
'scan_start' argument. If set to NI_DAQ_INTERNAL conversions are started
with a fixed time spacing given by the 'conversion_duration' argument.
Otherwise each conversion is started by an external trigger where the
'conversion_polarity' controls if the trigger is recognized by a raising
or a falling edge of the trigger signal.

Finally, the 'num_scans' argument determines how many scans make up
a complete acquisition and must be a number between 1 and 2^24. The
number of data points that will get sampled during the acquisition
is this number times the return value of the function
ni_daq_ai_channel_configuration().

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO    NI_DAQ_ERR_IVA    NI_DAQ_ERR_INT
    NI_DAQ_ERR_IVS    NI_DAQ_ERR_NPT    NI_DAQ_ERR_NCS    NI_DAQ_ERR_NEM


======================================================================

int ni_daq_ai_start_acq( int board )

This function can be used to start an AI acquisition with the board selected
by the argument. Please note that starting an acquisition requires that
both the functions ni_daq_ai_channel_configuration() and ni_daq_ai_acq_setup()
have been called before successfully.

Calling this function is unnecessary if in the 'start' argument of the call of
function ni_daq_ai_acq_setup() had been NI_DAQ_NOW - in this case the
acquisition is started automatically.

Please note that an acquisition is also started automatically by calling
the function ni_daq_ai_get_acq_data().

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_INT    NI_DAQ_ERR_NCS
    NI_DAQ_ERR_NAS    NI_DAQ_ERR_NEM


======================================================================

int ni_daq_ai_stop_acq( int board )

This function can be used to stop an AI acquisition with the board selected
by the argument. Please note that that no data from the stopped acquisition
are available after this function has been called, so first get all data
you're interested in using the function ni_daq_ai_get_acq_data() before
calling ni_daq_ai_stop_acq().

On failure the function returns one of the following error codes

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_INT


======================================================================

ssize_t ni_daq_ai_get_acq_data( int board, double *volts[ ],
                                size_t offset, size_t num_data_per_channel,
                                int wait_for_end )

This function obtains measured data from an acquisition. If the acquisition
hasn't been started yet (but the acquisition parameters have been set up
using ni_daq_ai_channel_configuration() and ni_daq_ai_acq_setup()) calling
the function will automatically start an acquisition.

As usual the first argument of the function is a handle for the board.
The second argument is an array of as many double pointers as there are
channels returning data, i.e. the return value of the function 
ni_daq_ai_channel_configuration(). Each pointer has to point to an array
of doubles with at least as many elements as there are scans to be fetched
from (which is also the fourth element). Data converted to volts (according
to the gain setttings of the channels) are returned via these arrays.

   -------
  | volts |______________________
   -------                       |
   |   |__________               |
   |              |              |
   v              v              v
   ----------     ----------     ----------
  | volts[0] |   | volts[1] |   | volts[2] |
   ----------     ----------     ----------
   |               |_______    |______________________
   |                       |                          |
   v                       v                          v
   --------------------    -----------------------    -----------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
   --------------------    -----------------------    -----------------------

   num_data_per_channel

The third element is an offset into these arrays that finally will hold the
returned data for the different channels. The offset can be useful when one
doesn't want to wait until the acquisition is complete but instead wants to
fetch intermediate data. Without the offset the function would start writing
the newly acquired data starting at the first element of the arrays. But when
a none-zero offset has been specified the offset is automatically added to
the pointers pointed to by the first argument, thus not overwriting the
elements with an index smaller than offset.

The fifth and last element is a flag that tells if the function should either
return immediately with as many data as where avaiable (if 'wait_for_data'
is zero) or if the function should only return when the acquisition is
complete (if 'wait_for_data' is non-zero).

On success the function returns the number of data points that have been
acquired for each channel (but never more than 'num_data_per_channel').
On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_INT    NI_DAQ_ERR_NCS
    NI_DAQ_ERR_NAS    NI_DAQ_ERR_NEM   NI_DAQ_ERR_SIG


======================================================================


C. Functions for analog output (AO)
-----------------------------------

======================================================================

int ni_daq_ao_channel_configuration( int board, int num_channels,
									 int *channels,
									 NI_DAQ_STATE *external_reference,
									 NI_DAQ_BU_POLARITY *polarity )


Before doing analog output the channels to be used can be set up,
which is done using this function. (Without a setup both channels
use the internal reference and work in bipolar mode.)

Beside the board handle the function expects four further arguments.
The first of these is the number of channels to be set up. The next is
an array of the channel numbers identifiying the channels to set up,
which can range between 0 and the maximum number of available AO channels
minus one. Then follows an array of values of type NI_DAQ_STATE, which
can be set to either

    NI_DAQ_ENABLED   or    NI_DAQ_DISABLED

and which determine if for the corresponding channel if the output
voltage is created from the internal reference voltage of 10 V is to
be used (when set to NI_DAQ_DISABLED) or an external reference voltage
applied to the EXT_REF input pin is to be used.

The final argument is an array of values of type NI_DAQ_BU_POLARITY,
which can be set to 

   NI_DAQ_BIPOLAR   or   NI_DAQ_UNIPOLAR

and determine if the output voltage of the corresponding channel is to be
symmetrically in the range between the negative and positive reference
voltage (if set to NI_DAQ_BIPOLAR) or only between 0 V and the maximum
of the reference voltage.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_NAO    NI_DAQ_ERR_IVA
    NI_DAQ_ERR_INT


======================================================================

int ni_daq_ao( int board, int num_channels, int *channels, double *values );

This function can be called to do an AO conversion for a set of channels.
It expects four arguments, first the handle for the board, then the number
of channels and an array of channel numbers (between 0 and the maximum
number of available AO channels minus one). The last argument is a pointer
of as many doubles as there are channels. For channels using the internal
voltage reference of 10 V this must be a number between -10 and +10 (if
the channel has been set up for bipolar output) or 0 an 10 (when the channel
was set up for unipolar output), representing the voltage to be output.
For channels using an external reference applied to the EXT_REF pin this
must be a number between -1 and +1 (if the channel has been set up for
bipolar output) or 0 an 1 (when the channel was set up for unipolar output),
where the intervsal represents the range covered by the external reference
voltage.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_NAO    NI_DAQ_ERR_IVA
    NI_DAQ_ERR_NCS    NI_DAQ_ERR_INT


======================================================================


D Counter/pulser functions (GPCT)
---------------------------------


======================================================================

int ni_daq_gpct_set_speed( int board, NI_DAQ_CLOCK_SPEED_VALUE speed )

This function allows to set the speed of the fast clock as seen by the
general purpose counter and timer (GPCT) subsystem. The first argument
is as usual the board handle, while the second arguments determines the
speed divider for the fast clock. It can have two values, either

    NI_DAQ_FULL_SPEED   or   NI_DAQ_HALF_SPEED

When NI_DAQ_FAST_CLOCK is used, the clock speed is set to 20 MHz, otherwise
to 10 MHz.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_IVA   NI_DAQ_ERR_INT


======================================================================

int ni_daq_gpct_get_speed( int board, NI_DAQ_CLOCK_SPEED_VALUE *speed )

The function can be used to find out the current divider setting for
the fast clock as seen by the GPCT subsystem. The first argument is as
usual the board handle, while the second arguments is a pointer to
a variable of type 'NI_DAQ_CLOCK_SPEED_VALUE'. If successful the
value of the variable pointed to will be set to either

    NI_DAQ_FULL_SPEED   or   NI_DAQ_HALF_SPEED

indicating if the clock is running at either 20 MHz or 10 MHz.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_IVA   NI_DAQ_ERR_INT


======================================================================

int ni_daq_gpct_start_counter( int board, int counter, int source )

The function starts a countinuously counting counter. The counter is
initialized to 0 at the start and counts upwards.

As usually, 'board' is the board handle. The 'counter' argument is the
number of the counter to be used, which is either 0 or 1. The 'source'
argument, indicating what to count, must be one the following constants:

    NI_DAQ_G_IN_TIMEBASE1
	NI_DAQ_PFI0 - NI_DAQ_PFI9
	NI_DAQ_RTSI0 - NI_DAQ_RTSI6
	NI_DAQ_IN_TIMEBASE2
	NI_DAQ_G_TC_OTHER

'NI_DAQ_G_IN_TIMEBASE1' is the fast clock of the GPCT subsystem,
'NI_DAQ_PFI0' to 'NI_DAQ_PFI9' are the PFI0 to PFI9 input pins,
'NI_DAQ_RTSI0' to 'NI_DAQ_RTSI6' are the RTSI pins,
'NI_DAQ_IN_TIMEBASE2' is the slow time base and 'NI_DAQ_G_TC_OTHER'
is for counting TC events of the other counter.

The counter will remain busy and can't be used for other purposes until
the function ni_daq_stop_counter() has been called for the counter.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_IVA    NI_DAQ_ERR_CBS


======================================================================

int ni_daq_gpct_start_gated_counter( int board, int counter,
                                     double gate_length, int source )

The function starts a gated counter. The counter will run only for the
time specified by the 'gate_length' argument and then stop. The counter
is initialized with 0 and counts upwards.

The function does requires also the other counter beside the one specified
by the 'counter' argument (which must be 0 or 1) to create the gate for
the counter. Thus both counters must be available, i.e. not being counting
when the function gets called.

'gate_length' must be at least 100 ns and must also be an integer multiple
of 50 ns if the fast clock can be used and then must be not longer than
1.6777216 s. If the slow clock gets used the minimum length is 10 us or
20 us and must be an integer of 5 us or 10 us, depending on which speed
the slow clock is working in. The simplest way to find out if a timing is
possible is to call the function and check if 'NI_DAQ_OK' is returned,
indicating success, or 'NI_DAQ_ERR_NPT', indicating that the requested
gate length isn't possible.

The 'source' argument can have the same values as for calling the
ni_daq_start_counter() function.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO    NI_DAQ_ERR_IVA    NI_DAQ_ERR_CBS
    NI_DAQ_ERR_NCB    NI_DAQ_ERR_INT


======================================================================

int ni_daq_gpct_stop_counter( int board, int counter )

The function stops one counter or both counters (to stop both counters
the 'counter argument must be set to 2 instead of the 0 or 1, as it is
required for a single counter). If the specified counter isn't counting
nothing happens (i.e. success is reported).

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO    NI_DAQ_ERR_IVA    NI_DAQ_ERR_INT


======================================================================

int ni_daq_gpct_get_count( int board, int counter, int wait_for_end,
					       unsigned long *count, int *state )

The function returns the current value of a counter. If the
'wait_for_end' argument has a non-zero value, the function will
only return after the counter has stopped counting with the final
result - because a continuous counter will never stop the function
will return indicating an error when this ius tried with a continuously
running counter. If a signal gets caught while waiting for the counter
to finish the error code NI_DAQ_ERR_ITR gets returned.

The counters value is returned in the variable pointed to by 'count'.
The maximum return value is 16777216. If the counter did overflow (more
events than this number happened) the counter did reset to 0 and the
final result is the modulo of the real number of events and 16777216.

The current state of the counter, i.e. if the counter is still counting
or is already stopped is returned in the variable pointed to by the
'state' argument (unless 'state' is NULL). The variable 'state' is
pointing to will either get set to 'NI_DAQ_BUSY' or 'NI_DAQ_IDLE'.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO    NI_DAQ_ERR_IVA    NI_DAQ_ERR_INT
    NI_DAQ_ERR_ITR


======================================================================

int ni_daq_gpct_generate_single_pulse( int board, int counter,
                                       double duration, double *delay,
									   int dont_start )

The function creates a single pulse of 'duration' length at the output
connectors of the specified counter.

Depending on which clock and settings can be used 'duration' must be at
least either 100 ns, 10 us or 20 us and must also be an integer multiple
of 50 ns, 5 us or 10 us. What 'delay' points to is the time the creation
of the pulse is delayed and its value has to follow the same rules as
the value for 'duration' except that when set to zero or a negative
value the shortest possible start delay is used. When its content was
zero or negative on return it is changed to reflect the real delay
(there is always a short delay of 2 ticks of the clock getting used).

If the flag 'dont_start' is non-zero the pulse will not be created
immediately but only when the function ni_daq_gpct_start_pulses()
is called. This allows to initialize the settings for the pulse
but start it only later together with pulses from the other counter.
But even when start of the counter creating the pulse is delayed in
this way ni_daq_gpct_state() will still report the counter as busy
and you have to either start the counter or call the function
ni_daq_gpct_stop_pulses() in order to reset this condition.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO    NI_DAQ_ERR_IVA    NI_DAQ_ERR_NPT
    NI_DAQ_ERR_CBS    NI_DAQ_ERR_INT


======================================================================

int ni_daq_gpct_generate_continuous_pulses( int board, int counter,
									        double high_phase,
                                            double low_phase, double *delay,
											int dont_start )

The function creates a continuous train of pulses at the output
connectors of of the specified counter.

The arguments 'high_phase' and 'low_phase' specify the durations of the
pulses being in a high state and the time between pulses. Thus the repe-
tition frequency of the created pulses is the sum of both arguments.

Depending on the clock settings both 'high_phase' and 'low_phase' must be
either at least 100 ns, 10 us or 20 us and must also be integer multiples
of 50 ns, 5 us or 10 us. What 'delay' points to is the time the creation
of the pulse is delayed and its value has to follow the same rules as the
values for 'high_phase' and 'low_phase' except that when set to zero or a
negative value the shortest possible start delay is used. When its content
was zero or negative on return it is changed to reflect the real delay
(there is always a short delay of 2 ticks of the clock getting used).

If the flag 'dont_start' is non-zero the pulses will not be created
immediately but only when the function ni_daq_gpct_start_pulses()
is called. This allows to initialize the settings for the pulses
but start them only later together with pulses from the other counter.
But even when start of the counter creating the pulses is delayed in
this way ni_daq_gpct_state() will still report the counter as busy
and you have call ni_daq_gpct_stop_pulses() in order to reset
this condition.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO    NI_DAQ_ERR_IVA    NI_DAQ_ERR_NPT
    NI_DAQ_ERR_CBS    NI_DAQ_ERR_INT


======================================================================

ni_daq_gpct_start_pulses( int board, int counter )

This function needs only to be called when either the function
ni_daq_gpct_generate_single_pulse() or the function
ni_daq_gpct_generate_continuous_pulses() had been called with
the 'dont_start' flag being set. In this case the corresponding
counter has only been initialized but no pulses are created yet.
Otherwise calling the function will result in an error code
being returned (NI_DAQ_ERR_PNI).

Beside the usual 'board' argument the function expects the number
of the counter creating the pulses, i.e either 0 or 1. But to start
both pulsers absolutely synchronously also the number 2 can be
passed to the function.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO    NI_DAQ_ERR_IVA    NI_DAQ_ERR_PNI
	NI_DAQ_ERR_INT


======================================================================

int ni_daq_gpct_stop_pulses( int board, int counter )

The function is just an alias for the ni_daq_stop_counter() function.


======================================================================

int ni_daq_gpct_state( int board, int counter, int *state )

The function checks if a counter is armed and thus can be taken to
be counting and therefore busy.

The state, either 'NI_DAQ_BUSY' or 'NI_DAQ_IDLE', will be returned
via the variable pointed to by 'state'.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO    NI_DAQ_ERR_IVA    NI_DAQ_ERR_INT


======================================================================


E DIO functions (DIO)
---------------------

======================================================================

int ni_daq_dio_write( int board, unsigned char bits, unsigned char mask )

The function sets a subset, selected via the 'mask' argument, of the
8 DIO output lines of the board to the states given by the 'bits'
argument.

'mask' must be used to select a subset of the DIO lines. Setting bit 0 
(i.e. the least sigificant bit) of 'mask' allows to set the DIO line 0,
Setting bit 1 allows to set DIO line 1 etc. To allow setting all lines
thus 255 (or 0xFF) has to be specified for 'mask'.

'bits' specifies the state the lines specified by 'mask' are to be set
to. Setting bit 0 ((i.e. the least sigificant bit) of 'bits' to 1 will
set the DIO line 0 to a high voltage level, setting this bit to 0 will
set this line to a low voltage level (of course requiring that also
bit 0 of 'mask' is set). Setting or unsetting bit 1 of 'bits' will
change the DIO line 1 accordingly (as long as also bit 1 of 'mask' is
set) etc.

DIO lines for which no bit is set in 'mask' can be used for input
simultaneously.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_NAO
	NI_DAQ_ERR_INT

======================================================================

int ni_daq_dio_read( int board, unsigned char *bits, unsigned char mask )

The function returns the state of a subset, selected via the 'mask'
argument, of the 8 DIO output lines of the board.

'mask' must be used to select a subset of the DIO lines. Setting bit 0 
(i.e. the least sigificant bit) of 'mask' allows to read the state of
DIO line 0, Setting bit 1 allows to read DIO line 1 etc. To allow
reading all lines thus 255 (or 0xFF) has to be specified for 'mask'.

In the variable pointed to by 'bits' the state of the lines selected
by 'mask' is returned. Bit 0 (i.e. the least sigificant bit of 'bits')
reflects the state of DIO line 0 (1 for a high voltage level, 0 for a
low level), bit 1 the state of line 1 etc.

DIO lines for which no bit is set in 'mask' can be used for output
simultaneously.

On failure the function returns one of the following error codes

    NI_DAQ_ERR_NSB    NI_DAQ_ERR_BNO   NI_DAQ_ERR_NAO
	NI_DAQ_ERR_IVA    NI_DAQ_ERR_INT


======================================================================
