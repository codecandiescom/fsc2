#!/usr/bin/perl
# -*- cperl -*-
# Generated by fsc2_guify from edl/saturation.EDL on Tue May 20 16:12:54 CEST 2003

use strict;
use warnings;
use Tk;
use Tk::Balloon;

my @version = split /\./, $Tk::VERSION;
die "Installed Perl-Tk version is $Tk::VERSION but Tk800.022 is required.\n"
    if $version[ 0 ] + 0.001 * $version[ 1 ] < 800.022;

my %fp = ( -side => 'top',
           -fill => 'x',
           -padx => '2m',
           -pady => '2m' );
my %wp = ( -side => 'left',
           -fill => 'x',
           -expand => 1 );
my %up = ( -side => 'left' );

my $fsc2_how_to_run = "Test program";
my @fsc2_how_to_run = ( "Start experiment",
                        "Test program",
                        "Load into fsc2" );
my $fsc2_main_window = MainWindow->new( );
my $fsc2_main_frame = $fsc2_main_window->Frame( -relief => "ridge",
                                                -borderwidth => "1m" );
my $fsc2_balloon = $fsc2_main_frame->Balloon( );
my $fsc2_apply_frame = $fsc2_main_window->Frame( );
my $fsc2_apply_button = $fsc2_apply_frame->Button( -text => "Apply",
                                                   -command => \&write_out );
$fsc2_apply_button->bind( "all", "<Alt-a>" => \&write_out );
my $fsc2_quit_button = $fsc2_apply_frame->Button( -text => "Quit",
                 -command => sub { &store_defs; $fsc2_main_window->destroy } );
$fsc2_quit_button->bind( "all",
                         "<Alt-q>" =>
                         sub { &store_defs; $fsc2_main_window->destroy } );
$fsc2_apply_frame->pack( -side => "bottom",
                         -fill => "x",
                         -padx => "4m" );

# === FC_TYPE menu [ "without Gaussmeter", "with Gaussmeter" ] [ 1 ]  "Field controller"
my %FC_TYPE;
$FC_TYPE{ tk_frame } = $fsc2_main_frame->Frame( );
$FC_TYPE{ tk_label } = $FC_TYPE{ tk_frame }->Label( -text => "Field controller",
-width => 20,
-anchor => 'w' );
$FC_TYPE{ value } = "without Gaussmeter";
my @FC_TYPE = ( "without Gaussmeter", "with Gaussmeter" );
$FC_TYPE{ tk_entry } = $FC_TYPE{ tk_frame }->Optionmenu( -options => \@FC_TYPE,
-width => 10,
-textvariable => \$FC_TYPE{ value } );
$FC_TYPE{ tk_unit } = $FC_TYPE{ tk_frame }->Label( -text => "",
-width => 5 );
$FC_TYPE{ tk_frame }->pack( %fp );
$FC_TYPE{ tk_label }->pack( %wp );
$FC_TYPE{ tk_entry }->pack( %wp );
$FC_TYPE{ tk_unit }->pack( %up );

# === START_FIELD float [ 2900.0 : 3400.0 ] [ 3100.0 ] "Start field" "G"
my %START_FIELD;
$START_FIELD{ tk_frame } = $fsc2_main_frame->Frame( );
$START_FIELD{ tk_label } = $START_FIELD{ tk_frame }->Label( -text => "Start field",
-width => 20,
-anchor => 'w' );
$START_FIELD{ value } = 3100.0;
$START_FIELD{ min } = 2900.0;
$START_FIELD{ max } = 3400.0;
$START_FIELD{ tk_entry } = $START_FIELD{ tk_frame }->Entry( -textvariable => \$START_FIELD{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_check( shift,
( defined $START_FIELD{ min } ? $START_FIELD{ min } : undef ),
( defined $START_FIELD{ max } ? $START_FIELD{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $START_FIELD{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $START_FIELD{ min } ? $START_FIELD{ min } : '-inf' ) .
" : " . ( defined $START_FIELD{ max } ? $START_FIELD{ max } : '+inf' ) . " ]" );
$START_FIELD{ tk_unit } = $START_FIELD{ tk_frame }->Label( -text => "G",
-width => 5 );
$START_FIELD{ tk_frame }->pack( %fp );
$START_FIELD{ tk_label }->pack( %wp );
$START_FIELD{ tk_entry }->pack( %wp );
$START_FIELD{ tk_unit }->pack( %up );

# === END_FIELD   float [ 2900.0 : 3400.0 ] [ 3200.0 ] "End field"   "G"
my %END_FIELD;
$END_FIELD{ tk_frame } = $fsc2_main_frame->Frame( );
$END_FIELD{ tk_label } = $END_FIELD{ tk_frame }->Label( -text => "End field",
-width => 20,
-anchor => 'w' );
$END_FIELD{ value } = 3200.0;
$END_FIELD{ min } = 2900.0;
$END_FIELD{ max } = 3400.0;
$END_FIELD{ tk_entry } = $END_FIELD{ tk_frame }->Entry( -textvariable => \$END_FIELD{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_check( shift,
( defined $END_FIELD{ min } ? $END_FIELD{ min } : undef ),
( defined $END_FIELD{ max } ? $END_FIELD{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $END_FIELD{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $END_FIELD{ min } ? $END_FIELD{ min } : '-inf' ) .
" : " . ( defined $END_FIELD{ max } ? $END_FIELD{ max } : '+inf' ) . " ]" );
$END_FIELD{ tk_unit } = $END_FIELD{ tk_frame }->Label( -text => "G",
-width => 5 );
$END_FIELD{ tk_frame }->pack( %fp );
$END_FIELD{ tk_label }->pack( %wp );
$END_FIELD{ tk_entry }->pack( %wp );
$END_FIELD{ tk_unit }->pack( %up );

# === FIELD_STEP  float [ 0.1 : 10.0 ]     [ 0.5 ]    "Field step" "G"
my %FIELD_STEP;
$FIELD_STEP{ tk_frame } = $fsc2_main_frame->Frame( );
$FIELD_STEP{ tk_label } = $FIELD_STEP{ tk_frame }->Label( -text => "Field step",
-width => 20,
-anchor => 'w' );
$FIELD_STEP{ value } = 0.5;
$FIELD_STEP{ min } = 0.1;
$FIELD_STEP{ max } = 10.0;
$FIELD_STEP{ tk_entry } = $FIELD_STEP{ tk_frame }->Entry( -textvariable => \$FIELD_STEP{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_check( shift,
( defined $FIELD_STEP{ min } ? $FIELD_STEP{ min } : undef ),
( defined $FIELD_STEP{ max } ? $FIELD_STEP{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $FIELD_STEP{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $FIELD_STEP{ min } ? $FIELD_STEP{ min } : '-inf' ) .
" : " . ( defined $FIELD_STEP{ max } ? $FIELD_STEP{ max } : '+inf' ) . " ]" );
$FIELD_STEP{ tk_unit } = $FIELD_STEP{ tk_frame }->Label( -text => "G",
-width => 5 );
$FIELD_STEP{ tk_frame }->pack( %fp );
$FIELD_STEP{ tk_label }->pack( %wp );
$FIELD_STEP{ tk_entry }->pack( %wp );
$FIELD_STEP{ tk_unit }->pack( %up );

# === DELAY int [ 1 : 3000 ] [ 300 ] "Delay" "ms"
my %DELAY;
$DELAY{ tk_frame } = $fsc2_main_frame->Frame( );
$DELAY{ tk_label } = $DELAY{ tk_frame }->Label( -text => "Delay",
-width => 20,
-anchor => 'w' );
$DELAY{ value } = 300;
$DELAY{ min } = 1;
$DELAY{ max } = 3000;
$DELAY{ tk_entry } = $DELAY{ tk_frame }->Entry( -textvariable => \$DELAY{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ int_check( shift,
( defined $DELAY{ min } ? $DELAY{ min } : undef ),
( defined $DELAY{ max } ? $DELAY{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $DELAY{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $DELAY{ min } ? $DELAY{ min } : '-inf' ) .
" : " . ( defined $DELAY{ max } ? $DELAY{ max } : '+inf' ) . " ]" );
$DELAY{ tk_unit } = $DELAY{ tk_frame }->Label( -text => "ms",
-width => 5 );
$DELAY{ tk_frame }->pack( %fp );
$DELAY{ tk_label }->pack( %wp );
$DELAY{ tk_entry }->pack( %wp );
$DELAY{ tk_unit }->pack( %up );

# === CUR_ATT   int [ 0 : 99 ] [ 99 ] "Present attenuation" "dB"
my %CUR_ATT;
$CUR_ATT{ tk_frame } = $fsc2_main_frame->Frame( );
$CUR_ATT{ tk_label } = $CUR_ATT{ tk_frame }->Label( -text => "Present attenuation",
-width => 20,
-anchor => 'w' );
$CUR_ATT{ value } = 99;
$CUR_ATT{ min } = 0;
$CUR_ATT{ max } = 99;
$CUR_ATT{ tk_entry } = $CUR_ATT{ tk_frame }->Entry( -textvariable => \$CUR_ATT{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ int_check( shift,
( defined $CUR_ATT{ min } ? $CUR_ATT{ min } : undef ),
( defined $CUR_ATT{ max } ? $CUR_ATT{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $CUR_ATT{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $CUR_ATT{ min } ? $CUR_ATT{ min } : '-inf' ) .
" : " . ( defined $CUR_ATT{ max } ? $CUR_ATT{ max } : '+inf' ) . " ]" );
$CUR_ATT{ tk_unit } = $CUR_ATT{ tk_frame }->Label( -text => "dB",
-width => 5 );
$CUR_ATT{ tk_frame }->pack( %fp );
$CUR_ATT{ tk_label }->pack( %wp );
$CUR_ATT{ tk_entry }->pack( %wp );
$CUR_ATT{ tk_unit }->pack( %up );

# === START_ATT int [ 0 : 99 ] [ 1 ]  "Initial attenuation" "dB"
my %START_ATT;
$START_ATT{ tk_frame } = $fsc2_main_frame->Frame( );
$START_ATT{ tk_label } = $START_ATT{ tk_frame }->Label( -text => "Initial attenuation",
-width => 20,
-anchor => 'w' );
$START_ATT{ value } = 1;
$START_ATT{ min } = 0;
$START_ATT{ max } = 99;
$START_ATT{ tk_entry } = $START_ATT{ tk_frame }->Entry( -textvariable => \$START_ATT{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ int_check( shift,
( defined $START_ATT{ min } ? $START_ATT{ min } : undef ),
( defined $START_ATT{ max } ? $START_ATT{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $START_ATT{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $START_ATT{ min } ? $START_ATT{ min } : '-inf' ) .
" : " . ( defined $START_ATT{ max } ? $START_ATT{ max } : '+inf' ) . " ]" );
$START_ATT{ tk_unit } = $START_ATT{ tk_frame }->Label( -text => "dB",
-width => 5 );
$START_ATT{ tk_frame }->pack( %fp );
$START_ATT{ tk_label }->pack( %wp );
$START_ATT{ tk_entry }->pack( %wp );
$START_ATT{ tk_unit }->pack( %up );

# === LIMIT_1DB int [ 0 : 99 ] [ 4 ]  "Limit of 1 dB steps" "dB"
my %LIMIT_1DB;
$LIMIT_1DB{ tk_frame } = $fsc2_main_frame->Frame( );
$LIMIT_1DB{ tk_label } = $LIMIT_1DB{ tk_frame }->Label( -text => "Limit of 1 dB steps",
-width => 20,
-anchor => 'w' );
$LIMIT_1DB{ value } = 4;
$LIMIT_1DB{ min } = 0;
$LIMIT_1DB{ max } = 99;
$LIMIT_1DB{ tk_entry } = $LIMIT_1DB{ tk_frame }->Entry( -textvariable => \$LIMIT_1DB{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ int_check( shift,
( defined $LIMIT_1DB{ min } ? $LIMIT_1DB{ min } : undef ),
( defined $LIMIT_1DB{ max } ? $LIMIT_1DB{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $LIMIT_1DB{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $LIMIT_1DB{ min } ? $LIMIT_1DB{ min } : '-inf' ) .
" : " . ( defined $LIMIT_1DB{ max } ? $LIMIT_1DB{ max } : '+inf' ) . " ]" );
$LIMIT_1DB{ tk_unit } = $LIMIT_1DB{ tk_frame }->Label( -text => "dB",
-width => 5 );
$LIMIT_1DB{ tk_frame }->pack( %fp );
$LIMIT_1DB{ tk_label }->pack( %wp );
$LIMIT_1DB{ tk_entry }->pack( %wp );
$LIMIT_1DB{ tk_unit }->pack( %up );

# === LIMIT_2DB int [ 0 : 99 ] [ 28 ] "Limit of 2 dB steps" "dB"
my %LIMIT_2DB;
$LIMIT_2DB{ tk_frame } = $fsc2_main_frame->Frame( );
$LIMIT_2DB{ tk_label } = $LIMIT_2DB{ tk_frame }->Label( -text => "Limit of 2 dB steps",
-width => 20,
-anchor => 'w' );
$LIMIT_2DB{ value } = 28;
$LIMIT_2DB{ min } = 0;
$LIMIT_2DB{ max } = 99;
$LIMIT_2DB{ tk_entry } = $LIMIT_2DB{ tk_frame }->Entry( -textvariable => \$LIMIT_2DB{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ int_check( shift,
( defined $LIMIT_2DB{ min } ? $LIMIT_2DB{ min } : undef ),
( defined $LIMIT_2DB{ max } ? $LIMIT_2DB{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $LIMIT_2DB{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $LIMIT_2DB{ min } ? $LIMIT_2DB{ min } : '-inf' ) .
" : " . ( defined $LIMIT_2DB{ max } ? $LIMIT_2DB{ max } : '+inf' ) . " ]" );
$LIMIT_2DB{ tk_unit } = $LIMIT_2DB{ tk_frame }->Label( -text => "dB",
-width => 5 );
$LIMIT_2DB{ tk_frame }->pack( %fp );
$LIMIT_2DB{ tk_label }->pack( %wp );
$LIMIT_2DB{ tk_entry }->pack( %wp );
$LIMIT_2DB{ tk_unit }->pack( %up );

# === LIMIT_3DB int [ 0 : 99 ] [ 40 ] "Limit of 3 dB steps" "dB"
my %LIMIT_3DB;
$LIMIT_3DB{ tk_frame } = $fsc2_main_frame->Frame( );
$LIMIT_3DB{ tk_label } = $LIMIT_3DB{ tk_frame }->Label( -text => "Limit of 3 dB steps",
-width => 20,
-anchor => 'w' );
$LIMIT_3DB{ value } = 40;
$LIMIT_3DB{ min } = 0;
$LIMIT_3DB{ max } = 99;
$LIMIT_3DB{ tk_entry } = $LIMIT_3DB{ tk_frame }->Entry( -textvariable => \$LIMIT_3DB{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ int_check( shift,
( defined $LIMIT_3DB{ min } ? $LIMIT_3DB{ min } : undef ),
( defined $LIMIT_3DB{ max } ? $LIMIT_3DB{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $LIMIT_3DB{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $LIMIT_3DB{ min } ? $LIMIT_3DB{ min } : '-inf' ) .
" : " . ( defined $LIMIT_3DB{ max } ? $LIMIT_3DB{ max } : '+inf' ) . " ]" );
$LIMIT_3DB{ tk_unit } = $LIMIT_3DB{ tk_frame }->Label( -text => "dB",
-width => 5 );
$LIMIT_3DB{ tk_frame }->pack( %fp );
$LIMIT_3DB{ tk_label }->pack( %wp );
$LIMIT_3DB{ tk_entry }->pack( %wp );
$LIMIT_3DB{ tk_unit }->pack( %up );

$fsc2_main_frame->pack( %fp, -pady => '1m' );
$fsc2_main_window->Optionmenu( -options => \@fsc2_how_to_run,
                                -textvariable => \$fsc2_how_to_run,
                              )->pack( -padx => '3m',
                                       -pady => '3m' );

$fsc2_apply_button->pack( %wp, padx => '5m', -pady => '3m' );
$fsc2_quit_button->pack( %wp, padx => '5m', -pady => '3m' );

load_defs( );
MainLoop;


################################################################

sub int_check {
    my ( $new, $min, $max ) = @_;

    return 0 if $new =~ /^\+?(\d+)?$/ and defined $max and $max < 0;
    return 0 if $new =~ /^-/ and defined $min and $min >= 0;
    if ( $new =~ /^[+-]?$/ ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
         return 1;
     }

    return 0 unless $new =~ /^[+-]?\d+?$/;

    if ( ( defined $min and $new < $min )
         or ( defined $max and $new > $max ) ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
     } else {
         $fsc2_apply_button->configure( -state => 'normal' );
     }
     return 1;
}


################################################################

sub float_check {
    my ( $new, $min, $max ) = @_;
    my $float_rep = '[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?';

    return 0 if $new =~ /^\+/ and defined $max and $max < 0;
    return 0 if $new =~ /^-/ and defined $min and $min > 0;

    if ( $new =~ /^$float_rep$/ ) {
        if ( ( defined $max and $max < $new ) or
             ( defined $min and $min > $new ) ) {
            $fsc2_apply_button->configure( -state => 'disabled' );
        } else {
            $fsc2_apply_button->configure( -state => 'normal' );
        }
        return 1;
    }

    if ( $new =~ /^[+-]?(\d+)?\.?(\d+)?([Ee][+-]?(\d+)?)?$/ ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
         return 1;
     }

     return 0;
}


################################################################

sub write_out {
    my $fh;
    open( $fh, "|fsc2_" . lc $fsc2_how_to_run )
        or die "Can't find utility fsc2_" . lc $fsc2_how_to_run . ".\n";

    my $FC_TYPE = $FC_TYPE{ value };
    my $START_FIELD = $START_FIELD{ value };
    my $END_FIELD = $END_FIELD{ value };
    my $FIELD_STEP = $FIELD_STEP{ value };
    my $DELAY = $DELAY{ value };
    my $CUR_ATT = $CUR_ATT{ value };
    my $START_ATT = $START_ATT{ value };
    my $LIMIT_1DB = $LIMIT_1DB{ value };
    my $LIMIT_2DB = $LIMIT_2DB{ value };
    my $LIMIT_3DB = $LIMIT_3DB{ value };

    print $fh "
DEVICES:

hjs_daadc;
";
# === if FC_TYPE eq "without Gaussmeter"
    if ( eval { $FC_TYPE eq "without Gaussmeter" } ) {
        print $fh "hjs_sfc;
";
# === else
    } else {
        print $fh "witio_48;
bnm12;
hjs_fc;
";
# === endif
    }

    print $fh "hjs_attenuator;


VARIABLES:

start_field = $START_FIELD G;
end_field   = $END_FIELD G;
";
# === if START_FIELD <= END_FIELD
    if ( eval { $START_FIELD <= $END_FIELD } ) {
        print $fh "field_step  = $FIELD_STEP G;
";
# === else
    } else {
        print $fh "field_step  = - $FIELD_STEP G;
";
# === endif
    }

    print $fh "
cur_field;

tc = $DELAY ms;

steps_dB[ 3 ]  = { 1 dB,  2 dB,  3 dB };
limits_dB[ 3 ] = { $LIMIT_1DB dB, $LIMIT_2DB dB, $LIMIT_3DB dB };

N_points = ceil( abs( end_field - start_field ) / abs( field_step ) ) + 1;
data[ 4, * ];
cur_db;
I, J, K;


PREPARATIONS:

magnet_setup( start_field, field_step );
";
# === if START_FIELD <= END_FIELD
    if ( eval { $START_FIELD <= $END_FIELD } ) {
        print $fh "init_1d( 4, 0, start_field, field_step, \"Field [G]\", \"Amplitude [V]\" );
";
# === else
    } else {
        print $fh "init_1d( 4, 0, end_field, - field_step, \"Field [G]\", \"Amplitude [V]\" );
";
# === endif
    }

    print $fh "mw_attenuator_initial_attenuation( $CUR_ATT dB );


EXPERIMENT:

FOR I = 1 : size( steps_dB ) {
	IF I == 1 {
		cur_db = $START_ATT dB;
	} ELSE {
		cur_db = limits_dB[ I - 1 ] + steps_dB[ I ];
	}


	WHILE ( cur_db <= limits_dB[ I ] )
	{
		cur_field = reset_field( );
		mw_attenuator_attenuation( cur_db );
		fsave( \"\\n\\# Attenuation: # dB\\n\\n\", cur_db );

";
# === if START_FIELD <= END_FIELD
    if ( eval { $START_FIELD <= $END_FIELD } ) {
        print $fh "		FOR J = 1 : N_points {
";
# === else
    } else {
        print $fh "		FOR J = N_points : 1 : -1 {
";
# === endif
    }

    print $fh "			wait( tc );
			data[ 1, J ] = daq_get_voltage( );
			display_1d( J, data[ 1, J ] );
			fsave( \"# G  # V\\n\", cur_field, data[ 1, J ] );
			cur_field = sweep_up( );
		}

		clear_curve_1d( 1 );
		FOR K = 4 : 2 : - 1 {
			data[ K ] = data[ K - 1 ];
			IF size(  data[ K ] ) > 0 {
			   display_1d( 1, data[ K ], K );
		   }
		}

		cur_db += steps_dB[ I ];
	}
}
";
    close $fh;

    my $text;
    if ( $? != 0 ) {
        if ( $? >> 8 == 255 ) {
            $text = "Internal error.";
        } elsif ( $? >> 8 == 1 ) {
            $text = "Someone else is running fsc2.";
        } elsif ( $? >> 8 == 2 ) {
            $text = "fsc2 is already testing or\nrunning an experiment.";
        } elsif ( $? >> 8 == 3 ) {
            $text = "Internal error of fsc2.";
        } elsif ( $? >> 8 == 4 ) {
            $text = "Could not start fsc2.";
        } else {
            $text = "Something strange\nis going on here.";
        }

        &show_message( $text ) if $? >> 8 != 0;
    }
}


################################################################

sub show_message {
    my $text = shift;

    $fsc2_main_window->messageBox( -icon => 'error',
                                   -type => 'Ok',
                                   -title => 'Error',
                                   -message => $text );
}


################################################################

sub store_defs {

    my $fh;
    my $name = $0;

    $name =~ s|^.*?([^/]+)$|$1|;
    mkdir "$ENV{ HOME }/.fsc2", 0777 unless -e "$ENV{ HOME }/.fsc2";
    open( $fh, ">$ENV{ HOME }/.fsc2/$name" ) or return;
    print $fh "# Do not edit - created automatically!\n";

    print $fh "$FC_TYPE{ value }\n";

    if ( $START_FIELD{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o and
         ( defined $START_FIELD{ max } ? $START_FIELD{ max } >= $START_FIELD{ value } : 1 ) and
         ( defined $START_FIELD{ min } ? $START_FIELD{ min } <= $START_FIELD{ value } : 1 ) ) {
        print $fh "$START_FIELD{ value }\n";
    } else {
        print $fh "3100.0\n";
    }

    if ( $END_FIELD{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o and
         ( defined $END_FIELD{ max } ? $END_FIELD{ max } >= $END_FIELD{ value } : 1 ) and
         ( defined $END_FIELD{ min } ? $END_FIELD{ min } <= $END_FIELD{ value } : 1 ) ) {
        print $fh "$END_FIELD{ value }\n";
    } else {
        print $fh "3200.0\n";
    }

    if ( $FIELD_STEP{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o and
         ( defined $FIELD_STEP{ max } ? $FIELD_STEP{ max } >= $FIELD_STEP{ value } : 1 ) and
         ( defined $FIELD_STEP{ min } ? $FIELD_STEP{ min } <= $FIELD_STEP{ value } : 1 ) ) {
        print $fh "$FIELD_STEP{ value }\n";
    } else {
        print $fh "0.5\n";
    }

    if ( $DELAY{ value } =~ /^[+-]?\d+$/o and
         ( defined $DELAY{ max } ? $DELAY{ max } >= $DELAY{ value } : 1 ) and
         ( defined $DELAY{ min } ? $DELAY{ min } <= $DELAY{ value } : 1 ) ) {
        print $fh "$DELAY{ value }\n";
    } else {
        print $fh "300\n";
    }

    if ( $CUR_ATT{ value } =~ /^[+-]?\d+$/o and
         ( defined $CUR_ATT{ max } ? $CUR_ATT{ max } >= $CUR_ATT{ value } : 1 ) and
         ( defined $CUR_ATT{ min } ? $CUR_ATT{ min } <= $CUR_ATT{ value } : 1 ) ) {
        print $fh "$CUR_ATT{ value }\n";
    } else {
        print $fh "99\n";
    }

    if ( $START_ATT{ value } =~ /^[+-]?\d+$/o and
         ( defined $START_ATT{ max } ? $START_ATT{ max } >= $START_ATT{ value } : 1 ) and
         ( defined $START_ATT{ min } ? $START_ATT{ min } <= $START_ATT{ value } : 1 ) ) {
        print $fh "$START_ATT{ value }\n";
    } else {
        print $fh "1\n";
    }

    if ( $LIMIT_1DB{ value } =~ /^[+-]?\d+$/o and
         ( defined $LIMIT_1DB{ max } ? $LIMIT_1DB{ max } >= $LIMIT_1DB{ value } : 1 ) and
         ( defined $LIMIT_1DB{ min } ? $LIMIT_1DB{ min } <= $LIMIT_1DB{ value } : 1 ) ) {
        print $fh "$LIMIT_1DB{ value }\n";
    } else {
        print $fh "4\n";
    }

    if ( $LIMIT_2DB{ value } =~ /^[+-]?\d+$/o and
         ( defined $LIMIT_2DB{ max } ? $LIMIT_2DB{ max } >= $LIMIT_2DB{ value } : 1 ) and
         ( defined $LIMIT_2DB{ min } ? $LIMIT_2DB{ min } <= $LIMIT_2DB{ value } : 1 ) ) {
        print $fh "$LIMIT_2DB{ value }\n";
    } else {
        print $fh "28\n";
    }

    if ( $LIMIT_3DB{ value } =~ /^[+-]?\d+$/o and
         ( defined $LIMIT_3DB{ max } ? $LIMIT_3DB{ max } >= $LIMIT_3DB{ value } : 1 ) and
         ( defined $LIMIT_3DB{ min } ? $LIMIT_3DB{ min } <= $LIMIT_3DB{ value } : 1 ) ) {
        print $fh "$LIMIT_3DB{ value }\n";
    } else {
        print $fh "40\n";
    }

    print $fh "$fsc2_how_to_run\n";

    close $fh;
};


################################################################

sub load_defs {
    my $fh;
    my $name = $0;
    my $ne;
    my $found;

    $name =~ s|^.*?([^/]+)$|$1|;
    if ( $ARGV[ 0 ] ) {
        open( $fh, "<$ARGV[ 0 ]" ) or return;
    } else {
        open( $fh, "<$ENV{ HOME }/.fsc2/$name" ) or return;
    }

    goto done_reading unless defined( $ne = <$fh> ) and $ne =~ /^#/;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @FC_TYPE ) {
        if ( $ne eq $_) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $FC_TYPE{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> )
        and $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o;
    chomp $ne;
    goto done_reading if ( defined $START_FIELD{ max } and $ne > $START_FIELD{ max } ) or
                         ( defined $START_FIELD{ min } and $ne < $START_FIELD{ min } );
    $START_FIELD{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> )
        and $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o;
    chomp $ne;
    goto done_reading if ( defined $END_FIELD{ max } and $ne > $END_FIELD{ max } ) or
                         ( defined $END_FIELD{ min } and $ne < $END_FIELD{ min } );
    $END_FIELD{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> )
        and $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o;
    chomp $ne;
    goto done_reading if ( defined $FIELD_STEP{ max } and $ne > $FIELD_STEP{ max } ) or
                         ( defined $FIELD_STEP{ min } and $ne < $FIELD_STEP{ min } );
    $FIELD_STEP{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> )
        and $ne =~ /^[+-]?\d+$/;
    chomp $ne;
    goto done_reading if ( defined $DELAY{ max } and $ne > $DELAY{ max } ) or
                         ( defined $DELAY{ min } and $ne < $DELAY{ min } );
    $DELAY{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> )
        and $ne =~ /^[+-]?\d+$/;
    chomp $ne;
    goto done_reading if ( defined $CUR_ATT{ max } and $ne > $CUR_ATT{ max } ) or
                         ( defined $CUR_ATT{ min } and $ne < $CUR_ATT{ min } );
    $CUR_ATT{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> )
        and $ne =~ /^[+-]?\d+$/;
    chomp $ne;
    goto done_reading if ( defined $START_ATT{ max } and $ne > $START_ATT{ max } ) or
                         ( defined $START_ATT{ min } and $ne < $START_ATT{ min } );
    $START_ATT{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> )
        and $ne =~ /^[+-]?\d+$/;
    chomp $ne;
    goto done_reading if ( defined $LIMIT_1DB{ max } and $ne > $LIMIT_1DB{ max } ) or
                         ( defined $LIMIT_1DB{ min } and $ne < $LIMIT_1DB{ min } );
    $LIMIT_1DB{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> )
        and $ne =~ /^[+-]?\d+$/;
    chomp $ne;
    goto done_reading if ( defined $LIMIT_2DB{ max } and $ne > $LIMIT_2DB{ max } ) or
                         ( defined $LIMIT_2DB{ min } and $ne < $LIMIT_2DB{ min } );
    $LIMIT_2DB{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> )
        and $ne =~ /^[+-]?\d+$/;
    chomp $ne;
    goto done_reading if ( defined $LIMIT_3DB{ max } and $ne > $LIMIT_3DB{ max } ) or
                         ( defined $LIMIT_3DB{ min } and $ne < $LIMIT_3DB{ min } );
    $LIMIT_3DB{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @fsc2_how_to_run ) {
        if ( $ne eq $_) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $fsc2_how_to_run = $ne;

  done_reading:
    close $fh;
};
