#!/usr/bin/perl -w
# -*- cperl -*-
#
# $Id$
#
# Copyright (C) 1999-2003 Jens Thoms Toerring
#
# This file is part of fsc2.
#
# Fsc2 is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# Fsc2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with fsc2; see the file COPYING.  If not, write to
# the Free Software Foundation, 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

use strict;
use Tk;
use Tk::Balloon;
use Tk::Dialog;


my @version = split /\./, $Tk::VERSION;
die "Installed Perl-Tk version is $Tk::VERSION but Tk800.022 is required.\n"
    if $version[ 0 ] + 0.001 * $version[ 1 ] < 800.022;


my ( $f0, $f1, $f2, $f3, $f4, $f5 );
my %fp = ( '-side' => 'top',
		   '-fill' => 'x',
		   '-padx' => '2m',
		   '-pady' => '2m' );

my %wp = ( '-side'   => 'left',
		   '-fill'   => 'x',
		   '-padx'   => '3m',
		   '-expand' => 1 );

my $mw = MainWindow->new( );
$mw->title( "SPEX" );

$f0 = $mw->Frame( )->pack( '-side' => 'top',
						   '-padx' => '2m',
						   '-ipadx'  => '2m',
						   '-ipady'  => '2m',
						   '-pady' => '2m' );
$f1 = $f0->Button( '-text' => "Measurement",
				   '-command' => \&exp_setup );
$f2 = $f0->Button( '-text' => "Monitor Mode",
				   '-command' => \&monit );
$f3 = $f0->Button( '-text' => "Calibration",
				   '-command' => \&calib );
$f4 = $mw->Frame(  );
$f5 = $mw->Button( '-text' => "Quit",
				   '-command' => sub { $mw->destroy } );

$f1->pack( %fp );
$f2->pack( %fp );
$f3->pack( %fp );
$f4->pack( '-side' => 'top',
		   '-fill' => 'x' );
$f5->pack( '-side' => 'top',
		   '-padx' => '2m',
		   '-pady' => '2m' );

MainLoop;


##########################################################

sub calib {

	local *F;

	open( F, "|fsc2_start" )
		or die "Can't find utility fsc2_start" . ".\n";

	print F <<EOF;
/*-----------------------------------------------------------*/
/* EDL script to do a calibration of the SPEX monochromator. */
/* How to use it:                                            */
/* 1. Set the correct laser line position in the topmost     */
/*    input field (in absolute wavenumber units)             */
/* 2. If necessary change the range for the scan over the    */
/*    laser line (also in absolute wavenumber units) and the */
/*    step width.                                            */
/* 3. If necessary change the sampling time (i.e. the time   */
/*    for which at every spectral position photons are       */
/*    counted).                                              */
/* 4. Make sure the slit of the monochromator isn't too wide */
/*    open, otherwise you could destroy the PMT!             */
/* 5. Press the "Start scan" button and wait for the end of  */
/*    the scan over the laser line.                          */
/* 6. Either enter the position where the laser line did     */
/*    appear during the scan (you can determine the position */
/*    by pressing both the left and the right mouse button   */
/*    while moving the mouse to the top of the peak, it's    */
/*    coordinates will be shown in the upper left hand       */
/*    corner of the window with the spectrum) or by pressing */
/*    the "Find line" button (please note: this will only    */
/*    lead to reasonable results when the spectrum has been  */
/*    measured with a good S/N ratio, e.g. above 200).       */
/* 7. After determining the observed line position press the */
/*    "Accept" button to make the program automatically      */
/*    correct for the deviation between the exact and the    */
/*    observed line position.                                */
/* 8. If necessary repeat the above procedure - when the     */
/*    offset of the monochromator has been set correctly the */
/*    deviation between the theoretical and the observed     */
/*    line position should be zero or at least very small.   */
/*-----------------------------------------------------------*/

DEVICES:

ni6601;
spex_cd2a;


VARIABLES:

laser_line,
nll;
start_wn = 0.0;
end_wn = 0.0;
step_size = 0.1 cm^-1;
mtime = 0.1;
lpos = 0.0;
new;
N_points;
B_ll, B_swn, B_ewn, B_stsz, B_mt, B_scan, B_find, B_lpos, B_acc;
I;
data[ * ];
P_count = 0;
offset;
Accepted = 0;


PREPARATIONS:

init_1d( 1, "Wavenumber [cm-^1]", "Counts per second" );


EXPERIMENT:

laser_line = monochromator_laser_line( );
nll = laser_line;
monochromator_laser_line( 0.0 );

IF laser_line - monochromator_offset( ) >= 46000.0 / 3.0 + 2 &
   laser_line - monochromator_offset( ) <= 43998.0 {
	start_wn = laser_line + 2 cm^-1;
	end_wn   = laser_line - 2 cm^-1;
	P_count  = 2;
}

hide_toolbox( "ON" );
B_ll   = input_create( "FLOAT_INPUT", laser_line, "Laser line [cm^-1]",
					   "", "%.4f" );
B_swn  = input_create( "FLOAT_INPUT", start_wn, "Scan start [cm^-1]",
					   "", "%.4f" );
B_ewn  = input_create( "FLOAT_INPUT", end_wn, "Scan end [cm^-1]", "", "%.4f" );
B_stsz = input_create( "FLOAT_INPUT", step_size, "Scan step size [cm^-1]",
					   "", "%.4f" );
B_mt   = input_create( "FLOAT_INPUT", mtime, "Sampling time [s]" );
B_scan = button_create( "NORMAL_BUTTON", "Start scan" );
IF P_count < 2 {
	object_enable( B_scan, "OFF" );
}
B_lpos = input_create( "FLOAT_INPUT", lpos, "Observed line position [cm^-1]",
						"", "%.4f" );
object_enable( B_lpos, "OFF" );
B_find = button_create( "NORMAL_BUTTON", "Find line" );
object_enable( B_find, "OFF" );
B_acc  = button_create( "NORMAL_BUTTON", "Accept" );
object_enable( B_acc, "OFF" );
hide_toolbox( "OFF" );

FOREVER {

	IF toolbox_changed( B_ll ) {

		new = input_value( B_ll );

		IF new == nll {
			NEXT;
		}

		IF new < 0.0 {
			input_value( B_ll, nll );
			NEXT;
		}

		nll = new;

		IF nll > 0.0 & nll - lpos <= 10.0 {
			object_enable( B_acc, "ON" );
		} ELSE {
			object_enable( B_acc, "OFF" );
		}
	}

	IF toolbox_changed( B_swn ) {

		new = input_value( B_swn );

		IF new == start_wn {
			NEXT;
		}

		IF new - monochromator_offset( ) > 44000.0 |
		   new - monochromator_offset( ) < 46000.0 / 3.0 {
			input_value( B_swn, start_wn );
			NEXT;
		}

		start_wn = new;
		P_count += 1;

		IF P_count >= 2 {
			object_enable( B_scan, "ON" );
		}
	}

	IF toolbox_changed( B_ewn ) {

		new = input_value( B_ewn );

		IF new == end_wn {
			NEXT;
		}

		IF new - monochromator_offset( ) > 44000.0 |
		   new - monochromator_offset( ) < 46000.0 / 3.0 {
			input_value( B_ewn, end_wn );
			NEXT;
		}

		end_wn = new;
		P_count += 1;

		IF P_count >= 2 {
			object_enable( B_scan, "ON" );
		}
	}

	IF toolbox_changed( B_stsz ) {

		new = input_value( B_stsz );

		IF new == step_size {
			NEXT;
		}

		IF new <= 0.0 | new > 10.0 {
			input_value( B_stsz, step_size );
			NEXT;
		}

		step_size = new;
	}

	IF toolbox_changed( B_mt ) {

		new = input_value( B_mt );

		IF new == mtime {
			NEXT;
		}

		IF new < 0.001 | new > 100.0 {
			input_value( B_mt, mtime );
			NEXT;
		}

		mtime = new;
	}

	IF button_state( B_scan ) {

		object_enable( B_scan, "OFF" );

		IF start_wn < end_wn {
			show_message( "Scan start is not larger than scan end" );
			NEXT;
		}

		N_points = int( ceil( ( start_wn - end_wn ) / step_size ) + 1 );

		IF N_points < 2 {
			show_message( "Step size is too large" );
			NEXT;
		}

		clear_curve( );
		clear_marker( );
		rescale( N_points );
		change_scale( start_wn, - step_size );
		monochromator_scan_setup( start_wn, step_size );
		monochromator_start_scan( );

		FOR I = 1 : N_points {

			data[ I ] = 2.0 * counter_timed_count( CH0, mtime ) / mtime;

			display( I, data[ I ] );

			IF I < N_points {
				monochromator_scan_step( );
			}
		}

		object_enable( B_scan, "ON" );
		object_enable( B_find, "ON" );
		object_enable( B_lpos, "ON" );
	}

	IF toolbox_changed( B_lpos ) {

		new = input_value( B_lpos );

		IF new == lpos {
			NEXT;
		}

		IF new > start_wn | new < end_wn {
			input_value( B_lpos, lpos );
			NEXT;
		}

		lpos = new;
		clear_marker( );
		draw_marker( round( ( start_wn - lpos ) / step_size + 1 ) );

		IF nll > 0.0 & nll - lpos <= 10.0 {
			object_enable( B_acc, "ON" );
		} ELSE {
			object_enable( B_acc, "OFF" );
		}
	}

	IF button_state( B_find ) {

		new = find_peak( slice( data, 1, N_points ) );

		IF new < 1.0 | new > size( data ) {
			NEXT;
		}

		lpos = start_wn - ( new - 1.0 ) * step_size;
		input_value( B_lpos, lpos );
		clear_marker( );
		draw_marker_1d( round( new ) );
		object_enable( B_acc, "ON" );
	}

	IF button_state( B_acc ) {

		offset = nll - lpos;
		monochromator_offset( offset );
		lpos = nll;
		input_value( B_lpos, lpos );
		start_wn += offset;
		input_value( B_swn, start_wn );
		end_wn += offset;
		input_value( B_ewn, end_wn );
		change_scale( start_wn, - step_size );
		clear_marker( );
		draw_marker_1d( round( ( start_wn - lpos ) / step_size + 1 ) );
		Accepted = 1;
	}
}

ON_STOP:

monochromator_laser_line( Accepted ? nll : laser_line );
EOF

	close F;
	show_message( $? ) if $? != 0;
}


##########################################################

sub monit {
	local *F;

	open( F, "|fsc2_start" )
		or die "Can't find utility fsc2_start" . ".\n";

	print F <<EOF;
/*-----------------------------------------------------------*/
/* EDL script for mitor mode:                                */
/* 1. "Scan start" allows to set a new spectral position for */
/*    the start of a scan.                                   */
/* 2. Press the button "Go to scan start position" to set    */
/*    monochromator to the scan start position (instead of   */
/*    defering the action until a scan is started). Can be   */
/*    used while sampling but not while scan is in progress. */
/* 3. Use the "Scan step size" and "Sampling time" fields    */
/*    to set up the wavenumber decrement used in a scan and  */
/*    the time photons are counted at spectral positions.    */
/* 4. Use the "Start scan" button to start a scan and the    */
/*    "Start sampling" button to start sampling (but without */
/*    changing the spectral position).                       */
/* 5. Use the "Stop scan/sampling" to abort a scan or stop   */
/*    sampling mode.                                         */
/* 6. The "Relative units" and "Absolute units" allow you    */
/*    to switch between display of wavenumber units relative */
/*    to the laser line position and absolute wavenumbers.   */
/* 7. Use the "Clear screen" button to remove all displayed  */
/*    data.                                                  */
/*-----------------------------------------------------------*/

DEVICES:

ni6601;
spex_cd2a;


VARIABLES:

start_wn  = 100.0 cm^-1;
step_size = 1 cm^-1;
mtime     = 0.1 s;
cwn = start_wn;
old_start_wn = start_wn;
old_step_size = step_size;

ll;
new;
data;
Doing_Scan = 0;
Doing_Sampling = 0;
I = 1;
I_start = 1;
Mode = 0;

B_swn, B_goto, B_stsz, B_mt, B_scan, B_samp,
B_cwn, B_stop, B_rel, B_abs, B_clr;


PREPARATIONS:

init_1d( "Wavenumber [cm^-1 rel.]", "Counts per second" );


EXPERIMENT:

hide_toolbox( "ON" );
B_swn =  input_create( "FLOAT_INPUT", start_wn, "Scan start [cm^-1 rel.]",
					   "", "%.4f" );
B_goto = button_create( "NORMAL_BUTTON", "Go to scan start position" );
B_stsz = input_create( "FLOAT_INPUT", step_size, "Scan step size [cm^-1 rel.]",
					   "", "%.4f" );
B_mt   = input_create( "FLOAT_INPUT", mtime, "Sampling time [s]" );
B_scan = button_create( "NORMAL_BUTTON", "Start scan" );
B_samp = button_create( "NORMAL_BUTTON", "Start sampling" );
B_cwn  = output_create( "FLOAT_OUTPUT", cwn, "Current position [cm^-1 rel]",
						"", "%.4f" );
B_stop = button_create( "NORMAL_BUTTON", "Stop scan/sampling" );
object_enable( B_stop, "OFF" );
B_rel  = button_create( "RADIO_BUTTON", "Relative units" );
B_abs  = button_create( "RADIO_BUTTON", B_rel, "Absolute units" );
button_state( B_rel, "ON" );
B_clr  = button_create( "NORMAL_BUTTON", "Clear screen" );
hide_toolbox( "OFF" );

ll = monochromator_laser_line( );

FOREVER {

	IF toolbox_changed( ) {
		IF button_changed( B_rel ) {
			button_state( B_rel );
			output_value( B_swn, start_wn );
			object_change_label( B_swn, "Scan start [cm^-1 rel.]" );
			output_value( B_cwn, cwn );
			object_change_label( B_cwn, "Current position [cm^-1 rel.]" );
			change_label( "Wavenumber [cm^-1 rel.]" );
			change_scale( old_start_wn - ( I_start - 1 ) * old_step_size,
						  old_step_size );
			Mode = 0;
		}

		IF button_changed( B_abs ) {
			button_state( B_abs );
			output_value( B_swn, ll - start_wn );
			object_change_label( B_swn, "Scan start [cm^-1 abs.]" );
			output_value( B_cwn, ll - cwn );
			object_change_label( B_cwn, "Current position [cm^-1 abs.]" );
			change_label( "Wavenumber [cm^-1 abs.]" );
			change_scale( ll - old_start_wn + ( I_start - 1 ) * old_step_size,
						  - old_step_size );
			Mode = 1;
		}

		IF input_changed( B_swn ) {
			new = input_value( B_swn );

			IF ( Mode == 0 &
				 ( ll - new > 44000.0 | ll - new < 46000.0 / 3.0 ) ) |
			   ( Mode == 1 &
				 ( new > 44000.0 | new < 46000.0 / 3.0 ) ) {
				input_value( B_swn, Mode == 0 ? start_wn : ll - start_wn);
				NEXT;
			}

			start_wn = Mode == 0 ? new : ll - new;
			IF ! Doing_Scan {
				object_enable( B_scan, "ON" );
			}
			IF Mode == 0 {
				change_scale( start_wn + ( I - 1 ) * step_size, - step_size );
			} ELSE {
				change_scale( ll - start_wn - ( I - 1 ) * step_size,
							  step_size );
			}
		}

		IF button_changed( B_goto ) {
			button_state( B_goto );
			IF cwn != start_wn {
				cwn = start_wn;
				output_value( B_cwn, Mode == 0 ? cwn : ll - cwn );
				monochromator_wavenumber( Mode == 0 ? start_wn :
										  ll - start_wn );
			}
		}

		IF input_changed( B_stsz ) {
			new = input_value( B_stsz );

			IF new <= 0.0 | new > 10.0 {
				input_value( B_stsz, step_size );
				NEXT;
			}

			step_size = new;
		}

		IF input_changed( B_mt ) {
			new = input_value( B_mt );

			IF new < 0.001 | new > 100.0 {
				input_value( B_mt, mtime );
				NEXT;
			}

			mtime = new;
		}

		IF button_state( B_clr ) {
			clear_curve( );
			clear_marker( );
			rescale( 32 );
			I = 1;
			old_start_wn = cwn;
			IF Mode == 0 {
				change_scale( cwn - ( I - 1 ) * step_size, step_size );
			} ELSE {
				change_scale( ll - cwn + ( I - 1 ) * step_size, - step_size );
			}
		}

		IF button_state( B_scan ) {
			object_enable( B_goto, "OFF" );
			object_enable( B_scan, "OFF" );
			object_enable( B_samp, "OFF" );
			object_enable( B_stop, "ON" );

			cwn = start_wn;
			output_value( B_cwn, Mode == 0 ? cwn : ll - cwn );

			IF Mode == 0 {
				change_scale( start_wn - ( I - 1 ) * step_size, step_size );
			} ELSE {
				change_scale( ll - start_wn + ( I - 1 ) * step_size,
							  - step_size );
			}

			I_start = I;
			old_start_wn = start_wn;
			old_step_size = step_size;
			monochromator_scan_setup( start_wn, step_size );
			monochromator_start_scan( );
			Doing_Scan = 1;
		}

		IF button_state( B_samp ) {
			object_enable( B_scan, "OFF" );
			object_enable( B_samp, "OFF" );
			object_enable( B_stop, "ON" );
			Doing_Sampling = 1;

		}

		IF button_state( B_stop ) {
			draw_marker( I );
			object_enable( B_scan, "ON" );
			object_enable( B_samp, "ON" );
			object_enable( B_stop, "OFF" );
			object_enable( B_goto, "ON" );
			Doing_Scan = 0;
			Doing_Sampling = 0;
		}

	} ELSE IF Doing_Scan {
		data = 2.0 * counter_timed_count( CH0, mtime ) / mtime;
		display( I, data );
		I += 1;

		IF ll - cwn > 46000.0 / 3.0 + step_size {
	        cwn = monochromator_scan_step( );
			output_value( B_cwn, Mode == 0 ? cwn : ll - cwn );

		} ELSE {
			draw_marker( I - 1 );
			object_enable( B_stop, "ON" );
			object_enable( B_stop, "OFF" );
			Doing_Scan = 0;
		}
	} ELSE IF Doing_Sampling {
		data = 2.0 * counter_timed_count( CH0, mtime ) / mtime;
		display( I, data );
		I += 1;
	} ELSE {
		wait( 0.2 s )
	}
}
EOF

	close F;
	show_message( $? ) if $? != 0;
}


##########################################################

sub exp_setup {
	my ( $swn, $ewn, $sz, $mt, $Ns ) = get_defs( );

	$swn = 0 unless defined $swn;
	$ewn = 0 unless defined $ewn;
	$sz = 0 unless defined $sz;
	$mt = 0 unless defined $mt;
	$Ns = 0 unless defined $Ns;

	my $balloon = $mw->Balloon( );

	$f1->configure( '-state' => 'disabled' );

	my $smw = $mw->Toplevel( '-title' => "SPEX measurement" );

	my $x1 = $smw->Frame( );
	my $x1_l1 = $x1->Label( '-text'           => 'Start wavenumber:',
							'-width'          => '20',
							'anchor'          => 'w' );
	my $x1_v = $x1->Entry( '-textvariable'    => \$swn,
						   '-width'           => '8',
						   '-validate'        => 'key',
						   '-validatecommand' => \&is_numeric,
						   '-relief'          => 'sunken' );
	$balloon->attach( $x1_v, '-balloonmsg' =>
					  "Enter the start of scan\n" .
					  "wavenumber (in cm^-1 rel.)" );
	my $x1_l2 = $x1->Label( '-text'           => 'cm^-1 rel.',
							'-width'          => 8 );

	$x1->pack( %fp );
	$x1_l1->pack( %wp );
	$x1_v->pack( %wp );
	$x1_l2->pack( %wp );

	my $x2 = $smw->Frame( );
	my $x2_l1 = $x2->Label( '-text'           => 'End wavenumber:',
							'-width'          => '20',
							'anchor'          => 'w' );
	my $x2_v = $x2->Entry( '-textvariable'    => \$ewn,
						   '-width'           => '8',
						   '-validate'        => 'key',
						   '-validatecommand' => \&is_numeric,
						   '-relief'          => 'sunken' );
	$balloon->attach( $x2_v, '-balloonmsg' =>
					  "Enter the end of scan\n" .
					  "wavenumber (in cm^-1 rel.)" );
	my $x2_l2 = $x2->Label( '-text'           => 'cm^-1 rel.',
							'-width'          => 8 );

	$x2->pack( %fp );
	$x2_l1->pack( %wp );
	$x2_v->pack( %wp );
	$x2_l2->pack( %wp );

	my $x3 = $smw->Frame( );
	my $x3_l1 = $x3->Label( '-text'           => 'Scan step size:',
							'-width'          => '20',
							'anchor'          => 'w' );
	my $x3_v = $x3->Entry( '-textvariable'    => \$sz,
						   '-width'           => '8',
						   '-validate'        => 'key',
						   '-validatecommand' => \&is_unsigned_numeric,
						   '-relief'          => 'sunken' );
	$balloon->attach( $x3_v, '-balloonmsg' =>
					  "Enter the scan step size (in cm^-1)" );
	my $x3_l2 = $x3->Label( '-text'           => 'cm^-1',
							'-width'          => 8 );

	$x3->pack( %fp );
	$x3_l1->pack( %wp );
	$x3_v->pack( %wp );
	$x3_l2->pack( %wp );

	my $x4 = $smw->Frame( );
	my $x4_l1 = $x4->Label( '-text'           => 'Sampling time:',
							'-width'          => '20',
							'anchor'          => 'w' );
	my $x4_v = $x4->Entry( '-textvariable'    => \$mt,
						   '-width'           => '8',
						   '-validate'        => 'key',
						   '-validatecommand' => \&is_unsigned_numeric,
						   '-relief'          => 'sunken' );
	$balloon->attach( $x4_v, '-balloonmsg' =>
					  "Enter how many seconds to sample\n" .
					  "at each spectral position" );
	my $x4_l2 = $x4->Label( '-text'           => 's',
							'-width'          => 8 );

	$x4->pack( %fp );
	$x4_l1->pack( %wp );
	$x4_v->pack( %wp );
	$x4_l2->pack( %wp );

	my $x5 = $smw->Frame( );
	my $x5_l1 = $x5->Label( '-text'           => 'Number of scans:',
							'-width'          => '20',
							'anchor'          => 'w' );
	my $x5_v = $x5->Entry( '-textvariable'    => \$Ns,
						   '-width'           => '8',
						   '-validate'        => 'key',
						   '-validatecommand' =>
						   					   sub { $_[ 0 ] =~ /^s*\d*\s*$/ },
						   '-relief'          => 'sunken' );
	$balloon->attach( $x5_v, '-balloonmsg' =>
					  "Enter the maximum number of scans" );
	my $x5_l2 = $x5->Label( '-text'           => '',
							'-width'          => 8 );

	$x5->pack( %fp );
	$x5_l1->pack( %wp );
	$x5_v->pack( %wp );
	$x5_l2->pack( %wp );

	my $x6 = $smw->Frame( )->pack( %fp );

	my $f7 = $smw->Frame( );
	my $f7_a = $smw->Button( '-text' => 'Apply',
							'-command' => sub { start_exp( $swn, $ewn, $sz,
														   $mt, $Ns ); } );
	my $f7_q = $smw->Button( '-text' => 'Quit',
							 '-command' => sub { store_defs( $swn, $ewn, $sz,
															 $mt, $Ns );
								 				 $f1->configure( '-state' =>
														 		 "normal" );
												 $smw->destroy } );
	$f7->pack( '-side' => 'top',
			   '-fill' => 'x',
			   '-padx' => '4m' );
	$f7_a->pack( %wp, 'padx' => '5m', '-pady' => '3m' );
	$f7_q->pack( %wp, 'padx' => '5m', '-pady' => '3m' );
}


#############################################

sub is_numeric {

	my $new_val = shift;
	$new_val =~ /^[+-]?((\d+\.?(\d+)?)|(\.(\d+)?))?$/;
}


#############################################

sub is_unsigned_numeric {

	my $new_val = shift;
	$new_val =~ /^((\d+\.?(\d+)?)|(\.(\d+)?))?$/;
}


#############################################

sub get_defs {

	local *F;
	my ( $ne, $swn, $ewn, $sz, $mt, $Ns );

	if ( $ARGV[ 0 ] ) {
		open( F, "<$ARGV[ 0 ]" ) or return;
	} else {
		open( F, "<$ENV{ HOME }/.fsc2/spex" ) or return;
	}

	goto done_reading unless defined( $ne = <F> ) and $ne =~ /^#/;

	goto done_reading unless defined( $ne = <F> ) and is_numeric( $ne );
	chomp $ne;
	$swn = $ne;

	goto done_reading unless defined( $ne = <F> ) and is_numeric( $ne );
	chomp $ne;
	$ewn = $ne;

	goto done_reading unless defined( $ne = <F> )
		 and is_unsigned_numeric( $ne );
	chomp $ne;
	$sz = $ne;

	goto done_reading unless defined( $ne = <F> )
		 and is_unsigned_numeric( $ne );
	chomp $ne;
	$mt = $ne;

	goto done_reading unless defined( $ne = <F> ) and $ne =~ /^s*\d*\s*$/;
	chomp $ne;
	$Ns = $ne;

  done_reading:
	close F;

	return ( $swn, $ewn, $sz, $mt, $Ns );
}


#############################################

sub store_defs {
	local *F;

	my ( $swn, $ewn, $sz, $mt, $Ns ) = @_;

	mkdir "$ENV{ HOME }/.fsc2", 0777 unless -e "$ENV{ HOME }/.fsc2";
	open( F, ">$ENV{ HOME }/.fsc2/spex" ) or return;

	$swn = 0 if $swn eq ".";
	$ewn = 0 if $ewn eq ".";
	$sz = 0 if $sz eq ".";
	$mt = 0 if $mt eq ".";

	print F "# Do not edit - created automatically!\n";
	print F "$swn\n$ewn\n$sz\n$mt\n$Ns\n";

	close F;
}


#############################################

sub do_checks {
	my ( $swn, $ewn, $sz, $mt, $Ns ) = @_;

	if ( ! defined $swn ) {
		$mw->messageBox( '-icon' => 'error',
						 '-type' => 'Ok',
						 '-title' => 'Error',
						 '-message' => "Start of scan is missing" );
		return 1;
	}

	if ( ! defined $ewn ) {
		$mw->messageBox( '-icon' => 'error',
						 '-type' => 'Ok',
						 '-title' => 'Error',
						 '-message' => "End of scan is missing" );
		return 1;
	}

	if ( ! defined $sz ) {
		$mw->messageBox( '-icon' => 'error',
						 '-type' => 'Ok',
						 '-title' => 'Error',
						 '-message' => "Scan step size is missing" );
		return 1;
	}

	if ( ! defined $mt ) {
		$mw->messageBox( '-icon' => 'error',
						 '-type' => 'Ok',
						 '-title' => 'Error',
						 '-message' => "Sampling time is missing" );
		return 1;
	}

	if ( ! defined $Ns ) {
		$mw->messageBox( '-icon' => 'error',
						 '-type' => 'Ok',
						 '-title' => 'Error',
						 '-message' => "Number of scan is missing" );
		return 1;
	}

	if ( $ewn <= $swn ) {
		$mw->messageBox( '-icon' => 'error',
						 '-type' => 'Ok',
						 '-title' => 'Error',
						 '-message' => "Start of scan not below end of scan" );
		return 1;
	}

	if ( $swn <= 0 && $ewn >= 0 and
		 $mw->Dialog( '-text' => "The scan range includes the\n" .
					  "the laser line. Do you really\n" .
					  "want to continue?\n",
					  '-buttons' => [ "Yes", "No" ],
		 			  '-default_button' => "No" )->Show( ) eq "No" ) {
		return 1;
	}

	if ( $ewn - $swn < $sz ) {
		$mw->messageBox( '-icon' => 'error',
						 '-type' => 'Ok',
						 '-title' => 'Error',
						 '-message' =>
						 "Scan width not larger than scan step size" );
		return 1;
	}

	if ( $mt == 0.0 ) {
		$mw->messageBox( '-icon' => 'error',
						 '-type' => 'Ok',
						 '-title' => 'Error',
						 '-message' => "Zero sampling time" );
		return 1;
	}

	if ( $Ns == 0 ) {
		$mw->messageBox( '-icon' => 'error',
						 '-type' => 'Ok',
						 '-title' => 'Error',
						 '-message' => "Zero number of scans" );
		return 1;
	}

}


##########################################################

sub start_exp {

	return if do_checks( @_ ) > 0;

	my ( $swn, $ewn, $sz, $mt, $Ns ) = @_;

	local *F;

	open( F, "|fsc2_start" )
		or die "Can't find utility fsc2_start" . ".\n";

	print F <<EOF;
DEVICES:

ni6601;
spex_cd2a;


VARIABLES:

start_wn  =  $swn cm^-1;
end_wn    =  $ewn cm^-1;
step_size =  $sz cm^-1;
mtime     =  $mt s;
N_scans   =  $Ns;

N_points = int( ceil( ( end_wn - start_wn ) / step_size ) );
data[ N_points ];
mean_data[ N_points ];
new_mean;
cwn = start_wn;
laser_line;

I, J;
F_all, F_cur;

Display_Mode = 0;                // 0: relative, 1: absolute
Scan_is_done = 0;

B_stop, B_rel, B_abs, B_cr, B_cwn;


PREPARATIONS:

init_1d( 2, N_points, start_wn, step_size,
		 "Wavenumber [cm^-1 rel.]", "Counts per second" );


EXPERIMENT:

monochromator_scan_setup( start_wn, step_size );
laser_line = monochromator_laser_line( );

hide_toolbox( "ON" );
B_rel  = button_create( "RADIO_BUTTON", "Relative units" );
B_abs  = button_create( "RADIO_BUTTON", B_rel, "Absolute units" );
button_state( B_rel, "ON" );
B_cr   = output_create( "INT_OUTPUT", 1,
						 sprint( "Current scan (of #)", N_scans ) );
B_cwn  = output_create( "FLOAT_OUTPUT", cwn,
						"Current position [cm^-1 rel.]", "", "%.4f" );
B_stop = button_create( "PUSH_BUTTON", "Stop on end of scan" );
hide_toolbox( "OFF" );

F_all = get_file( "", "*.dat", "", "", "dat" );

FOR I = 1 : N_scans {

	Scan_is_done = 0;

	F_cur = clone_file( F_all, "dat", sprint( "scan_#.dat", I ) );
	output_value( B_cr, I );
	output_value( B_cwn, start_wn );
	monochromator_start_scan( );

	FOR J = 1 : N_points {

		IF button_state( B_abs ) & Display_Mode == 0 {
			change_scale( laser_line - start_wn, -step_size );
			change_label( "Wavenumber [cm^-1 abs.]" );
			object_change_label( B_cwn, "Current position [cm^-1 abs.]" );
			output_value( B_cwn, laser_line - cwn );
			Display_Mode = 1;
		}

		IF button_state( B_rel ) & Display_Mode == 1 {
			change_scale( start_wn, step_size );
			change_label( "Wavenumber [cm^-1 rel.]" );
			object_change_label( B_cwn, "Current position [cm^-1 rel.]" );
			output_value( B_cwn, cwn );
			Display_Mode = 0;
		}

		data[ J ] = 2.0 * counter_timed_count( CH0, mtime ) / mtime;
		new_mean = ( ( I - 1 ) * mean_data[ J ] + data[ J ] ) / I;
		display( J, new_mean, 2, J, data[ J ], 1 );

		save( F_cur, data[ J ] );

		IF J < N_points {
			cwn = monochromator_scan_step( );
			output_value( B_cwn,
				 Display_Mode == 0 ? cwn : laser_line - cwn );
		}
	}

	mean_data = ( ( I - 1 ) * mean_data + data ) / I;
	Scan_is_done = 1;

	IF button_state( B_stop ) {
		BREAK;
	}

	clear_curve( 1 );
}

ON_STOP:

IF Scan_is_done == 0 {
	I -= 1;
}

IF I > 0 {
	save( F_all, mean_data );
}
EOF

	close F;
	show_message( $? ) if $? != 0;
}



##########################################################

sub show_message {
	my $ret = shift;
	my $text;

	if ( $ret >> 8 == 255 ) {
		$text = "Internal error.";
	} elsif ( $ret >> 8 == 1 ) {
		$text = "Someone else is running fsc2.";
	} elsif ( $ret >> 8 == 2 ) {
		$text = "fsc2 is currently busy.";
	} elsif ( $ret >> 8 == 3 ) {
		$text = "Internal error of fsc2.";
	} elsif ( $ret >> 8 == 4 ) {
		$text = "Could not start fsc2.";
	} else {
		$text = "Something strange is going on here.";
	}

	$mw->messageBox( '-icon' => 'error',
					 '-type' => 'Ok',
					 '-title' => 'Error',
					 '-message' => $text );
}
