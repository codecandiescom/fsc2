#!/usr/bin/perl -w

# $Id$


use Tk::Balloon;
use strict;
use Tk;

my $lockin		       = 'SR810';
my $start_field        = 3350;
my $end_field	       = 3500;
my $field_step	       = 1;
my $sweep_method       = "simple";
my $field_error        = "";
my $hidden_field_error = "";
my $num_runs	       = 1;
my $tc_fact  	       = 1;
my $tc			       = "Don't set";
my $sens		       = "Don't set";
my $how			       = 'Start experiment';
my $bridge		       = 'cw';


my %fp = ( '-side' => 'top',
		   '-fill' => 'x',
		   '-padx' => '2m',
		   '-pady' => '2m' );

my %wp = ( '-side' => 'left',
		   '-fill' => 'x',
		   '-padx' => '3m',
		   '-expand' => 1 );

# Get defaults

&get_defs;

# Create all the graphic stuff

my $mw = MainWindow->new( );
$mw->title( "cw_epr" );
my $ballon = $mw->Balloon( );

my $f0 = $mw->Frame( );
my $f0_l1 = $f0->Label( '-text' => 'Bridge:',
						'-width' => '20',
						'anchor' => 'w' );
my $f0_m = $f0->Optionmenu( '-options' => [ ( 'cw', 'pulsed' ) ],
							'-width' => 9,
							'-variable' => \$bridge );
$ballon->attach( $f0_m,
				 '-balloonmsg' => "Selects either cw bridge or\n" .
                                  "bridge for pulsed experiments" );
$f0->pack( %fp );
$f0_l1->pack( %wp );
$f0_m->pack( %wp );


my $f1 = $mw->Frame( );
my $f1_l1 = $f1->Label( '-text' => 'Start field:',
						'-width' => '20',
						'anchor' => 'w' );
my $f1_v = $f1->Entry( '-textvariable' => \$start_field,
					   '-width' => '8',
					   '-validate' => 'key',
					   '-validatecommand' => \&is_numeric,
					   '-relief' => 'sunken' );
$ballon->attach( $f1_v,
				 '-balloonmsg' => "Enter the start field (in Gauss)" );
my $f1_l2 = $f1->Label( '-text' => 'G',
						'-width' => 1 );

$f1->pack( %fp );
$f1_l1->pack( %wp );
$f1_v->pack( %wp );
$f1_l2->pack( %wp );


my $f2 = $mw->Frame( );
my $f2_l1 = $f2->Label( '-text' => 'End field:',
						'-width' => '20',
						'anchor' => 'w' );
my $f2_v = $f2->Entry( '-textvariable' => \$end_field,
					   '-width' => '8',
					   '-validate' => 'key',
					   '-validatecommand' => \&is_numeric,
					   '-relief' => 'sunken' );
$ballon->attach( $f2_v,
				 '-balloonmsg' => "Enter the end field (in Gauss)" );
my $f2_l2 = $f2->Label( '-text' => 'G',
						'-width' => 1 );

$f2->pack( %fp );
$f2_l1->pack( %wp );
$f2_v->pack( %wp );
$f2_l2->pack( %wp );


my $f3 = $mw->Frame( );
my $f3_l1 = $f3->Label( '-text' => 'Field step size:',
						'-width' => '20',
						'anchor' => 'w' );
my $f3_v = $f3->Entry( '-textvariable' => \$field_step,
					   '-width' => '8',
					   '-validate' => 'key',
					   '-validatecommand' => \&is_numeric,
					   '-relief' => 'sunken' );
$ballon->attach( $f3_v,
				 '-balloonmsg' => "Enter the size of the " .
				                  "field steps (in Gauss)" );
my $f3_l2 = $f3->Label( '-text' => 'G',
						'-width' => 1 );

$f3->pack( %fp );
$f3_l1->pack( %wp );
$f3_v->pack( %wp );
$f3_l2->pack( %wp );


my $f5 = $mw->Frame( );
my $f5_l1 = $f5->Label( '-text' => 'Maximum field error:',
						'-width' => '20',
						'anchor' => 'w' );
my $f5_v = $f5->Entry( '-textvariable' => \$field_error,
					   '-width' => '8',
					   '-validate' => 'key',
					   '-validatecommand' => \&is_numeric,
					   '-relief' => 'sunken',
					   'state' => $sweep_method eq 'simple' ?
					   'disabled' : 'normal' );
$ballon->attach( $f5_v,
				 '-balloonmsg' => "Sets maximum acceptable field\n" .
				                  "deviation in tested sweep\n" .
			                      "(in Gauss, not larger than\n" .
				                  "10% of field step size)" );
my $f5_l2 = $f5->Label( '-text' => 'G',
						'-width' => 1 );


my $f4 = $mw->Frame( );
my $f4_l = $f4->Label( '-text' => 'Sweep method:',
						'-width' => '20',
						'anchor' => 'w' );
my $f4_m = $f4->Optionmenu( '-options' =>
							[ ( 'simple', 'tested' ) ],
							'-width' => 9,
							'-variable' => \$sweep_method,
						    '-command' => \&set_sweep_method );
$ballon->attach( $f4_m,
				 '-balloonmsg' => "Selects either a simple sweep\n" .
				                  "(no intermediate checks of field)\n" .
				                  "or a controlled sweep (slower)" );

$f4->pack( %fp );
$f4_l->pack( %wp );
$f4_m->pack( %wp );


$f5->pack( %fp );
$f5_l1->pack( %wp );
$f5_v->pack( %wp );
$f5_l2->pack( %wp );



my $f6 = $mw->Frame( );
my $f6_l1 = $f6->Label( '-text' => 'Number of runs:',
						'-width' => '20',
						'anchor' => 'w' );
my $f6_v = $f6->Entry( '-textvariable' => \$num_runs,
					   '-width' => '8',
					   '-validate' => 'key',
					   '-validatecommand' => sub { $_[ 0 ] =~ /^\s*\d*\s*$/ },
					   '-relief' => 'sunken' );
my $f6_l2 = $f6->Label( '-text' => ' ',
						'-width' => 1 );

$f6->pack( %fp );
$f6_l1->pack( %wp );
$f6_v->pack( %wp );
$f6_l2->pack( %wp );


my $f7 = $mw->Frame( '-width' => '29' );
my $f7_l1 = $f7->Label( '-text' => 'Waiting time:',
						'-width' => '20',
						'anchor' => 'w' );
my $f7_v = $f7->Entry( '-textvariable' => \$tc_fact,
					   '-width' => '7',
					   '-validate' => 'key',
					   '-validatecommand' => \&is_numeric,
					   '-relief' => 'sunken' );
my $f7_l2 = $f7->Label( '-text' => '* tc',
						'-width' => 2 );

$f7->pack( %fp );
$f7_l1->pack( %wp );
$f7_v->pack( %wp );
$f7_l2->pack( %wp );


my $f8 = $mw->Frame( );
my $f8_l = $f8->Label( '-text' => 'Lock-in amplifier:',
						'-width' => '20',
						'anchor' => 'w' );
my $f8_m = $f8->Optionmenu( '-options' =>
							[ ( 'SR510', 'SR530', 'SR810', 'SR830' ) ],
							'-width' => 9,
							'-variable' => \$lockin );
$f8->pack( %fp );
$f8_l->pack( %wp );
$f8_m->pack( %wp );



my $f9 = $mw->Frame( );
my $f9_l = $f9->Label( '-text' => 'Time constant (tc):',
					   '-width' => '20',
					   'anchor' => 'w' );
my $f9_m = $f9->Optionmenu( '-options' =>
                            [ ( "Don't set", '100 s', ' 30 s', ' 10 s',
                                '  3 s', '  1 s', '300 ms', '100 ms', ' 30 ms',
                                ' 10 ms', '  3 ms', '  1 ms' ) ],
							'-width' => 9,
							'-variable' => \$tc );
$f9->pack( %fp );
$f9_l->pack( %wp );
$f9_m->pack( %wp );


my $f10 = $mw->Frame( );
my $f10_l = $f10->Label( '-text' => 'Sensitivity:',
						 '-width' => '20',
						 'anchor' => 'w' );
my $f10_m = $f10->Optionmenu( '-options' =>
							  [ ( "Don't set", '500 mV', '200 mV', '100 mV',
								  ' 50 mV', ' 20 mV', ' 10 mV', '  5 mv',
								  '  2 mV', '  1 mV', '500 uV', '200 uV',
								  '100 uV', ' 50 uV', ' 20 uV', ' 10 uV',
								  '  5 uV', '  2 uV', '  1 uV',
								  '500 nV', '200 nV', '100 nV', ' 50 nV',
								  ' 10 nV', '  5 nV', '  2 nV', '  1 nV' ) ],
							  '-width' => 9,
							  '-variable' => \$sens );
$f10->pack( %fp );
$f10_l->pack( %wp );
$f10_m->pack( %wp );


$mw->Optionmenu( '-options' => [ ( 'Start experiment', 'Test program',
								   'Load into fsc2' ) ],
				 '-variable' => \$how,
				 '-command' => \&write_out
			   )->pack( '-padx' => '3m',
						'-pady' => '3m' );



$mw->Button( '-text' => 'Quit',
			 '-command' => sub { &store_defs; $mw->destroy }
		   )->pack( '-padx' => '3m',
					'-pady' => '3m' );

MainLoop;


#############################################

sub set_sweep_method {
	if ( $sweep_method eq 'simple' ) {
		$f5_v->configure( 'state' => 'disabled' );
		$hidden_field_error = $field_error;
		$field_error = "";
	} else {
		$f5_v->configure( 'state' => 'normal' );
		$field_error = $hidden_field_error;
	}
}


#############################################

sub get_defs {

local *F;
my $ne;

if ( $ARGV[ 0 ] ) {
	open( F, "<$ARGV[ 0 ]" ) or return;
} else {
	open( F, "<$ENV{ HOME }/.fsc2/cw_epr" ) or return;
}

goto done_reading unless defined( $ne = <F> ) and $ne =~ /^#/;

goto done_reading unless defined( $ne = <F> ) and $ne =~ /^(cw)|(pulsed)$/;
chomp $ne;
$bridge = $ne;

goto done_reading unless defined( $ne = <F> ) and is_numeric( $ne );
chomp $ne;
$start_field = $ne;

goto done_reading unless defined( $ne = <F> ) and is_numeric( $ne );
chomp $ne;
$end_field = $ne;

goto done_reading unless defined( $ne = <F> ) and is_numeric( $ne );
chomp $ne;
$field_step = $ne;

goto done_reading unless defined( $ne = <F> )
	and $ne =~ /^(simple)|(tested)$/;
chomp $ne;
$sweep_method = $ne;

goto done_reading unless defined( $ne = <F> ) and is_numeric( $ne );
chomp $ne;
$hidden_field_error = $ne;
$field_error = $ne if $sweep_method =~ /tested/;

goto done_reading unless defined( $ne = <F> ) and $ne =~ /^\d+$/;
chomp $ne;
$num_runs = $ne;

goto done_reading unless defined( $ne = <F> )
	and $ne =~ /^SR(5|8)(1|3)0$/;
chomp $ne;
$lockin = $ne;

goto done_reading unless defined( $ne = <F> )
	and $ne =~ /(^Don't set)|([13]0{0,2} m?s)$/;
chomp $ne;
$tc = $ne;

goto done_reading unless defined( $ne = <F> )
	and $ne =~ /(^Don't set)|([125]0{0,2} [mun]V)$/;
chomp $ne;
$sens = $ne;

done_reading:
close F;
}


#############################################

sub store_defs {
	local *F;

	mkdir "$ENV{ HOME }/.fsc2", 0777 unless -e "$ENV{ HOME }/.fsc2";
	open( F, ">$ENV{ HOME }/.fsc2/cw_epr" ) or return;

	$start_field = 0 if $start_field eq ".";
	$end_field = 0 if $end_field eq ".";
	$field_step = 0 if $field_step eq ".";
	$hidden_field_error = 0 if $hidden_field_error eq ".";

	print F "# Do not edit - created automatically!\n";

	print F "$bridge\n$start_field\n$end_field\n$field_step\n$sweep_method\n" .
	        "$hidden_field_error\n$num_runs\n$lockin\n$tc\n$sens\n";

	close F;
}


#############################################

sub is_numeric {

	my $new_val = shift;
	$new_val =~ /^((\d+\.?(\d+)?)|(\.(\d+)?))?$/;
}


#############################################

sub write_out {

return if &do_checks( ) != 0;

local *F;
my $text;

open( F, "|fsc2_" . lc $how ) or die "Can't find utility.\n";

print F
"DEVICES:\n\n";
print F "dg2020_b;\n" if $bridge =~ /pulsed/;
print F lc( $lockin ), ";\n";
print F "er035m_s;
aeg_x_band;\n\n\n";

print F
"VARIABLES:\n\nI";
print F ", J" if $num_runs != 1;
print F ";
start_field = $start_field G;
end_field = $end_field G;
field_step = ";
print F $end_field > $start_field ? $field_step : - $field_step;
print F " G;\n";
print F "act_field;\nfield_error = $field_error G;\n"
	if $sweep_method eq 'tested';
print F
"N_points = ceil( abs( end_field - start_field ) / abs( field_step ) ) + 1;
data[ N_points ];
N_runs = $num_runs;\n";

if ( $num_runs != 1 ) {
	print F "new_data[ N_points ];\n";
}

if ( $tc eq "Don't set" ) {
	print F "tc;\n";
} else {
	print F "tc = $tc;\n";
}

print F
"\n\nASSIGNMENTS:\n
TIMEBASE:	  5 ns;
MICROWAVE:	  POD = 1, 2, 3, 4, 5, V_HIGH = 5 V, V_LOW = 0 V, INVERTED;
PHASE_SETUP:  MICROWAVE, CW: 5;\n" if $bridge =~ /pulsed/;


print F "\n\nPREPARATIONS:\n\n";
print F "pulser_cw_mode( );\n" if $bridge =~ /pulsed/;
print F "magnet_setup( start_field, field_step );\n"
	if $sweep_method eq 'simple';
print F "lockin_time_constant( tc );\n" if $tc ne "Don't set";
print F "lockin_sensitivity( $sens );\n" if $sens ne "Don't set";
print F "init_1d( ";
print F $num_runs == 1 ? "1" : "3";
print F ", N_points, start_field, field_step, \"Magnetic field / G\",
		 \"Signal / V\" );\n\n\n";

print F
"EXPERIMENT:\n
fsave( \"% Field:\\n\"
	   \"%	 Start field:     # G\\n\"
	   \"%	 End field:       # G\\n\"
	   \"%	 Field step size: # G\\n\"
	   \"% Lock-In:\\n\"
	   \"%	 Sensitivity:     # V\\n\"
	   \"%	 Time constant:   # s\\n\"
	   \"%	 Phase:			  # degree\\n\"
	   \"% Number of runs:	  #\\n\",
	   start_field, start_field + ( N_points - 1 ) * field_step, field_step,
	   lockin_sensitivity( ), lockin_time_constant( ), lockin_phase( ),
	   N_runs );
save_comment( \"% \" );
save_program( \"% \", \"Sample:  \\nMicrowave frequency:  \\n\"
              \"Microwave power:  \\nTemperature:  \\n\" );\n\n";

print F "act_field = set_field( start_field );\n"
	if $sweep_method eq 'tested';
print F "tc = lockin_time_constant( );\n\n" if $tc eq "Don't set";
if ( $num_runs != 1 ) {
	print F
"FOR J = 1 : N_runs \{

	print( \"Starting #. run out of #\\n\", J, N_runs );

	FOR I = 1 : N_points \{

		new_data[ I ] = lockin_get_data( );\n\n\t\t";

if ( $sweep_method eq 'simple' ) {
	print F "fsave( \"# #\\n\", start_field + ( I - 1 ) * field_step, " .
		    "new_data[ I ] );";
} else {
	print F "fsave( \"# #\\n\", act_field, new_data[ I ] );";
}
print F "
		display( I, ( data[ I ] + new_data[ I ] ) / float( J ), 1,
		         I, new_data[ I ], 3 );

		IF ( I < N_points ) \{\n\t\t\t";
if ( $sweep_method eq 'simple' ) {
	print F "sweep_up( );";
} else {
	print F "act_field = set_field( start_field + I * field_step, " .
		"field_error );";
}
print F "
			wait( ";
print F "$tc_fact * " if $tc_fact != 1;
print F "tc );
		\}
	\}

	data += new_data;
	clear_curve( 1, 3 );
	display( 1, data / float( J ), 2 );

	fsave( \"\\n\" );
	IF ( J < N_runs ) \{\n\t\t";
if ( $sweep_method eq 'simple' ) {
	print F	"reset_field( );";
} else {
	print F "act_field = set_field( start_field );";
}
print F "
		wait( ";
print F "$tc_fact * " if $tc_fact != 1;
print F "tc );
	\}
\}


ON_STOP:

fsave( \"\\n\" );
FOR I = 1 : N_points \{
	fsave( \"# #\\n\", start_field + ( I - 1 ) * field_step, data[ I ] );
\}
";
} else {
	print F
"FOR I = 1 : N_points \{
	data[ I ] = lockin_get_data( );\n\t";
if ( $sweep_method eq 'simple' ) {
	print F "fsave( \"# #\\n\", " .
		"start_field + ( I - 1 ) * field_step, data[ I ] );";
} else {
	print F "fsave( \"# #\\n\", act_field, data[ I ] );";
}
print F "
	display( I, data[ I ] );
	IF ( I < N_points ) \{\n\t\t";
if ( $sweep_method eq 'simple' ) {
	print F "sweep_up( );";
} else {
	print F "act_field = set_field( start_field + I * field_step, field_error );";
}
print F "
		wait( ";
print F "$tc_fact * " if $tc_fact != 1;
print F "tc );
	\}
\}";
}

close F;

# Notify the user if sending the program to fsc2 failed for some reasons

if ( $? != 0 ) {
    if ( $? >> 8 == -1 ) {
        $text = "Internal error.";
    } elsif ( $? >> 8 == 1 ) {
        $text = "Someone else is running fsc2.";
    } elsif ( $? >> 8 == 2 ) {
        $text = "fsc2 is currently busy.";
    } elsif ( $? >> 8 == 3 ) {
        $text = "Internal error of fsc2.";
    } elsif ( $? >> 8 == 4 ) {
        $text = "Could not start fsc2.";
    } else {
        $text = "Something strange is going on here.";
    }

    &show_message( $text ) if $? >> 8 != 0;
}
}


#############################################

sub do_checks {

	if ( $start_field =~ /^\.?$/ ) {
		&show_message( "Start field hasn't been set." );
		return -1;
	}

	if ( $start_field < 1460 ) {
		&show_message( "Start field is too low." );
		return -1;
	}

	if ( $start_field > 19900 ) {
		&show_message( "Start field is too high." );
	}

	if ( $end_field =~ /^\.?$/ ) {
		&show_message( "End field hasn't been set." );
		return -1;
	}

	if ( $end_field < 1460 ) {
		&show_message( "End field is too low." );
		return -1;
	}

	if ( $end_field > 19900 ) {
		&show_message( "End field is too high." );
		return -1;
	}

	if ( $field_step =~ /^\.?$/ ) {
		&show_message( "Field step size hasn't been set." );
		return -1;
	}

	$field_error = 0
		if $sweep_method eq 'tested' and $field_error =~ /^\.?$/;

	if ( $sweep_method eq 'tested' and $field_error > 0.1 * $field_step ) {
		&show_message( "Field error larger than\n10% of field step size." );
		return -1;
	}

	if ( abs( $field_step ) > abs( $end_field - $start_field ) ) {
		&show_message( "Field step size larger than\n" .
					   "difference between start and\n" .
					   "end field." );
		return -1;
	}

	if ( $num_runs =~ /^$/ ) {
		&show_message( "Number of runs hasn't been\n" .
					   "set, defaulting to 1." );
		$num_runs = 1;
	}

	if ( $num_runs < 1 ) {
		&show_message( "Invalid number of runs." );
		return -1;
	}

	return 0;
}


#############################################

sub show_message {
	my $text = shift;

	$mw->messageBox( '-icon' => 'error',
					 '-type' => 'Ok',
					 '-title' => 'Error',
					 '-message' => $text );
}
