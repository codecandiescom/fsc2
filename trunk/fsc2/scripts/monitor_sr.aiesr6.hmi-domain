#!/usr/bin/perl
# -*- cperl -*-
# Generated by fsc2_guify from monitor_sr.EDL on Di 10. MÃ¤r 15:01:00 CET 2009

use strict;
use warnings;
use utf8;
use Tk;
use Tk::Balloon;

my @version = split /\./, $Tk::VERSION;
die "Installed Perl-Tk version is $Tk::VERSION but Tk800.022 is required.\n"
    if $version[ 0 ] + 0.001 * $version[ 1 ] < 800.022;

my %fp = ( -side => 'top',
           -fill => 'x',
           -padx => 10,
           -pady => 5 );
my %wp = ( -side   => 'left',
           -fill   => 'x',
           -expand => 1 );
my %up = ( -side => 'left' );
my $geom;

my @VARS;
my $fsc2_how_to_run = 'Test program';
my @fsc2_how_to_run = ( 'Start experiment',
                        'Test program',
                        'Load into fsc2' );
my $fsc2_main_window = MainWindow->new( -title =>
                               ( split /\./, ( split /\//, $0 )[ -1 ] )[ 0 ] );
my $fsc2_main_frame = $fsc2_main_window->Frame( -relief      => 'ridge',
                                                -borderwidth => 5 );
my $fsc2_balloon = $fsc2_main_frame->Balloon( );
my $fsc2_apply_frame = $fsc2_main_window->Frame( );
my $fsc2_apply_button = $fsc2_apply_frame->Button( -text    => 'Apply',
                                                   -command => \&write_out );
$fsc2_apply_button->bind( 'all', '<Alt-a>' => \&write_out );
my $fsc2_quit_button = $fsc2_apply_frame->Button( -text => 'Quit',
                 -command => sub { $fsc2_main_window->geometry =~
                                                   /^\d+x\d+([+-]\d+[+-]\d+)$/;
                                   $geom = $1;
                                   &store_defs;
                                   $fsc2_main_window->destroy } );
$fsc2_quit_button->bind( 'all',
                         '<Alt-q>' =>
                                sub { $fsc2_main_window->geometry =~
                                                   /^\d+x\d+([+-]\d+[+-]\d+)$/;
                                      $geom = $1;
                                      &store_defs;
                                      $fsc2_main_window->destroy } );
$fsc2_apply_frame->pack( -side => 'bottom',
                         -fill => 'x',
                         -padx => 20 );

# === RESONATOR menu [ "Unspecified", "XXX", "YYY", "ZZZ" ] [ 1 ] "Resonator"

my %RESONATOR;
push @VARS, \%RESONATOR;
$RESONATOR{ is_valid } = 1;
$RESONATOR{ type } = 'menu';
$RESONATOR{ tk_frame } = $fsc2_main_frame->Frame( );
$RESONATOR{ tk_label } = $RESONATOR{ tk_frame }->Label( -text => "Resonator",
-width => 20,
-anchor => 'w' );
$RESONATOR{ value } = "Unspecified";
my @RESONATOR = ( "Unspecified", "XXX", "YYY", "ZZZ" );
$RESONATOR{ tk_entry } = $RESONATOR{ tk_frame }->Optionmenu( -options     => \@RESONATOR,
-width        => 10,
-textvariable => \$RESONATOR{ value } );
$RESONATOR{ tk_unit } = $RESONATOR{ tk_frame }->Label( -text => "",
-width => 5 );
$RESONATOR{ tk_frame }->pack( %fp );
$RESONATOR{ tk_label }->pack( %wp );
$RESONATOR{ tk_entry }->pack( %wp );
$RESONATOR{ tk_unit  }->pack( %up );

$fsc2_main_frame->pack( %fp, -pady => '5' );
$fsc2_main_window->Optionmenu( -options      => \@fsc2_how_to_run,
                                -textvariable => \$fsc2_how_to_run,
                              )->pack( -padx => 15,
                                       -pady => 5 );

$fsc2_apply_button->pack( %wp, -padx => 25, -pady => 5 );
$fsc2_quit_button->pack(  %wp, -padx => 25, -pady => 5 );

load_defs( );
$fsc2_main_window->geometry( $geom ) if defined $geom;
MainLoop;


################################################################

sub int_check {
    my ( $new, $is_valid, $min, $max ) = @_;

    $$is_valid = 0;

    return 0 if $new =~ /^\+?(\d+)?$/ and defined $max and $max < 0;
    return 0 if $new =~ /^-/ and defined $min and $min >= 0;
    if ( $new =~ /^[+-]?$/ ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
         return 1;
     }

    return 0 unless $new =~ /^[+-]?\d+?$/;

    if ( ( defined $min and $new < $min )
         or ( defined $max and $new > $max ) ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
     } else {
         $$is_valid = 1;
         check_all_vars( );
     }
     return 1;
}


################################################################

sub int_empty_check {
    my ( $new, $is_valid, $min, $max ) = @_;

    $$is_valid = 0;

    if ( $new =~ /^$/ ) {
        $$is_valid = 1;
        check_all_vars( );
        return 1;
    }

    return 0 if $new =~ /^\+?(\d+)?$/ and defined $max and $max < 0;
    return 0 if $new =~ /^-/ and defined $min and $min >= 0;
    if ( $new =~ /^[+-]?$/ ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
         return 1;
     }

    return 0 unless $new =~ /^[+-]?\d+?$/;

    if ( ( defined $min and $new < $min )
         or ( defined $max and $new > $max ) ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
     } else {
         $$is_valid = 1;
         check_all_vars( );
     }

     return 1;
}


################################################################

sub float_check {
    my ( $new, $is_valid, $min, $max ) = @_;
    my $float_rep = '[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?';

    $$is_valid = 0;

    return 0 if $new =~ /^\+/ and defined $max and $max < 0;
    return 0 if $new =~ /^-/ and defined $min and $min > 0;

    if ( $new =~ /^$float_rep$/ ) {
        if ( ( defined $max and $max < $new ) or
             ( defined $min and $min > $new ) ) {
            $fsc2_apply_button->configure( -state => 'disabled' );
        } else {
            $$is_valid = 1;
            check_all_vars( );
        }
        return 1;
    }

    if ( $new =~ /^[+-]?(\d+)?\.?(\d+)?([Ee][+-]?(\d+)?)?$/ ) {
        $$is_valid = 0;
        check_all_vars( );
        return 1;
     }

     return 0;
}


################################################################

sub float_empty_check {
    my ( $new, $is_valid, $min, $max ) = @_;
    my $float_rep = '[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?';

    $$is_valid = 0;

    if ( $new =~ /^$/ ) {
        $$is_valid = 1;
        check_all_vars( );
        return 1;
    }

    return 0 if $new =~ /^\+/ and defined $max and $max < 0;
    return 0 if $new =~ /^-/ and defined $min and $min > 0;

    if ( $new =~ /^$float_rep$/ ) {
        if ( ( defined $max and $max < $new ) or
             ( defined $min and $min > $new ) ) {
            $fsc2_apply_button->configure( -state => 'disabled' );
        } else {
            $$is_valid = 1;
            check_all_vars( );
        }
        return 1;
    }

    if ( $new =~ /^[+-]?(\d+)?\.?(\d+)?([Ee][+-]?(\d+)?)?$/ ) {
        $$is_valid = 0;
        check_all_vars( );
        return 1;
    }

    return 0;
}


################################################################

sub check_all_vars {
    for ( @VARS ) {
        if ( ! $_->{ is_valid } ) {
            $fsc2_apply_button->configure( -state => 'disabled' );
            return;
        }
    }

    $fsc2_apply_button->configure( -state => 'normal' );
}


################################################################

sub write_out {
    for ( @VARS ) {
        $_->{ value } = undef
            if $_->{ type } =~ /^(int|float)_empty/ and $_->{ value } eq '';
    }

    open my $fh, '|-:utf8', 'fsc2_' . lc $fsc2_how_to_run
        or die "Can't find utility fsc2_" . lc $fsc2_how_to_run . ".\n";

    my $RESONATOR = $RESONATOR{ value };

    print $fh "DEVICES:

er032m;
sr830;
";
# === if RESONATOR ne "Unspecified"
    if ( eval { $RESONATOR ne "Unspecified" } ) {
        print $fh "epr_mod;
";
# === endif
    }

    print $fh "

VARIABLES:

current_field;
max_field = 23000 G;
min_field = -50 G;
field_step = 0.25 G;
min_field_step = 1 mG;
max_field_step = 1600 G;
Sweep_State = 0;

";
# === if RESONATOR ne 'Unspecified'
    if ( eval { $RESONATOR ne 'Unspecified' } ) {
        print $fh "Can_extrapolate = 0;
Can_interpolate = 0;

raw_ampl, new_raw_ampl, mod_ampl;
min_ampl = 0.004 V;
max_ampl = 5.0 V;

mod_freq, new_mod_freq;
min_freq = 1 mHz,
max_freq = 102 kHz;
freqs[ * ];
MF, MA;
C;
";
# === endif
    }

    print $fh "
Acq_State = 0, STOPPED = 0; UP = 1; DOWN = -1;

I;
data[ 2 ];
dval;

Current_Field, New_Field, Set_Field, Field_Step, Sweep_Up,
Sweep_Stop, Sweep_Down, Pause, Clear;


PREPARATIONS:

init_1d( 2, 64, \"Points\", \"Signal [uV]\" );


EXPERIMENT:

current_field = magnet_field( );

/* Create the toolbox with the buttons for sweeping etc. */

hide_toolbox( \"ON\" );
Current_Field = output_create( \"FLOAT_OUTPUT\", current_field,
                               \"Current field [G]\" );
New_Field  = input_create( \"FLOAT_INPUT\", current_field, \"New field [G]\" );
Set_Field  = button_create( \"NORMAL_BUTTON\", \"Set new field\" );
Field_Step = input_create( \"FLOAT_INPUT\", field_step, \"Field step size [G]\" );
Sweep_Up   = button_create( \"RADIO_BUTTON\", \"Sweep up\" );
Sweep_Stop = button_create( \"RADIO_BUTTON\", Sweep_Up, \"Stop sweep\" );
Sweep_Down = button_create( \"RADIO_BUTTON\", Sweep_Up, \"Sweep Down\" );
button_state( Sweep_Stop, \"ON\" );

";
# === if RESONATOR ne 'Unspecified'
    if ( eval { $RESONATOR ne 'Unspecified' } ) {
        print $fh "/* If the modulation settings for the resonator allow extrapolation just show
   an input field for the modulation amplitide. If not distinguish between the
   cases of resonators for which interpolation is allowed and those that only
   have calibrations for discrete frequencies. In the first case we have an
   input field for the modulation frequency, in the second a menu for picking
   one of the allowed frequencies. Then we have to make sure that the
   modulation frequency set at the lock-in fits the restrictions gue to the
   calibration and change the freqency as necessary. */

mod_freq = lockin_ref_freq( );
raw_ampl = lockin_ref_level( );

IF epr_modulation_calibration_can_extrapolate( \"$RESONATOR\" \" (SR830)\" ) {
    Can_extrapolate = 1;
    Can_interpolate = 1;
	MF = input_create( \"FLOAT_INPUT\", mod_freq / 1 kHz,
		   	 		   \"Modulation frequency [kHz]\" );
} ELSE {
	freqs = epr_modulation_calibration_frequencies( \"$RESONATOR\" \" (SR830)\" );
    IF ! epr_modulation_calibration_can_interpolate( \"$RESONATOR\" \" (SR830)\" ) {
		MF = menu_create( \"Modulation frequency\",
                          sprint( \"# kHz\", freqs[ 1 ] / 1 kHz ) );
		C = 1;
		FOR I = 2 : size( freqs ) {
			menu_add( MF, sprint( \"# kHz\", freqs[ I ] / 1 kHz ) );
			IF mod_freq >= freqs[ I ] {
	    		C = I;
			}
    	}
		menu_choice( MF, C );
		mod_freq = lockin_ref_freq( freqs[ C ] );
	} ELSE {
		Can_interpolate = 1;
        min_freq = freqs[ 1 ];
	    max_freq = freqs[ size( freqs ) ];
	    IF mod_freq > max_freq {
			mod_freq = lockin_ref_freq( max_freq );
		} ELSE IF mod_freq < min_freq {
			mod_freq = lockin_ref_freq( min_freq );
		}
		MF = input_create( \"FLOAT_INPUT\", mod_freq / 1 kHz,
		   	 			   \"Modulation frequency [kHz]\" );
	}
}

/* Create the input field for the modulation amplitude (in G) */

mod_ampl =   raw_ampl
           * epr_modulation_ratio( \"$RESONATOR\" \" (SR830)\", mod_freq );
MA = input_create( \"FLOAT_INPUT\", mod_ampl, \"Modulation amplitude [G]\" );
";
# === endif
    }

    print $fh "
Pause = button_create( \"PUSH_BUTTON\", \"Pause acquisition\" );
button_state( Pause, Acq_State ? 0 : 1 );
Clear = button_create( \"NORMAL_BUTTON\", \"Clear screen\" );
hide_toolbox( \"OFF\" );

lockin_lock_keyboard( \"OFF\" );

I = 1;

FOREVER {
	/* If acquisition is stopped and sweep is off wait a bit */

	IF Acq_State == 0 AND Sweep_State == 0 {
		wait( 0.2 s );
	}

	/* If acquisition isn't stopped get new value from lock-in and display it */

	IF Acq_State {
		wait( lockin_time_constant( ) );
		data = lockin_get_data( 1, 2 ) / 1uV;
		display_1d( I, data[ 1 ], 1,
		            I, data[ 2 ], 2 );
		I += 1;
	}

	/* Sweep up or down after checking that the field does not reach the upper
	   or lower limits (stop sweep in that case) */

    IF Sweep_State != STOPPED {
		IF Sweep_State == UP {
			IF current_field + field_step <= max_field {
				current_field = magnet_field( current_field + field_step );
				output_value( Current_Field, current_field );
			} ELSE {
                Sweep_State = STOPPED;
                button_state( Sweep_Stop, \"ON\" );
			    draw_marker( I, \"YELLOW\" );
				object_enable( Sweep_Up, \"OFF\" );
				object_enable( Sweep_Stop, \"OFF\" );
			}
		} ELSE {
			IF current_field - field_step >= min_field {
				current_field = magnet_field( current_field - field_step );
				output_value( Current_Field, current_field );
			} ELSE {
                Sweep_State = STOPPED;
                button_state( Sweep_Stop, \"ON\" );
			    draw_marker( I, \"YELLOW\" );
				object_enable( Sweep_Down, \"OFF\" );
				object_enable( Sweep_Stop, \"OFF\" );
			}
		}
	}

";
# === if RESONATOR ne 'Unspecified'
    if ( eval { $RESONATOR ne 'Unspecified' } ) {
        print $fh "	/* If we've got a resonator with a calibration we have to monitor manual
	   changes to the modulation frequency and amplitude */

	new_mod_freq = lockin_ref_freq( );	
	new_raw_ampl = lockin_ref_level( );

	IF new_mod_freq != mod_freq {
	    /* For a resonator that doesn't allow extrapolation don't allow
		   manual changes of the modulation frequency (just reset any changes
		   that have been made). For a resonator with extrapolation the
		   modulation voltage of the lock-in must be changed so that the
		   modulation amplitude in G stays the same (at least as far as
		   possible) */

		IF ! ( Can_extrapolate OR Can_interpolate ) {
			mod_freq = lockin_ref_freq( mod_freq );
		} ELSE {
			IF new_mod_freq > max_freq {
				new_mod_freq = max_freq;
				new_mod_freq = lockin_ref_freq( new_mod_freq );
			} ELSE IF new_mod_freq < min_freq {
				new_mod_freq = min_freq;
				new_mod_freq = lockin_ref_freq( new_mod_freq );
			}
			input_value( MF, new_mod_freq / 1 kHz);
			mod_freq = new_mod_freq;
			mod_ampl = output_value( MA );
			raw_ampl =   mod_ampl
                    / epr_modulation_ratio( \"$RESONATOR\" \" (SR830)\", mod_freq );
			print( \"raw #\\n\", raw_ampl );
			IF raw_ampl > max_ampl {
				raw_ampl = max_ampl;
			} ELSE IF raw_ampl < min_ampl {
				raw_ampl = min_ampl;
			}
			new_raw_ampl = raw_ampl;
			lockin_ref_level( raw_ampl );
			mod_ampl = raw_ampl
                   * epr_modulation_ratio( \"$RESONATOR\" \" (SR830)\", mod_freq );
			output_value( MA, mod_ampl );
		}
	}

	/* If the amplitude got changed manually show it in the modulation amplitude
	   input field */

	IF raw_ampl != new_raw_ampl {
		raw_ampl = new_raw_ampl;
		mod_ampl =   raw_ampl
                   * epr_modulation_ratio( \"$RESONATOR\" \" (SR830)\", mod_freq );
		output_value( MA, mod_ampl );
	}
";
# === endif
    }

    print $fh "
	/* If nothing in the toolbox changed we're done */

	IF ! toolbox_changed( ) {
		NEXT;
	}

	/* If a new field has been set enable the \"Set field\" button if the
	   value is within limits, otherwise disable it */

	IF input_changed( New_Field ) {
		dval = input_value( New_Field );
		IF dval > max_field OR dval < min_field {
			object_enable( Set_Field, \"OFF\" );
		} ELSE {
			object_enable( Set_Field, \"ON\" );
		}
	}

	/* If \"Set field\" button was clicked on set the new field (if possible) */

	IF button_changed( Set_Field ) AND button_state( Set_Field ) {
		dval = input_value( New_Field );
		IF dval > max_field OR dval < min_field {
			object_enable( Set_Field, \"OFF\" );
			NEXT;
		}
		IF dval < max_field {
			object_enable( Sweep_Up, \"ON\" );
		}
		IF dval > min_field {
			object_enable( Sweep_Down, \"ON\" );
		}

		current_field = magnet_field( dval );
		output_value( Current_Field, current_field );
		draw_marker( I, \"BLUE\" );
	}

	/* Handle changes of the \"Field step\" input field */

	IF input_changed( Field_Step ) {
		dval = input_value( Field_Step );
		IF dval < min_field_step OR dval > max_field_step {
			input_value( Field_Step, field_step );
			NEXT;
		}

		field_step = dval;
	}

	IF     button_changed( Sweep_Up )
	   AND button_state( Sweep_Up )
       AND current_field < max_field {
		Sweep_State = UP;
        draw_marker( I, \"RED\" );
		object_enable( Sweep_Down, \"ON\" );
		object_enable( Sweep_Stop, \"ON\" );
	}

	IF     button_changed( Sweep_Down )
	   AND button_state( Sweep_Down )
	   AND current_field > min_field {
		Sweep_State = DOWN;
        draw_marker( I, \"GREEN\" );
		object_enable( Sweep_Up, \"ON\" );
		object_enable( Sweep_Stop, \"ON\" );
	}

	IF button_changed( Sweep_Stop ) AND button_state( Sweep_Stop ) {
	    Sweep_State = STOPPED;
	    draw_marker( I, \"YELLOW\" );
		IF current_field > min_field {
			object_enable( Sweep_Up, \"ON\" );
		}
		IF current_field - field_step < max_field {
			object_enable( Sweep_Down, \"ON\" );
		}
	}

";
# === if RESONATOR ne 'Unspecified'
    if ( eval { $RESONATOR ne 'Unspecified' } ) {
        print $fh "	/* If the modulation amplitude input field was changed set the new
	   amplitude at the lock-in after making sure the new value is within
	   the limits the lock-in can produce */

	IF input_changed( MA ) {
		raw_ampl = input_value( MA )
                   / epr_modulation_ratio( \"$RESONATOR\" \" (SR830)\", mod_freq );
		IF raw_ampl > max_ampl {
			raw_ampl = max_ampl;
		} ELSE IF raw_ampl < min_ampl {
			raw_ampl = min_ampl;
		}
		raw_ampl = lockin_ref_level( raw_ampl );
		mod_ampl = raw_ampl
                   * epr_modulation_ratio( \"$RESONATOR\" \" (SR830)\", mod_freq );
		input_value( MA, mod_ampl );
	}

	/* Changes of the modulation frequency input field can only happen for
	   resonators for which extrapolation isn't allowed. For those the do
	   allow interpolation and input field has to be checked, for those
	   without interpolation a menu. After changing the frequency also the
       modulation set at the lock-in has to be changed to keep the modulation
	   amplitude (in G) constant. */

	IF    ( ( Can_extrapolate OR Can_interpolate ) AND input_changed( MF ) )
	   OR ( ! Can_interpolate AND menu_changed( MF )  ) {
		IF Can_extrapolate OR Can_interpolate {
			mod_freq = input_value( MF ) * 1 kHz;
			IF mod_freq < min_freq {
				mod_freq = min_freq;
			} ELSE IF mod_freq > max_freq {
				mod_freq = max_freq;
			}
			mod_freq = lockin_ref_freq( mod_freq );
			input_value( MF, mod_freq / 1 kHz );
		} ELSE IF ! Can_interpolate {
			mod_freq = lockin_ref_freq( freqs[ menu_choice( MF ) ] );
		}

		raw_ampl =   mod_ampl
                   / epr_modulation_ratio( \"$RESONATOR\" \" (SR830)\", mod_freq );
		IF raw_ampl > max_ampl {
			raw_ampl = max_ampl;
		} ELSE IF raw_ampl < min_ampl {
			raw_ampl = min_ampl;
		}
		raw_ampl = lockin_ref_level( raw_ampl );
		mod_ampl =   raw_ampl
                   * epr_modulation_ratio( \"$RESONATOR\" \" (SR830)\", mod_freq );
		input_value( MA, mod_ampl );
	}
";
# === endif	
    }

    print $fh "
	IF button_changed( Pause ) {
		Acq_State = button_state( Pause ) ? 0 : 1;
	}

	IF button_changed( Clear ) {
	    button_state( Clear );
        clear_curve_1d( 1, 2 );
        clear_marker_1d( );
        I = 1;
        rescale_1d( 64 );
    }
}
";
    close $fh;

    my $text;
    if ( $? != 0 ) {
        if ( $? >> 8 == 255 ) {
            $text = "Internal error.";
        } elsif ( $? >> 8 == 1 ) {
            $text = "Someone else is running fsc2.";
        } elsif ( $? >> 8 == 2 ) {
            $text = "fsc2 is already testing or\nrunning an experiment.";
        } elsif ( $? >> 8 == 3 ) {
            $text = "Internal error of fsc2.";
        } elsif ( $? >> 8 == 4 ) {
            $text = "Could not start fsc2.";
        } else {
            $text = "Something strange\nis going on here.";
        }

        &show_message( $text ) if $? >> 8 != 0;
    }
}


################################################################

sub show_message {
    my $text = shift;

    $fsc2_main_window->messageBox( -icon => 'error',
                                   -type => 'Ok',
                                   -title => 'Error',
                                   -message => $text );
}


################################################################

sub store_defs {
    my $fh;
    my $name = $0;

    $name =~ s|^.*?([^/]+)$|$1|;
    mkdir "$ENV{ HOME }/.fsc2", 0777 unless -e "$ENV{ HOME }/.fsc2";
    open $fh, '>:utf8', $ENV{ HOME } . "/.fsc2/$name" or return;
    print $fh "# Do not edit - created automatically!\n";

    print $fh "$RESONATOR{ value }\n";

    print $fh "$fsc2_how_to_run\n";

    print $fh "$geom\n" if defined $geom;

    close $fh;
};


################################################################

sub load_defs {
    my $fh;
    my $name = $0;
    my $ne;
    my $found;

    $name =~ s|^.*?([^/]+)$|$1|;
    if ( $ARGV[ 0 ] ) {
        open $fh, '<:utf8', $ARGV[ 0 ] or return;
    } else {
        open $fh, '<:utf8', $ENV{ HOME } . "/.fsc2/$name" or return;
    }

    goto done_reading unless defined( $ne = <$fh> ) and $ne =~ /^#/;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @RESONATOR ) {
        if ( $ne eq $_ ) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $RESONATOR{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @fsc2_how_to_run ) {
        if ( $ne eq $_ ) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $fsc2_how_to_run = $ne;

    goto done_reading unless     defined( $ne = <$fh> )
                             and $ne =~ /^\s*([+-]\d+[+-]\d+)\s*$/;
    $geom = $1;

  done_reading:
    close $fh;
};
