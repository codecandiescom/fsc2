#!/usr/bin/perl
# -*- cperl -*-
# Generated by fsc2_guify from cw_epr_bruker.EDL on Mo 9. MÃ¤r 13:57:09 CET 2009

use strict;
use warnings;
use utf8;
use Tk;
use Tk::Balloon;

my @version = split /\./, $Tk::VERSION;
die "Installed Perl-Tk version is $Tk::VERSION but Tk800.022 is required.\n"
    if $version[ 0 ] + 0.001 * $version[ 1 ] < 800.022;

my %fp = ( -side => 'top',
           -fill => 'x',
           -padx => 10,
           -pady => 5 );
my %wp = ( -side   => 'left',
           -fill   => 'x',
           -expand => 1 );
my %up = ( -side => 'left' );
my $geom;

my @VARS;
my $fsc2_how_to_run = 'Test program';
my @fsc2_how_to_run = ( 'Start experiment',
                        'Test program',
                        'Load into fsc2' );
my $fsc2_main_window = MainWindow->new( -title =>
                               ( split /\./, ( split /\//, $0 )[ -1 ] )[ 0 ] );
my $fsc2_main_frame = $fsc2_main_window->Frame( -relief      => 'ridge',
                                                -borderwidth => 5 );
my $fsc2_balloon = $fsc2_main_frame->Balloon( );
my $fsc2_apply_frame = $fsc2_main_window->Frame( );
my $fsc2_apply_button = $fsc2_apply_frame->Button( -text    => 'Apply',
                                                   -command => \&write_out );
$fsc2_apply_button->bind( 'all', '<Alt-a>' => \&write_out );
my $fsc2_quit_button = $fsc2_apply_frame->Button( -text => 'Quit',
                 -command => sub { $fsc2_main_window->geometry =~
                                                   /^\d+x\d+([+-]\d+[+-]\d+)$/;
                                   $geom = $1;
                                   &store_defs;
                                   $fsc2_main_window->destroy } );
$fsc2_quit_button->bind( 'all',
                         '<Alt-q>' =>
                                sub { $fsc2_main_window->geometry =~
                                                   /^\d+x\d+([+-]\d+[+-]\d+)$/;
                                      $geom = $1;
                                      &store_defs;
                                      $fsc2_main_window->destroy } );
$fsc2_apply_frame->pack( -side => 'bottom',
                         -fill => 'x',
                         -padx => 20 );

# === START_FIELD float [ -50 : 23000 ] [ 3000 ] "Start field" "G"

my %START_FIELD;
push @VARS, \%START_FIELD;
$START_FIELD{ is_valid } = 1;
$START_FIELD{ type } = 'float';
$START_FIELD{ tk_frame } = $fsc2_main_frame->Frame( );
$START_FIELD{ tk_label } = $START_FIELD{ tk_frame }->Label( -text => "Start field",
-width => 20,
-anchor => 'w' );
$START_FIELD{ value } = 3000;

$START_FIELD{ min } = -50;
$START_FIELD{ max } = 23000;
$START_FIELD{ tk_entry } = $START_FIELD{ tk_frame }->Entry( -textvariable => \$START_FIELD{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_check( shift, \$START_FIELD{ is_valid },
( defined $START_FIELD{ min } ? $START_FIELD{ min } : undef ),
( defined $START_FIELD{ max } ? $START_FIELD{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $START_FIELD{ tk_entry },
-balloonmsg  => 'Range: [ ' . ( defined $START_FIELD{ min } ? $START_FIELD{ min } : '-inf' ) . ' : ' . ( defined $START_FIELD{ max } ? $START_FIELD{ max } : '+inf' ) . ' ]' . ( $START_FIELD{ type } =~ /_empty$/ ? ' or leave empty' : '' ) );
$START_FIELD{ tk_unit } = $START_FIELD{ tk_frame }->Label( -text => "G",
-width => 5 );
$START_FIELD{ tk_frame }->pack( %fp );
$START_FIELD{ tk_label }->pack( %wp );
$START_FIELD{ tk_entry }->pack( %wp );
$START_FIELD{ tk_unit  }->pack( %up );

# === END_FIELD float [ -50 : 23000 ] [ 3500 ] "End field" "G"

my %END_FIELD;
push @VARS, \%END_FIELD;
$END_FIELD{ is_valid } = 1;
$END_FIELD{ type } = 'float';
$END_FIELD{ tk_frame } = $fsc2_main_frame->Frame( );
$END_FIELD{ tk_label } = $END_FIELD{ tk_frame }->Label( -text => "End field",
-width => 20,
-anchor => 'w' );
$END_FIELD{ value } = 3500;

$END_FIELD{ min } = -50;
$END_FIELD{ max } = 23000;
$END_FIELD{ tk_entry } = $END_FIELD{ tk_frame }->Entry( -textvariable => \$END_FIELD{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_check( shift, \$END_FIELD{ is_valid },
( defined $END_FIELD{ min } ? $END_FIELD{ min } : undef ),
( defined $END_FIELD{ max } ? $END_FIELD{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $END_FIELD{ tk_entry },
-balloonmsg  => 'Range: [ ' . ( defined $END_FIELD{ min } ? $END_FIELD{ min } : '-inf' ) . ' : ' . ( defined $END_FIELD{ max } ? $END_FIELD{ max } : '+inf' ) . ' ]' . ( $END_FIELD{ type } =~ /_empty$/ ? ' or leave empty' : '' ) );
$END_FIELD{ tk_unit } = $END_FIELD{ tk_frame }->Label( -text => "G",
-width => 5 );
$END_FIELD{ tk_frame }->pack( %fp );
$END_FIELD{ tk_label }->pack( %wp );
$END_FIELD{ tk_entry }->pack( %wp );
$END_FIELD{ tk_unit  }->pack( %up );

# === FIELD_STEP float [ 0.001 : 1600 ] [ 1 ] "Field step size" "G"

my %FIELD_STEP;
push @VARS, \%FIELD_STEP;
$FIELD_STEP{ is_valid } = 1;
$FIELD_STEP{ type } = 'float';
$FIELD_STEP{ tk_frame } = $fsc2_main_frame->Frame( );
$FIELD_STEP{ tk_label } = $FIELD_STEP{ tk_frame }->Label( -text => "Field step size",
-width => 20,
-anchor => 'w' );
$FIELD_STEP{ value } = 1;

$FIELD_STEP{ min } = 0.001;
$FIELD_STEP{ max } = 1600;
$FIELD_STEP{ tk_entry } = $FIELD_STEP{ tk_frame }->Entry( -textvariable => \$FIELD_STEP{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_check( shift, \$FIELD_STEP{ is_valid },
( defined $FIELD_STEP{ min } ? $FIELD_STEP{ min } : undef ),
( defined $FIELD_STEP{ max } ? $FIELD_STEP{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $FIELD_STEP{ tk_entry },
-balloonmsg  => 'Range: [ ' . ( defined $FIELD_STEP{ min } ? $FIELD_STEP{ min } : '-inf' ) . ' : ' . ( defined $FIELD_STEP{ max } ? $FIELD_STEP{ max } : '+inf' ) . ' ]' . ( $FIELD_STEP{ type } =~ /_empty$/ ? ' or leave empty' : '' ) );
$FIELD_STEP{ tk_unit } = $FIELD_STEP{ tk_frame }->Label( -text => "G",
-width => 5 );
$FIELD_STEP{ tk_frame }->pack( %fp );
$FIELD_STEP{ tk_label }->pack( %wp );
$FIELD_STEP{ tk_entry }->pack( %wp );
$FIELD_STEP{ tk_unit  }->pack( %up );

# === NUM_SCANS int [ 0 : ][ 0 ] "Number of scans"

my %NUM_SCANS;
push @VARS, \%NUM_SCANS;
$NUM_SCANS{ is_valid } = 1;
$NUM_SCANS{ type } = 'int';
$NUM_SCANS{ tk_frame } = $fsc2_main_frame->Frame( );
$NUM_SCANS{ tk_label } = $NUM_SCANS{ tk_frame }->Label( -text => "Number of scans",
-width => 20,
-anchor => 'w' );
$NUM_SCANS{ value } = 0;

$NUM_SCANS{ min } = 0;
$NUM_SCANS{ max } = undef;
$NUM_SCANS{ tk_entry } = $NUM_SCANS{ tk_frame }->Entry( -textvariable => \$NUM_SCANS{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ int_check( shift, \$NUM_SCANS{ is_valid },
( defined $NUM_SCANS{ min } ? $NUM_SCANS{ min } : undef ),
( defined $NUM_SCANS{ max } ? $NUM_SCANS{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $NUM_SCANS{ tk_entry },
-balloonmsg  => 'Range: [ ' . ( defined $NUM_SCANS{ min } ? $NUM_SCANS{ min } : '-inf' ) . ' : ' . ( defined $NUM_SCANS{ max } ? $NUM_SCANS{ max } : '+inf' ) . ' ]' . ( $NUM_SCANS{ type } =~ /_empty$/ ? ' or leave empty' : '' ) );
$NUM_SCANS{ tk_unit } = $NUM_SCANS{ tk_frame }->Label( -text => "",
-width => 5 );
$NUM_SCANS{ tk_frame }->pack( %fp );
$NUM_SCANS{ tk_label }->pack( %wp );
$NUM_SCANS{ tk_entry }->pack( %wp );
$NUM_SCANS{ tk_unit  }->pack( %up );

# === RESONATOR menu [ "Unspecified", "Raumtemperatur 1" ] [ 1 ] "Resonator"

my %RESONATOR;
push @VARS, \%RESONATOR;
$RESONATOR{ is_valid } = 1;
$RESONATOR{ type } = 'menu';
$RESONATOR{ tk_frame } = $fsc2_main_frame->Frame( );
$RESONATOR{ tk_label } = $RESONATOR{ tk_frame }->Label( -text => "Resonator",
-width => 20,
-anchor => 'w' );
$RESONATOR{ value } = "Unspecified";
my @RESONATOR = ( "Unspecified", "Raumtemperatur 1" );
$RESONATOR{ tk_entry } = $RESONATOR{ tk_frame }->Optionmenu( -options     => \@RESONATOR,
-width        => 10,
-textvariable => \$RESONATOR{ value } );
$RESONATOR{ tk_unit } = $RESONATOR{ tk_frame }->Label( -text => "",
-width => 5 );
$RESONATOR{ tk_frame }->pack( %fp );
$RESONATOR{ tk_label }->pack( %wp );
$RESONATOR{ tk_entry }->pack( %wp );
$RESONATOR{ tk_unit  }->pack( %up );

# === SENS1 menu [ "1.0", "1.25", "1.5", "2.0", "2.5", "3.0", "4.0", "5.0",   "6.0", "8.0" ][ 1 ] "Receiver gain\n(factor)"

my %SENS1;
push @VARS, \%SENS1;
$SENS1{ is_valid } = 1;
$SENS1{ type } = 'menu';
$SENS1{ tk_frame } = $fsc2_main_frame->Frame( );
$SENS1{ tk_label } = $SENS1{ tk_frame }->Label( -text => "Receiver gain\n(factor)",
-width => 20,
-anchor => 'w' );
$SENS1{ value } = "1.0";
my @SENS1 = ( "1.0", "1.25", "1.5", "2.0", "2.5", "3.0", "4.0", "5.0", "6.0", "8.0" );
$SENS1{ tk_entry } = $SENS1{ tk_frame }->Optionmenu( -options     => \@SENS1,
-width        => 10,
-textvariable => \$SENS1{ value } );
$SENS1{ tk_unit } = $SENS1{ tk_frame }->Label( -text => "",
-width => 5 );
$SENS1{ tk_frame }->pack( %fp );
$SENS1{ tk_label }->pack( %wp );
$SENS1{ tk_entry }->pack( %wp );
$SENS1{ tk_unit  }->pack( %up );

# === SENS2 menu [ "1.0e2", "1.0e3", "1.0e4", "1.0e5", "1.0e6" ] [ 3 ]   "Receiver gain\n(magnitude)"

my %SENS2;
push @VARS, \%SENS2;
$SENS2{ is_valid } = 1;
$SENS2{ type } = 'menu';
$SENS2{ tk_frame } = $fsc2_main_frame->Frame( );
$SENS2{ tk_label } = $SENS2{ tk_frame }->Label( -text => "Receiver gain\n(magnitude)",
-width => 20,
-anchor => 'w' );
$SENS2{ value } = "1.0e4";
my @SENS2 = ( "1.0e2", "1.0e3", "1.0e4", "1.0e5", "1.0e6" );
$SENS2{ tk_entry } = $SENS2{ tk_frame }->Optionmenu( -options     => \@SENS2,
-width        => 10,
-textvariable => \$SENS2{ value } );
$SENS2{ tk_unit } = $SENS2{ tk_frame }->Label( -text => "",
-width => 5 );
$SENS2{ tk_frame }->pack( %fp );
$SENS2{ tk_label }->pack( %wp );
$SENS2{ tk_entry }->pack( %wp );
$SENS2{ tk_unit  }->pack( %up );

# === TC menu [ "Don't set", "2.5 ms", "5 ms", "10 ms", "20 ms", "40 ms",   "80 ms", "160 ms", "320 ms", "640 ms", "1.25 s", "2.5 s", "5 s" ] [ 1 ]   "Lock-in Time constant"

my %TC;
push @VARS, \%TC;
$TC{ is_valid } = 1;
$TC{ type } = 'menu';
$TC{ tk_frame } = $fsc2_main_frame->Frame( );
$TC{ tk_label } = $TC{ tk_frame }->Label( -text => "Lock-in Time constant",
-width => 20,
-anchor => 'w' );
$TC{ value } = "Don't set";
my @TC = ( "Don't set", "2.5 ms", "5 ms", "10 ms", "20 ms", "40 ms", "80 ms", "160 ms", "320 ms", "640 ms", "1.25 s", "2.5 s", "5 s" );
$TC{ tk_entry } = $TC{ tk_frame }->Optionmenu( -options     => \@TC,
-width        => 10,
-textvariable => \$TC{ value } );
$TC{ tk_unit } = $TC{ tk_frame }->Label( -text => "",
-width => 5 );
$TC{ tk_frame }->pack( %fp );
$TC{ tk_label }->pack( %wp );
$TC{ tk_entry }->pack( %wp );
$TC{ tk_unit  }->pack( %up );

# === FACTOR float [ 1.0e-3 : 100 ] [ 1.0  ] "Waiting time"  "* tc"

my %FACTOR;
push @VARS, \%FACTOR;
$FACTOR{ is_valid } = 1;
$FACTOR{ type } = 'float';
$FACTOR{ tk_frame } = $fsc2_main_frame->Frame( );
$FACTOR{ tk_label } = $FACTOR{ tk_frame }->Label( -text => "Waiting time",
-width => 20,
-anchor => 'w' );
$FACTOR{ value } = 1.0;

$FACTOR{ min } = 1.0e-3;
$FACTOR{ max } = 100;
$FACTOR{ tk_entry } = $FACTOR{ tk_frame }->Entry( -textvariable => \$FACTOR{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_check( shift, \$FACTOR{ is_valid },
( defined $FACTOR{ min } ? $FACTOR{ min } : undef ),
( defined $FACTOR{ max } ? $FACTOR{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $FACTOR{ tk_entry },
-balloonmsg  => 'Range: [ ' . ( defined $FACTOR{ min } ? $FACTOR{ min } : '-inf' ) . ' : ' . ( defined $FACTOR{ max } ? $FACTOR{ max } : '+inf' ) . ' ]' . ( $FACTOR{ type } =~ /_empty$/ ? ' or leave empty' : '' ) );
$FACTOR{ tk_unit } = $FACTOR{ tk_frame }->Label( -text => "* tc",
-width => 5 );
$FACTOR{ tk_frame }->pack( %fp );
$FACTOR{ tk_label }->pack( %wp );
$FACTOR{ tk_entry }->pack( %wp );
$FACTOR{ tk_unit  }->pack( %up );

# === MODFREQ menu [ "Don't set", "100 kHz", "50 kHz", "25 kHz", "12.5 kHz",   "6.25 kHz", "3.125 kHz", "1.5625 kHz" ] [ 1 ] "Modulation frequency"

my %MODFREQ;
push @VARS, \%MODFREQ;
$MODFREQ{ is_valid } = 1;
$MODFREQ{ type } = 'menu';
$MODFREQ{ tk_frame } = $fsc2_main_frame->Frame( );
$MODFREQ{ tk_label } = $MODFREQ{ tk_frame }->Label( -text => "Modulation frequency",
-width => 20,
-anchor => 'w' );
$MODFREQ{ value } = "Don't set";
my @MODFREQ = ( "Don't set", "100 kHz", "50 kHz", "25 kHz", "12.5 kHz", "6.25 kHz", "3.125 kHz", "1.5625 kHz" );
$MODFREQ{ tk_entry } = $MODFREQ{ tk_frame }->Optionmenu( -options     => \@MODFREQ,
-width        => 10,
-textvariable => \$MODFREQ{ value } );
$MODFREQ{ tk_unit } = $MODFREQ{ tk_frame }->Label( -text => "",
-width => 5 );
$MODFREQ{ tk_frame }->pack( %fp );
$MODFREQ{ tk_label }->pack( %wp );
$MODFREQ{ tk_entry }->pack( %wp );
$MODFREQ{ tk_unit  }->pack( %up );

# === MODAMP float_empty [ 0 : ] [ 1 ] "Modulation amplitude" "G"

my %MODAMP;
push @VARS, \%MODAMP;
$MODAMP{ is_valid } = 1;
$MODAMP{ type } = 'float_empty';
$MODAMP{ tk_frame } = $fsc2_main_frame->Frame( );
$MODAMP{ tk_label } = $MODAMP{ tk_frame }->Label( -text => "Modulation amplitude",
-width => 20,
-anchor => 'w' );
$MODAMP{ value } = 1;

$MODAMP{ min } = 0;
$MODAMP{ max } = undef;
$MODAMP{ tk_entry } = $MODAMP{ tk_frame }->Entry( -textvariable => \$MODAMP{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_empty_check( shift, \$MODAMP{ is_valid },
( defined $MODAMP{ min } ? $MODAMP{ min } : undef ),
( defined $MODAMP{ max } ? $MODAMP{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $MODAMP{ tk_entry },
-balloonmsg  => 'Range: [ ' . ( defined $MODAMP{ min } ? $MODAMP{ min } : '-inf' ) . ' : ' . ( defined $MODAMP{ max } ? $MODAMP{ max } : '+inf' ) . ' ]' . ( $MODAMP{ type } =~ /_empty$/ ? ' or leave empty' : '' ) );
$MODAMP{ tk_unit } = $MODAMP{ tk_frame }->Label( -text => "G",
-width => 5 );
$MODAMP{ tk_frame }->pack( %fp );
$MODAMP{ tk_label }->pack( %wp );
$MODAMP{ tk_entry }->pack( %wp );
$MODAMP{ tk_unit  }->pack( %up );

# === PHASE float_empty [ -360.0 : 360.0 ] [ 0.0 ] "Modulation phase"

my %PHASE;
push @VARS, \%PHASE;
$PHASE{ is_valid } = 1;
$PHASE{ type } = 'float_empty';
$PHASE{ tk_frame } = $fsc2_main_frame->Frame( );
$PHASE{ tk_label } = $PHASE{ tk_frame }->Label( -text => "Modulation phase",
-width => 20,
-anchor => 'w' );
$PHASE{ value } = 0.0;

$PHASE{ min } = -360.0;
$PHASE{ max } = 360.0;
$PHASE{ tk_entry } = $PHASE{ tk_frame }->Entry( -textvariable => \$PHASE{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_empty_check( shift, \$PHASE{ is_valid },
( defined $PHASE{ min } ? $PHASE{ min } : undef ),
( defined $PHASE{ max } ? $PHASE{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $PHASE{ tk_entry },
-balloonmsg  => 'Range: [ ' . ( defined $PHASE{ min } ? $PHASE{ min } : '-inf' ) . ' : ' . ( defined $PHASE{ max } ? $PHASE{ max } : '+inf' ) . ' ]' . ( $PHASE{ type } =~ /_empty$/ ? ' or leave empty' : '' ) );
$PHASE{ tk_unit } = $PHASE{ tk_frame }->Label( -text => "",
-width => 5 );
$PHASE{ tk_frame }->pack( %fp );
$PHASE{ tk_label }->pack( %wp );
$PHASE{ tk_entry }->pack( %wp );
$PHASE{ tk_unit  }->pack( %up );

$fsc2_main_frame->pack( %fp, -pady => '5' );
$fsc2_main_window->Optionmenu( -options      => \@fsc2_how_to_run,
                                -textvariable => \$fsc2_how_to_run,
                              )->pack( -padx => 15,
                                       -pady => 5 );

$fsc2_apply_button->pack( %wp, -padx => 25, -pady => 5 );
$fsc2_quit_button->pack(  %wp, -padx => 25, -pady => 5 );

load_defs( );
$fsc2_main_window->geometry( $geom ) if defined $geom;
MainLoop;


################################################################

sub int_check {
    my ( $new, $is_valid, $min, $max ) = @_;

    $$is_valid = 0;

    return 0 if $new =~ /^\+?(\d+)?$/ and defined $max and $max < 0;
    return 0 if $new =~ /^-/ and defined $min and $min >= 0;
    if ( $new =~ /^[+-]?$/ ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
         return 1;
     }

    return 0 unless $new =~ /^[+-]?\d+?$/;

    if ( ( defined $min and $new < $min )
         or ( defined $max and $new > $max ) ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
     } else {
         $$is_valid = 1;
         check_all_vars( );
     }
     return 1;
}


################################################################

sub int_empty_check {
    my ( $new, $is_valid, $min, $max ) = @_;

    $$is_valid = 0;

    if ( $new =~ /^$/ ) {
        $$is_valid = 1;
        check_all_vars( );
        return 1;
    }

    return 0 if $new =~ /^\+?(\d+)?$/ and defined $max and $max < 0;
    return 0 if $new =~ /^-/ and defined $min and $min >= 0;
    if ( $new =~ /^[+-]?$/ ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
         return 1;
     }

    return 0 unless $new =~ /^[+-]?\d+?$/;

    if ( ( defined $min and $new < $min )
         or ( defined $max and $new > $max ) ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
     } else {
         $$is_valid = 1;
         check_all_vars( );
     }

     return 1;
}


################################################################

sub float_check {
    my ( $new, $is_valid, $min, $max ) = @_;
    my $float_rep = '[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?';

    $$is_valid = 0;

    return 0 if $new =~ /^\+/ and defined $max and $max < 0;
    return 0 if $new =~ /^-/ and defined $min and $min > 0;

    if ( $new =~ /^$float_rep$/ ) {
        if ( ( defined $max and $max < $new ) or
             ( defined $min and $min > $new ) ) {
            $fsc2_apply_button->configure( -state => 'disabled' );
        } else {
            $$is_valid = 1;
            check_all_vars( );
        }
        return 1;
    }

    if ( $new =~ /^[+-]?(\d+)?\.?(\d+)?([Ee][+-]?(\d+)?)?$/ ) {
        $$is_valid = 0;
        check_all_vars( );
        return 1;
     }

     return 0;
}


################################################################

sub float_empty_check {
    my ( $new, $is_valid, $min, $max ) = @_;
    my $float_rep = '[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?';

    $$is_valid = 0;

    if ( $new =~ /^$/ ) {
        $$is_valid = 1;
        check_all_vars( );
        return 1;
    }

    return 0 if $new =~ /^\+/ and defined $max and $max < 0;
    return 0 if $new =~ /^-/ and defined $min and $min > 0;

    if ( $new =~ /^$float_rep$/ ) {
        if ( ( defined $max and $max < $new ) or
             ( defined $min and $min > $new ) ) {
            $fsc2_apply_button->configure( -state => 'disabled' );
        } else {
            $$is_valid = 1;
            check_all_vars( );
        }
        return 1;
    }

    if ( $new =~ /^[+-]?(\d+)?\.?(\d+)?([Ee][+-]?(\d+)?)?$/ ) {
        $$is_valid = 0;
        check_all_vars( );
        return 1;
    }

    return 0;
}


################################################################

sub check_all_vars {
    for ( @VARS ) {
        if ( ! $_->{ is_valid } ) {
            $fsc2_apply_button->configure( -state => 'disabled' );
            return;
        }
    }

    $fsc2_apply_button->configure( -state => 'normal' );
}


################################################################

sub write_out {
    for ( @VARS ) {
        $_->{ value } = undef
            if $_->{ type } =~ /^(int|float)_empty/ and $_->{ value } eq '';
    }

    open my $fh, '|-:utf8', 'fsc2_' . lc $fsc2_how_to_run
        or die "Can't find utility fsc2_" . lc $fsc2_how_to_run . ".\n";

    my $START_FIELD = $START_FIELD{ value };
    my $END_FIELD = $END_FIELD{ value };
    my $FIELD_STEP = $FIELD_STEP{ value };
    my $NUM_SCANS = $NUM_SCANS{ value };
    my $RESONATOR = $RESONATOR{ value };
    my $SENS1 = $SENS1{ value };
    my $SENS2 = $SENS2{ value };
    my $TC = $TC{ value };
    my $FACTOR = $FACTOR{ value };
    my $MODFREQ = $MODFREQ{ value };
    my $MODAMP = $MODAMP{ value };
    my $PHASE = $PHASE{ value };

    print $fh "DEVICES:

er032m;
er023m;
eip371;
";
# === if RESONATOR ne "Unspecified"
    if ( eval { $RESONATOR ne "Unspecified" } ) {
        print $fh "epr_mod;
";
# === endif
    }

    print $fh "

VARIABLES:

start_field = $START_FIELD G;
end_field   = $END_FIELD G;
field_step  = $FIELD_STEP G;
Num_Points = int( abs( end_field - start_field ) / field_step ) + 1;
field[ Num_Points ];
data[ Num_Points ];
avg_data[ Num_Points ];
Files[ 2 ];
factor = $FACTOR;
I, J, K;
Scans_Done = 0;
Scans_Written = 0;
freq[ 2 ];
avg_freq = 0.0;
Stop_Button;
Scan_No;
li_tc;
li_sens;
li_amp;
mod_amp;
li_freq;
li_phase;
CT;
TT;


PREPARATIONS:

magnet_setup( start_field, field_step );
";
# === if START_FIELD <= END_FIELD
    if ( eval { $START_FIELD <= $END_FIELD } ) {
        print $fh "init_1d( 2, Num_Points, start_field, field_step, \"Field [G]\", \"Signal [uV]\" );
";
# === else
    } else {
        print $fh "init_1d( 2, Num_Points, end_field, field_step, \"Field [G]\", \"Signal [uV]\" );
";
# === endif
    }

    print $fh "
EXPERIMENT:

/* Set up magnet related stuff */

start_field = magnet_field( );
field[ 1 ] = start_field;
field_step = magnet_field_step_size( field_step );
";
# === if START_FIELD <= END_FIELD
    if ( eval { $START_FIELD <= $END_FIELD } ) {
        print $fh "end_field = start_field + ( Num_Points - 1 ) * field_step;
change_scale_1d( start_field, field_step );
";
# === else
    } else {
        print $fh "end_field = start_field - ( Num_Points - 1 ) * field_step;
change_scale_1d( end_field, field_step );

/* Set up the lock-in and get its settings */

";
# === endif
    }

    print $fh "";
# === if SENS1 ne "Don't set"
    if ( eval { $SENS1 ne "Don't set" } ) {
        print $fh "lockin_sensitivity( $SENS1 * $SENS2 );
";
# === endif
    }

    print $fh "";
# === if defined PHASE
    if ( eval { defined $PHASE } ) {
        print $fh "lockin_phase( float( $PHASE ) );
";
# === endif
    }

    print $fh "";
# === if MODFREQ ne "Don't set" 
    if ( eval { $MODFREQ ne "Don't set" } ) {
        print $fh "lockin_ref_freq( $MODFREQ );
";
# === endif
    }

    print $fh "";
# === if defined MODAMP
    if ( eval { defined $MODAMP } ) {
        print $fh "";
# ===   if RESONATOR ne "Unspecified"
    if ( eval { $RESONATOR ne "Unspecified" } ) {
        print $fh "lockin_ref_level( $MODAMP G / epr_modulation_ratio( \"$RESONATOR\" \" (ER023M)\",
                                                   lockin_ref_freq( ) ) );
";
# ===   else
    } else {
        print $fh "lockin_ref_level( $MODAMP G );
";
# ===   endif
    }

    print $fh "";
# === endif
    }

    print $fh "";
# === if TC ne "Don't set"
    if ( eval { $TC ne "Don't set" } ) {
        print $fh "li_tc = lockin_time_constant( $TC );
CT = round( li_tc / 0.32 ms );
IF CT < 10 {
    CT = 10;
} ELSE IF CT > 9999 {
    CT = 9999;
}
lockin_conversion_time( CT * 0.32 ms );
";
# === else
    } else {
        print $fh "li_tc = lockin_time_constant( );
";
# === endif
    }

    print $fh "
li_sens = lockin_sensitivity( ) / 1 mV;
";
# === if RESONATOR ne "Unspecified"
    if ( eval { $RESONATOR ne "Unspecified" } ) {
        print $fh "mod_amp =   lockin_ref_level( ) 
          * epr_modulation_ratio( \"$RESONATOR\" \" (ER023M)\", lockin_ref_freq( ) );
";
# === endif
    }

    print $fh "li_amp = lockin_ref_level( );
li_freq = lockin_ref_freq( ) / 1kHz;
li_phase = lockin_phase( );

/* Open a file for the averaged data and one for all raw data */

Files[ 1 ] = get_file( \"\", \"*.avg\", \"\", \"\", \"avg\" );
Files[ 2 ] = clone_file( Files[ 1 ], \"avg\", \"scans\" );

hide_toolbox( \"ON\" );
Scan_No = output_create( \"INT_OUTPUT\", 0, \"Scan Number\" );
Stop_Button = button_create( \"PUSH_BUTTON\", \"Stop after end of scan\" );
hide_toolbox( \"OFF\" );

IF $NUM_SCANS > 0 {
   TT = ceil( $NUM_SCANS * Num_Points * factor * li_tc );
   print( \"Minimum experiment duration: #:# min\\n\", TT / 60, TT % 60 );
}

I = 0;
FOREVER {
    I += 1;
    output_value( Scan_No, I );
    freq[ 1 ] = freq_counter_measure( );

	/* Loop for all field points of a scan */

    FOR J = 1 : Num_Points {
        wait( factor * li_tc );
";
# === if START_FIELD <= END_FIELD
    if ( eval { $START_FIELD <= $END_FIELD } ) {
        print $fh "        data[ J ] = lockin_get_data( );
        display_1d( J, data[ J ] / 1 uV, 1,
                    J, add_to_average( avg_data[ J ], data[ J ], I ) / 1 uV,
                    2 );
        IF J < Num_Points {
            field[ J + 1 ] = magnet_sweep_up( );
        }
";
# === else
    } else {
        print $fh "        K = Num_Points - J + 1;
        data[ K ] = lockin_get_data( );
        display_1d( K, data[ K ] / 1 uV, 1,
                    K, add_to_average( avg_data[ K ], data[ K ], I ) / 1 uV,
                    2 );
        IF K > 1 {
            field[ J + 1 ] = magnet_sweep_down( );
        }
";
# === endif
    }

    print $fh "    }

    /* Measure the RF frequency again and calculate the new average */

    freq[ 2 ] = freq_counter_measure( );
    avg_freq = add_to_average( avg_freq, 0.5 * ( freq[ 1 ] + freq[ 2 ] ), I );

    fsave( Files[ 2 ], \"\\# Scan: #, MW freq. = # GHz (# GHz, # GHz)\\n\\n\",
           I, 0.5 * ( freq[ 1 ] + freq[ 2 ] ) / 1 GHz,
";
# === if START_FIELD <= END_FIELD
    if ( eval { $START_FIELD <= $END_FIELD } ) {
        print $fh "           freq[ 1 ] / 1 GHz, freq[ 2 ] / 1 GHz );
";
# === else
    } else {
        print $fh "           freq[ 2 ] / 1 GHz, freq[ 1 ] / 1 GHz );
";
# === endif
    }

    print $fh "
    /* Append the new data to the raw data file */

    FOR K = 1 : Num_Points {
";
# === if START_FIELD <= END_FIELD
    if ( eval { $START_FIELD <= $END_FIELD } ) {
        print $fh "        fsave( Files[ 2 ], \"#, #\\n\", field[ K ], data[ K ] );
";
# === else
    } else {
        print $fh "        fsave( Files[ 2 ], \"#, #\\n\", field[ Num_Points - K + 1 ], data[ K ] );
";
# === endif
    }

    print $fh "    }
    fsave( Files[ 2 ], \"\\n\" );
    Scans_Written = 1;

    /* Calculate the new average data and rewrite the file for the
       average data */

    avg_data = add_to_average( avg_data, data, I );
    Scans_Done += 1;

    reset_file( Files[ 1 ] );
    fsave( Files[ 1 ], \"\\# Date                : # #\\n\"
                       \"\\# Start field         = # G\\n\"
                       \"\\# End field           = # G\\n\"
                       \"\\# Field step size     = # G\\n\"
                       \"\\# Number of points    = #\\n\"
                       \"\\# No. of scans        = #\\n\"
                       \"\\# MW frequency        = # GHz\\n\"
                       \"\\# Lockin-In           = Bruker signal channel ER023M\\n\"
                       \"\\# Sensitivity         = # mV\\n\"
                       \"\\# Time constant       = # ms\\n\"
                       \"\\# Waiting time factor = #\\n\"
";
# === if RESONATOR ne "Unspecified"
    if ( eval { $RESONATOR ne "Unspecified" } ) {
        print $fh "                       \"\\# Resonator           = $RESONATOR\\n\"
                       \"\\# Modulation ampl.    = # G (raw: # G)\\n\"
";
# === else
    } else {
        print $fh "                       \"\\# Modulation ampl.    = # G (raw)\\n\"
";
# === endif
    }

    print $fh "                       \"\\# Modulation freq.    = # kHz\\n\"
                       \"\\# Phase               = #\\n\",
           date( ), time( ), start_field,
";
# === if START_FIELD <= END_FIELD
    if ( eval { $START_FIELD <= $END_FIELD } ) {
        print $fh "           start_field + ( Num_Points - 1 ) * field_step, field_step,
";
# === else
    } else {
        print $fh "           start_field - ( Num_Points - 1 ) * field_step, - field_step,
";
# === endif
    }

    print $fh "           Num_Points , Scans_Done, avg_freq / 1 GHz,
           li_sens, li_tc / 1 ms, factor,
";
# === if RESONATOR ne "Unspecified"
    if ( eval { $RESONATOR ne "Unspecified" } ) {
        print $fh "           mod_amp,
";
# === endif
    }

    print $fh "           li_amp, li_freq, li_phase );

    FOR K = 1 : Num_Points {
";
# === if START_FIELD <= END_FIELD
    if ( eval { $START_FIELD <= $END_FIELD } ) {
        print $fh "        fsave( Files[ 1 ], \"#, #\\n\", field[ K ], avg_data[ K ] );
";
# === else
    } else {
        print $fh "        fsave( Files[ 1 ], \"#, #\\n\", field[ Num_Points - K + 1 ],
               avg_data[ K ] );
";
# === endif
    }

    print $fh "    }

    /* Update the displayed average data */

    display_1d( 1, avg_data / 1 uV, 2 );

    IF button_state( Stop_Button ) OR Scans_Done == $NUM_SCANS {
        BREAK;
    }
    magnet_reset_field( );
    field[ 1 ] = magnet_field( );
}

ON_STOP:

hide_toolbox( \"ON\" );

IF ! Scans_Written {
    Num_Points = J - 1;
    IF Num_Points <= 1 {
        abort( );
    }

    freq[ 2 ] = freq_counter_measure( );
    avg_freq = 0.5 * ( freq[ 1 ] + freq[ 2 ] );

    fsave( Files[ 2 ], \"\\# Scan: 1, MW freq. = # GHz (# GHz, # GHz)\\n\\n\",
           0.5 * ( freq[ 1 ] + freq[ 2 ] ) / 1 GHz,
";
# === if START_FIELD <= END_FIELD
    if ( eval { $START_FIELD <= $END_FIELD } ) {
        print $fh "           freq[ 1 ] / 1 GHz, freq[ 2 ] / 1 GHz );
";
# === else
    } else {
        print $fh "           freq[ 2 ] / 1 GHz, freq[ 1 ] / 1 GHz );
";
# === endif
    }

    print $fh "
    FOR K = 1 : Num_Points {
";
# === if START_FIELD <= END_FIELD
    if ( eval { $START_FIELD <= $END_FIELD } ) {
        print $fh "        fsave( Files[ 2 ], \"#, #\\n\", field[ K ], data[ K ] );
";
# === else
    } else {
        print $fh "        fsave( Files[ 2 ], \"#, #\\n\", field[ Num_Points - K + 1 ], data[ K ] );
";
# === endif
    }

    print $fh "    }
    fsave( Files[ 2 ], \"\\n\" );
    avg_data = data;
    Scans_Done = 1;
}

reset_file( Files[ 1 ] );
FOR K = 1 : 2 {
    fsave( Files[ K ], \"\\# Date                : # #\\n\"
                       \"\\# Start field         = # G\\n\"
                       \"\\# End field           = # G\\n\"
                       \"\\# Field step size     = # G\\n\"
                       \"\\# Number of points    = #\\n\"
                       \"\\# No. of scans        = #\\n\"
                       \"\\# MW frequency        = # GHz\\n\"
                       \"\\# Lockin-In           = Stanford Research SR830\\n\"
                       \"\\# Sensitivity         = # mV\\n\"
                       \"\\# Time constant       = # ms\\n\"
                       \"\\# Waiting time factor = #\\n\"
";
# === if RESONATOR ne "Unspecified"
    if ( eval { $RESONATOR ne "Unspecified" } ) {
        print $fh "                       \"\\# Resonator           = $RESONATOR\\n\"
                       \"\\# Modulation ampl.    = # G (raw: #)\\n\"
";
# === else
    } else {
        print $fh "                       \"\\# Modulation ampl.    = # G (raw)\\n\"
";
# === endif
    }

    print $fh "                       \"\\# Modulation freq.    = # kHz\\n\"
                       \"\\# Phase               = #\\n\",
           date( ), time( ), start_field,
";
# === if START_FIELD <= END_FIELD
    if ( eval { $START_FIELD <= $END_FIELD } ) {
        print $fh "           start_field + ( Num_Points - 1 ) * field_step, field_step,
";
# === else
    } else {
        print $fh "           start_field - ( Num_Points - 1 ) * field_step, - field_step,
";
# === endif
    }

    print $fh "           Num_Points , Scans_Done, avg_freq / 1 GHz,
           li_sens, li_tc / 1 ms, factor,
";
# === if RESONATOR ne "Unspecified"
    if ( eval { $RESONATOR ne "Unspecified" } ) {
        print $fh "           mod_amp,
";
# === endif
    }

    print $fh "           li_amp, li_freq, li_phase );
}

save_comment( Files[ 1 ], \"# \", \"Sample: \\nTemperature: \\nCavity: \" );

FOR K = 1 : Num_Points {
";
# === if START_FIELD <= END_FIELD
    if ( eval { $START_FIELD <= $END_FIELD } ) {
        print $fh "    fsave( Files[ 1 ], \"#, #\\n\", field[ K ], avg_data[ K ] );
";
# === else
    } else {
        print $fh "    fsave( Files[ 1 ], \"#, #\\n\", field[ Num_Points - K + 1 ],
           avg_data[ K ] );
";
# === endif
    }

    print $fh "}
";
    close $fh;

    my $text;
    if ( $? != 0 ) {
        if ( $? >> 8 == 255 ) {
            $text = "Internal error.";
        } elsif ( $? >> 8 == 1 ) {
            $text = "Someone else is running fsc2.";
        } elsif ( $? >> 8 == 2 ) {
            $text = "fsc2 is already testing or\nrunning an experiment.";
        } elsif ( $? >> 8 == 3 ) {
            $text = "Internal error of fsc2.";
        } elsif ( $? >> 8 == 4 ) {
            $text = "Could not start fsc2.";
        } else {
            $text = "Something strange\nis going on here.";
        }

        &show_message( $text ) if $? >> 8 != 0;
    }
}


################################################################

sub show_message {
    my $text = shift;

    $fsc2_main_window->messageBox( -icon => 'error',
                                   -type => 'Ok',
                                   -title => 'Error',
                                   -message => $text );
}


################################################################

sub store_defs {
    my $fh;
    my $name = $0;

    $name =~ s|^.*?([^/]+)$|$1|;
    mkdir "$ENV{ HOME }/.fsc2", 0777 unless -e "$ENV{ HOME }/.fsc2";
    open $fh, '>:utf8', $ENV{ HOME } . "/.fsc2/$name" or return;
    print $fh "# Do not edit - created automatically!\n";

    if (    (     $START_FIELD{ type } =~ /^float_empty$/o
              and $START_FIELD{ value } eq '' )
         or (     $START_FIELD{ value } ne ''
              and $START_FIELD{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o
              and ( defined $START_FIELD{ max } ? $START_FIELD{ max } >= $START_FIELD{ value } : 1 )
              and ( defined $START_FIELD{ min } ? $START_FIELD{ min } <= $START_FIELD{ value } : 1 ) ) ) {
        print $fh "$START_FIELD{ value }\n";
    } else {
        print $fh "3000\n";
    }

    if (    (     $END_FIELD{ type } =~ /^float_empty$/o
              and $END_FIELD{ value } eq '' )
         or (     $END_FIELD{ value } ne ''
              and $END_FIELD{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o
              and ( defined $END_FIELD{ max } ? $END_FIELD{ max } >= $END_FIELD{ value } : 1 )
              and ( defined $END_FIELD{ min } ? $END_FIELD{ min } <= $END_FIELD{ value } : 1 ) ) ) {
        print $fh "$END_FIELD{ value }\n";
    } else {
        print $fh "3500\n";
    }

    if (    (     $FIELD_STEP{ type } =~ /^float_empty$/o
              and $FIELD_STEP{ value } eq '' )
         or (     $FIELD_STEP{ value } ne ''
              and $FIELD_STEP{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o
              and ( defined $FIELD_STEP{ max } ? $FIELD_STEP{ max } >= $FIELD_STEP{ value } : 1 )
              and ( defined $FIELD_STEP{ min } ? $FIELD_STEP{ min } <= $FIELD_STEP{ value } : 1 ) ) ) {
        print $fh "$FIELD_STEP{ value }\n";
    } else {
        print $fh "1\n";
    }

    if (    (     $NUM_SCANS{ type } =~ /^int_empty$/o
              and $NUM_SCANS{ value } eq '' )
         or (     $NUM_SCANS{ value } ne ''
              and $NUM_SCANS{ value } =~ /^[+-]?\d+$/o
              and ( defined $NUM_SCANS{ max } ? $NUM_SCANS{ max } >= $NUM_SCANS{ value } : 1 )
              and ( defined $NUM_SCANS{ min } ? $NUM_SCANS{ min } <= $NUM_SCANS{ value } : 1 ) ) ) {
        print $fh "$NUM_SCANS{ value }\n";
    } else {
        print $fh "0\n";
    }

    print $fh "$RESONATOR{ value }\n";

    print $fh "$SENS1{ value }\n";

    print $fh "$SENS2{ value }\n";

    print $fh "$TC{ value }\n";

    if (    (     $FACTOR{ type } =~ /^float_empty$/o
              and $FACTOR{ value } eq '' )
         or (     $FACTOR{ value } ne ''
              and $FACTOR{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o
              and ( defined $FACTOR{ max } ? $FACTOR{ max } >= $FACTOR{ value } : 1 )
              and ( defined $FACTOR{ min } ? $FACTOR{ min } <= $FACTOR{ value } : 1 ) ) ) {
        print $fh "$FACTOR{ value }\n";
    } else {
        print $fh "1.0\n";
    }

    print $fh "$MODFREQ{ value }\n";

    if (    (     $MODAMP{ type } =~ /^float_empty$/o
              and $MODAMP{ value } eq '' )
         or (     $MODAMP{ value } ne ''
              and $MODAMP{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o
              and ( defined $MODAMP{ max } ? $MODAMP{ max } >= $MODAMP{ value } : 1 )
              and ( defined $MODAMP{ min } ? $MODAMP{ min } <= $MODAMP{ value } : 1 ) ) ) {
        print $fh "$MODAMP{ value }\n";
    } else {
        print $fh "1\n";
    }

    if (    (     $PHASE{ type } =~ /^float_empty$/o
              and $PHASE{ value } eq '' )
         or (     $PHASE{ value } ne ''
              and $PHASE{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o
              and ( defined $PHASE{ max } ? $PHASE{ max } >= $PHASE{ value } : 1 )
              and ( defined $PHASE{ min } ? $PHASE{ min } <= $PHASE{ value } : 1 ) ) ) {
        print $fh "$PHASE{ value }\n";
    } else {
        print $fh "0.0\n";
    }

    print $fh "$fsc2_how_to_run\n";

    print $fh "$geom\n" if defined $geom;

    close $fh;
};


################################################################

sub load_defs {
    my $fh;
    my $name = $0;
    my $ne;
    my $found;

    $name =~ s|^.*?([^/]+)$|$1|;
    if ( $ARGV[ 0 ] ) {
        open $fh, '<:utf8', $ARGV[ 0 ] or return;
    } else {
        open $fh, '<:utf8', $ENV{ HOME } . "/.fsc2/$name" or return;
    }

    goto done_reading unless defined( $ne = <$fh> ) and $ne =~ /^#/;

    goto done_reading unless     defined( $ne = <$fh> )
                             and $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o;
    chomp $ne;
    goto done_reading if    ( defined $START_FIELD{ max } and $ne > $START_FIELD{ max } )
                         or ( defined $START_FIELD{ min } and $ne < $START_FIELD{ min } );
    $START_FIELD{ value } = $ne;

    goto done_reading unless     defined( $ne = <$fh> )
                             and $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o;
    chomp $ne;
    goto done_reading if    ( defined $END_FIELD{ max } and $ne > $END_FIELD{ max } )
                         or ( defined $END_FIELD{ min } and $ne < $END_FIELD{ min } );
    $END_FIELD{ value } = $ne;

    goto done_reading unless     defined( $ne = <$fh> )
                             and $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o;
    chomp $ne;
    goto done_reading if    ( defined $FIELD_STEP{ max } and $ne > $FIELD_STEP{ max } )
                         or ( defined $FIELD_STEP{ min } and $ne < $FIELD_STEP{ min } );
    $FIELD_STEP{ value } = $ne;

    goto done_reading unless     defined( $ne = <$fh> )
                             and $ne =~ /^[+-]?\d+$/;
    chomp $ne;
    goto done_reading if    ( defined $NUM_SCANS{ max } and $ne > $NUM_SCANS{ max } )
                         or ( defined $NUM_SCANS{ min } and $ne < $NUM_SCANS{ min } );
    $NUM_SCANS{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @RESONATOR ) {
        if ( $ne eq $_ ) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $RESONATOR{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @SENS1 ) {
        if ( $ne eq $_ ) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $SENS1{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @SENS2 ) {
        if ( $ne eq $_ ) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $SENS2{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @TC ) {
        if ( $ne eq $_ ) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $TC{ value } = $ne;

    goto done_reading unless     defined( $ne = <$fh> )
                             and $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o;
    chomp $ne;
    goto done_reading if    ( defined $FACTOR{ max } and $ne > $FACTOR{ max } )
                         or ( defined $FACTOR{ min } and $ne < $FACTOR{ min } );
    $FACTOR{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @MODFREQ ) {
        if ( $ne eq $_ ) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $MODFREQ{ value } = $ne;

    goto done_reading unless     defined( $ne = <$fh> )
                             and (    $ne =~ /^$/o
                                   or $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o );
    chomp $ne;
    goto done_reading if     $ne ne ''
                         and (    ( defined $MODAMP{ max } and $ne > $MODAMP{ max } )
                               or ( defined $MODAMP{ min } and $ne < $MODAMP{ min } ) );
    $MODAMP{ value } = $ne;

    goto done_reading unless     defined( $ne = <$fh> )
                             and (    $ne =~ /^$/o
                                   or $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o );
    chomp $ne;
    goto done_reading if     $ne ne ''
                         and (    ( defined $PHASE{ max } and $ne > $PHASE{ max } )
                               or ( defined $PHASE{ min } and $ne < $PHASE{ min } ) );
    $PHASE{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @fsc2_how_to_run ) {
        if ( $ne eq $_ ) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $fsc2_how_to_run = $ne;

    goto done_reading unless     defined( $ne = <$fh> )
                             and $ne =~ /^\s*([+-]\d+[+-]\d+)\s*$/;
    $geom = $1;

  done_reading:
    close $fh;
};
