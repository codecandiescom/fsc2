#!/usr/bin/perl
# -*- cperl -*-
# Generated by fsc2_guify from hjs_cw_epr.EDL on Mit Apr 30 18:10:00 MEST 2003

use strict;
use warnings;
use Tk;
use Tk::Balloon;

my @version = split /\./, $Tk::VERSION;
die "Installed Perl-Tk version is $Tk::VERSION but Tk800.022 is required.\n"
    if $version[ 0 ] + 0.001 * $version[ 1 ] < 800.022;

my %fp = ( -side => 'top',
           -fill => 'x',
           -padx => '2m',
           -pady => '2m' );
my %wp = ( -side => 'left',
           -fill => 'x',
           -expand => 1 );
my %up = ( -side => 'left' );

my $fsc2_how_to_run = "Test program";
my @fsc2_how_to_run = ( "Start experiment",
                        "Test program",
                        "Load into fsc2" );
my $fsc2_main_window = MainWindow->new( );
my $fsc2_main_frame = $fsc2_main_window->Frame( -relief => "ridge",
                                                -borderwidth => "1m" );
my $fsc2_balloon = $fsc2_main_frame->Balloon( );
my $fsc2_apply_frame = $fsc2_main_window->Frame( );
my $fsc2_apply_button = $fsc2_apply_frame->Button( -text => "Apply",
                                                   -command => \&write_out );
$fsc2_apply_button->bind( "all", "<Alt-a>" => \&write_out );
my $fsc2_quit_button = $fsc2_apply_frame->Button( -text => "Quit",
                 -command => sub { &store_defs; $fsc2_main_window->destroy } );
$fsc2_quit_button->bind( "all",
                         "<Alt-q>" =>
                         sub { &store_defs; $fsc2_main_window->destroy } );
$fsc2_apply_frame->pack( -side => "bottom",
                         -fill => "x",
                         -padx => "4m" );

# === FC_TYPE menu [ "without Gaussmeter", "with Gaussmeter" ] [ 1 ]  "Field controller"
my %FC_TYPE;
$FC_TYPE{ tk_frame } = $fsc2_main_frame->Frame( );
$FC_TYPE{ tk_label } = $FC_TYPE{ tk_frame }->Label( -text => "Field controller",
-width => 20,
-anchor => 'w' );
$FC_TYPE{ value } = "without Gaussmeter";
my @FC_TYPE = ( "without Gaussmeter", "with Gaussmeter" );
$FC_TYPE{ tk_entry } = $FC_TYPE{ tk_frame }->Optionmenu( -options => \@FC_TYPE,
-width => 10,
-textvariable => \$FC_TYPE{ value } );
$FC_TYPE{ tk_unit } = $FC_TYPE{ tk_frame }->Label( -text => "",
-width => 5 );
$FC_TYPE{ tk_frame }->pack( %fp );
$FC_TYPE{ tk_label }->pack( %wp );
$FC_TYPE{ tk_entry }->pack( %wp );
$FC_TYPE{ tk_unit }->pack( %up );

# === N_RUNS      int   [ 1 : ] [ 1 ] "Number of runs"
my %N_RUNS;
$N_RUNS{ tk_frame } = $fsc2_main_frame->Frame( );
$N_RUNS{ tk_label } = $N_RUNS{ tk_frame }->Label( -text => "Number of runs",
-width => 20,
-anchor => 'w' );
$N_RUNS{ value } = 1;
$N_RUNS{ min } = 1;
$N_RUNS{ max } = undef;
$N_RUNS{ tk_entry } = $N_RUNS{ tk_frame }->Entry( -textvariable => \$N_RUNS{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ int_check( shift,
( defined $N_RUNS{ min } ? $N_RUNS{ min } : undef ),
( defined $N_RUNS{ max } ? $N_RUNS{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $N_RUNS{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $N_RUNS{ min } ? $N_RUNS{ min } : '-inf' ) .
" : " . ( defined $N_RUNS{ max } ? $N_RUNS{ max } : '+inf' ) . " ]" );
$N_RUNS{ tk_unit } = $N_RUNS{ tk_frame }->Label( -text => "",
-width => 5 );
$N_RUNS{ tk_frame }->pack( %fp );
$N_RUNS{ tk_label }->pack( %wp );
$N_RUNS{ tk_entry }->pack( %wp );
$N_RUNS{ tk_unit }->pack( %up );

# === START_FIELD float [ 2900.0 : 3400.0 ] [ 3100 ] "Start field" "G"
my %START_FIELD;
$START_FIELD{ tk_frame } = $fsc2_main_frame->Frame( );
$START_FIELD{ tk_label } = $START_FIELD{ tk_frame }->Label( -text => "Start field",
-width => 20,
-anchor => 'w' );
$START_FIELD{ value } = 3100;
$START_FIELD{ min } = 2900.0;
$START_FIELD{ max } = 3400.0;
$START_FIELD{ tk_entry } = $START_FIELD{ tk_frame }->Entry( -textvariable => \$START_FIELD{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_check( shift,
( defined $START_FIELD{ min } ? $START_FIELD{ min } : undef ),
( defined $START_FIELD{ max } ? $START_FIELD{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $START_FIELD{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $START_FIELD{ min } ? $START_FIELD{ min } : '-inf' ) .
" : " . ( defined $START_FIELD{ max } ? $START_FIELD{ max } : '+inf' ) . " ]" );
$START_FIELD{ tk_unit } = $START_FIELD{ tk_frame }->Label( -text => "G",
-width => 5 );
$START_FIELD{ tk_frame }->pack( %fp );
$START_FIELD{ tk_label }->pack( %wp );
$START_FIELD{ tk_entry }->pack( %wp );
$START_FIELD{ tk_unit }->pack( %up );

# === END_FIELD   float [ 2900.0 : 3400.0 ] [ 3300 ] "End field" "G"
my %END_FIELD;
$END_FIELD{ tk_frame } = $fsc2_main_frame->Frame( );
$END_FIELD{ tk_label } = $END_FIELD{ tk_frame }->Label( -text => "End field",
-width => 20,
-anchor => 'w' );
$END_FIELD{ value } = 3300;
$END_FIELD{ min } = 2900.0;
$END_FIELD{ max } = 3400.0;
$END_FIELD{ tk_entry } = $END_FIELD{ tk_frame }->Entry( -textvariable => \$END_FIELD{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_check( shift,
( defined $END_FIELD{ min } ? $END_FIELD{ min } : undef ),
( defined $END_FIELD{ max } ? $END_FIELD{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $END_FIELD{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $END_FIELD{ min } ? $END_FIELD{ min } : '-inf' ) .
" : " . ( defined $END_FIELD{ max } ? $END_FIELD{ max } : '+inf' ) . " ]" );
$END_FIELD{ tk_unit } = $END_FIELD{ tk_frame }->Label( -text => "G",
-width => 5 );
$END_FIELD{ tk_frame }->pack( %fp );
$END_FIELD{ tk_label }->pack( %wp );
$END_FIELD{ tk_entry }->pack( %wp );
$END_FIELD{ tk_unit }->pack( %up );

# === FIELD_STEP  float [ 0.1 : 10.0 ] [ 0.5 ] "Field step size" "G"
my %FIELD_STEP;
$FIELD_STEP{ tk_frame } = $fsc2_main_frame->Frame( );
$FIELD_STEP{ tk_label } = $FIELD_STEP{ tk_frame }->Label( -text => "Field step size",
-width => 20,
-anchor => 'w' );
$FIELD_STEP{ value } = 0.5;
$FIELD_STEP{ min } = 0.1;
$FIELD_STEP{ max } = 10.0;
$FIELD_STEP{ tk_entry } = $FIELD_STEP{ tk_frame }->Entry( -textvariable => \$FIELD_STEP{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_check( shift,
( defined $FIELD_STEP{ min } ? $FIELD_STEP{ min } : undef ),
( defined $FIELD_STEP{ max } ? $FIELD_STEP{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $FIELD_STEP{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $FIELD_STEP{ min } ? $FIELD_STEP{ min } : '-inf' ) .
" : " . ( defined $FIELD_STEP{ max } ? $FIELD_STEP{ max } : '+inf' ) . " ]" );
$FIELD_STEP{ tk_unit } = $FIELD_STEP{ tk_frame }->Label( -text => "G",
-width => 5 );
$FIELD_STEP{ tk_frame }->pack( %fp );
$FIELD_STEP{ tk_label }->pack( %wp );
$FIELD_STEP{ tk_entry }->pack( %wp );
$FIELD_STEP{ tk_unit }->pack( %up );

# === TC          int   [ 40 : 40000 ] [ 400 ] "Time constant" "ms"
my %TC;
$TC{ tk_frame } = $fsc2_main_frame->Frame( );
$TC{ tk_label } = $TC{ tk_frame }->Label( -text => "Time constant",
-width => 20,
-anchor => 'w' );
$TC{ value } = 400;
$TC{ min } = 40;
$TC{ max } = 40000;
$TC{ tk_entry } = $TC{ tk_frame }->Entry( -textvariable => \$TC{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ int_check( shift,
( defined $TC{ min } ? $TC{ min } : undef ),
( defined $TC{ max } ? $TC{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $TC{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $TC{ min } ? $TC{ min } : '-inf' ) .
" : " . ( defined $TC{ max } ? $TC{ max } : '+inf' ) . " ]" );
$TC{ tk_unit } = $TC{ tk_frame }->Label( -text => "ms",
-width => 5 );
$TC{ tk_frame }->pack( %fp );
$TC{ tk_label }->pack( %wp );
$TC{ tk_entry }->pack( %wp );
$TC{ tk_unit }->pack( %up );

$fsc2_main_frame->pack( %fp, -pady => '1m' );
$fsc2_main_window->Optionmenu( -options => \@fsc2_how_to_run,
                                -textvariable => \$fsc2_how_to_run,
                              )->pack( -padx => '3m',
                                       -pady => '3m' );

$fsc2_apply_button->pack( %wp, -padx => '5m', -pady => '3m' );
$fsc2_quit_button->pack( %wp, -padx => '5m', -pady => '3m' );

load_defs( );
MainLoop;


################################################################

sub int_check {
    my ( $new, $min, $max ) = @_;

    return 0 if $new =~ /^\+?(\d+)?$/ and defined $max and $max < 0;
    return 0 if $new =~ /^-/ and defined $min and $min >= 0;
    if ( $new =~ /^[+-]?$/ ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
         return 1;
     }

    return 0 unless $new =~ /^[+-]?\d+?$/;

    if ( ( defined $min and $new < $min )
         or ( defined $max and $new > $max ) ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
     } else {
         $fsc2_apply_button->configure( -state => 'normal' );
     }
     return 1;
}


################################################################

sub float_check {
    my ( $new, $min, $max ) = @_;
    my $float_rep = '[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?';

    return 0 if $new =~ /^\+/ and defined $max and $max < 0;
    return 0 if $new =~ /^-/ and defined $min and $min > 0;

    if ( $new =~ /^$float_rep$/ ) {
        if ( ( defined $max and $max < $new ) or
             ( defined $min and $min > $new ) ) {
            $fsc2_apply_button->configure( -state => 'disabled' );
        } else {
            $fsc2_apply_button->configure( -state => 'normal' );
        }
        return 1;
    }

    if ( $new =~ /^[+-]?(\d+)?\.?(\d+)?([Ee][+-]?(\d+)?)?$/ ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
         return 1;
     }

     return 0;
}


################################################################

sub write_out {
    my $fh;
    open( $fh, "|fsc2_" . lc $fsc2_how_to_run )
        or die "Can't find utility fsc2_" . lc $fsc2_how_to_run . ".\n";

    my $FC_TYPE = $FC_TYPE{ value };
    my $N_RUNS = $N_RUNS{ value };
    my $START_FIELD = $START_FIELD{ value };
    my $END_FIELD = $END_FIELD{ value };
    my $FIELD_STEP = $FIELD_STEP{ value };
    my $TC = $TC{ value };

    print $fh "DEVICES:

hjs_daadc;
";
# === if FC_TYPE eq "without Gaussmeter"
    if ( eval { $FC_TYPE eq "without Gaussmeter" } ) {
        print $fh "hjs_sfc;
";
# === else
    } else {
        print $fh "witio_48;
bnm12;
hjs_fc;
";
# === endif
    }

    print $fh "

VARIABLES:

start_field = $START_FIELD G;
end_field   = $END_FIELD G;
";
# === if START_FIELD < END_FIELD
    if ( eval { $START_FIELD < $END_FIELD } ) {
        print $fh "field_step  = $FIELD_STEP G;
";
# === else
    } else {
        print $fh "field_step  = - $FIELD_STEP G;
";
# === endif
    }

    print $fh "field = start_field;

N_points = ceil( abs( end_field - start_field ) / abs( field_step ) ) + 1;
N_runs = $N_RUNS;

tc = $TC ms;

data[ 3, * ];

I, J;

PREPARATIONS:

magnet_setup( start_field, field_step );
init_1d( 3, N_points, start_field, field_step, \"Field [G]\", \"Signal [a.u.]\" );


EXPERIMENT:

save_comment( \"# \" );
fsave( \"\\# Start field:    # G\\n\", start_field );
fsave( \"\\# End field:      # G\\n\", end_field );
fsave( \"\\# Field step:     # G\\n\", field_step );
fsave( \"\\# Number of runs: #\\n\", N_runs );
fsave( \"\\# Delay:          # ms\\n\", tc );

FOR I = 1 : N_runs {
	fsave( \"\\# #. Ueberlauf\\n\\n\", I );
";
# === if FC_TYPE eq "without Gaussmeter"
    if ( eval { $FC_TYPE eq "without Gaussmeter" } ) {
        print $fh "	wait ( 5s );
";
# === endif
    }

    print $fh "
";
# === if START_FIELD < END_FIELD
    if ( eval { $START_FIELD < $END_FIELD } ) {
        print $fh "	FOR J = 1 : N_points {
";
# === else
    } else {
        print $fh "	FOR J = N_points : 1 : -1 {
";
# === endif
    }

    print $fh "
		data[ 1, J ] = daq_get_voltage( ) / 10.0;

		IF I == 1 {
			data[ 2, J ] = data[ 1, J ];
		} ELSE {
			data[ 2, J ] = ( data[ 2, J ] * ( I - 1 ) + data[ 1, J ] ) / I;
		}

		display_1d( J, data[ 1, J ], 1, J, data[ 2, J ], 2 );

";
# === if FC_TYPE eq "without Gaussmeter"
    if ( eval { $FC_TYPE eq "without Gaussmeter" } ) {
        print $fh "		fsave( \"# #\\n\", field, data[ 1, J ] );
";
# === else
    } else {
        print $fh "		fsave( \"# #\\n\", gaussmeter_field( ), data[ 1, J ] );
";
# === endif
    }

    print $fh "
";
# === if START_FIELD < END_FIELD
    if ( eval { $START_FIELD < $END_FIELD } ) {
        print $fh "		IF J < N_points {
";
# === else
    } else {
        print $fh "		IF J > 1 {
";
# === endif
    }

    print $fh "			field = magnet_sweep_up( );
		}

		wait( tc );
	}

	fsave( \"\\n\" );

	data[ 3 ] = data[ 1 ];
	clear_curve( 1 );
	display_1d( 1, data[ 3 ], 3 );

	field = magnet_reset_field( );
}
";
    close $fh;

    my $text;
    if ( $? != 0 ) {
        if ( $? >> 8 == 255 ) {
            $text = "Internal error.";
        } elsif ( $? >> 8 == 1 ) {
            $text = "Someone else is running fsc2.";
        } elsif ( $? >> 8 == 2 ) {
            $text = "fsc2 is already testing or\nrunning an experiment.";
        } elsif ( $? >> 8 == 3 ) {
            $text = "Internal error of fsc2.";
        } elsif ( $? >> 8 == 4 ) {
            $text = "Could not start fsc2.";
        } else {
            $text = "Something strange\nis going on here.";
        }

        &show_message( $text ) if $? >> 8 != 0;
    }
}


################################################################

sub show_message {
    my $text = shift;

    $fsc2_main_window->messageBox( -icon => 'error',
                                   -type => 'Ok',
                                   -title => 'Error',
                                   -message => $text );
}


################################################################

sub store_defs {

    my $fh;
    my $name = $0;

    $name =~ s|^.*?([^/]+)$|$1|;
    mkdir "$ENV{ HOME }/.fsc2", 0777 unless -e "$ENV{ HOME }/.fsc2";
    open( $fh, ">$ENV{ HOME }/.fsc2/$name" ) or return;
    print $fh "# Do not edit - created automatically!\n";

    print $fh "$FC_TYPE{ value }\n";

    if ( $N_RUNS{ value } =~ /^[+-]?\d+$/o and
         ( defined $N_RUNS{ max } ? $N_RUNS{ max } >= $N_RUNS{ value } : 1 ) and
         ( defined $N_RUNS{ min } ? $N_RUNS{ min } <= $N_RUNS{ value } : 1 ) ) {
        print $fh "$N_RUNS{ value }\n";
    } else {
        print $fh "1\n";
    }

    if ( $START_FIELD{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o and
         ( defined $START_FIELD{ max } ? $START_FIELD{ max } >= $START_FIELD{ value } : 1 ) and
         ( defined $START_FIELD{ min } ? $START_FIELD{ min } <= $START_FIELD{ value } : 1 ) ) {
        print $fh "$START_FIELD{ value }\n";
    } else {
        print $fh "3100\n";
    }

    if ( $END_FIELD{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o and
         ( defined $END_FIELD{ max } ? $END_FIELD{ max } >= $END_FIELD{ value } : 1 ) and
         ( defined $END_FIELD{ min } ? $END_FIELD{ min } <= $END_FIELD{ value } : 1 ) ) {
        print $fh "$END_FIELD{ value }\n";
    } else {
        print $fh "3300\n";
    }

    if ( $FIELD_STEP{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o and
         ( defined $FIELD_STEP{ max } ? $FIELD_STEP{ max } >= $FIELD_STEP{ value } : 1 ) and
         ( defined $FIELD_STEP{ min } ? $FIELD_STEP{ min } <= $FIELD_STEP{ value } : 1 ) ) {
        print $fh "$FIELD_STEP{ value }\n";
    } else {
        print $fh "0.5\n";
    }

    if ( $TC{ value } =~ /^[+-]?\d+$/o and
         ( defined $TC{ max } ? $TC{ max } >= $TC{ value } : 1 ) and
         ( defined $TC{ min } ? $TC{ min } <= $TC{ value } : 1 ) ) {
        print $fh "$TC{ value }\n";
    } else {
        print $fh "400\n";
    }

    print $fh "$fsc2_how_to_run\n";

    close $fh;
};


################################################################

sub load_defs {
    my $fh;
    my $name = $0;
    my $ne;
    my $found;

    $name =~ s|^.*?([^/]+)$|$1|;
    if ( $ARGV[ 0 ] ) {
        open( $fh, "<$ARGV[ 0 ]" ) or return;
    } else {
        open( $fh, "<$ENV{ HOME }/.fsc2/$name" ) or return;
    }

    goto done_reading unless defined( $ne = <$fh> ) and $ne =~ /^#/;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @FC_TYPE ) {
        if ( $ne eq $_) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $FC_TYPE{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> )
        and $ne =~ /^[+-]?\d+$/;
    chomp $ne;
    goto done_reading if ( defined $N_RUNS{ max } and $ne > $N_RUNS{ max } ) or
                         ( defined $N_RUNS{ min } and $ne < $N_RUNS{ min } );
    $N_RUNS{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> )
        and $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o;
    chomp $ne;
    goto done_reading if ( defined $START_FIELD{ max } and $ne > $START_FIELD{ max } ) or
                         ( defined $START_FIELD{ min } and $ne < $START_FIELD{ min } );
    $START_FIELD{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> )
        and $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o;
    chomp $ne;
    goto done_reading if ( defined $END_FIELD{ max } and $ne > $END_FIELD{ max } ) or
                         ( defined $END_FIELD{ min } and $ne < $END_FIELD{ min } );
    $END_FIELD{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> )
        and $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o;
    chomp $ne;
    goto done_reading if ( defined $FIELD_STEP{ max } and $ne > $FIELD_STEP{ max } ) or
                         ( defined $FIELD_STEP{ min } and $ne < $FIELD_STEP{ min } );
    $FIELD_STEP{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> )
        and $ne =~ /^[+-]?\d+$/;
    chomp $ne;
    goto done_reading if ( defined $TC{ max } and $ne > $TC{ max } ) or
                         ( defined $TC{ min } and $ne < $TC{ min } );
    $TC{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @fsc2_how_to_run ) {
        if ( $ne eq $_) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $fsc2_how_to_run = $ne;

  done_reading:
    close $fh;
};


################################################################
# Package for showing a file selector

package fsc2_filesel;

use Tk;
use strict;
use warnings;

my $cur_dir;
my $cur_file;

BEGIN {
    $cur_dir = `pwd`;
    chomp $cur_dir;
}

sub show {
    my ( $top, $file ) = @_;

    my $selected = undef;

    if ( defined $file and $file =~ m|^((.*?)/)?([^/]+)$|o ) {
        $cur_file = $3;
        $cur_dir = $2 ne "" ? $2 : $1 if defined $1;
    } else {
        $cur_file = "";
    }

    my %fs;

    $fs{ top } = $top->Toplevel( '-title' => 'File Select' );
    $fs{ top }->grab;
    $fs{ dir } = $fs{ top }->Entry( -textvariable => \$cur_dir,
                                    -width => 35
                                  )->pack( -side => 'top',
                                           -fill => 'x',
                                           -padx => '2m',
                                           -pady => '1m',
                                         );
    $fs{ list } = $fs{ top }->Scrolled( 'Listbox',
                                        -selectmode => 'single',
                                        -scrollbars => 'osoe',
                                      )->pack( -side => 'top',
                                               -fill => 'both',
                                               -anchor => 's',
                                               -padx => '2m',
                                               -pady => '1m',
                                               -expand => 1 );
    populate_fs( $fs{ list }, $cur_dir );
    $fs{ file } = $fs{ top }->Entry( -textvariable => \$cur_file
                                   )->pack( -side => 'top',
                                            -fill => 'x',
                                            -padx => '2m',
                                            -pady => '1m'
                                          );
    $fs{ frame } = $fs{ top }->Frame( )->pack( -side => 'bottom' );
    $fs{ frame }->Button( -text => 'Cancel',
                          -command => sub { $selected = "" }
                        )->pack( -side => 'left',
                                 -padx => '2m',
                                 -pady => '1m'
                               );
    $fs{ frame }->Button( -text => 'Rescan',
                          -command => [ \&populate_fs, $fs{ list },
                                        $cur_dir ]
                        )->pack( -side => 'left',
                                 -padx => '2m',
                                 -pady => '1m'
                                             );
    $fs{ frame }-> Button( -text => '  Ok  ',
                           -command => sub { $selected = $cur_file }
                         )->pack( -side => 'right',
                                  -padx => '2m',
                                  -pady => '1m'
                                );
    $fs{ list }->bind( '<ButtonPress-1>' =>
                       [ \&new_selection, $fs{ list }, Ev( 'y' ) ] );
    $fs{ top }->bind( '<ButtonPress-4>' =>
                       sub { $fs{ list }->yview( scroll => -1, 'units' ) } );
    $fs{ top }->bind( '<Up>' =>
                       sub { $fs{ list }->yview( scroll => -1, 'units' ) } );
    $fs{ top }->bind( '<Prior>' =>
                       sub { $fs{ list }->yview( scroll => -1, 'page' ) } );
    $fs{ top }->bind( '<ButtonPress-5>' =>
                       sub { $fs{ list }->yview( scroll => 1, 'units' ) } );
    $fs{ top }->bind( '<Down>' =>
                       sub { $fs{ list }->yview( scroll => 1, 'units' ) } );
    $fs{ top }->bind( '<Next>' =>
                       sub { $fs{ list }->yview( scroll => 1, 'page' ) } );
    $fs{ top }->bind( '<Home>' => sub { $fs{ list }->yview( 0 ) } );
    $fs{ top }->bind( '<End>' =>
                      sub { $fs{ list }->yview( $fs{ list }->size - 1 ) } );
    $fs{ top }->bind( '<Delete>' => sub { $selected = "" } );
    $fs{ top }->bind( '<BackSpace>' => sub { $selected = "" } );
    $fs{ top }->bind( '<Return>' => sub { $selected = $cur_file } );
    $fs{ top }->bind( '<Tab>' =>
                      sub { populate_fs( $fs{ list }, $cur_dir ) } );

    $fs{ top }->waitVariable( \$selected );
    $fs{ top }->destroy;
    return undef if $selected =~ /^$/o;
    if ( $cur_dir =~ m|^/$|o ) {
        return "/$selected";
    } else {
        return "$cur_dir/$selected";
    }
}


################################################################

sub new_selection {
    my ( $d, $l, $y ) = @_;
    my $sel = $l->get( $l->nearest( $y ) );
    if ( $sel =~ /^d (.*)$/o ) {
        my $dir = $1;
        $cur_file = "";
        return if $dir =~ /^\.$/o;
        if ( $dir =~ /^\.\.$/o ) {
            $cur_dir =~ s|^(.*?)/[^/]+$|$1|;
            $cur_dir = "/" if $cur_dir =~ /^$/o;
            populate_fs( $l, $cur_dir );
        }
        else {
            if ( $cur_dir =~ m|^/$|o ) {
                $cur_dir .= "$dir";
            } else {
                $cur_dir .= "/$dir";
            }
            populate_fs( $l, $cur_dir );
        }
    } else {
        $cur_file = $sel;
        $cur_file =~ s/^[l ] (.*)$/$1/o;
    }
}


################################################################

sub populate_fs {
    my ( $list, $dir ) = @_;

    $list->delete( 0, 'end' );
    my @ls = `ls -a $dir`;
    for ( @ls ) {
        chomp;
        next unless -d "$dir/$_";
        $list->insert( 'end', "d $_" );
        undef $_;
    }

    for ( @ls ) {
        $list->insert( 'end', "  $_" ) if defined;
    }
}

1;
