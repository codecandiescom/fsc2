#!/usr/bin/perl
# -*- cperl -*-
#
# Copyright (C) 1999-2009 Jens Thoms Toerring
#
# This file is part of fsc2.
#
# Fsc2 is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# Fsc2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with fsc2; see the file COPYING.  If not, write to
# the Free Software Foundation, 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.


use strict;
use warnings;
use Tk;
use Tk::Balloon;
use Tk::Dialog;


my @version = split /\./, $Tk::VERSION;
die "Installed Perl-Tk version is $Tk::VERSION but Tk800.022 is required.\n"
    if $version[ 0 ] + 0.001 * $version[ 1 ] < 800.022;


########################################################################

my $sm_exp_time = 0.1;       # single window mode exp time
my $sm_N_scans = 1;          # single window mode number of runs
my $rm_exp_time = 0.1;       # realtime mode exp time
my $geom = get_defs( );

# This variable is the minimum distance a wavenumber may have from the laser
# line. In most cases the user is getting asked if he really wants to
# continue if he tries to use one that's nearer (the script for setting up
# the ROI and binning does not accept them at all).

my $Min_Dist = 200.0;                  # in cm^-1


$SIG{ CHLD } = sub { };

create_gui( $geom );
MainLoop;


#############################################

sub create_gui {

	my @f;
	my @b;
	my %fp = ( '-side' => 'top',
			   '-fill' => 'x',
			   '-padx' => '2m',
			   '-pady' => '2m' );

	my $mw = MainWindow->new( );
	$mw->title( "SPEX" );
	$mw->geometry( $geom ) if defined $geom;

	$f[ 0 ] = $mw->Frame( );
	$b[ 0 ] = $f[ 0 ]->Button( '-text' => "Single-Window Measurement" );
	$b[ 1 ] = $f[ 0 ]->Button( '-text' => "Realtime Mode" );
	$b[ 2 ] = $f[ 0 ]->Button( '-text' => "ROI & Binning" );
	$b[ 3 ] = $f[ 0 ]->Button( '-text' => "Calibration" );
	$b[ 4 ] = $f[ 0 ]->Button( '-text' => "Center position" );
	$b[ 5 ] = $f[ 0 ]->Button( '-text' => "Laser Line" );
	$b[ 6 ] = $f[ 0 ]->Button( '-text' => "CCD Temperture" );

	$f[ 1 ] = $mw->Frame(  );
	$b[ 7 ] = $f[ 1 ]->Button( '-text' => "Quit",
							   '-command' =>
							   	   sub { $mw->geometry=~ /^\d+x\d+(.*)$/;
									     store_defs( $1 );
									     $mw->destroy } );

	$b[ 0 ]->configure( '-command' =>
						sub { Single_Measurement::run( $mw,\$sm_exp_time,
													   \$sm_N_scans,
													   $b[ 0 ]->geometry ) } );
	$b[ 1 ]->configure( '-command' =>
						sub { Realtime::run( $mw, \$rm_exp_time,
											 $b[ 1 ]->geometry ) } );
	$b[ 2 ]->configure( '-command' => sub { ROI_Bin::run( $mw ); } );
	$b[ 3 ]->configure( '-command' => sub { Calibration::run( $mw ); } );
	$b[ 4 ]->configure( '-command' =>
						sub { Center_Line::run( $mw, $b[ 4 ]->geometry ); } );
	$b[ 5 ]->configure( '-command' =>
						sub { Laser_Line::run( $mw, $b[ 4 ]->geometry ); } );
	$b[ 6 ]->configure( '-command' => sub { Temperature::run( $mw ); } );

	$f[ 0 ]->pack( %fp );
	$f[ 1 ]->pack( %fp );
	$_->pack( %fp ) foreach @b;
}


#############################################

sub get_defs {

	my ( $f, $ne, $geom );


	if ( $ARGV[ 0 ] ) {
		open $f, '<', $ARGV[ 0 ] or return;
	} else {
		open $f, '<', "$ENV{ HOME }/.fsc2/spex_cam" or return;
	}

	goto done_reading unless defined( $ne = <$f> ) and $ne =~ /^#/;
	goto done_reading unless defined( $ne = <$f> )
		and $ne =~ /^([+-]\d+[+-]\d+)$/;
	$geom = $1;
	goto done_reading unless defined( $ne = <$f> ) and
		$ne =~ /^(\d+)?\.?(\d+)?([Ee]\+?(\d+)?)?$/;
	chomp $ne;
	$sm_exp_time = $ne;
	goto done_reading unless defined( $ne = <$f> ) and
		$ne =~ /^(\d+)$/;
	chomp $ne;
	$sm_N_scans = $ne;
	goto done_reading unless defined( $ne = <$f> ) and
		$ne =~ /^(\d+)?\.?(\d+)?([Ee]\+?(\d+)?)?$/;
	chomp $ne;
	$rm_exp_time = $ne;

  done_reading:
	close $f;
	return $geom;
}


#############################################

sub store_defs {
	my $geom = shift;

	mkdir "$ENV{ HOME }/.fsc2", 0777 unless -e "$ENV{ HOME }/.fsc2";
	open my $f, '>', "$ENV{ HOME }/.fsc2/spex_cam or return;
	$geom = "+0+0" unless defined $geom and $geom =~ /^[-+]\d+[-+]\d+$/;
	print $f <<EOF;
# Do not edit - created automatically!
$geom
$sm_exp_time
$sm_N_scans
$rm_exp_time
EOF
	close $f;
}



#############################################
# Package for displaying the temperature of the CCD camera
#############################################

package Temperature;

sub run {
	my $top = shift;
    my $fh;

	$top->withdraw;

    unless ( open $fh, '|-', 'fsc2_start -w' ) {
		Tools::show_message( $top, "Can't start fsc2" );
		$top->deiconify;
		return;
	}

    print $fh <<EOF;
DEVICES:
rs_spec10;

VARIABLES:
I = 1;
temp;

PREPARATIONS:
init_1d( 1, "", "Temperature [K]" );

EXPERIMENT:
FOREVER {
	temp =  ccd_camera_temperature( );
	print( "# K (# C)\\n", temp, K_to_C( temp ) );
	display_1d( I, temp );
	I += 1;
	wait( 1 s );
}
EOF

    close $fh;

    my $text;
    if ( $? != 0 ) {
        if ( $? >> 8 == 255 ) {
            $text = "Internal error.";
        } elsif ( $? >> 8 == 1 ) {
            $text = "Someone else is running fsc2.";
        } elsif ( $? >> 8 == 2 ) {
            $text = "fsc2 is already testing or\nrunning an experiment.";
        } elsif ( $? >> 8 == 3 ) {
            $text = "Internal error of fsc2.";
        } elsif ( $? >> 8 == 4 ) {
            $text = "Could not start fsc2.";
        } else {
            $text = "Something strange\nis going on here.";
        }

        show_message( $top, $text ) if $? >> 8 != 0;
    }

	$top->deiconify;
}


1;


#############################################
# Package for determining and setting the laser line
# position for the SPEX CD2A monochromator
#############################################

package Laser_Line;

use Tk;
use strict;
use warnings;
use File::Temp ':mktemp';
use IO::Handle;

sub run {
	my ( $top, $geom ) = @_;
	my $ll = Tools::get_laser_line( $top );
	return unless defined $ll;

	$top->withdraw;

	my @f;
	my %fp = ( -side => 'top',
			   -fill => 'x',
			   -padx => '2m',
			   -pady => '2m' );
	my %wp = ( -side => 'left',
			   -fill => 'x',
			   -expand => 1 );
	my %up = ( -side => 'left' );

	$f[ 0 ] = $top->Toplevel( '-title' => 'Laser Line' );
	$f[ 1 ] = $f[ 0 ]->Frame( );
	$f[ 2 ] = $f[ 1 ]->Label( -text => "Laser line:  " );
	$f[ 3 ] = $f[ 1 ]->Entry( -textvariable => \$ll );
	$f[ 4 ] = $f[ 1 ]->Label( -text => "  cm^-1" );

	$f[ 5 ] = $f[ 0 ]->Frame( );
	$f[ 6 ] = $f[ 5 ]->Button( -text => "Apply",
							   -command => sub { set_line( $top, $ll );
												 $top->deiconify;
												 $f[ 0 ]->destroy; } );
	$f[ 7 ] = $f[ 5 ]->Button( -text => "Quit",
							   -command => sub { $top->deiconify;
												 $f[ 0 ]->destroy; } );

	$f[ 1 ]->pack( %fp );
	$f[ 2 ]->pack( %wp );
	$f[ 3 ]->pack( %wp );
	$f[ 4 ]->pack( %up );
	$f[ 5 ]->pack( -side => "bottom",
				   -fill => "x",
				   -padx => "4m" );
	$f[ 6 ]->pack( %wp, -padx => '5m', -pady => '3m' );
	$f[ 7 ]->pack( %wp, -padx => '5m', -pady => '3m' );

	# New window should appear on top of the button that started it

	if ( defined $geom ) {
		$f[ 0 ]->raise;
		$top->geometry =~ /^(\d+)x(\d)+([+-]\d+)([+-]\d+)$/;
		my ( $tw, $th, $tx, $ty ) = ( $1, $2, $3, $4 );
		$f[ 0 ]->geometry =~ /^(\d+)x(\d+)[+-]\d+[+-]\d+$/;
		my ( $fw, $fh ) = ( $f[ 0 ]->width, $f[ 0 ]->height );
		$geom =~ /^\d+x\d+([+-]\d+)([+-]\d+)/;
		my ( $bx, $by ) = ( $1, $2 );
		my $nx = $tx - int( ( $tw - $fw ) / 2 );
		my $ny = $ty + $by;
		$geom = sprintf "%+d%+d", $nx, $ny;
		$f[ 0 ]->geometry( $geom );
	 }

	# Add a validation handler for the data in the entry field

	$f[ 3 ]->configure( -validate => 'key',
						-vcmd => sub{ ll_valid( shift, $f[ 6 ] ) } );

	# Focus should be in the entry field and cursor after the last character

	$f[ 3 ]->focus;
	$f[ 3 ]->icursor( 'end' );

	MainLoop;
}


#############################################
# Function for checking if a laser line value is valid - it accepts only
# characters that can be parts of a (non-negative) floating point values
# and disables the "Apply" button of the form unless te complete string
# makes up a non-negative floating point number.

sub ll_valid {
	my ( $new, $start_button ) = @_;
    my $float_rep = '((\d+(\.(\d+)?)?)|(\.\d+))([eE]\+?\d+)?';

    if ( $new =~ /^$float_rep$/ ) {
		$start_button->configure( -state => 'normal' );
        return 1;
    }

    if ( $new =~ /^(\d+)?\.?(\d+)?([Ee]\+?(\d+)?)?$/ ) {
         $start_button->configure( -state => 'disabled' );
         return 1;
     }

     return 0;
}


#############################################
# Function invokes fsc2 (in non-graphics mode) to set a new value of the
# laser line

sub set_line {
	my ( $top, $ll ) = @_;
	$ll = Tools::round( $ll, 3 );
	return unless Tools::is_laser_line_safe( $top, $ll );

	my ( $f, $fn ) = mkstemp( "/tmp/spex_cam.XXXXXX" );

	print $f <<EOF;
DEVICES:
spex232;
VARIABLES:
EXPERIMENT:
monochromator_laser_line( $ll cm^-1 );
EOF

	close $f;

	unless ( open $f, '-|', "fsc2 -ng $fn 2>&1" ) {
		close $f;
		unlink $fn;
		Tools::show_message( $top, "Can't start fsc2" );
		return;
	}

	my $reply = <$f>;
	close $f;
	unlink $fn;

	if ( defined $reply and $reply =~ /^F\s+spex232:\s+(.+)$/ ) {
		Tools::show_message( $top, "Can't set monochromators laser " .
							 "line:\n$1" );
	}
}


1;


#############################################
# Package for determining and setting the center position
# position for the SPEX CD2A monochromator
#############################################

package Center_Line;

use Tk;
use strict;
use warnings;
use File::Temp ':mktemp';
use IO::Handle;

sub run {
	my ( $top, $geom ) = @_;

	my $cwn = Tools::round( Tools::get_wavenumber( $top ), 3 );
	my $laser_line = Tools::get_laser_line( $top );
	my @limits = Tools::get_wavenumber_limits( $top );
	if ( $laser_line != 0.0 ) {
		my $x = $laser_line - $limits[ 0 ];
		$limits[ 0 ] = $laser_line - $limits[ 1 ];
		$limits[ 1 ] = $x;
	}
	@limits = map { Tools::round( $_, 3 ) } @limits;

	$top->withdraw;

	my @f;
	my %fp = ( -side => 'top',
			   -fill => 'x',
			   -padx => '2m',
			   -pady => '2m' );
	my %wp = ( -side => 'left',
			   -fill => 'x',
			   -expand => 1 );
	my %up = ( -side => 'left' );

	$f[ 0 ] = $top->Toplevel( '-title' => 'Center Position' );
	$f[ 1 ] = $f[ 0 ]->Frame( );
	$f[ 2 ] = $f[ 1 ]->Label( -text => "Center position:  " );
	$f[ 3 ] = $f[ 1 ]->Entry( -textvariable => \$cwn );
	my $balloon = $f[ 1 ]->Balloon( );
	$balloon->attach( $f[ 3 ],
					  -balloonmsg => "Range: $limits[0] - $limits[1] cm^-1" );
	$f[ 4 ] = $f[ 1 ]->Label( -text => "  cm^-1 " .
							  ( $laser_line != 0.0 ? "rel." : "abs." ) );

	$f[ 5 ] = $f[ 0 ]->Frame( );
	$f[ 6 ] = $f[ 5 ]->Button( -text => "Apply",
							   -command => sub { $f[ 0 ]->destroy;
												 set_cwn( $top, $cwn,
														  $laser_line );
												 $top->deiconify; } );
	$f[ 7 ] = $f[ 5 ]->Button( -text => "Quit",
							   -command => sub { $top->deiconify;
												 $f[ 0 ]->destroy; } );

	$f[ 1 ]->pack( %fp );
	$f[ 2 ]->pack( %wp );
	$f[ 3 ]->pack( %wp );
	$f[ 4 ]->pack( %up );
	$f[ 5 ]->pack( -side => "bottom",
				   -fill => "x",
				   -padx => "4m" );
	$f[ 6 ]->pack( %wp, -padx => '5m', -pady => '3m' );
	$f[ 7 ]->pack( %wp, -padx => '5m', -pady => '3m' );

	# New window should appear on top of the button that started it

	if ( defined $geom ) {
		$f[ 0 ]->raise;
		$top->geometry =~ /^(\d+)x(\d)+([+-]\d+)([+-]\d+)$/;
		my ( $tw, $th, $tx, $ty ) = ( $1, $2, $3, $4 );
		$f[ 0 ]->geometry =~ /^(\d+)x(\d+)[+-]\d+[+-]\d+$/;
		my ( $fw, $fh ) = ( $f[ 0 ]->width, $f[ 0 ]->height );
		$geom =~ /^\d+x\d+([+-]\d+)([+-]\d+)/;
		my ( $bx, $by ) = ( $1, $2 );
		my $nx = $tx - int( ( $tw - $fw ) / 2 );
		my $ny = $ty + $by;
		$geom = sprintf "%+d%+d", $nx, $ny;
		$f[ 0 ]->geometry( $geom );
	 }

	# Add a validation handler for the data in the entry field

	$f[ 3 ]->configure( -validate => 'key',
						-vcmd => sub{ cwn_valid( shift, $f[ 6 ], @limits ) } );

	# Focus should be in the entry field and cursor after the last character

	$f[ 3 ]->focus;
	$f[ 3 ]->icursor( 'end' );

	MainLoop;
}


#############################################
# Function for setting a new center position for the monochromator

sub set_cwn {
	my ( $top, $cwn, $laser_line ) = @_;

	Tools::is_laser_line_safe( $top, $laser_line, $cwn ) or return;

	my ( $f, $fn ) = mkstemp( "/tmp/spex_cam.XXXXXX" );

	print $f <<EOF;
DEVICES:
spex232;
EXPERIMENT:
monochromator_wavenumber( $cwn cm^-1 );
EOF

	close $f;

	unless ( open $f, '-|', "fsc2 -ng $fn 2>&1" ) {
		close $f;
		unlink $fn;
		Tools::show_message( "Can't start fsc2" );
		return;
	}

	my $reply = <$f>;
	close $f;
	unlink $fn;

	if ( defined $reply ) {
		Tools::show_message( "Can't set monochromators center position " .
							 "line:\n$reply" );
		return 0;
	}

	return 1;
}


#############################################
# Function for checking if a center line value is valid - it accepts only
# strings that can be taken to be floating point values and disables the
# "Apply" button of the form if the value isn't within the range of values
# the center line can be set to.

sub cwn_valid {
	my ( $new, $start_button, @limits ) = @_;
    my $float_rep = '-?((\d+(\.(\d+)?)?)|(\.\d+))([eE]\+?\d+)?';

    if ( $new =~ /^$float_rep$/ ) {
		if ( $new < $limits[ 0 ] or $new > $limits[ 1 ] ) {
            $start_button->configure( -state => 'disabled' );
        } else {
            $start_button->configure( -state => 'normal' );
        }
        return 1;
    }

    if ( $new =~ /^-?(\d+)?\.?(\d+)?([Ee]\+?(\d+)?)?$/ ) {
         $start_button->configure( -state => 'disabled' );
         return 1;
     }

     return 0;
}


1;


#############################################
# Package for determining the monochromator
# offset and the width of a camera pixel
#############################################

package Calibration;

use Tk;
use strict;
use warnings;


sub run {
	my $top = shift;
	my $fh;

	$top->withdraw;

    unless ( open $fh, '|-', 'fsc2_start -w' ) {
		Tools::show_message( $top, "Can't start fsc2" );
		return;
	}

	print $fh <<EOF;
DEVICES:

spex232;
rs_spec10;

VARIABLES:

cwn;
ll;
ROI[ 4 ] = ccd_camera_roi( );
BIN[ 2 ] = ccd_camera_binning( );
ccd_size[ 2 ] = ccd_camera_pixel_area( );

exposure_time = $rm_exp_time s;
NUM_Points = ( ROI[ 3 ] - ROI[ 1 ] + 1 ) / BIN[ 1 ];
lpos = 0.5 * ( ccd_size[ 1 ] - ROI[ 1 ] + 1 ) / BIN[ 1 ] + 0.5;
new;
Spec[ * ];
lambda[ * ] = { 1, 2 };        // wavelengths of the lines
pos[ * ] = { 1, 2 };           // positions of the lines in pixels, counting
                               // from the left border of the camera chip
LP_count = 0;
L_count = 1;
P_count = 1;
pixel_diff;                    // wavelength difference between two pixels of
                               // the camera chip
lambda_center;                 // assumed wavelength at center of the chip
delta_lambda_theo;             // theoretical deviation between wavelength
                               // center of chip and CoG of the lines
delta_lambda_exp;              // observed deviation between wavelength at
                               // center of chip  and CoG of the lines
                               // (using the wavelength difference between
                               // pixels of the chip)
center_dev;
xm, lm;
B_wn, B_et, B_gs, B_lpos, B_conf, B_pd, B_cd, B_acc = -1;
I;

PREPARATIONS:

init_1d( 1, NUM_Points,
		 BIN[ 1 ] == 1 ? "Position [pixel]" : "Position [pixel (binned)]",
		 "Counts" );

EXPERIMENT:

lambda_center = monochromator_wavelength( );
cwn = monochromator_wavenumber( );
ll = monochromator_laser_line( );

hide_toolbox( "ON" );
B_wn = input_create( "FLOAT_INPUT", cwn, "Expected line position [cm^-1" +
                     ( ll == 0 cm^-1 ? " abs.]" : " rel.]" ), "", "%.3f" );
B_et = input_create( "FLOAT_INPUT", exposure_time, "Exposure time [s]" );
B_gs = button_create( "NORMAL_BUTTON", "Get spectrum" );
B_lpos = input_create( "FLOAT_INPUT", lpos, "Observed line position [pixel]",
                       "", "%.4f" );
B_conf  = button_create( "NORMAL_BUTTON", "Accept line position" );
hide_toolbox( "OFF" );

Spec = spike_remove( ccd_camera_get_spectrum( ) );
display( 1, Spec );

FOREVER {

	IF ! toolbox_changed( ) {
		wait( 0.2 s );
		NEXT;
	}

	IF toolbox_changed( B_wn ) {
		new = input_value( B_wn );
		IF ll != 0 cm^-1 {
			new = ll - new;
		}
		L_count = 1;
		FOR I = 1 : LP_count {
			IF lambda[ I ] != WN_to_WL( new ) {
				L_count += 1;
			}
		}
		object_enable( B_conf, L_count == LP_count + 1 AND L_count == P_count ?
					   "ON" : "OFF" );
	}

   	IF toolbox_changed( B_et ) {
       	new = input_value( B_et );
       	IF new == exposure_time OR new < 1 us OR new > 3600 s {
           	input_value( B_et, exposure_time );
           	NEXT;
       	}

       	exposure_time = new;
		ccd_camera_exposure_time( exposure_time );
		Spec = spike_remove( ccd_camera_get_spectrum( ) );
		display_1d( 1, Spec );
   	}

    IF button_state( B_gs ) {
		Spec = spike_remove( ccd_camera_get_spectrum( ) );
		display_1d( 1, Spec );
    }

	IF toolbox_changed( B_lpos ) {
		new = input_value( B_lpos );
		IF new < 1 | new > NUM_Points {
			input_value( B_lpos, lpos );
			object_enable( B_conf, "OFF" );
			NEXT;
		}

		P_count = 1;
		FOR I = 1 : LP_count {
			IF pos[ I ] != new {
				P_count += 1;
			}
		}
		object_enable( B_conf, P_count == LP_count + 1 AND L_count == P_count ?
					   "ON" : "OFF" );
		lpos = new;
        clear_marker( );
		draw_marker_1d( round( new ) );
	}

	IF button_state( B_conf ) {
		LP_count += 1;

        /* Convert the position of the lines the user entered to positions
         * in pixels (relative to the left-most pixel on the chip without
         * binning or ROI) */

		pos[ LP_count ] = input_value( B_lpos ) * BIN[ 1 ]
                          + 0.5 * ( BIN[ 1 ] - 1 ) + ROI[ 1 ] - 1;

        /* ...and convert the (absolute or relative) wavenumbers for the lines
         *  to wavelengths (in nm) */

		IF ll == 0 cm^-1 {
			lambda[ LP_count ] = WN_to_WL( input_value( B_wn ) );
		} ELSE {
			lambda[ LP_count ] = WN_to_WL( ll - input_value( B_wn ) );
		}

        clear_marker( );
		object_enable( B_conf, "OFF" );
		IF LP_count == 2 {
			BREAK;
		}
	}
}

/* Calculate the wavelength difference between two pixels on the chip (this
 * assumes that diffraction for a grating is linear in wavelength). */

pixel_diff = ( lambda[ 2 ] - lambda[ 1 ] ) / ( pos[ 2 ] - pos[ 1 ] );

/* Calculate the wavelength difference between the wavelength at the center
 * of the chip (that's where the light with the wavelength the monochromator
 * is set to is supposed to arrive) and the wavelength of the "center of
 * gravity" of the lines the user used for the calibration. */

delta_lambda_theo = lambda_center - 0.5 * ( lambda[ 1 ] + lambda[ 2 ] );

/* Now calculate difference between the center pixel position on the chip and
 * the "center of gravity" of the positions the user observed. This gets
 * multiplied by the wavelength difference between to pixels on the chip to
 * arrive at an "observed" wavelength difference.*/

delta_lambda_exp  = 0.5 * pixel_diff
                    * ( ccd_size[ 1 ] + 1 - pos[ 1 ] - pos[ 2 ] );

/* The difference between the "theoretical" difference between the center and
 * the CoG of the lines used for the calibration and the "observed" difference
 * tells us how far off the wavelength at the center is from what we set at
 * the monochromator and thus how much we have to change the offset we use
 * for the monochromator. */

center_dev = delta_lambda_theo - delta_lambda_exp;

hide_toolbox( "ON" );
B_pd = output_create( "FLOAT_OUTPUT", pixel_diff / 1 nm,
                      "Pixel width [nm]" );
B_cd = output_create( "FLOAT_OUTPUT", center_dev / 1 nm,
                      "Center offset [nm]" );
B_acc = button_create( "PUSH_BUTTON", "Accept calibration" );
hide_toolbox( "OFF" );

FOREVER {
	IF ! toolbox_changed( ) {
		wait( 0.2 s );
		NEXT;
	}

	IF toolbox_changed( B_wn ) {
		new = input_value( B_wn );
		IF ll != 0 cm^-1 {
			new = ll - new;
		}
		L_count = 1;
		FOR I = 1 : LP_count {
			IF lambda[ I ] != WN_to_WL( new ) {
				L_count += 1;
			}
		}
		object_enable( B_conf, L_count == LP_count + 1 AND L_count == P_count ?
					   "ON" : "OFF" );
	}

   	IF toolbox_changed( B_et ) {
       	new = input_value( B_et );
       	IF new == exposure_time OR new < 1 us OR new > 3600 s {
           	input_value( B_et, exposure_time );
           	NEXT;
       	}
       	exposure_time = new;
		ccd_camera_exposure_time( exposure_time );
		Spec = spike_remove( ccd_camera_get_spectrum( ) );
		display_1d( 1, Spec );
   	}

    IF button_state( B_gs ) {
		Spec = spike_remove( ccd_camera_get_spectrum( ) );
		display_1d( 1, Spec );
    }

	IF toolbox_changed( B_lpos ) {
		new = input_value( B_lpos );
		IF new < 1 | new > NUM_Points {
			input_value( B_lpos, lpos );
			object_enable( B_conf, "OFF" );
			NEXT;
		}

		P_count = 1;
		FOR I = 1 : LP_count {
			IF pos[ I ] != new {
				P_count += 1;
			}
		}
		object_enable( B_conf, P_count == LP_count + 1 AND L_count == P_count ?
					   "ON" : "OFF" );
		lpos = new;
        clear_marker( );
		draw_marker_1d( round( new ) );
	}

	IF button_state( B_conf ) {
		LP_count += 1;
		pos[ LP_count ] = input_value( B_lpos ) * BIN[ 1 ]
                          + 0.5 * ( BIN[ 1 ] - 1 ) + ROI[ 1 ] - 1;
		IF ll == 0 cm^-1 {
			lambda[ LP_count ] = WN_to_WL( input_value( B_wn ) );
		} ELSE {
			lambda[ LP_count ] = WN_to_WL( ll - input_value( B_wn ) );
		}

		object_enable( B_conf, "OFF" );
        clear_marker( );

		pixel_diff = 0 nm;
		FOR I = 2 : LP_count {
			pixel_diff +=   ( lambda[ I ] - lambda[ 1 ] )
                          / ( pos[ I ] - pos[ 1 ] );
		}
		pixel_diff /= LP_count - 1;

		xm = 0.0;
		lm = 0.0;
		FOR I = 1 : LP_count {
			xm += pos[ I ];
			lm += lambda[ I ];
		}
		xm /= LP_count;
		lm /= LP_count;

        delta_lambda_theo = lambda_center - lm;
        delta_lambda_exp  = pixel_diff * ( 0.5 * ( ccd_size[ 1 ] + 1 ) - xm );
        center_dev = delta_lambda_theo - delta_lambda_exp;

		output_value( B_pd, pixel_diff / 1 nm );
		output_value( B_cd, center_dev / 1 nm );
	}
}

ON_STOP:

IF B_acc != -1 AND button_state( B_acc ) {
	monochromator_calibrate( center_dev, pixel_diff );
}
EOF

	close $fh;

    my $text;
    if ( $? != 0 ) {
        if ( $? >> 8 == 255 ) {
            $text = "Internal error.";
        } elsif ( $? >> 8 == 1 ) {
            $text = "Someone else is running fsc2.";
        } elsif ( $? >> 8 == 2 ) {
            $text = "fsc2 is already testing or\nrunning an experiment.";
        } elsif ( $? >> 8 == 3 ) {
            $text = "Internal error of fsc2.";
        } elsif ( $? >> 8 == 4 ) {
            $text = "Could not start fsc2.";
        } else {
            $text = "Something strange\nis going on here.";
        }

        Tools::show_message( $top, $text ) if $? >> 8 != 0;
    }

	$top->deiconify;
}

1;


#############################################
# Package for interactively setting the ROI and binning
# parameters of the Roper Scientific Spec-10 CCD camera
#############################################

package ROI_Bin;

use strict;
use warnings;
use POSIX ":sys_wait_h";

sub run {
	my $top = shift;
    my $fh;

	$top->withdraw;

    unless ( open $fh, '|-', 'fsc2_start -w' ) {
		Tools::show_message( $top, "Can't start fsc2" );
		$top->deiconify;
		return;
	}

    print $fh <<EOF;
DEVICES:

spex232;
rs_spec10;

VARIABLES:

exposure_time = 0.1 s;
CCD_size[ 2 ] = ccd_camera_pixel_area( );
ROI[ 4 ] = ccd_camera_roi( );
BIN[ 2 ] = ccd_camera_binning( );
B_et, B_roi[ 4 ], B_bin[ 2 ], B_type[ 2 ], B_gi;
Image[ *, * ];
D_Im[ *, * ];
Spec[ * ];
New, new;
data[ * ];
I, J, K, L;
A[ 1, 1 ];

PREPARATIONS:

init_1d( 1, ( ROI[ 3 ] - ROI[ 1 ] + 1 ) / BIN[ 1 ],
		 BIN[ 1 ] == 1 ? "x pixel" : "x pixel (binned)", "Counts" );
init_2d( 1, ( ROI[ 3 ] - ROI[ 1 ] + 1 ) / BIN[ 1 ],
		 ( ROI[ 4 ] - ROI[ 2 ] + 1 ) / BIN[ 2 ],
		 BIN[ 1 ] == 1 ? "x pixel" : "x pixel (binned)",
		 BIN[ 2 ] == 1 ? "y pixel" : "y pixel (binned)", "Counts" );

EXPERIMENT:

ccd_camera_exposure_time( exposure_time );

hide_toolbox( "ON" );
B_et = input_create( "FLOAT_INPUT", exposure_time, "Exposure time [s]" );
B_roi[ 1 ] = input_create( "INT_INPUT", ROI[ 1 ], "ROI:  x-LLC" );
B_roi[ 2 ] = input_create( "INT_INPUT", ROI[ 2 ], "ROI:  y-LLC" );
B_roi[ 3 ] = input_create( "INT_INPUT", ROI[ 3 ],
             sprint( "ROI:  x-URC  (max. #)", CCD_size[ 1 ] ) );
B_roi[ 4 ] = input_create( "INT_INPUT", ROI[ 4 ],
             sprint( "ROI:  y-URC  (max. #)", CCD_size[ 2 ] ) );
B_bin[ 1 ] = input_create( "INT_INPUT", BIN[ 1 ], "x Binning factor" );
B_bin[ 2 ] = input_create( "INT_INPUT", BIN[ 2 ], "y Binning factor" );
B_type[ 1 ] = button_create( "RADIO_BUTTON", "Hardware binning" );
B_type[ 2 ] = button_create( "RADIO_BUTTON", B_type[ 1 ], "Software binning" );
IF ccd_camera_binning_method( ) {
	button_state( B_type[ 2 ], "ON" );
}
B_gi = button_create( "NORMAL_BUTTON", "Get image" );
object_enable( B_gi, "OFF" );
hide_toolbox( "OFF" );

Spec = ccd_camera_get_spectrum( );
display_1d( 1, Spec );
Image = ccd_camera_get_image( );
display_2d( 1, 1, Image );
object_enable( B_gi, "ON" );

FOREVER {

	IF ! toolbox_changed( ) {
		wait( 0.2 s );
		NEXT;
	}

   	IF toolbox_changed( B_et ) {
       	new = input_value( B_et );
       	IF new == exposure_time OR new < 1 us OR new > 3600 s {
           	input_value( B_et, exposure_time );
           	NEXT;
       	}

       	exposure_time = new;
		ccd_camera_exposure_time( exposure_time );
	}

	IF toolbox_changed( B_roi[ 1 ] ) {
		New = input_value( B_roi[ 1 ] );

		IF New < 1 {
			New = 1;
			input_value( B_roi[ 1 ], New )
		}

		IF New > ROI[ 3 ] - BIN[ 1 ]{
			input_value( B_roi[ 1 ], ROI[ 1 ] );
			NEXT;
		}

		ROI[ 1 ] = New;
		ROI[ 3 ] = ( ( ROI[ 3 ] - ROI[ 1 ] + 1 ) / BIN[ 1 ] )
				   * BIN[ 1 ] + ROI[ 1 ] - 1;
		IF ROI[ 3 ] < ROI[ 1 ] {
			ROI[ 3 ] = ROI[ 1 ] + BIN[ 1 ] + 1;
		}

		input_value( B_roi[ 3 ], ROI[ 3 ] );
		ccd_camera_roi( ROI );
	}

	IF toolbox_changed( B_roi[ 2 ] ) {
		New = input_value( B_roi[ 2 ] );

		IF New < 1 {
			New = 1;
			input_value( B_roi[ 2 ], New );
		}

		IF New > ROI[ 4 ] - BIN[ 2 ] {
			input_value( B_roi[ 2 ], ROI[ 2 ] );
			NEXT;
		}

		ROI[ 2 ] = New;
		ROI[ 4 ] = ( ( ROI[ 4 ] - ROI[ 2 ] + 1 ) / BIN[ 2 ] )
				   * BIN[ 2 ] + ROI[ 2 ] - 1;
		IF ROI[ 4 ] < ROI[ 2 ] {
			ROI[ 4 ] = ROI[ 2 ] + BIN[ 2 ] + 1;
		}

		input_value( B_roi[ 4 ], ROI[ 4 ] );
		ccd_camera_roi( ROI );
	}

	IF toolbox_changed( B_roi[ 3 ] ) {
		New = input_value( B_roi[ 3 ] );

		IF New > CCD_size[ 1 ] {
			New = CCD_size[ 1 ];
			input_value( B_roi[ 3 ], New );
		}

		IF New < ROI[ 1 ] + BIN[ 1 ] {
			input_value( B_roi[ 3 ], ROI[ 3 ] );
			NEXT;
		}

		ROI[ 3 ] = ( ( New - ROI[ 1 ] + 1 ) / BIN[ 1 ] )
				   * BIN[ 1 ] + ROI[ 1 ] - 1;
		input_value( B_roi[ 3 ], ROI[ 3 ] != ROI[ 1 ] ?
					 ROI[ 3 ] : ROI[ 1 ] + BIN[ 1 ] + 1 );
		ccd_camera_roi( ROI );
	}

	IF toolbox_changed( B_roi[ 4 ] ) {
		New = input_value( B_roi[ 4 ] );

		IF  New > CCD_size[ 2 ] {
			New = CCD_size[ 2 ];
			input_value( B_roi[ 4 ], New );
		}

		IF New < ROI[ 2 ] + BIN[ 2 ] {
			input_value( B_roi[ 4 ], ROI[ 4 ] );
			NEXT;
		}
		ROI[ 4 ] = ( ( New - ROI[ 2 ] + 1 ) / BIN[ 2 ] )
				   * BIN[ 2 ] + ROI[ 2 ] - 1;
		input_value( B_roi[ 4 ], ROI[ 4 ] != ROI[ 2 ] ?
					 ROI[ 4 ] : ROI[ 2 ] + BIN[ 2 ] + 1);
		ccd_camera_roi( ROI );
	}

	IF toolbox_changed( B_bin[ 1 ] ) {
		New = input_value( B_bin[ 1 ] );
		IF New < 1 OR New > ROI[ 3 ] - ROI[ 1 ] - 1 {
			input_value( B_bin[ 1 ], BIN[ 1 ] );
			NEXT;
		}

		BIN[ 1 ] = New;
	    ROI[ 3 ] = ( ( ROI[ 3 ] - ROI[ 1 ] + 1 ) / BIN[ 1 ] )
				   * BIN[ 1 ] + ROI[ 1 ] - 1;
		IF ROI[ 3 ] < ROI[ 1 ] {
			  ROI[ 3 ] = ROI[ 1 ] + BIN[ 1 ] + 1;
		  }
	    input_value( B_roi[ 3 ], ROI[ 3 ] );
		ccd_camera_roi( ROI );
		ccd_camera_binning( BIN, "HARDWARE" );
	}

	IF toolbox_changed( B_bin[ 2 ] ) {
		New = input_value( B_bin[ 2 ] );
		IF New < 1 OR New > ROI[ 4 ] - ROI[ 2 ] - 1 {
			input_value( B_bin[ 2 ], BIN[ 2 ] );
			NEXT;
		}

		BIN[ 2 ] = New;
		ROI[ 4 ] = ( ( ROI[ 4 ] - ROI[ 2 ] + 1 ) / BIN[ 2 ] )
				   * BIN[ 2 ] + ROI[ 2 ] - 1;
		IF ROI[ 4 ] < ROI[ 2 ] {
			ROI[ 4 ] = ROI[ 2 ] + BIN[ 2 ] + 1;
		}
		input_value( B_roi[ 4 ], ROI[ 4 ] );
		ccd_camera_roi( ROI );
		ccd_camera_binning( BIN, "HARDWARE" );
	}

	IF button_changed( B_type[ 1 ] ) {
		button_state( B_type[ 1 ] );
		ccd_camera_binning( BIN, "HARDWARE" );
	}

	IF button_changed( B_type[ 2 ] ) {
		button_state( B_type[ 2 ] );
		ccd_camera_binning( BIN, "SOFTWARE" );
	}

	IF button_state( B_gi ) {
		hide_toolbox( "ON" );
		clear_curve_1d( );
		Spec = ccd_camera_get_spectrum( );
		rescale_1d( ( ROI[ 3 ] - ROI[ 1 ] + 1 ) / BIN[ 1 ] );
		change_label_1d( BIN[ 1 ] == 1 ? "x pixel" : "x pixel (binned)" );
		display_1d( 1, Spec );
		clear_curve_2d( );
		Image = ccd_camera_get_image( );
		change_label_2d( BIN[ 1 ] == 1 ? "x pixel" : "x pixel (binned)",
						 BIN[ 2 ] == 1 ? "y pixel" : "y pixel (binned)" );
		rescale_2d( ( ROI[ 3 ] - ROI[ 1 ] + 1 ) / BIN[ 1 ],
					( ROI[ 4 ] - ROI[ 2 ] + 1 ) / BIN[ 2 ] );
		display_2d( 1, 1, Image );
		hide_toolbox( "OFF" );
	}
}
EOF

    close $fh;

    my $text;
    if ( $? != 0 ) {
        if ( $? >> 8 == 255 ) {
            $text = "Internal error.";
        } elsif ( $? >> 8 == 1 ) {
            $text = "Someone else is running fsc2.";
        } elsif ( $? >> 8 == 2 ) {
            $text = "fsc2 is already testing or\nrunning an experiment.";
        } elsif ( $? >> 8 == 3 ) {
            $text = "Internal error of fsc2.";
        } elsif ( $? >> 8 == 4 ) {
            $text = "Could not start fsc2.";
        } else {
            $text = "Something strange\nis going on here.";
        }

        Tools::show_message( $top, $text ) if $? >> 8 != 0;
    }

	$top->deiconify;
}

1;


#############################################
# Package for doing an experiment with the Roper Scientific Spec-10 CCD
# camera connected to the SPEX CD2A monochromator where the wavenumber
# position of the monochromator doesn't get changed (i.e. is set to the
# center of the spectrum to be measured).
#############################################

package Realtime;

use strict;
use warnings;
use Tk;


sub run {
	my ( $top, $exp_time, $geom ) = @_;

	my $cwl        = Tools::get_wavelength( $top );
	my $laser_line = Tools::get_laser_line( $top );
	my $pixel_diff = Tools::get_pixel_width( $top );
	my ( $roi_left, $roi_right, $bin, $num_pixel ) =
		                                    Tools::get_camera_settings( $top );

	$top->withdraw;

	if ( $pixel_diff <= 0.0 ) {
		Tools::show_message( $top, "Please do calibration first." );
		$top->deiconify;
		return;
	}

	if (    $roi_right <= $roi_left or $roi_left < 1 or $bin  < 1
		 or ( $roi_right - $roi_left + 1 ) % $bin != 0 ) {
		Tools::show_message( $top,
							"Please set ROI and binning parameters first." );
		$top->deiconify;
		return;
	}

	my $wl_start = $cwl + $pixel_diff
		           * (   0.5 * ( $bin - 1 ) + ( $roi_left - 1 )
					   - 0.5 * ( $num_pixel - 1 ) );
	my $wl_end = $wl_start + $pixel_diff * ( $roi_right - $roi_left );

	my %p;

	$p{ wn_center } = Tools::wl2wn( $cwl );
	$p{ wn_center } = $laser_line - $p{ wn_center } if $laser_line != 0.0;
	$p{ wn_width }  = Tools::wl2wn( $wl_start ) - Tools::wl2wn( $wl_end );
	$p{ wn_res }    = $bin * $p{ wn_width } / ( $roi_right - $roi_left + 1 );

	my @f;
	my %fp = ( -side => 'top',
			   -fill => 'x',
			   -padx => '2m',
			   -pady => '2m' );
	my %wp = ( -side => 'left',
			   -fill => 'x',
			   -expand => 1 );
	my %up = ( -side => 'left' );

	$$exp_time = Tools::round( $$exp_time, 6 );

	$f[ 0 ] = $top->Toplevel( '-title' => 'Realtime Mode' );

	$f[ 1 ] = $f[ 0 ]->Frame( );
	$f[ 2 ] = $f[ 1 ]->Label( -text => "Exposure time:",
							  -width => 20,
							  -anchor => 'w' );
	$f[ 3 ] = $f[ 1 ]->Entry( -textvariable => $exp_time,
							  -width => 10 );
	$f[ 4 ] = $f[ 1 ]->Label( -text => " s",
							  -width => 9 );

	$f[ 5 ] = $f[ 0 ]->Frame( );
	$f[ 6 ] = $f[ 5 ]->Label( -text => "Wavenumber:",
							  -width => 20,
							  -anchor => 'w' );
	$f[ 7 ] = $f[ 5 ]->Label( -text => Tools::round( $p{ wn_center }, 3 ),
							  -width => 10,
							  -anchor => 'w' );
	$f[ 8 ] = $f[ 5 ]->Label( -text => " cm^-1 " .
							  ( $laser_line == 0.0 ? "abs." : "rel." ),
							  -width => 9 );

	$f[  9 ] = $f[ 0 ]->Frame( );
	$f[ 10 ] = $f[ 9 ]->Label( -text => "Spectral width:",
							   -width => 20,
							   -anchor => 'w' );
	$f[ 11 ] = $f[ 9 ]->Label( -text => Tools::round( $p{ wn_width }, 3 ),
							   -width => 10,
							   -anchor => 'w' );
	$f[ 12 ] = $f[ 9 ]->Label( -text => " cm^-1",
							   -width => 9 );

	$f[ 13 ] = $f[  0 ]->Frame( );
	$f[ 14 ] = $f[ 13 ]->Label( -text => "Spectral resolution:",
								-width => 20,
								-anchor => 'w' );
	$f[ 15 ] = $f[ 13 ]->Label( -text => 'ca. ' .
								         Tools::round( $p{ wn_res }, 3 ),
								-width => 10,
								-anchor => 'w' );
	$f[ 16 ] = $f[ 13 ]->Label( -text => " cm^-1",
								-width => 9 );


	$f[ 17 ] = $f[ 0 ]->Frame( );
	$f[ 18 ] = $f[ 17 ]->Button( -text => "Start measurement",
								 -command => sub { $f[ 0 ]->withdraw;
												   $f[ 0 ]->destroy;
												   realtime_run( $top,
																 $exp_time,
																 %p );
												   $top->deiconify; } );
	$f[ 19 ] = $f[ 17 ]->Button( -text => "Quit",
								 -command => sub { $f[ 0 ]->destroy;
												   $top->deiconify; } );

	$f[ 1 ]->pack( %fp );
	$f[ 2 ]->pack( %wp );
	$f[ 3 ]->pack( %wp );
	$f[ 4 ]->pack( %up );

	$f[ 5 ]->pack( %fp );
	$f[ 6 ]->pack( %wp );
	$f[ 7 ]->pack( %wp );
	$f[ 8 ]->pack( %up );

	$f[  9 ]->pack( %fp );
	$f[ 10 ]->pack( %wp );
	$f[ 11 ]->pack( %wp );
	$f[ 12 ]->pack( %up );

	$f[ 13 ]->pack( %fp );
	$f[ 14 ]->pack( %wp );
	$f[ 15 ]->pack( %wp );
	$f[ 16 ]->pack( %up );

	$f[ 17 ]->pack( -side => "bottom",
				   -fill => "x",
				   -padx => "4m" );
	$f[ 18 ]->pack( %wp, -padx => '5m', -pady => '3m' );
	$f[ 19 ]->pack( %wp, -padx => '5m', -pady => '3m' );

	# Add validation handlers for the data in the entry fields

	$f[ 3 ]->configure( -validate => 'key',
						-vcmd => sub { exp_time_check( shift,
														$f[ 18 ] ); } );

	# Focus should be in the entry field and cursor after the last character

	$f[ 3 ]->focus;
	$f[ 3 ]->icursor( 'end' );

	# New window should appear on top of the button that started it

	if ( defined $geom ) {
		$f[ 0 ]->raise;
		$top->geometry =~ /^(\d+)x(\d)+([+-]\d+)([+-]\d+)$/;
		my ( $tw, $th, $tx, $ty ) = ( $1, $2, $3, $4 );
		$f[ 0 ]->geometry =~ /^(\d+)x(\d+)[+-]\d+[+-]\d+$/;
		my ( $fw, $fh ) = ( $f[ 0 ]->width, $f[ 0 ]->height );
		$geom =~ /^\d+x\d+([+-]\d+)([+-]\d+)/;
		my ( $bx, $by ) = ( $1, $2 );
		my $nx = $tx - int( ( $tw - $fw ) / 2 );
		my $ny = $ty + $by;
		$geom = sprintf "%+d%+d", $nx, $ny;
		$f[ 0 ]->geometry( $geom );
	 }

	MainLoop;
}


#############################################
# Checks for input in the experiment time field

sub exp_time_check {
	my ( $new, $start_button ) = @_;
    my $float_rep = '(((\d+(\.(\d+)?)?)|(\.\d+))([eE]([+-]?\d*)?)?)';

	return 0 unless $new ne "" or $new =~ /^($float_rep)?$/;

	if ( $new eq "" or $new < 1.0e-6 or $new > 3600 ) {
		$start_button->configure( -state => 'disabled' );
	} else {
		$start_button->configure( -state => 'normal' );
	}

	return 1;
}


#############################################
# Runs the actual experiment

sub realtime_run {
	my ( $top, $exp_time, %p ) = @_;

	my $fh;

    unless ( open $fh, '|-', 'fsc2_start -w' ) {
		Tools::show_message( $top, "Can't start fsc2" );
		return;
	}

    print $fh <<EOF;
DEVICES:

spex232;
rs_spec10;


VARIABLES:

exposure_time = $$exp_time s;
laser_line;
spec[ * ];
B_rel,B_abs, B_wl;
I, J;
axis[ 4 ];

PREPARATIONS:

init_1d( 1 );

EXPERIMENT:

ccd_camera_exposure_time( exposure_time );
laser_line = monochromator_laser_line( );

hide_toolbox( 1 );

B_wl  = button_create( "RADIO_BUTTON", "Wavelengths" );
B_abs = button_create( "RADIO_BUTTON", B_wl, "Absolute wavenumbers" );
change_label_1d( "Wavelength [nm]" );
IF laser_line != 0.0 {
	B_rel = button_create( "RADIO_BUTTON", B_wl, "Relative wavenumbers" );
}
axis = monochromator_wavelength_axis( );
change_scale( axis[ 3 ] / 1 nm, axis[ 4 ] / 1 nm );

hide_toolbox( 0 );

FOREVER {
	spec = spike_remove( ccd_camera_get_spectrum( ) );
	display_1d( 1, spec );

	IF ! toolbox_changed( ) {
		NEXT;
	}

	IF button_state( B_wl ) {
		change_label_1d( "Wavelength [nm]" );
        axis = monochromator_wavelength_axis( );
        change_scale( axis[ 3 ] / 1 nm, axis[ 4 ] / 1 nm );
	}

	IF button_state( B_abs ) {
		change_label_1d( "Wavenumbers [cm^-1 abs.]" );
		axis = monochromator_wavenumber_axis( );
		change_scale( axis[ 3 ], axis[ 4 ] );
	}

	IF laser_line != 0.0 AND button_state( B_rel ) {
		change_label_1d( "Wavenumbers [cm^-1 rel.]" );
		axis = monochromator_wavenumber_axis( );
		change_scale( laser_line - axis[ 3 ], - axis[ 4 ] );
	}
}
EOF
    close $fh;

    my $text;
    if ( $? != 0 ) {
        if ( $? >> 8 == 255 ) {
            $text = "Internal error.";
        } elsif ( $? >> 8 == 1 ) {
            $text = "Someone else is running fsc2.";
        } elsif ( $? >> 8 == 2 ) {
            $text = "fsc2 is already testing or\nrunning an experiment.";
        } elsif ( $? >> 8 == 3 ) {
            $text = "Internal error of fsc2.";
        } elsif ( $? >> 8 == 4 ) {
            $text = "Could not start fsc2.";
        } else {
            $text = "Something strange\nis going on here.";
        }

        Tools::show_message( $top, $text ) if $? >> 8 != 0;
    }
}


1;


#############################################
# Package for doing an experiment with the Roper Scientific Spec-10 CCD
# camera connected to the SPEX CD2A monochromator where the wavenumber
# position of the monochromator doesn't get changed (i.e. is set to the
# center of the spectrum to be measured).
#############################################

package Single_Measurement;

use strict;
use warnings;
use Tk;


sub run {
	my ( $top, $exp_time, $N_scans, $geom ) = @_;

	my $cwl        = Tools::get_wavelength( $top );
	my $laser_line = Tools::get_laser_line( $top );
	my $pixel_diff = Tools::get_pixel_width( $top );
	my ( $roi_left, $roi_right, $bin, $num_pixel ) =
		                                    Tools::get_camera_settings( $top );

	$top->withdraw;

	if ( $pixel_diff <= 0.0 ) {
		Tools::show_message( $top, "Please do a calibration first." );
		$top->deiconify;
		return;
	}

	if (    $roi_right <= $roi_left or $roi_left < 1 or $bin  < 1
		 or ( $roi_right - $roi_left + 1 ) % $bin != 0 ) {
		Tools::show_message( $top,
							"Please set ROI and binning parameters first." );
		$top->deiconify;
		return;
	}

	my $wl_start = $cwl + $pixel_diff
		           * (   0.5 * ( $bin - 1 ) + ( $roi_left - 1 )
					   - 0.5 * ( $num_pixel - 1 ) );
	my $wl_end = $wl_start + $pixel_diff * ( $roi_right - $roi_left );

	my %p;

	$p{ wn_center } = Tools::wl2wn( $cwl );
	$p{ wl_res }    = $pixel_diff * $bin;
	$p{ wn_center } = $laser_line - $p{ wn_center } if $laser_line != 0.0;
	$p{ wn_width }  = Tools::wl2wn( $wl_start ) - Tools::wl2wn( $wl_end );
	$p{ wn_res }    = $bin * $p{ wn_width } / ( $roi_right - $roi_left + 1 );

	$$exp_time = Tools::round( $$exp_time, 6 );

	my @f;
	my %fp = ( -side => 'top',
			   -fill => 'x',
			   -padx => '2m',
			   -pady => '2m' );
	my %wp = ( -side => 'left',
			   -fill => 'x',
			   -expand => 1 );
	my %up = ( -side => 'left' );

	$f[ 0 ] = $top->Toplevel( '-title' => 'Single-Window Measurement' );

	$f[ 1 ] = $f[ 0 ]->Frame( );
	$f[ 2 ] = $f[ 1 ]->Label( -text => "Exposure time:",
							  -width => 20,
							  -anchor => 'w' );
	$f[ 3 ] = $f[ 1 ]->Entry( -textvariable => $exp_time,
							  -width => 10 );
	$f[ 4 ] = $f[ 1 ]->Label( -text => " s",
							  -width => 9 );

	$f[ 5 ] = $f[ 0 ]->Frame( );
	$f[ 6 ] = $f[ 5 ]->Label( -text => "Number of scans:",
							  -width => 20,
							  -anchor => 'w' );
	$f[ 7 ] = $f[ 5 ]->Entry( -textvariable => $N_scans,
							  -width => 10 );
	$f[ 8 ] = $f[ 5 ]->Label( -text => "",
							  -width => 9 );
	$f[  9 ] = $f[ 0 ]->Frame( );
	$f[ 10 ] = $f[ 9 ]->Label( -text => "Wavenumber:",
							   -width => 20,
							   -anchor => 'w' );
	$f[ 11 ] = $f[ 9 ]->Label( -text => Tools::round( $p{ wn_center }, 3 ),
							   -width => 10 );
	$f[ 12 ] = $f[ 9 ]->Label( -text => " cm^-1 " .
							  ( $laser_line != 0 ? "rel." : "abs." ),
							   -width => 9 );

	$f[ 13 ] = $f[ 0 ]->Frame( );
	$f[ 14 ] = $f[ 13 ]->Label( -text => "Spectral width:",
								-width => 20,
								-anchor => 'w' );
	$f[ 15 ] = $f[ 13 ]->Label( -text => Tools::round( $p{ wn_width }, 3 ),
							  -width => 10,
							  -anchor => 'w' );
	$f[ 16 ] = $f[ 13 ]->Label( -text => " cm^-1",
							  -width => 9 );

	$f[ 17 ] = $f[ 0 ]->Frame( );
	$f[ 18 ] = $f[ 17 ]->Label( -text => "Spectral resolution:",
								-width => 20,
								-anchor => 'w' );
	$f[ 19 ] = $f[ 17 ]->Label( -text => 'ca. ' .
								         Tools::round( $p{ wn_res }, 3 ),
								-width => 10,
								-anchor => 'w' );
	$f[ 20 ] = $f[ 17 ]->Label( -text => " cm^-1",
								-width => 9 );


	$f[ 21 ] = $f[ 0 ]->Frame( );
	$f[ 22 ] = $f[ 21 ]->Button( -text => "Start measurement",
								 -command => sub { $f[ 0 ]->withdraw;
												   $f[ 0 ]->destroy;
												   single_run( $top, $N_scans,
															   $exp_time, %p );
												   $top->deiconify; } );
	$f[ 23 ] = $f[ 21 ]->Button( -text => "Quit",
								 -command => sub { $f[ 0 ]->destroy;
												   $top->deiconify; } );

	$f[ 1 ]->pack( %fp );
	$f[ 2 ]->pack( %wp );
	$f[ 3 ]->pack( %wp );
	$f[ 4 ]->pack( %up );

	$f[ 5 ]->pack( %fp );
	$f[ 6 ]->pack( %wp );
	$f[ 7 ]->pack( %wp );
	$f[ 8 ]->pack( %up );

	$f[ 9 ]->pack( %fp );
	$f[ 10 ]->pack( %wp );
	$f[ 11 ]->pack( %wp );
	$f[ 12 ]->pack( %up );

	$f[ 13 ]->pack( %fp );
	$f[ 14 ]->pack( %wp );
	$f[ 15 ]->pack( %wp );
	$f[ 16 ]->pack( %up );

	$f[ 17 ]->pack( %fp );
	$f[ 18 ]->pack( %wp );
	$f[ 19 ]->pack( %wp );
	$f[ 20 ]->pack( %up );

	$f[ 21 ]->pack( -side => "bottom",
				   -fill => "x",
				   -padx => "4m" );
	$f[ 22 ]->pack( %wp, -padx => '5m', -pady => '3m' );
	$f[ 23 ]->pack( %wp, -padx => '5m', -pady => '3m' );

	# Add validation handlers for the data in the entry fields

	$f[ 3 ]->configure( -validate => 'key',
						-vcmd => sub { exp_time_check( shift, $N_scans,
													   $f[ 22 ] ); } );
	$f[ 7 ]->configure( -validate => 'key',
						-vcmd => sub { my $N = shift;
									   return 0 unless $N =~ /^\d*$/;
									   check_all_parms( $f[ 22 ],
														$$exp_time, $N );
									   return 1; } );

	check_all_parms( $f[ 22 ], $$exp_time, $$N_scans );

	# Focus should be in the entry field and cursor after the last character

	$f[ 3 ]->focus;
	$f[ 3 ]->icursor( 'end' );

	# New window should appear on top of the button that started it

	if ( defined $geom ) {
		$f[ 0 ]->raise;
		$top->geometry =~ /^(\d+)x(\d)+([+-]\d+)([+-]\d+)$/;
		my ( $tw, $th, $tx, $ty ) = ( $1, $2, $3, $4 );
		$f[ 0 ]->geometry =~ /^(\d+)x(\d+)[+-]\d+[+-]\d+$/;
		my ( $fw, $fh ) = ( $f[ 0 ]->width, $f[ 0 ]->height );
		$geom =~ /^\d+x\d+([+-]\d+)([+-]\d+)/;
		my ( $bx, $by ) = ( $1, $2 );
		my $nx = $tx - int( ( $tw - $fw ) / 2 );
		my $ny = $ty + $by;
		$geom = sprintf "%+d%+d", $nx, $ny;
		$f[ 0 ]->geometry( $geom );
	 }

	MainLoop;
}


#############################################
# Checks for input in the experiment time field

sub exp_time_check {
	my ( $new, $N_scans, $start_button ) = @_;
    my $float_rep = '(((\d+(\.(\d+)?)?)|(\.\d+))([eE]([+-]?\d*)?)?)';

	return 0 if $new ne "" and $new !~ /^($float_rep)?$/;

	check_all_parms( $start_button, $new, $$N_scans );
	return 1;
}


#############################################
# Function to switch the "Start" button between enabled and disabled

sub check_all_parms {
	my ( $start_button, $et, $N ) = @_;
    my $float_rep = '((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?';

	if ( $et !~ /^$float_rep$/ or $et < 1.0e-6 or $et > 3600 or
		 $N eq "" or $N == 0 ) {
		$start_button->configure( -state => 'disabled' );
		return;
	}

	$start_button->configure( -state => 'active' );
}


#############################################
# Runs the actual experiment

sub single_run {
	my ( $top, $N_scans, $exp_time, %p ) = @_;

	my $fh;
    unless ( open $fh, '|-', 'fsc2_start -w' ) {
		Tools::show_message( $top, "Can't start fsc2" );
		return;
	}

    print $fh <<EOF;
DEVICES:

spex232;
rs_spec10;

VARIABLES:

exposure_time = $$exp_time s;
N_scans = $$N_scans;
laser_line;
cwn_offset;
spec[ * ];
avg[ * ];
wl[ * ];
mp[ * ];
B_rel, B_abs, B_wl, B_eas, I_scan, MP_rel, MP_abs, MP_wl;
I, J;
F_all, F_cur;
axis[ * ];
N_Points;

PREPARATIONS:

init_1d( 2 );

EXPERIMENT:

ccd_camera_exposure_time( exposure_time );
laser_line = monochromator_laser_line( );

hide_toolbox( 1 );
I_scan = output_create( "INT_OUTPUT", 0,
                        sprint( "Current scan (of #)", N_scans ) );
change_label_1d( "Wavelength [nm]" );
axis = monochromator_wavelength_axis( );
change_scale_1d( axis[ 3 ] / 1 nm, axis[ 4 ] / 1 nm );

B_wl  = button_create( "RADIO_BUTTON", "Wavelengths" );
B_abs = button_create( "RADIO_BUTTON", B_wl, "Absolute wavenumbers" );
IF laser_line != 0.0 {
	B_rel = button_create( "RADIO_BUTTON", B_wl, "Relative wavenumbers" );
}

B_eas = button_create( "PUSH_BUTTON", "Stop at end of running scan" );
hide_toolbox( 0 );

F_all = get_file( "", "*.dat", "", "", "dat" );

FOR I = 1 : N_scans {
	output_value( I_scan, I );
	spec = ccd_camera_get_spectrum( );

	IF I == 1 {
        N_Points = size( spec );
		avg = float_slice( N_Points );
		axis = monochromator_wavelength_axis( );
		wl = lin_space( axis[ 3 ] / 1 nm,
                        ( axis[ 3 ] + ( N_Points - 1 ) * axis[ 4 ] ) / 1 nm,
                        N_Points );
	}

	F_cur = clone_file( F_all, "dat", sprint( "scan_#.dat", I ) );
	FOR J = 1 : N_Points {
		ffsave( F_cur, "%.3f %f\\n", wl[ J ], spec[ J ] );
	}

	spec = spike_remove( spec );
	avg = add_to_average( avg, spec, I );
	display_1d( 1, spec, 2, 1, avg, 1 );

	IF ! toolbox_changed( ) {
		NEXT;
	}

	IF button_state( B_eas ) {
		BREAK;
	}

	IF button_state( B_wl ) {
		change_label_1d( "Wavelength [nm]" );
        axis = monochromator_wavelength_axis( );
        change_scale_1d( axis[ 3 ] / 1 nm, axis[ 4 ] / 1 nm );
	}

	IF button_state( B_abs ) {
		change_label_1d( "Wavenumbers [cm^-1 abs.]" );
		axis = monochromator_wavenumber_axis( );
		change_scale( axis[ 3 ], axis[ 4 ] );
	}

	IF laser_line != 0 cm^-1 AND button_state( B_rel ) {
		change_label_1d( "Wavenumbers [cm^-1 rel.]" );
		axis = monochromator_wavenumber_axis( );
		change_scale( laser_line - axis[ 3 ], - axis[ 4 ] );
	}
}

hide_toolbox( 1 );
output_delete( I_scan );
button_delete( B_eas );
button_delete( B_abs );
button_delete( B_wl );
IF laser_line != 0 cm^-1 {
	button_delete( B_rel );
	MP_rel = output_create( "FLOAT_OUTPUT", -1.0,
                            "Mouse position [cm^-1 rel.]", "", "%.4f" );
}
MP_abs = output_create( "FLOAT_OUTPUT", -1.0, "Mouse position [cm^-1 abs.]",
                        "", "%.4f" );
MP_wl = output_create( "FLOAT_OUTPUT", -1.0, "Mouse position [nm]", "",
                       "%.6f" );
hide_toolbox( 0 );
change_label_1d( "Wavelength [nm]" );
axis = monochromator_wavelength_axis( );
change_scale_1d( axis[ 3 ] / 1 nm, axis[ 4 ] / 1 nm );

FOREVER {
	IF ! toolbox_changed( ) {
		mp = mouse_position( -1 );
		UNLESS ( mp[ 1 ] == 1 ) {
			IF laser_line != 0 cm^-1 {
				output_value( MP_rel, -1.0 );
			}
			output_value( MP_abs, -1.0 );
			output_value( MP_wl, -1.0 );
			NEXT;
		}

        IF laser_line != 0 cm^-1 {
			output_value( MP_rel, laser_line - 1.0e7 / mp[ 2 ] );
		}
		output_value( MP_abs, 1.0e7 / mp[ 2 ] );
		output_value( MP_wl, mp[ 2 ] );
		NEXT;
	}

	IF button_state( B_wl ) {
		axis = monochromator_wavelength_axis( );
		change_label_1d( "Wavelength [nm]" );
		change_scale_1d( axis[ 3 ] / 1 nm, axis[ 4 ] / 1 nm );
	}

	IF button_state( B_abs ) {
		axis = monochromator_wavenumber_axis( );
		change_label_1d( "Wavenumbers [cm^-1 abs.]" );
		change_scale( axis[ 3 ], axis[ 4 ] );
	}

	IF laser_line != 0 cm^-1 AND button_state( B_rel ) {
		axis = monochromator_wavenumber_axis( );
		change_label_1d( "Wavenumbers [cm^-1 rel.]" );
		change_scale( laser_line - axis[ 3 ], - axis[ 4 ] );
	}
}


ON_STOP:

fsave( F_all, "\\# Date:               # #\\n"
              "\\# Start wavelength  = # nm\\n"
              "\\# End wavelength    = # nm\\n"
              "\\# Resolution        = # nm\\n"
              "\\# Exposure time     = # s\\n"
              "\\# Number of scans   = #\\n",
              date( ), time( ), wl[ 1 ], wl[ N_Points ], 
              ( wl[ N_Points ] - wl[ 1 ] ) / N_Points,
			  exposure_time, I > N_scans ? N_scans : I );

IF laser_line != 0.0 {
    fsave( F_all, "\\# Laser line        = # cm^-1\\n\\n", laser_line );
} ELSE {
	fsave( F_all, "\\n" );
}

FOR J = 1 : N_Points {
	fsave( F_all, "# #\\n", wl[ J ], avg[ J ] );
}
EOF
    close $fh;

    my $text;
    if ( $? != 0 ) {
        if ( $? >> 8 == 255 ) {
            $text = "Internal error.";
        } elsif ( $? >> 8 == 1 ) {
            $text = "Someone else is running fsc2.";
        } elsif ( $? >> 8 == 2 ) {
            $text = "fsc2 is already testing or\nrunning an experiment.";
        } elsif ( $? >> 8 == 3 ) {
            $text = "Internal error of fsc2.";
        } elsif ( $? >> 8 == 4 ) {
            $text = "Could not start fsc2.";
        } else {
            $text = "Something strange\nis going on here.";
        }

        Tools::show_message( $top, $text ) if $? >> 8 != 0;
    }
}


1;


#############################################
# Often used function
#############################################

package Tools;

use strict;
use warnings;
use File::Temp ':mktemp';
use IO::Handle;


#############################################
# Returns the wavelength the monochromator is set to

sub get_wavelength {
	my $top = shift;
	my ( $f, $fn ) = mkstemp( "/tmp/spex_cam.XXXXXX" );

	# Create EDL script for determining the monochromators wavelength
	# (with five digits after the decimal point)

	print $f <<EOF;
DEVICES:
spex232;
EXPERIMENT:
print( "#", monochromator_wavelength( ) / 1 nm );
EOF

	close $f;

	# Run the script and read in the result

	unless ( open $f, '-|', "fsc2 -ng $fn 2>&1" ) {
		close $f;
		unlink $fn;
		show_message( $top, "Can't start fsc2" );
		return;
	}

	my $reply = <$f>;
	close $f;
	unlink $fn;

	if ( ! defined $reply or $reply =~ /^F\s+spex232:\s+/i ) {
		show_message( $top, "Can't determine monochromators postion:\n$1" );
		return;
	}

	unless ( $reply =~ /\d+(\.\d*)?$/ ) {
		show_message( $top, "Can't determine monochromators position." );
		return;
	}

	return 1.0e-9 * $reply;
}


#############################################
# Returns the wavenumber the monochromator is set to

sub get_wavenumber {
	my $top = shift;
	my ( $f, $fn ) = mkstemp( "/tmp/spex_cam.XXXXXX" );

	# Create EDL script for determining the monochromators wavenumber
	# (with three digits after the decimal point)

	print $f <<EOF;
DEVICES:
spex232;
EXPERIMENT:
print( "#", monochromator_wavenumber( ) );
EOF

	close $f;

	# Run the script and read in the result

	unless ( open $f, '-|', "fsc2 -ng $fn 2>&1" ) {
		close $f;
		unlink $fn;
		show_message( $top, "Can't start fsc2" );
		return;
	}

	my $reply = <$f>;
	close $f;
	unlink $fn;

	if ( ! defined $reply or $reply =~ /^F\s+spex232:\s+/i ) {
		show_message( $top, "Can't determine monochromators postion:\n$1" );
		return;
	}

	unless ( $reply =~ /\d+(\.\d*)?$/ ) {
		show_message( $top, "Can't determine monochromators position." );
		return;
	}

	return round( $reply, 3 );
}


#############################################
# Returns the current setting of the laser line

sub get_laser_line {
	my $top = shift;
	my ( $f, $fn ) = mkstemp( "/tmp/spex_cam.XXXXXX" );

	# Create EDL script for determining the laser line (with three four
	# after the decimal point)

	print $f <<EOF;
DEVICES:
spex232;
EXPERIMENT:
print( "#", monochromator_laser_line( ) );
EOF

	close $f;

	# Run the script and read in the result

	unless ( open $f, '-|', "fsc2 -ng $fn 2>&1" ) {
		close $f;
		unlink $fn;
		show_message( $top, "Can't start fsc2" );
		return;
	}

	my $reply = <$f>;
	close $f;
	unlink $fn;

	if ( ! defined $reply and $reply =~ /^F\s+spex232:\s+$/i ) {
		show_message( $top, "Can't determine monochromators laser line " .
					  "setting:\n$1" );
		return;
	}

	unless ( $reply =~ /\d+(\.\d*)?$/ ) {
		show_message( $top, "Can't determine monochromators laser " .
					  "line setting." );
		return;
	}

	return round( $reply, 3 );
}


#############################################
# Returns the lower and upper wavenumber limit of the monochromator

sub get_wavenumber_limits {
	my $top = shift;
	my ( $f, $fn ) = mkstemp( "/tmp/spex_cam.XXXXXX" );

	# Create EDL script for determining the monochrmator wavenumber limits

	print $f <<EOF;
DEVICES:
spex232;
VARIABLES:
limits[ 2 ];
EXPERIMENT:
limits = monochromator_wavenumber_scan_limits( );
print( "# #", limits[ 1 ], limits[ 2 ] );
EOF

	close $f;

	# Run the script and read in the result

	unless ( open $f, '-|', "fsc2 -ng $fn 2>&1" ) {
		close $f;
		unlink $fn;
		show_message( $top, "Can't start fsc2" );
		return;
	}

	my $reply = <$f>;
	close $f;
	unlink $fn;

	if ( ! defined $reply and $reply =~ /^F\s+spex232:\s+/i ) {
		show_message( $top, "Can't determine monochromators limits:\n$1" );
		return;
	}

	my @res = map { round( $_, 3 ) } split ' ', $reply;

	unless ( @res == 2 ) {
		show_message( $top, "Can't determine monochromator limits." );
		return;
	}

	return @res;
}


#############################################

sub get_pixel_width {
	my $top = shift;
	my ( $f, $fn ) = mkstemp( "/tmp/spex_cam.XXXXXX" );

	# Create EDL script for determining the width of a pixel

	print $f <<EOF;
DEVICES:
spex232;
rs_spec10;
VARIABLES:
wla[ 4 ];
EXPERIMENT:
wla = monochromator_wavelength_axis( );
print( "#", wla[ 2 ] / 1 nm );
EOF

	close $f;

	# Run the script and read in the result

	unless ( open $f, '-|', "fsc2 -ng $fn 2>&1" ) {
		close $f;
		unlink $fn;
		show_message( $top, "Can't start fsc2" );
		return;
	}

	my $reply = <$f>;
	close $f;
	unlink $fn;

	if ( ! defined $reply and $reply =~ /^F\s+(spex232|rs_spec10):\s+/i ) {
		show_message( $top, "Can't determine width of a pixel:\n$1" );
		return;
	}

	return 1.0e-9 * $reply;
}


#############################################
# Determines the current settings for the camera (ROI, binning and chip size)

sub get_camera_settings {
	my $top = shift;
	my ( $f, $fn ) = mkstemp( "/tmp/spex_cam.XXXXXX" );

	# Create EDL script for determining the camera settings

	print $f <<EOF;
DEVICES:
rs_spec10;
VARIABLES:
ROI[ 4 ], BIN[ 2 ], CCD_size[ 2 ];
EXPERIMENT:
ROI = ccd_camera_roi( );
BIN = ccd_camera_binning( );
CCD_size = ccd_camera_pixel_area( );
print( "# # # #", ROI[ 1 ], ROI[ 3 ], BIN[ 1 ], CCD_size[ 1 ] );
EOF

	close $f;

	# Run the script and read in the result

	unless ( open $f, '-|', "fsc2 -ng $fn 2>&1" ) {
		close $f;
		unlink $fn;
		show_message( $top, "Can't start fsc2" );
		return;
	}

	my $reply = <$f>;
	close $f;
	unlink $fn;

	if ( ! defined $reply and $reply =~ /^F\s+rs_spec10:\s+/i ) {
		Tools::show_message( $top, "Can't determine camera settings:\n$1" );
		return;
	}

	my @res = split ' ', $reply;

	unless ( @res == 4 ) {
		show_message( $top, "Can't determine camera settings." );
		return;
	}

	return @res;
}


#############################################
# Displays a message box

sub show_message {
	my ( $mw, $text ) = @_;

    $mw->messageBox( '-icon' => 'error',
                     '-type' => 'Ok',
	                 '-title' => 'Error',
                     '-message' => $text );
}


#############################################
# Function for rounding a value to a certain number of digits

sub round {
	my ( $x, $digits ) = @_;
	return 10 ** - $digits * int( 10 ** $digits * $x + 0.5 * ( $x <=> 0 ) );
}


#############################################
# Function tests if a certain combination of the monochromator setting
# and the laser_line is safe, i.e. that the laser_line isn't too near
# to the cameras wavelength range

sub is_laser_line_safe {
	my ( $mw, $laser_line, $cwn ) = @_;
	return 1 if $laser_line == 0.0;

	$cwn = get_wavenumber( $mw ) unless defined $cwn;
	$cwn = $laser_line - $cwn;

	my ( undef, undef, undef, $num_pixel ) = get_camera_settings( $mw );
	my $pixel_width = get_pixel_width( $mw );

	my $swn = wl2wn( wn2wl( $cwn ) - 0.5 * $pixel_width * ( $num_pixel - 1 ) );
	my $ewn = wl2wn( wn2wl( $cwn ) + 0.5 * $pixel_width * ( $num_pixel - 1 ) );

	if ( $swn >= $laser_line and $ewn <= $laser_line ) {
		return $mw->Dialog( '-text' =>
							"The spectral range will include the the " .
							"laser line.\n" .
							"Do you really want this?",
							'-buttons' => [ "Yes", "No" ],
							'-default_button' => "No" )->Show( ) eq "Yes";
	}

	if ( abs( $swn - $laser_line ) < $Min_Dist or
		 abs( $ewn - $laser_line ) < $Min_Dist ) {
		return $mw->Dialog( '-text' =>
							"Start or end wavenumber are less than " .
							"$Min_Dist cm^-1 away from the laser line.\n" .
							"Do you really want this?",
							'-buttons' => [ "Yes", "No" ],
							'-default_button' => "No" )->Show( ) eq "Yes";
	}

	return 1;
}


#############################################
# Function for converting a wavenumber into a wavelength

sub wn2wl {
	return 0.01 / shift;
}


#############################################
# Function for converting a wavelength into a wavenumber

sub wl2wn {
	return 0.01 / shift;
}


1;
