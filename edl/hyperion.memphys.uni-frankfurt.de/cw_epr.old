#!/usr/bin/perl
# -*- cperl -*-
# Generated by fsc2_guify from cw_epr.old.EDL on Fri Jun 20 20:19:58 CEST 2008

use strict;
use warnings;
use Tk;
use Tk::Balloon;

my @version = split /\./, $Tk::VERSION;
die "Installed Perl-Tk version is $Tk::VERSION but Tk800.022 is required.\n"
    if $version[ 0 ] + 0.001 * $version[ 1 ] < 800.022;

my %fp = ( -side => 'top',
           -fill => 'x',
           -padx => '2m',
           -pady => '2m' );
my %wp = ( -side => 'left',
           -fill => 'x',
           -expand => 1 );
my %up = ( -side => 'left' );
my $geom;

my $fsc2_how_to_run = "Test program";
my @fsc2_how_to_run = ( "Start experiment",
                        "Test program",
                        "Load into fsc2" );
my $fsc2_main_window = MainWindow->new( -title =>
                               ( split /\./, ( split /\//, $0 )[ -1 ] )[ 0 ] );
my $fsc2_main_frame = $fsc2_main_window->Frame( -relief => "ridge",
                                                -borderwidth => "1m" );
my $fsc2_balloon = $fsc2_main_frame->Balloon( );
my $fsc2_apply_frame = $fsc2_main_window->Frame( );
my $fsc2_apply_button = $fsc2_apply_frame->Button( -text => "Apply",
                                                   -command => \&write_out );
$fsc2_apply_button->bind( "all", "<Alt-a>" => \&write_out );
my $fsc2_quit_button = $fsc2_apply_frame->Button( -text => "Quit",
                 -command => sub { $fsc2_main_window->geometry =~
                                                   /^\d+x\d+([+-]\d+[+-]\d+)$/;
                                   $geom = $1;
                                   &store_defs;
                                   $fsc2_main_window->destroy } );
$fsc2_quit_button->bind( "all",
                         "<Alt-q>" =>
                                sub { $fsc2_main_window->geometry =~
                                                   /^\d+x\d+([+-]\d+[+-]\d+)$/;
                                      $geom = $1;
                                      &store_defs;
                                      $fsc2_main_window->destroy } );
$fsc2_apply_frame->pack( -side => "bottom",
                         -fill => "x",
                         -padx => "4m" );

# === START_CURRENT float  [ -20.0 : 20.0 ] [ 0.0  ] "Start current" "A"

my %START_CURRENT;
$START_CURRENT{ tk_frame } = $fsc2_main_frame->Frame( );
$START_CURRENT{ tk_label } = $START_CURRENT{ tk_frame }->Label( -text => "Start current",
-width => 20,
-anchor => 'w' );
$START_CURRENT{ value } = 0.0;
$START_CURRENT{ min } = -20.0;
$START_CURRENT{ max } = 20.0;
$START_CURRENT{ tk_entry } = $START_CURRENT{ tk_frame }->Entry( -textvariable => \$START_CURRENT{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_check( shift,
( defined $START_CURRENT{ min } ? $START_CURRENT{ min } : undef ),
( defined $START_CURRENT{ max } ? $START_CURRENT{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $START_CURRENT{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $START_CURRENT{ min } ? $START_CURRENT{ min } : '-inf' ) .
" : " . ( defined $START_CURRENT{ max } ? $START_CURRENT{ max } : '+inf' ) . " ]" );
$START_CURRENT{ tk_unit } = $START_CURRENT{ tk_frame }->Label( -text => "A",
-width => 5 );
$START_CURRENT{ tk_frame }->pack( %fp );
$START_CURRENT{ tk_label }->pack( %wp );
$START_CURRENT{ tk_entry }->pack( %wp );
$START_CURRENT{ tk_unit  }->pack( %up );

# === END_CURRENT   float  [ -20.0 : 20.0 ] [ 1.0  ] "End current"   "A"

my %END_CURRENT;
$END_CURRENT{ tk_frame } = $fsc2_main_frame->Frame( );
$END_CURRENT{ tk_label } = $END_CURRENT{ tk_frame }->Label( -text => "End current",
-width => 20,
-anchor => 'w' );
$END_CURRENT{ value } = 1.0;
$END_CURRENT{ min } = -20.0;
$END_CURRENT{ max } = 20.0;
$END_CURRENT{ tk_entry } = $END_CURRENT{ tk_frame }->Entry( -textvariable => \$END_CURRENT{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_check( shift,
( defined $END_CURRENT{ min } ? $END_CURRENT{ min } : undef ),
( defined $END_CURRENT{ max } ? $END_CURRENT{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $END_CURRENT{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $END_CURRENT{ min } ? $END_CURRENT{ min } : '-inf' ) .
" : " . ( defined $END_CURRENT{ max } ? $END_CURRENT{ max } : '+inf' ) . " ]" );
$END_CURRENT{ tk_unit } = $END_CURRENT{ tk_frame }->Label( -text => "A",
-width => 5 );
$END_CURRENT{ tk_frame }->pack( %fp );
$END_CURRENT{ tk_label }->pack( %wp );
$END_CURRENT{ tk_entry }->pack( %wp );
$END_CURRENT{ tk_unit  }->pack( %up );

# === CURRENT_STEP  float  [ 1.0 : 1000.0 ] [ 50.0 ] "Current step"  "mA"

my %CURRENT_STEP;
$CURRENT_STEP{ tk_frame } = $fsc2_main_frame->Frame( );
$CURRENT_STEP{ tk_label } = $CURRENT_STEP{ tk_frame }->Label( -text => "Current step",
-width => 20,
-anchor => 'w' );
$CURRENT_STEP{ value } = 50.0;
$CURRENT_STEP{ min } = 1.0;
$CURRENT_STEP{ max } = 1000.0;
$CURRENT_STEP{ tk_entry } = $CURRENT_STEP{ tk_frame }->Entry( -textvariable => \$CURRENT_STEP{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_check( shift,
( defined $CURRENT_STEP{ min } ? $CURRENT_STEP{ min } : undef ),
( defined $CURRENT_STEP{ max } ? $CURRENT_STEP{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $CURRENT_STEP{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $CURRENT_STEP{ min } ? $CURRENT_STEP{ min } : '-inf' ) .
" : " . ( defined $CURRENT_STEP{ max } ? $CURRENT_STEP{ max } : '+inf' ) . " ]" );
$CURRENT_STEP{ tk_unit } = $CURRENT_STEP{ tk_frame }->Label( -text => "mA",
-width => 5 );
$CURRENT_STEP{ tk_frame }->pack( %fp );
$CURRENT_STEP{ tk_label }->pack( %wp );
$CURRENT_STEP{ tk_entry }->pack( %wp );
$CURRENT_STEP{ tk_unit  }->pack( %up );

# === FACTOR        float  [ 1.0e-3 : 100 ] [ 1.0  ] "Waiting time"  "* tc"

my %FACTOR;
$FACTOR{ tk_frame } = $fsc2_main_frame->Frame( );
$FACTOR{ tk_label } = $FACTOR{ tk_frame }->Label( -text => "Waiting time",
-width => 20,
-anchor => 'w' );
$FACTOR{ value } = 1.0;
$FACTOR{ min } = 1.0e-3;
$FACTOR{ max } = 100;
$FACTOR{ tk_entry } = $FACTOR{ tk_frame }->Entry( -textvariable => \$FACTOR{ value },
-width => 10,
-validate => 'key',
-validatecommand => sub{ float_check( shift,
( defined $FACTOR{ min } ? $FACTOR{ min } : undef ),
( defined $FACTOR{ max } ? $FACTOR{ max } : undef ) ); },
-relief => 'sunken' );
$fsc2_balloon->attach( $FACTOR{ tk_entry },
-balloonmsg  => "Range: [ " . ( defined $FACTOR{ min } ? $FACTOR{ min } : '-inf' ) .
" : " . ( defined $FACTOR{ max } ? $FACTOR{ max } : '+inf' ) . " ]" );
$FACTOR{ tk_unit } = $FACTOR{ tk_frame }->Label( -text => "* tc",
-width => 5 );
$FACTOR{ tk_frame }->pack( %fp );
$FACTOR{ tk_label }->pack( %wp );
$FACTOR{ tk_entry }->pack( %wp );
$FACTOR{ tk_unit  }->pack( %up );

# === TEST          button [ OFF ]  "Test only"

my %TEST;
$TEST{ tk_frame } = $fsc2_main_frame->Frame( );
$TEST{ tk_label } = $TEST{ tk_frame }->Label( -text => "Test only",
-width => 20,
-anchor => 'w' );
$TEST{ value } = 0;
$TEST{ tk_entry } = $TEST{ tk_frame }->Checkbutton( -variable => \$TEST{ value },
-width => 10 );
$TEST{ tk_unit } = $TEST{ tk_frame }->Label( -text => "",
-width => 5 );
$TEST{ tk_frame }->pack( %fp );
$TEST{ tk_label }->pack( %wp );
$TEST{ tk_entry }->pack( %wp );
$TEST{ tk_unit  }->pack( %up );

$fsc2_main_frame->pack( %fp, -pady => '1m' );
$fsc2_main_window->Optionmenu( -options => \@fsc2_how_to_run,
                                -textvariable => \$fsc2_how_to_run,
                              )->pack( -padx => '3m',
                                       -pady => '3m' );

$fsc2_apply_button->pack( %wp, -padx => '5m', -pady => '3m' );
$fsc2_quit_button->pack(  %wp, -padx => '5m', -pady => '3m' );

load_defs( );
$fsc2_main_window->geometry( $geom ) if defined $geom;
MainLoop;


################################################################

sub int_check {
    my ( $new, $min, $max ) = @_;

    return 0 if $new =~ /^\+?(\d+)?$/ and defined $max and $max < 0;
    return 0 if $new =~ /^-/ and defined $min and $min >= 0;
    if ( $new =~ /^[+-]?$/ ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
         return 1;
     }

    return 0 unless $new =~ /^[+-]?\d+?$/;

    if ( ( defined $min and $new < $min )
         or ( defined $max and $new > $max ) ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
     } else {
         $fsc2_apply_button->configure( -state => 'normal' );
     }
     return 1;
}


################################################################

sub float_check {
    my ( $new, $min, $max ) = @_;
    my $float_rep = '[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?';

    return 0 if $new =~ /^\+/ and defined $max and $max < 0;
    return 0 if $new =~ /^-/ and defined $min and $min > 0;

    if ( $new =~ /^$float_rep$/ ) {
        if ( ( defined $max and $max < $new ) or
             ( defined $min and $min > $new ) ) {
            $fsc2_apply_button->configure( -state => 'disabled' );
        } else {
            $fsc2_apply_button->configure( -state => 'normal' );
        }
        return 1;
    }

    if ( $new =~ /^[+-]?(\d+)?\.?(\d+)?([Ee][+-]?(\d+)?)?$/ ) {
         $fsc2_apply_button->configure( -state => 'disabled' );
         return 1;
     }

     return 0;
}


################################################################

sub write_out {
    my $fh;

    open( $fh, "|fsc2_" . lc $fsc2_how_to_run )
        or die "Can't find utility fsc2_" . lc $fsc2_how_to_run . ".\n";

    my $START_CURRENT = $START_CURRENT{ value };
    my $END_CURRENT = $END_CURRENT{ value };
    my $CURRENT_STEP = $CURRENT_STEP{ value };
    my $FACTOR = $FACTOR{ value };
    my $TEST = $TEST{ value };

    print $fh "";
# === if ( ! TEST )
    if ( eval { ( ! $TEST ) } ) {
        print $fh "DEVICES:

fsps25;              /* sweep power supply */
sr530;               /* lock-in amplifier  */


";
# === endif
    }

    print $fh "VARIABLES:

start_current = $START_CURRENT A;
end_current   = $END_CURRENT A;
current_step  = $CURRENT_STEP mA;

N_points = int( abs( start_current - end_current ) / current_step ) + 1;

data[ *, *, * ];     /* acquired data (field, x- and y-lock-in data) */
avg[ N_points, 2 ];  /* averaged lock-in data */

";
# === if ( START_CURRENT <= END_CURRENT )
    if ( eval { ( $START_CURRENT <= $END_CURRENT ) } ) {
        print $fh "SP = 1;
EP = N_points;
D = 1;               /* scan direction, 1: up, -1 down */
sc = start_current;
";
# === else
    } else {
        print $fh "SP = N_points;
EP = 1;
D = -1;              /* scan direction, 1: up, -1 down */
sc = end_current;
";
# === endif
    }

    print $fh "
I = 0,               /* scan and point counters */
J = 0;
Scans_done = 0;      /* final value of number of scans */
Points_done = 0;     /* final value of number of points per scan */
delay;               /* delay for lock-in */
ec;                  /* current at end of scan */
p = 0.0;             /* phase correction variables */
np;
s = 0.0;
c = 1.0;
tmp[ * ];

Current_scan;        /* toolbox variables */
Act_current;
Stop_after_scan;
Phase_slider;
Phase_input;
Done;

File_d;              /* variables for output files */
File_i;
File_pc;


PREPARATIONS:

init_1d( 4, N_points, sc, current_step, \"Current [A]\", \"Signal [mV]\" );


EXPERIMENT:

/* Calculate how long t wait for lock-in to measure new data and go to the
   the start field */

";
# === if ( ! TEST )
    if ( eval { ( ! $TEST ) } ) {
        print $fh "delay = $FACTOR * lockin_time_constant( );

data[ 1, SP, 1 ] = magnet_field( start_current );
";
# === else
    } else {
        print $fh "delay = $FACTOR * 0.02;

data[ 1, SP, 1 ] = start_current;
";
# === endif
    }

    print $fh "sc = data[ 1, SP, 1 ];

/* Create the toolbos that shows the current scan number and allows to
   request to end the experiment with the end of the scan */

hide_toolbox( \"ON\" );
Current_scan = output_create( \"INT_OUTPUT\",  \"Current scan no.\" );
Act_current =  output_create( \"FLOAT_OUTPUT\", sc, \"Coil current[ A]\" );
Stop_after_scan = button_create( \"PUSH_BUTTON\", \"Stop after end of scan\" );
hide_toolbox( \"OFF\" );

/* Keep repeating scans until the user stops it */

FOREVER {

	/* Set new number of scan and display it */

	I += 1;
	output_value( Current_scan, I );

	/* Record the requested number of points for the scan */

	FOR J = SP : EP : D {

		/* Update the output field with the actual current */

		output_value( Act_current, data[ I, J, 1 ] );

		/* Sleep a bit until the lock-in had had enough time to measure
		   new data points, then fetch them */

		wait( delay );
";
# === if ( ! TEST )
    if ( eval { ( ! $TEST ) } ) {
        print $fh "		data[ I, J, 2 : 3 ] = lockin_get_data( 1, 2 ) / 1 mV;
";
# === else
    } else {
        print $fh "		data[ I, J, 2 ] = grandom( ) + - 0.5 * ( J - N_points / 2 ) *
 			              exp( - ( J - N_points / 2 )^2 / 55.0^2 );
		data[ I, J, 3 ] = grandom( ) + 0.134 * ( J - N_points / 2 ) *
		                  exp( - ( J - N_points / 2 )^2 / 55.0^2 );
";
# === endif
    }

    print $fh "
		/* Calculate the new averaged data, tne display the new points and
		   the updayed average */

		avg[ J ] = add_to_average( avg[ J ], data[ I, J, 2 : 3 ], I );
		display( J, data[ I, J, 2 ], 1,
		         J, data[ I, J, 3 ], 2,
				 J, avg[ J, 1 ], 3,
				 J, avg[ J, 2 ], 4 );

		/* If we're not at the end of the scan change the field */

";
# === if ( ! TEST )
    if ( eval { ( ! $TEST ) } ) {
        print $fh "        IF    ( D ==  1 AND J < N_points )
	    	data[ I, J + 1, 1 ] =
			            magnet_field( start_current + J * current_step );
		} ELSE  IF D == -1 AND J > 1 {
	    	data[ I, J - 1, 1 ] =
			            magnet_field( end_current + ( J - 2 ) * current_step );
		}
";
# === else
    } else {
        print $fh "        IF D ==  1 AND J < N_points {
	    	data[ I, J + 1, 1 ] = start_current + J * current_step;
		} ELSE IF D == -1 AND J > 1 {
	    	data[ I, J - 1, 1 ] = end_current + ( J - 2 ) * current_step;
		}
";
# === endif
    }

    print $fh "    }

	/* Scan is done, if the user told us to stop (by clicking on the \"Stop
	   after end of scan\"-button do so */

    Scans_done = I;

	IF button_state( Stop_after_scan ) {
		BREAK;
	}

	/* Otherwise go back to the start field */

";
# === if ( ! TEST )
    if ( eval { ( ! $TEST ) } ) {
        print $fh "	data[ I + 1, SP, 1 ] = magnet_field( start_current );
";
# === else
    } else {
        print $fh "	data[ I + 1, SP, 1 ] = start_current;
";
# === endif
    }

    print $fh "}


ON_STOP:

/* If the experiment got aborted immediately at the start (less than three
   points got measured) don't do anything anymore*/

IF     Scans_done == 0
   AND ( ( D == 1 AND J <= 3 ) OR ( D == -1 AND J >= N_points - 2 ) ) { 
	abort( );
}

/* Remove contents of the toolbox */

hide_toolbox( \"ON\" );
object_delete( Current_scan );
object_delete( Stop_after_scan );

/* Ask for the data file, if none gets selected skip all the rest */

File_d = get_file( \"\", \"*.dat\", \"\", \"\", \"dat\" );

IF ! is_file( File_d ) {
	abort( );
}

/* Get the file for the experiments parameters */

File_i = clone_file( File_d, \"dat\", \"inf\" );

/* If the experiment got stopped already during the very first scan throw
   away the last point, we can't be sure it really got measured. If we got
   stopped within another scan the data of the last scan are thrown away
   since they are incomplete. */

IF Scans_done == 0 {
	Scans_done = 1;
	IF D == 1 {
    	IF J <= N_points {
			J -= 1;
		}
		Points_done = J;
		EP = J;
	} ELSE {
    	IF J > 0 {
			J += 1;
		}
		Points_done = N_points - J + 1;
		SP = J;
		EP = N_points;
	}
	ec = data[ 1, J, 1 ];
} ELSE {
	Points_done = N_points;
	IF D == 1 {
		ec = data[ 1, N_points, 1 ];
	} ELSE {
		SP = 1;
		EP = N_points;
		ec = data[ 1, 1, 1 ];
	}

	/* If necessary recalculate the average to get rid of the thrown away
	   points of the last (unfinished) scan */

	IF ( D == 1 AND J <= N_points ) OR ( D == -1 AND J > 0 ) {
		avg = data[ 1, 1 : N_points, 2 : 3 ];
		FOR I = 2 : Scans_done {
			avg = add_to_average( avg, data[ I, 1 : N_points, 2 : 3 ], I );
		}
	}
}

/* Save the \"raw\" data */

FOR I = 1 : Scans_done {
	save( \" \", File_d, data[ I, SP : EP ] );
	IF I < Scans_done {
		fsave( File_d, \"\\n\" );
	}
}

/* Prepare things for phase correction - it doesn't make much sense to
   display anything but the averaged curve, so remove anything else. */

clear_curve( 1, 2, 3, 4 );
display_1d( SP, avg[ SP : EP, 1 ], 3,
			SP, avg[ SP : EP, 2 ], 4 );

Phase_slider = slider_create( \"NORMAL_SLIDER\", -180.0, 180.0,
			   				  \"Phase (coarse)\" );
Phase_input = input_create( \"FLOAT_INPUT\", 0, \"Phase (venier)\" );
Done = button_create( \"NORMAL_BUTTON\", \"Done\" );
hide_toolbox( \"OFF\" );

/* Give the user a chance play around with the phase. Stops only when the
   \"Done\" button gets clicked on. Slider is for coarse setting and input
   field for fine adjustments. Keep the user form entering insane values. */

FOREVER {
	toolbox_wait( 1.0e12 s );

	IF button_state( Done ) {
		BREAK;
	}

	IF slider_changed( Phase_slider ) {
		np = slider_value( Phase_slider );
	} ELSE {
		np = input_value( Phase_input );
		IF abs( np ) > 10000.0 {
			input_value( Phase_input, p );
			NEXT;
		}

		WHILE np > 180.0 {
			np -= 360.0;
		}
		WHILE np < -180.0 {
			np += 360.0;
		}
	}

	input_value( Phase_input, np );
	slider_value( Phase_slider, np );

	IF np == p {
		NEXT;
	}

	p = np;
	s = sin( D_to_R( p ) );
	c = cos( D_to_R( p ) );
	display( SP,  c * avg[ SP : EP, 1 ] + s * avg[ SP : EP, 2 ], 3,
			 SP, -s * avg[ SP : EP, 1 ] + c * avg[ SP : EP, 2 ], 4 );
}

/* If the phase got changed write out the phase corrected data - got to
   phase-correct the data for each scan */

IF p != 0.0 {
   	File_pc = clone_file( File_d, \"dat\", \"pc\" );

	FOR I = 1 : Scans_done {
		tmp =   c * data[ I, SP : EP, 2 ] + s * data[ I, SP : EP, 3 ];
		data[ I, SP : EP, 3 ] =
	    	  - s * data[ I, SP : EP, 2 ] + c * data[ I, SP : EP, 3 ];
		data[ I, SP : EP, 2 ] = tmp;
		save( \" \", File_pc, data[ I, SP : EP ] );
			IF I < Scans_done {
			fsave( File_pc, \"\\n\" );
		}
	}
}

/* Finally write out the file with the experiments parameters (and a user
    comment) */

fsave( File_i, \"Date                   = # #\\n\"
               \"No. of points per scan = #\\n\"
               \"No. of scans           = #\\n\"
               \"Magnet:\\n\"
               \"  Start current        = # A\\n\"
               \"  End current          = # A\\n\"
               \"  Current step         = # mA\\n\"
               \"Lock-In:\\n\"
               \"  Sensitivity          = # mV\\n\"
               \"  Time constant        = # s\\n\"
			   \"  Phase                = #\\n\"
			   \"  Modulation frequency = # kHz\\n\\n\"
			   \"*** Lock-In data are in mV ***\\n\\n\",
       date( ), time( ), Points_done, Scans_done, sc, ec, current_step, 
";
# === if ( ! TEST )
    if ( eval { ( ! $TEST ) } ) {
        print $fh "	   lockin_sensitivity( ) / 1 mV, lockin_time_constant( ),
	   lockin_phase( ), lockin_ref_freq( ) / 1 kHz );
";
# === else
    } else {
        print $fh "	   1 mV, 300 ms, 123, 100 );
";
# === endif
    }

    print $fh "
IF p != 0.0 {
   	ffsave( File_i, \"Phase:\\n  Additional phase:    = %.1f\\n\", p );
}

save_comment( File_i );
";
    close $fh;

    my $text;
    if ( $? != 0 ) {
        if ( $? >> 8 == 255 ) {
            $text = "Internal error.";
        } elsif ( $? >> 8 == 1 ) {
            $text = "Could not start fsc2.";
        } else {
            $text = "Something strange\nis going on here.";
        }

        &show_message( $text ) if $? >> 8 != 0;
    }
}


################################################################

sub show_message {
    my $text = shift;

    $fsc2_main_window->messageBox( -icon => 'error',
                                   -type => 'Ok',
                                   -title => 'Error',
                                   -message => $text );
}


################################################################

sub store_defs {
    my $fh;
    my $name = $0;

    $name =~ s|^.*?([^/]+)$|$1|;
    mkdir "$ENV{ HOME }/.fsc2", 0777 unless -e "$ENV{ HOME }/.fsc2";
    open( $fh, '>', $ENV{ HOME } . "/.fsc2/$name" ) or return;
    print $fh "# Do not edit - created automatically!\n";

    if (     $START_CURRENT{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o
         and (     defined $START_CURRENT{ max } ? $START_CURRENT{ max } >= $START_CURRENT{ value } : 1 )
         and ( defined $START_CURRENT{ min } ? $START_CURRENT{ min } <= $START_CURRENT{ value } : 1 ) ) {
        print $fh "$START_CURRENT{ value }\n";
    } else {
        print $fh "0.0\n";
    }

    if (     $END_CURRENT{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o
         and (     defined $END_CURRENT{ max } ? $END_CURRENT{ max } >= $END_CURRENT{ value } : 1 )
         and ( defined $END_CURRENT{ min } ? $END_CURRENT{ min } <= $END_CURRENT{ value } : 1 ) ) {
        print $fh "$END_CURRENT{ value }\n";
    } else {
        print $fh "1.0\n";
    }

    if (     $CURRENT_STEP{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o
         and (     defined $CURRENT_STEP{ max } ? $CURRENT_STEP{ max } >= $CURRENT_STEP{ value } : 1 )
         and ( defined $CURRENT_STEP{ min } ? $CURRENT_STEP{ min } <= $CURRENT_STEP{ value } : 1 ) ) {
        print $fh "$CURRENT_STEP{ value }\n";
    } else {
        print $fh "50.0\n";
    }

    if (     $FACTOR{ value } =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o
         and (     defined $FACTOR{ max } ? $FACTOR{ max } >= $FACTOR{ value } : 1 )
         and ( defined $FACTOR{ min } ? $FACTOR{ min } <= $FACTOR{ value } : 1 ) ) {
        print $fh "$FACTOR{ value }\n";
    } else {
        print $fh "1.0\n";
    }

    print $fh "$TEST{ value }\n";

    print $fh "$fsc2_how_to_run\n";

    print $fh "$geom\n" if defined $geom;

    close $fh;
};


################################################################

sub load_defs {
    my $fh;
    my $name = $0;
    my $ne;
    my $found;

    $name =~ s|^.*?([^/]+)$|$1|;
    if ( $ARGV[ 0 ] ) {
        open( $fh, '<', $ARGV[ 0 ] ) or return;
    } else {
        open( $fh, '<'. $ENV{ HOME } . "/.fsc2/$name" ) or return;
    }

    goto done_reading unless defined( $ne = <$fh> ) and $ne =~ /^#/;

    goto done_reading unless     defined( $ne = <$fh> )
                             and $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o;
    chomp $ne;
    goto done_reading if    ( defined $START_CURRENT{ max } and $ne > $START_CURRENT{ max } )
                         or ( defined $START_CURRENT{ min } and $ne < $START_CURRENT{ min } );
    $START_CURRENT{ value } = $ne;

    goto done_reading unless     defined( $ne = <$fh> )
                             and $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o;
    chomp $ne;
    goto done_reading if    ( defined $END_CURRENT{ max } and $ne > $END_CURRENT{ max } )
                         or ( defined $END_CURRENT{ min } and $ne < $END_CURRENT{ min } );
    $END_CURRENT{ value } = $ne;

    goto done_reading unless     defined( $ne = <$fh> )
                             and $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o;
    chomp $ne;
    goto done_reading if    ( defined $CURRENT_STEP{ max } and $ne > $CURRENT_STEP{ max } )
                         or ( defined $CURRENT_STEP{ min } and $ne < $CURRENT_STEP{ min } );
    $CURRENT_STEP{ value } = $ne;

    goto done_reading unless     defined( $ne = <$fh> )
                             and $ne =~ /^[+-]?((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/o;
    chomp $ne;
    goto done_reading if    ( defined $FACTOR{ max } and $ne > $FACTOR{ max } )
                         or ( defined $FACTOR{ min } and $ne < $FACTOR{ min } );
    $FACTOR{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> ) and $ne =~ /^1|0$/o;
    chomp $ne;
    $TEST{ value } = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @fsc2_how_to_run ) {
        if ( $ne eq $_ ) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $fsc2_how_to_run = $ne;

    goto done_reading unless     defined( $ne = <$fh> )
                             and $ne =~ /^\s*([+-]\d+[+-]\d+)\s*$/;
    $geom = $1;

  done_reading:
    close $fh;
};
