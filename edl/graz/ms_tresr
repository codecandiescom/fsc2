#!/usr/bin/perl
# -*- cperl -*-
#
# $Id$

###################################################

package Stage1;

use strict;
use warnings;
use Tk;
use Tk::Balloon;
require Tk::Pane;

my @version = split /\./, $Tk::VERSION;
die "Installed Perl-Tk version is $Tk::VERSION but Tk800.022 is required.\n"
    if $version[ 0 ] + 0.001 * $version[ 1 ] < 800.022;

my $g3;


#########################

sub get_regions {
    my $num_regions;
    my %fp = ( -side   => 'top',
               -fill   => 'x',
               -padx   => '2m',
               -pady   => '2m' );
    my %wp = ( -side   => 'left',
               -fill   => 'x',
               -expand => 1 );

    my $mw = MainWindow->new( );
    $mw->title( "Regions" );
	$mw->optionAdd( '*BorderWidth' => 1 );

    my $mf = $mw->Frame( );

    my $f1 = $mf->Frame( );
    my $f2 = $f1->Label( -text           => 'Number of regions:',
                         -width          => '20',
                         -anchor          => 'w' );
    my $f3 = $f1->Entry( -textvariable    => \$num_regions,
                         -width           => '8',
                         -validate        => 'key',
                         -validatecommand => \&int_check,
                         -relief          => 'sunken' );

    $f1->pack( %fp );
    $f2->pack( %wp );
    $f3->pack( %wp );

    my $g1 = $mf->Frame( );
    my $g2 = $g1->Button( -text    => 'Quit',
                          -command => sub { $mw->destroy; exit 0; } );
    $g3    = $g1->Button( -text    => 'Continue',
                          -state   => 'disabled',
                          -command => sub { $mw->destroy } );

    $g1->pack( %fp );
    $g2->pack( %wp, -padx => '5m' );
    $g3->pack( %wp, -padx => '5m' );

    $mf->pack( );

    MainLoop( );

    return $num_regions;
}


#########################

sub int_check {
    my $val = shift;

    $g3->configure( -state => $val =~ /^\d+$/ ? 'normal' : 'disabled' );
    return $val =~ /^\d*$/;
}

1;


###################################################

package Stage2;

use strict;
use warnings;
use Tk;
use Tk::Balloon;

my $h3;
my $pretrigger_ok = 1;
my $field_ok = 0;

my @up_down = ( "Up", "Down" );
my @avg = ( "10", "20", "50", "100", "200", "500", "1000", "2000", "5000",
            "10000", "20000", "50000", "100000", "200000", "500000",
            "1000000" );
my @acq_channels = ( "CH1" , "CH2" );
my @avg_channels = ( "FUNC_E" , "FUNC_F" );
my @tr_channels = ( "CH1" , "CH2", "EXT", "EXT10" );
my @do_what = ( "Load program", "Test program", "Start program" );
my ( @fields, @steps, $st, $ud, $num_avg, $aqc, $avc, $tc, $pretrigger, $htr );

#########################

sub get_params {
    my $num_regions = shift;

    my %fp = ( -side   => 'top',
               -fill   => 'x',
               -padx   => '2m',
               -pady   => '1m' );
    my %wp = ( -side   => 'left',
               -fill   => 'x',
               -expand => 1 );

    load_defs( $num_regions );

    my $mw = MainWindow->new( );
    $mw->title( "Regions" );
	$mw->optionAdd( '*BorderWidth' => 1 );

	my $mf = $mw->Frame( );

    my $h1 = $mf->Frame( );
    my $h2 = $h1->Button( -text    => 'Quit',
                          -command => sub { $mw->destroy; exit 0; } );
    $h3    = $h1->Button( -text    => 'Continue',
                          -state   => 'disabled',
                          -command => sub { $mw->destroy } );

	my $mfi;

	if ( $num_regions < 6 ) {
		$mfi = $mw->Frame( );
	} else {
		$mfi = $mw->Scrolled( 'Frame',
							  -scrollbars => 'oe',
							  -height     => 400 );
	}

    my ( $i, @f );

    for ( $i = 0; $i < $num_regions; $i++ ) {
        $f[ 8 * $i ] = $mfi->Frame( );
        $f[ 8 * $i +  1 ] =
            $f[ 8 * $i ]->Label( -text    => "Start field " . ( $i + 1 ) . ":",
                                 -width   => '20',
                                 -anchor  => 'w' );
        $f[ 8 * $i + 2 ] =
            $f[ 8 * $i ]->Entry( -textvariable    => \$fields[ $i ],
                                 -width           => '8',
                                 -validate        => 'key',
                                 -validatecommand => \&float_check,
                                 -relief          => 'sunken' );
        $f[ 8 * $i + 3 ] =
            $f[ 8 * $i ]->Label( -text            => 'G',
                                 -width           => 5 );

        $f[ 8 * $i + 4 ] = $mfi->Frame( );
        $f[ 8 * $i + 5 ] =
            $f[ 8 * $i + 4 ]->Label( -text    => "Field step size " .
                                                   ( $i + 1 ) . ":",
                                     -width   => '20',
                                     -anchor  => 'w' );
        $f[ 8 * $i + 6 ] =
            $f[ 8 * $i + 4 ]->Entry( -textvariable    => \$steps[ $i ],
                                     -width           => '8',
                                     -validate        => 'key',
                                     -validatecommand => \&float_check,
                                     -relief          => 'sunken' );
        $f[ 8 * $i + 7 ] =
            $f[ 8 * $i + 4 ]->Label( -text            => 'G',
                                     -width           => 5 );
    }

    $f[ 8 * $i ] = $mfi->Frame( );
    $f[ 8 * $i + 1 ] =
        $f[ 8 * $i ]->Label( -text            => "End field:",
                             -width           => '20',
                             -anchor          => 'w' );
    $f[ 8 * $i + 2 ] =
        $f[ 8 * $i ]->Entry( -textvariable    => \$fields[ $i ],
                             -width           => '8',
                             -validate        => 'key',
                             -validatecommand => \&float_check,
                             -relief          => 'sunken' );
    $f[ 8 * $i + 3 ] =
        $f[ 8 * $i ]->Label( -text            => 'G',
                             -width           => 5 );

    for ( $i = 0; $i < @f; $i++ ) {
        $f[ $i ]->pack( $i % 4 ? %wp : %fp );
    }

    $mfi->pack( );

    my $g1 = $mf->Frame( );
    my $g2 = $g1->Button( -text    => 'Check/adjust field values',
                          -command => [ \&checks, $num_regions ] );
    $g1->pack( %fp );
    $g2->pack( %wp, -padx => '5m' );

    my $ud1 = $mf->Frame( );
    my $ud2 = $ud1->Label( -text   => "Sweep direction",
                           -width  => '20',
                           -anchor => 'w' );
    my $ud3 = $ud1->Optionmenu( -options      => \@up_down,
                                -width        => 10,
                                -textvariable => \$ud );

    $ud1->pack( %fp );
    $ud2->pack( %wp );
    $ud3->pack( %wp );


    my $st1 = $mf->Frame( );
    my $st2 = $st1->Label( -text    =>
                                   "Signal start field\n(for laser correction)",
                           -width   => '20',
                           -anchor  => 'w' );
    my $st3 = $st1->Entry( -textvariable    => \$st,
                           -width           => '8',
                           -validate        => 'key',
                           -validatecommand => \&float_check2,
                           -relief          => 'sunken' );
    my $st4 = $st1->Label( -text            => 'A',
                           -width           => 5 );

    $st1->pack( %fp );
    $st2->pack( %wp );
    $st3->pack( %wp );
    $st4->pack( %wp );


    my $p1 = $mf->Frame( );;
    my $p2 = $p1->Label( -text   => "Pre-trigger",
						 -width  => '20',
						 -anchor => 'w' );
    my $p3 = $p1->Entry( -textvariable    => \$pretrigger,
                         -width           => '8',
                         -validate        => 'key',
                         -validatecommand => \&int_check,
                         -relief          => 'sunken' );
    my $p4 = $p1->Label( -text            => 'in %',
                         -width           => 5 );

    $p1->pack( %fp );
    $p2->pack( %wp );
    $p3->pack( %wp );
    $p4->pack( %wp );


    my $n1 = $mf->Frame( );
    my $n2 = $n1->Label( -text    => "Number of averages",
						 -width   => '20',
						 -anchor  => 'w' );
    my $n3 = $n1->Optionmenu( -options => \@avg,
                              -width => 10,
                              -textvariable => \$num_avg );

    $n1->pack( %fp );
    $n2->pack( %wp );
    $n3->pack( %wp );


    my $aqc1 = $mf->Frame( );
    my $aqc2 = $aqc1->Label( -text   => "Aquisistion channel",
                             -width  => '20',
                             -anchor => 'w' );
    my $aqc3 = $aqc1->Optionmenu( -options => \@acq_channels,
                                  -width => 10,
                                  -textvariable => \$aqc );

    $aqc1->pack( %fp );
    $aqc2->pack( %wp );
    $aqc3->pack( %wp );


    my $avc1 = $mf->Frame( );
    my $avc2 = $avc1->Label( -text   => "Averaging channel",
                             -width  => '20',
                             -anchor => 'w' );
    my $avc3 = $avc1->Optionmenu( -options => \@avg_channels,
                                  -width => 10,
                                  -textvariable => \$avc );

    $avc1->pack( %fp );
    $avc2->pack( %wp );
    $avc3->pack( %wp );


    my $tc1 = $mf->Frame( );
    my $tc2 = $tc1->Label( -text   => "Trigger channel",
                           -width  => '20',
                           -anchor => 'w' );
    my $tc3 = $tc1->Optionmenu( -options => \@tr_channels,
								-width => 10,
								-textvariable => \$tc );

    $tc1->pack( %fp );
    $tc2->pack( %wp );
    $tc3->pack( %wp );


    my $htr1 = $mf->Frame( );
    my $htr2 = $htr1->Optionmenu( -options => \@do_what,
                                  -width => 10,
                                  -textvariable => \$htr );

    $htr1->pack( %fp );
    $htr2->pack( %wp, -padx => '17m' );

    $h1->pack( %fp );
    $h2->pack( %wp, -padx => '5m' );
    $h3->pack( %wp, -padx => '5m' );

    $mf->pack( );

    checks( $num_regions );

    MainLoop();

    $i = 0;
    while ( $i < $num_regions - 1 ) {
        if ( $steps[ $i ] == $steps[ $i + 1 ] ) {
            splice @fields, $i + 1, 1;
            splice @steps, $i + 1, 1;
            $num_regions--;
        } else {
            $i++;
        }
    }

    save_defs( $num_regions );
}


#########################

sub load_defs {
    my $num_regions = shift;
    my $name = $0;
    my $ne;
    my $found;
    my $fh;

    $name =~ s|^.*?([^/]+)$|$1|;
    if ( $ARGV[ 0 ] ) {
        open( $fh, "<$ARGV[ 0 ]" ) or return;
    } else {
        open( $fh, "<$ENV{ HOME }/.fsc2/$name" ) or return;
    }

    goto done_reading unless defined( $ne = <$fh> ) and $ne =~ /^#/;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @up_down ) {
        if ( $ne eq $_ ) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $ud = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @avg ) {
        if ( $ne eq $_ ) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $num_avg = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @acq_channels ) {
        if ( $ne eq $_ ) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $aqc = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @avg_channels ) {
        if ( $ne eq $_ ) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $avc = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @tr_channels ) {
        if ( $ne eq $_ ) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $tc = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $found = 0;
    for ( @do_what ) {
        if ( $ne eq $_ ) {
            $found = 1;
            last;
        }
    }
    goto done_reading unless $found;
    $htr = $ne;

    goto done_reading unless defined( $ne = <$fh> ) and $ne =~ /^\d+$/;
    chomp $ne;
    $pretrigger = $ne;

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $st = $ne if $ne =~ /^((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/;

    my $i;
    for ( $i = 0; $i < $num_regions; $i++ ) {
        goto done_reading unless defined( $ne = <$fh> );
        chomp $ne;
        $fields[ $i ] = $ne
            if $ne =~ /^((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/;
    
        goto done_reading unless defined( $ne = <$fh> );
        chomp $ne;
        $steps[ $i ]  = $ne
            if $ne =~ /^((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/;
    }

    goto done_reading unless defined( $ne = <$fh> );
    chomp $ne;
    $fields[ $i ] = $ne
        if $ne =~ /^((\d+(\.(\d+)?)?)|(\.\d+))([eE][+-]?\d+)?$/;
    
  done_reading:
    close $fh;
};


#########################

sub save_defs {
    my $num_regions = shift;
    my $fh;
    my $name = $0;

    $name =~ s|^.*?([^/]+)$|$1|;
    mkdir "$ENV{ HOME }/.fsc2", 0777 unless -e "$ENV{ HOME }/.fsc2";
    open( $fh, ">$ENV{ HOME }/.fsc2/$name" ) or return;
    print $fh "# Do not edit - created automatically!\n";

    print $fh "$ud\n$num_avg\n$aqc\n$avc\n$tc\n$htr\n";

    print $fh defined $pretrigger ? "$pretrigger\n" : "\n";
    print $fh defined $st ? "$st\n" : "\n";

    my $i;
    for ( $i = 0; $i < $num_regions; $i++ ) {
        print $fh defined $fields[ $i ] ? "$fields[ $i ]\n" : "\n";
        print $fh defined $steps[ $i ] ? "$steps[ $i ]\n" : "\n";
    }
    print $fh defined $fields[ $i ] ? "$fields[ $i ]\n" : "\n";
    
    close $fh;
}


#########################

sub int_check {
    my $val = shift;
    $pretrigger_ok = ( $val ne '' and $val =~ /^\d+$/ and $val <= 100 ) ? 1 : 0;
    $h3->configure( -state => ( $pretrigger_ok and $field_ok ) ?
                              'normal' : 'disabled' );
    return $val =~ /^\d*$/;
}


#########################

sub float_check {
    my $val = shift;
    $h3->configure( -state => 'disabled' );
    $field_ok = 0;
    return ( $val eq '' or $val =~ /^(\d+)?\.?(\d+)?([Ee][+-]?(\d+)?)?$/ );
}


#########################

sub float_check2 {
    my $val = shift;
    return ( $val eq '' or $val =~ /^(\d+)?\.?(\d+)?([Ee][+-]?(\d+)?)?$/ );
}


#########################

sub checks {
    my $num_regions = shift;
    my $step = 1.0e12;
    my @mult;
    my $ssi = -1;

    for ( my $i = 0; $i < $num_regions; $i++ ) {
        unless (     defined $steps[ $i ]
                 and $steps[ $i ] ne ''
                 and $steps[ $i ] > 0.001 ) {
            print "\a";
            return;
        }

        $steps[ $i ] = 1.0e-3 * int( 1.0e3 * $steps[ $i ] + 0.5 );
        $step = $steps[ $i ] if $steps[ $i ] < $step;
    }

    for ( my $i = 0; $i <= $num_regions; $i++ ) {
        unless ( defined $fields[ $i ] and $fields[ $i ] ne '' ) {
            print "\a";
            return;
        }
            
        if (     $i > 0
             and (    $fields[ $i ] <= $fields[ $i - 1 ]
                   or $fields[ $i ] - $fields[ $i - 1 ] < $steps[ $i - 1 ] ) ) {
            print "\a";
            return;
        }
    }

    for ( my $i = 0; $i < $num_regions; $i++ ) {
        $mult[ $i ] = int( $steps[ $i ] / $step );
        $steps[ $i ] = $mult[ $i ] * $step;
        $ssi = $i if $mult[ $i ] == 1 and $ssi < 0;
    }

    for ( my $i = $ssi; $i < $num_regions; $i++ ) {
        my $fsteps = ( $fields[ $i + 1 ] - $fields[ $i ] ) / $steps[ $i ];
        my $isteps;

        if ( abs( $fsteps - int( $fsteps + 0.5 ) ) == 0.0 ) {
            $isteps = int( $fsteps + 0.5 );
            $fields[ $i + 1 ] =   $fields[ $i ]
                                + $isteps * $steps[ $i ];
        } else {
            $isteps = int( $fsteps );

            if (    $i == $num_regions - 1
                 or $mult[ $i ] <= $mult[ $i + 1 ] ) {
                $fields[ $i + 1 ] =   $fields[ $i ]
                                    + ( $isteps + 1 ) * $steps[ $i ];
            } else {
                $fields[ $i + 1 ] =   $fields[ $i ]
                                    + $isteps * $steps[ $i ];
            }
        }
    }

    for ( my $i = $ssi; $i > 0; $i-- ) {
        my $fsteps = ( $fields[ $i ] - $fields[ $i - 1 ] )
                     / $steps[ $i - 1 ];
        my $isteps;

        if ( abs( $fsteps - int( $fsteps + 0.5 ) ) == 0.0 ) {
            $isteps = int( $fsteps + 0.5 );
            $fields[ $i - 1 ] =   $fields[ $i ]
                                - $isteps * $steps[ $i - 1 ];
        } else {
            $isteps = int( $fsteps );

            if (    $i == 1
                 or $mult[ $i - 1 ] <= $mult[ $i - 2 ] ) {
                $fields[ $i - 1 ] =   $fields[ $i ]
                                    - ( $isteps + 1 ) * $steps[ $i - 1 ];
            } else {
                $fields[ $i - 1 ] =   $fields[ $i ]
                                    - $isteps * $steps[ $i - 1 ];
            }
        }

    }

    $fields[ 0 ] += $mult[ 0 ] * $step if $fields[ 0 ] < 0;

    $_ = 1.0e-3 * int( 1.0e3 * $_ + 0.5 ) for @fields;

    $field_ok = 1;

    $h3->configure( -state => 'normal' ) if $pretrigger_ok;
}


1;



###################################################

use strict;
use warnings;

Stage2::get_params( Stage1::get_regions( ) );

my $step = 1.0e12;
for ( @steps ) {
    $step = $_ if $step > $_;
}

my @mult;
push @mult, int( $_ / $step + 0.5 ) for @steps;


my @traces;
my $num_traces = 0;
my $num_shown_traces = 0;
for ( 0 .. @steps - 1 ) {
    $traces[ $_ ] = abs( int( ( $fields[ $_ + 1 ] - $fields[ $_ ] )
                              / $steps[ $_ ] + 0.5 ) );
    $num_traces += $traces[ $_ ];
    $num_shown_traces += $mult[ $_ ] * $traces[ $_ ];
}

my $num_bg_traces = 0;

if ( $ud eq 'Up' ) {
    $st = -1 if ! defined $st or $st eq '' or $st > $fields[ -1 ];

    if ( $st >= $fields[ 0 ] ) {
        my $f = $fields[ 0 ];
        $num_bg_traces++;

        for ( my $i = 0; $i < @steps; $i++ ) {
            last if $f > $st;
            for ( 0 ... $traces[ $i ] - 1) {
                $f += $steps[ $i ];
                last if $f > $st;
                $num_bg_traces++;
            }
        }
    }
} else {
    @fields = reverse @fields;
    @steps = reverse @steps;
    @traces = reverse @traces;
    @mult = reverse @mult;

    $st = 1.0e12 if ! defined $st or $st eq '' or $st < $fields[ -1 ];
    if ( $st <= $fields[ 0 ] ) {
        my $f = $fields[ 0 ];
        $num_bg_traces++;

        for ( my $i = 0; $i < @steps; $i++ ) {
            last if $f < $st;
            for ( 0 ... $traces[ $i ] - 1) {
                $f -= $steps[ $i ];
                last if $f < $st;
                $num_bg_traces++;
            }
        }
    }
}

$traces[ -1 ]++;
$num_traces++;
$num_shown_traces++;

my $end_field = pop @fields;

my $prog = '';
$prog .= $_ while <DATA>;

$prog = ( split /---\n/, $prog )[ $ud eq 'Up' ? 0 : 1 ];

my $num_regions = scalar@fields;

$prog =~ s/NUM_REGIONS/$num_regions/g;

my $f = join ' G, ', @fields;
$f .= ' G';
$prog =~ s/ START_FIELDS / $f /g;

$prog =~ s/END_FIELD/$end_field/g;

$f = join ' G, ', @steps;
$f .= ' G';
$prog =~ s/ FIELD_STEPS / $f /g;

$f = join ', ', @mult;
$prog =~ s/ MULT / $f /g;

$f = join ', ', @traces;
$prog =~ s/ TRACES / $f /g;

$prog =~ s/SMALL_STEP/$step A/g;
$prog =~ s/PRETRIGGER/$pretrigger/g;
$prog =~ s/NUM_TRACES/$num_traces/g;
$prog =~ s/NUM_SHOWN_TRACES/$num_shown_traces/g;
$prog =~ s/NUM_AVG/$num_avg/g;
$prog =~ s/ACQ_CHANNEL/$aqc/g;
$prog =~ s/AVG_CHANNEL/$avc/g;
$prog =~ s/TRIGGER_CHANNEL/$tc/g;
$prog =~ s/NUM_NO_SIGNAL_TRACES/$num_bg_traces/g;

my $fh;

open $fh, "|fsc2_" . lc $htr
    or die "Can't find utility fsc2_" . lc $htr . ".\n";

print $fh $prog;

close $fh;

my $text;
if ( $? != 0 ) {
    if ( $? >> 8 == 255 ) {
        $text = "Internal error.";
    } elsif ( $? >> 8 == 1 ) {
        $text = "Someone else is running fsc2.";
    } elsif ( $? >> 8 == 2 ) {
        $text = "fsc2 is already testing or\nrunning an experiment.";
    } elsif ( $? >> 8 == 3 ) {
        $text = "Internal error of fsc2.";
    } elsif ( $? >> 8 == 4 ) {
        $text = "Could not start fsc2.";
    } else {
        $text = "Something strange\nis going on here.";
    }

    &show_message( $text ) if $? >> 8 != 0;
}

sub show_message {
    my $text = shift;
    my $mw = MainWindow->new( );
    $mw->title( "Error" );
	$mw->optionAdd( '*BorderWidth' => 1 );
    $mw->messageBox( -icon => 'error',
                     -type => 'Ok',
                     -title => 'Error',
                     -message => $text );
}


__DATA__
DEVICES:

er032m;
lecroy9400;


VARIABLES:

Num_regions = NUM_REGIONS;
start_fields[ Num_regions ] = { START_FIELDS };
end_field = END_FIELD A;
field_steps[ Num_regions ] = { FIELD_STEPS };
Mult[ Num_regions ] = { MULT };
Num_steps[ Num_regions ] = { TRACES };
small_step = SMALL_STEP;
Max_traces = NUM_TRACES;
Max_shown_traces = NUM_SHOWN_TRACES;
Num_no_signal_traces = NUM_NO_SIGNAL_TRACES;
field[ Max_traces ];
Num_Avg     = NUM_AVG;
Trace_len;
timebase;
time_res;
pretrigger  = 0.01 * PRETRIGGER;
Trace_no, Trace_shown_no;
data[ Max_traces, * ];
mdata[ Max_traces, * ];
data_xinteg[ Max_shown_traces, * ];
mdata_xinteg[ Max_shown_traces, * ];
mdata_g[ Max_traces, * ];
new_mdata[ * ];
new_mdata_g[ * ];
background[ * ];
Pretrigger_Points;
ground[ Max_traces ];
Scan_No = 0;
I, J, K, L, M, N;
BG_count = 0;
B1, B2, B3, B4;
File_p, File_p2, File_f, File_r, File_r2, File_d;
Scans_done = 0;


PREPARATIONS:

init_2d( Num_no_signal_traces > 0 ? 3 : 2, 0, Max_shown_traces, 0, 1,
         start_fields[ 1 ], small_step, "Time [µs]", "Field [G]",
         "Signal [mV]" );


EXPERIMENT:

Trace_len = digitizer_record_length( ACQ_CHANNEL );

background= float_slice( Trace_len );
mdata[ 1 ] = float_slice( Trace_len );
mdata_g[ 1 ] = mdata[ 1 ];
FOR I = 2 : Max_traces {
    mdata[ I ] = mdata[ 1 ];
    mdata_g[ I ] = mdata_g[ 1 ];
}

/* Now get the timebase and the corresponding time resolution */

timebase = digitizer_timebase( );
time_res = digitizer_time_per_point( );

pretrigger = 0.02 * timebase * round(   pretrigger * time_res
                                      * Trace_len * 50.0 / timebase );
digitizer_trigger_delay( pretrigger );
Pretrigger_Points = int( pretrigger / time_res );

/* Correct the x-axis for to the amount of pre-trigger and the timebase */

change_scale_2d( - pretrigger / 1 us, time_res / 1 us );

/* Set up triggering and averaging */

digitizer_trigger_channel( TRIGGER_CHANNEL );
digitizer_trigger_mode( "NORM" );

digitizer_averaging( AVG_CHANNEL, ACQ_CHANNEL, Num_Avg );

/* Create the toolbox with two output field, one for the current scan number
   and one for the current field as well as a push button for stopping the
   experiment at the end of a scan */

hide_toolbox( "ON" );
B1 = output_create( "INT_OUTPUT", "Current scan" );
B2 = output_create( "FLOAT_OUTPUT", "Current field [G]", "%.3f" );
B3 = button_create( "PUSH_BUTTON", "Pause/Continue" );
B4 = button_create( "PUSH_BUTTON", "Stop after end of scan" );
hide_toolbox( "OFF" );

/* Now we need two nested loops, the outer loop over the scans and the inner
   loop over the field positions */

FOREVER {

    Scan_No += 1;

    field[ 1 ] = magnet_field( start_fields[ 1 ] );
    output_value( B1, Scan_No );

    Trace_no = 0;
    Trace_shown_no = 0;

    FOR I = 1 : Num_regions {
        FOR J = 1 : Num_steps[ I ] {
            Trace_no += 1;

            output_value( B2, field[ Trace_no ] );

            /* Start an acquisition and fetch the resulting curve, then
               immediately sweep up */

            digitizer_start_acquisition( );
            data[ Trace_no ] = digitizer_get_curve( AVG_CHANNEL );
            FOR K = 1 : Mult[ I ] {
                IF Trace_shown_no + K <= Max_shown_traces {
                    data_xinteg[ Trace_shown_no + K ] = data[ Trace_no ];
                }
            }

            IF Trace_no != Max_traces {
                field[ Trace_no + 1 ] =
                          magnet_field( field[ Trace_no ] + field_steps[ I ] );
            }

            /* Calculate the mean of the data points before the trigger for the
               elimination of baseline drifts */

            IF Pretrigger_Points == 0 {
                ground[ Trace_no ] = 0.0;
            } ELSE IF Pretrigger_Points == 1 {
                ground[ Trace_no ] = data[ Trace_no, 1 ];
            } ELSE {
                ground[ Trace_no ] =
                                mean( data[ Trace_no, 1 : Pretrigger_Points ] );
            }

            new_mdata = add_to_average( mdata[ Trace_no ], data[ Trace_no ],
                                        Scan_No );
            mdata_g[ Trace_no ] =
                        add_to_average( mdata_g[ Trace_no ],
                                        data[ Trace_no ] - ground[ Trace_no ],
                                        Scan_No );

            FOR K = 1 : Mult[ I ] {
                IF Trace_shown_no + K <= Max_shown_traces {
                    display_2d( 1, Trace_shown_no + K, new_mdata / 1 mV, 1,
                                1, Trace_shown_no + K, mdata_g[ Trace_no ]
                                / 1 mV, 2 );
                }
            }

            IF Num_no_signal_traces <= 0 {
                Trace_shown_no += Mult[ I ];
                IF Trace_shown_no > Max_shown_traces {
                    Trace_shown_no = Max_shown_traces;
                }
                NEXT;
            }

            IF Trace_no <= Num_no_signal_traces {
                BG_count += 1;
                background =
                        add_to_average( background,
                                        data[ Trace_no ] - ground[ Trace_no ],
                                        BG_count );

                N = 0;
                Trace_shown_no = 0;
                FOR K = 1 : Num_regions {
                    FOR L = 1 : Num_steps[ K ] {
                        N += 1;
                        IF N > Trace_no {
                            BREAK;
                        }

                        FOR M = 1 : Mult[ K ] {
                            IF Trace_shown_no < Max_shown_traces {
                                Trace_shown_no += 1;
                                display_2d( 1, Trace_shown_no,
                                            ( mdata_g[ N ] - background )
                                            / 1 mV, 3 );
                            }
                        }
                    }
                }
            } ELSE {
                FOR K = 1 : Mult[ I ] {
                    IF Trace_shown_no < Max_shown_traces {
                        Trace_shown_no += 1;
                        display_2d( 1, Trace_shown_no,
                                    ( mdata_g[ Trace_no ] - background ) / 1 mV,
                                    3 );
                    }
                }
            }

            WHILE button_state( B3 ) {
                wait( 0.25 s );
            }
        }

        WHILE button_state( B3 ) {
            wait( 0.25 s );
        }
    }

    /* Now that we're done with the scan recalculate the new mean */

    mdata = add_to_average( mdata, data, Scan_No );
    mdata_xinteg = add_to_average( mdata_xinteg, data_xinteg, Scan_No );

    Scans_done += 1;                      // Update the number of scans done

    WHILE button_state( B3 ) {
        wait( 0.25 s );
    }

    IF button_state( B4 ) {               // Stop on user request
        BREAK;
    }
}


ON_STOP:

IF Scans_done == 0 AND Trace_no <= 1 {
    abort( );
}

hide_toolbox( "ON" );

File_d = get_file( "", "*.dat", "", "", "dat" );
IF ! is_file( File_d ) {
    abort( );
}

File_p = clone_file( File_d, "dat", "par" );
File_p2 = clone_file( File_d, "dat", "xinteg.par" );
File_f = clone_file( File_d, "dat", "fld" );
File_r = clone_file( File_d, "dat", "raw" );
File_r2 = clone_file( File_d, "dat", "xinteg.raw" );

fsave( File_p, "Date                : # #\n",
       date( ), time( ) );

IF Scans_done > 0 {
    FOR I = 1 : Num_regions {
        fsave( File_p, 
               "Start field #       = # G\n"
               "Field step size #   = # G\n"
               "No. of traces #     = #\n",
               I, start_fields[ I ], I, field_steps[ I ], I, Num_steps[ I ] );
    }
} ELSE {
    N = Trace_no - 1;
    FOR I = 1 : Num_regions {
        fsave( File_p, 
               "Start field #       = # G\n"
               "Field step size #   = # G\n"
               "No. of traces #     = #\n",
               I, start_fields[ I ], I, field_steps[ I ], I,
               N < Num_steps[ I ] ? N : Num_steps[ I ] );

        N -= Num_steps[ I ];
        IF N <= 0 {
            BREAK;
        }
    }
}

fsave( File_p, "End field           = # G\n"
               "No. of scans        = #\n"
               "No. of averages     = #\n"
               "Signal channel      = ACQ_CHANNEL\n"
               "Averaging channel   = AVG_CHANNEL\n"
               "Sensitivity         = # mV\n"
               "Timebase            = # us\n"
               "Time resolution     = # ns\n"
               "Trigger channel     = TRIGGER_CHANNEL\n"
               "Trigger position    = # us\n"
               "Trigger mode        = NORM\n"
               "Trigger level       = # V\n"
               "Total no. of traces = #\n"
               "Trace length        = #\n"
               "No signal traces    = #\n",
       Scans_done == 0 ? field[ Trace_no - 1 ] : field[ Max_traces ],
       Scans_done == 0 ? 1 : Scans_done, Num_Avg,
       digitizer_sensitivity( CH1 ) / 1 mV,
       timebase / 1 us, time_res / 1 ns, pretrigger / 1 us,
       digitizer_trigger_level( ),
       Scans_done == 0 ? Trace_no - 1 : Max_traces,
       Trace_len, Num_no_signal_traces );

fsave( File_p2, "Date                : # #\n"
                "Start field         = # G\n"
                "End field           = # G\n"
                "Field step size     = # G\n"
                "No. of scans        = #\n"
                "No. of averages     = #\n"
                "Signal channel      = ACQ_CHANNEL\n"
                "Averaging channel   = AVG_CHANNEL\n"
                "Sensitivity         = # mV\n"
                "Timebase            = # us\n"
                "Time resolution     = # ns\n"
                "Trigger channel     = TRIGGER_CHANNEL\n"
                "Trigger position    = # us\n"
                "Trigger mode        = NORM\n"
                "Trigger level       = # V\n"
                "No. of traces       = #\n"
                "Trace length        = #\n"
                "No signal traces    = #\n",
       date( ), time( ),
       start_fields[ 1 ],
       Scans_done == 0 ? field[ Trace_no - 1 ] : field[ Max_traces ],
       small_step,
       Scans_done == 0 ? 1 : Scans_done, Num_Avg,
       digitizer_sensitivity( CH1 ) / 1 mV,
       timebase / 1 us, time_res / 1 ns, pretrigger / 1 us,
       digitizer_trigger_level( ),
       Scans_done == 0 ? Trace_shown_no - 1 : Max_shown_traces,
       Trace_len, Num_no_signal_traces );

IF Scans_done == 0 {
    save( File_f, field[ 1 : Trace_no - 1 ] );
    save( " ", File_r, data[ 1 : Trace_no - 1 ] );
    save( " ", File_r2, data_xinteg[ 1 : Trace_shown_no - 1 ] );
    save( " ", File_d, mdata_g[ 1 : Trace_no - 1 ] );
} ELSE {
    save( File_f, field );
    save( " ", File_r, mdata );
    save( " ", File_r2, mdata_xinteg );
    save( " ", File_d, mdata_g );
}

save_comment( File_p );
---
DEVICES:

er032m;
lecroy9400;


VARIABLES:

Num_regions = NUM_REGIONS;
start_fields[ Num_regions ] = { START_FIELDS };
end_field = END_FIELD A;
field_steps[ Num_regions ] = { FIELD_STEPS };
Mult[ Num_regions ] = { MULT };
Num_steps[ Num_regions ] = { TRACES };
small_step = SMALL_STEP;
Max_traces = NUM_TRACES;
Max_shown_traces = NUM_SHOWN_TRACES;
Num_no_signal_traces = NUM_NO_SIGNAL_TRACES;
field[ Max_traces ];
Num_Avg     = NUM_AVG;
Trace_len;
timebase;
time_res;
pretrigger  = 0.01 * PRETRIGGER;
Trace_no, Trace_shown_no;
data[ Max_traces, * ];
mdata[ Max_traces, * ];
data_xinteg[ Max_shown_traces, * ];
mdata_xinteg[ Max_shown_traces, * ];
mdata_g[ Max_traces, * ];
new_mdata[ * ];
new_mdata_g[ * ];
background[ * ];
Pretrigger_Points;
ground[ Max_traces ];
Scan_No = 0;
I, J, K, L, M, N;
BG_count = 0;
B1, B2, B3, B4;
File_p, File_p2, File_f, File_r, File_r2, File_d;
Scans_done = 0;


PREPARATIONS:

init_2d( Num_no_signal_traces > 0 ? 3 : 2, 0, Max_shown_traces, 0, 1,
         end_field, small_step, "Time [µs]", "Field [G]", "Signal [mV]" );


EXPERIMENT:

Trace_len = digitizer_record_length( ACQ_CHANNEL );

background= float_slice( Trace_len );
mdata[ 1 ] = float_slice( Trace_len );
mdata_g[ 1 ] = mdata[ 1 ];
FOR I = 2 : Max_traces {
    mdata[ I ] = mdata[ 1 ];
    mdata_g[ I ] = mdata_g[ 1 ];
}

/* Now get the timebase and the corresponding time resolution */

timebase = digitizer_timebase( );
time_res = digitizer_time_per_point( );

pretrigger = 0.02 * timebase * round(   pretrigger * time_res
                                      * Trace_len * 50.0 / timebase );
digitizer_trigger_delay( pretrigger );
Pretrigger_Points = int( pretrigger / time_res );

/* Correct the x-axis for to the amount of pre-trigger and the timebase */

change_scale_2d( - pretrigger / 1 us, time_res / 1 us );

/* Set up triggering and averaging */

digitizer_trigger_channel( TRIGGER_CHANNEL );
digitizer_trigger_mode( "NORM" );

digitizer_averaging( AVG_CHANNEL, ACQ_CHANNEL, Num_Avg );

/* Create the toolbox with two output field, one for the current scan number
   and one for the current field as well as a push button for stopping the
   experiment at the end of a scan */

hide_toolbox( "ON" );
B1 = output_create( "INT_OUTPUT", "Current scan" );
B2 = output_create( "FLOAT_OUTPUT", "Current field [G]", "%.3f" );
B3 = button_create( "PUSH_BUTTON", "Pause/Continue" );
B4 = button_create( "PUSH_BUTTON", "Stop after end of scan" );
hide_toolbox( "OFF" );

/* Now we need two nested loops, the outer loop over the scans and the inner
   loop over the field positions */

FOREVER {

    Scan_No += 1;

    field[ 1 ] = magnet_field( start_fields[ 1 ] );
    output_value( B1, Scan_No );

    Trace_no = 0;
    Trace_shown_no = Max_shown_traces;

    FOR I = 1 : Num_regions {
        FOR J = 1 : Num_steps[ I ] {
            Trace_no += 1;

            output_value( B2, field[ Trace_no ] );

            /* Start an acquisition and fetch the resulting curve, then
               immediately sweep up */

            digitizer_start_acquisition( );
            data[ Trace_no ] = digitizer_get_curve( AVG_CHANNEL );
            FOR K = 0 : Mult[ I ] - 1 {
                IF Trace_shown_no - K > 0 {
                    data_xinteg[ Trace_shown_no - K ] = data[ Trace_no ];
                }
            }

            IF Trace_no != Max_traces {
                field[ Trace_no + 1 ] =
                          magnet_field( field[ Trace_no ] - field_steps[ I ] );
            }

            /* Calculate the mean of the data points before the trigger for the
               elimination of baseline drifts */

            IF Pretrigger_Points == 0 {
                ground[ Trace_no ] = 0.0;
            } ELSE IF Pretrigger_Points == 1 {
                ground[ Trace_no ] = data[ Trace_no, 1 ];
            } ELSE {
                ground[ Trace_no ] =
                                mean( data[ Trace_no, 1 : Pretrigger_Points ] );
            }

            new_mdata = add_to_average( mdata[ Trace_no ], data[ Trace_no ],
                                        Scan_No );
            mdata_g[ Trace_no ] =
                        add_to_average( mdata_g[ Trace_no ],
                                        data[ Trace_no ] - ground[ Trace_no ],
                                        Scan_No );

            FOR K = 1 : Mult[ I ] {
                IF Trace_shown_no - K >= 0 {
                    display_2d( 1, Trace_shown_no - K + 1, new_mdata / 1 mV, 1,
                                1, Trace_shown_no - K + 1,
                                mdata_g[ Trace_no ] / 1 mV, 2 );
                }
            }

            IF Num_no_signal_traces <= 0 {
                Trace_shown_no -= Mult[ I ];
                IF Trace_shown_no < 0 {
                    Trace_shown_no = 0;
                }
                NEXT;
            }

            IF Trace_no <= Num_no_signal_traces {
                BG_count += 1;
                background =
                        add_to_average( background,
                                        data[ Trace_no ] - ground[ Trace_no ],
                                        BG_count );

                N = 0;
                Trace_shown_no = Max_shown_traces;
                FOR K = 1 : Num_regions {
                    FOR L = 1 : Num_steps[ K ] {
                        N += 1;
                        IF N > Trace_no {
                            BREAK;
                        }

                        FOR M = 1 : Mult[ K ] {
                            IF Trace_shown_no > 0 {
                                display_2d( 1, Trace_shown_no,
                                            ( mdata_g[ N ] - background )
                                            / 1 mV,
                                            3 );
                                Trace_shown_no -= 1;
                            }
                        }
                    }
                }
            } ELSE {
                FOR K = 1 : Mult[ I ] {
                    IF Trace_shown_no > 0 {
                        display_2d( 1, Trace_shown_no,
                                    ( mdata_g[ Trace_no ] - background ) / 1 mV,
                                    3 );
                        Trace_shown_no -= 1;
                    }
                }
            }

            WHILE button_state( B3 ) {
                wait( 0.25 s );
            }
        }

        WHILE button_state( B3 ) {
            wait( 0.25 s );
        }
    }

    /* Now that we're done with the scan recalculate the new mean */

    mdata = add_to_average( mdata, data, Scan_No );
    mdata_xinteg = add_to_average( mdata_xinteg, data_xinteg, Scan_No );

    Scans_done += 1;                      // Update the number of scans done

    WHILE button_state( B3 ) {
        wait( 0.25 s );
    }

    IF button_state( B4 ) {               // Stop on user request
        BREAK;
    }
}


ON_STOP:

IF Scans_done == 0 AND Trace_no <= 1 {
    abort( );
}

hide_toolbox( "ON" );

File_d = get_file( "", "*.dat", "", "", "dat" );
IF ! is_file( File_d ) {
    abort( );
}

File_p = clone_file( File_d, "dat", "par" );
File_p2 = clone_file( File_d, "dat", "xinteg.par" );
File_f = clone_file( File_d, "dat", "fld" );
File_r = clone_file( File_d, "dat", "raw" );
File_r2 = clone_file( File_d, "dat", "xinteg.raw" );

fsave( File_p, "Date                : # #\n",
       date( ), time( ) );

IF Scans_done > 0 {
    FOR I = 1 : Num_regions {
        fsave( File_p, 
               "Start field #       = # G\n"
               "Field step size #   = -# G\n"
               "No. of traces #     = #\n",
               I, start_fields[ I ], I, field_steps[ I ], I, Num_steps[ I ] );
    }
} ELSE {
    N = Trace_no - 1;
    FOR I = 1 : Num_regions {
        fsave( File_p, 
               "Start field #       = # G\n"
               "Field step size #   = -# G\n"
               "No. of traces #     = #\n",
               I, start_fields[ I ], I, field_steps[ I ], I,
               N < Num_steps[ I ] ? N : Num_steps[ I ] );

        N -= Num_steps[ I ];
        IF N <= 0 {
            BREAK;
        }
    }
}

fsave( File_p, "End field           = # G\n"
               "No. of scans        = #\n"
               "No. of averages     = #\n"
               "Signal channel      = ACQ_CHANNEL\n"
               "Averaging channel   = AVG_CHANNEL\n"
               "Sensitivity         = # mV\n"
               "Timebase            = # us\n"
               "Time resolution     = # ns\n"
               "Trigger channel     = TRIGGER_CHANNEL\n"
               "Trigger position    = # us\n"
               "Trigger mode        = NORM\n"
               "Trigger level       = # V\n"
               "Total no. of traces = #\n"
               "Trace length        = #\n"
               "No signal traces    = #\n",
       Scans_done == 0 ? field[ Trace_no - 1 ] : field[ Max_traces ],
       Scans_done == 0 ? 1 : Scans_done, Num_Avg,
       digitizer_sensitivity( CH1 ) / 1 mV,
       timebase / 1 us, time_res / 1 ns, pretrigger / 1 us,
       digitizer_trigger_level( ),
       Scans_done == 0 ? Trace_no - 1 : Max_traces,
       Trace_len, Num_no_signal_traces );

fsave( File_p2, "Date                : # #\n"
                "Start field         = # G\n"
                "End field           = # G\n"
                "Field step size     = # G\n"
                "No. of scans        = #\n"
                "No. of averages     = #\n"
                "Signal channel      = ACQ_CHANNEL\n"
                "Averaging channel   = AVG_CHANNEL\n"
                "Sensitivity         = # mV\n"
                "Timebase            = # us\n"
                "Time resolution     = # ns\n"
                "Trigger channel     = TRIGGER_CHANNEL\n"
                "Trigger position    = # us\n"
                "Trigger mode        = NORM\n"
                "Trigger level       = # V\n"
                "No. of traces       = #\n"
                "Trace length        = #\n"
                "No signal traces    = #\n",
       date( ), time( ),
       Scans_done == 0 ? field[ Trace_no - 1 ] : field[ Max_traces ],
       field[ 1 ],
       small_step,
       Scans_done == 0 ? 1 : Scans_done, Num_Avg,
       digitizer_sensitivity( CH1 ) / 1 mV,
       timebase / 1 us, time_res / 1 ns, pretrigger / 1 us,
       digitizer_trigger_level( ),
       Scans_done == 0 ? Max_shown_traces - Trace_shown_no : Max_shown_traces,
       Trace_len, Num_no_signal_traces );

IF Scans_done == 0 {
    save( File_f, field[ 1 : Trace_no - 1 ] );
    save( " ", File_r, data[ 1 : Trace_no - 1 ] );
    save( " ", File_r2, data_xinteg[ Trace_shown_no + 1 : Max_shown_traces ] );
    save( " ", File_d, mdata_g[ 1 : Trace_no - 1 ] );
} ELSE {
    save( File_f, field );
    save( " ", File_r, mdata );
    save( " ", File_r2, mdata_xinteg );
    save( " ", File_d, mdata_g );
}

save_comment( File_p );
