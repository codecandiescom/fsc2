@c  Copyright (C) 1999-2009 Jens Thoms Toerring
@c
@c  This file is part of fsc2.
@c
@c  Fsc2 is free software; you can redistribute it and/or modify
@c  it under the terms of the GNU General Public License as published by
@c  the Free Software Foundation; either version 2, or (at your option)
@c  any later version.
@c
@c  Fsc2 is distributed in the hope that it will be useful,
@c  but WITHOUT ANY WARRANTY; without even the implied warranty of
@c  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c  GNU General Public License for more details.
@c
@c  You should have received a copy of the GNU General Public License
@c  along with fsc2; see the file COPYING.  If not, write to
@c  the Free Software Foundation, 59 Temple Place - Suite 330,
@c  Boston, MA 02111-1307, USA.


@node Built-in Functions, Device Functions, EDL, Top
@chapter Built-in Functions

@ifnottex

@menu
* Output functions::        Functions for drawing and printing.
* File handling functions:: Functions for storing data
* Interaction functions::   Functions buttons and sliders.
* Mathematical functions::  Function for doing mathematics.
* Auxiliary functions::     All other functions.
@end menu

@end ifnottex

In this chapter all functions built into @code{fsc2} are discussed in
detail. These functions are available even when no device modules have
been specified in the @code{DEVICES} section (or this section is
missing). Many functions can be used in the @code{VARIABLES},
@code{PREPARATIONS} as well as the @code{EXPERIMENT} section of an
@code{EDL} script, but there are some that can be used only either
before the @code{EXPERIMENT} section starts or within the
@code{EXPERIMENT} section.

The built-in functions can be roughly divided into four classes. The
first class of functions are functions for drawing the measured data
onto the screen, i.e.@: the main area of the display window (including
functions for changing the axis scaling and labels etc.@:), functions
for dealing with the output of the script, either by writing text to
the browser in the lower half of the main window or by writing data
etc.@: into files (including functions for specifying the files to be
used).

The second class of functions are interaction functions, functions that
allow to deal with additional graphical objects like buttons, sliders and
in- and output fields. These functions control the creation, setting,
query and deletion of these objects (all of them can be used only during
the @code{EXPERIMENT} section).

The third class of functions are mathematical functions that one would
expect to find in most programming languages like (i.e.@: trigonometric
functions, logarithms etc.@:).

Finally, the fourth class are auxiliary functions that can't be assigned
to one of the other classes and consists of functions for dealing with
time or date issues, conversion between different units or for determining
the sizes of arrays and several more.

Please note that all functions, built-in functions as well as device
functions (discussed in the next chapter), always return a value, even
if the return value sometimes doesn't make too much sense.


@node Output functions, File handling functions, Built-in Functions, Built-in Functions
@section Output functions
@cindex output functions

Before delving into the details of the functions for drawing measured
data into the main display window a short explanation of the basic
ideas probably is in order. There are two ways of displaying data. If
only one parameter gets changed during the experiment (e.g.@: just the
magnetic field gets sweeped) a 1D-display will be all you need. But if
you do measurements where two parameters get changed (e..g.@: if you
measure time traces of your signal after laser excitation at different
field positions) you will need a 2D-display to view all measured data.
Finally, there can be situations where you need both ways to display
your data. Thus, @code{fsc2} allows you to select either 1D-display,
2D-display or even both at once at the same time. You just have to
tell the program in the @code{PREPARATIONS} section by calling the
functions @code{@ref{init_1d()}} and @code{@ref{init_2d()}}. If both
function are invoked in the @code{PREPARATIONS} section two windows
will be displayed, one for the 1D-data and one for the 2D-data.

In 1D-display to display a new data point you have to specify the @i{x}-
and the @i{y}-coordinate of the point. The @i{x}-coordinate is always an
integer number, where @code{1} indicates the left-most point
(@i{x}-coordinates smaller than @code{1} aren't allowed). As the
@i{y}-coordinate usually the measured value is specified. To be able to
draw a meaningful @i{x}-axis the program needs another piece of
information: the starting point of the @i{x}-axis and the difference
between two adjacent points drawn along the @i{x}-axis. For example, if
you do an cw-EPR experiment, starting with a field of @w{3400 G} and a
spacing of @w{0.5 G} between the data points you will have to tell the
program about this in the graphics initialization. If you now specify,
when drawing a new point, an @i{x}-coordinate of @code{11} the point
will appear at an axis position of @w{3410 G} because the point numbered
@code{1} is drawn at @w{3400 G}, the point numbered @code{2} at
@w{3400.5 G} etc.@:, so the point numbered @code{11} will appear at
@w{3410 G}.

In contrast, for a 2D-display you have to specify three coordinates for
a new data point. Here both the @i{x}- and @i{y}-coordinate are
integers, both starting at @code{1}. The point with both the @i{x}- and
@i{y}-coordinate set to @code{1} is at lower left-and corner of the
display (and @i{x}- and @i{y}-coordinates with values smaller than @code{1}
aren't allowed). The third coordinate is the measured value, which usually
will be a floating point number. As in the case of 1D-displays also for
2D-display the program needs additional information to be able to draw
meaningful axis. Here not only the starting point and increment for the
@i{x}-axis must be given but also corresponding values for the @i{y}-axis.

Another point to be kept in mind: if you have not only one data point to
draw but a whole 1D-array (or in the case of 2D-display even a 2D-array,
i.e.@: a complete "picture") you can do this without having to draw each
point on its own. The functions for drawing also let you specify a whole
array. The data from the array are drawn so that the first data point of
the array appears at the @i{x}-coordinate you specified, and the following
points further to the right of it. In case of 2D-arrays the @i{x}- and
@i{y}-coordinate specifies the lower left hand corner of where the
2D-array will be drawn.

Finally, for 1D-display also another display mode is available where new
data are always drawn automatically to the right of already displayed
points and where the whole set of already drawn points is shifted to the
left (and out of the viewable area when the new data points wouldn't fit
into the display window anymore). Thus in this "sliding display" mode no
automatic scaling in horizontal direction happens, old data are simply
discarded when they don't fit into the display window anymore.


@noindent
@strong{List of all output functions}:
@table @samp
@item @ref{init_1d()}
@item @ref{init_2d()}
@item @ref{display_1d()}
@item @ref{display_2d()}
@item @ref{display()}
@item @ref{display_mode()}
@item @ref{change_scale_1d()}
@item @ref{change_scale_2d()}
@item @ref{change_scale()}
@item @ref{vert_rescale_1d()}
@item @ref{vert_rescale_2d()}
@item @ref{vert_rescale()}
@item @ref{change_label_1d()}
@item @ref{change_label_2d()}
@item @ref{change_label()}
@item @ref{rescale_1d()}
@item @ref{rescale_2d()}
@item @ref{rescale()}
@item @ref{zoom_1d()}
@item @ref{zoom_2d()}
@item @ref{zoom()}
@item @ref{clear_curve_1d()}
@item @ref{clear_curve_2d()}
@item @ref{clear_curve()}
@item @ref{draw_marker_1d()}
@item @ref{draw_marker_2d()}
@item @ref{draw_marker()}
@item @ref{clear_marker_1d()}
@item @ref{clear_marker_2d()}
@item @ref{clear_marker()}
@item @ref{curve_button_1d()}
@item @ref{curve_button_2d()}
@item @ref{curve_button()}
@item @ref{fs_button_1d()}
@item @ref{fs_button_2d()}
@item @ref{fs_button()}
@item @ref{print()}
@item @ref{show_message()}
@end table


@noindent
@strong{Descriptions of output functions}:


@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{init_1d()}
@findex init_1d()

@table @samp

@item init_1d()
This function initializes the display for one-dimensional data
representation - without a call to this function (or
@code{@ref{init_2d()}}, see below) no data can be displayed. The
function may only be called once and accepts up to six arguments, all
of them being optional. These are:
@enumerate
@item
The number of curves to be displayed, the maximum is currently 4
curves. If not given it defaults to 1.
@item
The number of points, if missing, zero or negative it will be treated as
unknown and default to 32 points. If the specified value (or the default
value) turns out to be too small it is adjusted automatically in the
experiment so that all data again will fit into the display (as long as
the @code{FS} (Full Scale) button is switched on).
@item
Start value of the @i{x}-axis. If missing (or undefined, see next point)
point numbers are printed, starting with @code{1}.
@item
Increment for data along the @i{x}-axis (thus restricting the display to
equally spaced data). Setting it to zero implies that the start value
and the increment are undefined and point numbers are shown
instead. Negative increments are handled correctly.
@item
A string variable with the label to be shown at the @i{x}-axis.
@item
A string variable with the label to be shown at the @i{y}-axis.
@end enumerate

Formally, the function with its arguments can be written as
@example
init_1d( [ n_curves [ , n_points [ , start, increment ] ], ]
         [ x_label [ , y_label ] ] )
@end example
@noindent
This means that the function can be called in all of the following ways:
@example
init_1d( n_curves, n_points, start, increment, x_label, y_label )
init_1d( n_curves, n_points, start, increment, x_label )
init_1d( n_curves, n_points, x_label, y_label )
init_1d( n_curves, n_points, x_label )
init_1d( n_curves, n_points )
init_1d( n_curves, x_label, y_label )
init_1d( n_curves, x_label )
init_1d( n_curves )
init_1d( x_label, y_label )
init_1d( x_label )
init_1d( )
@end example
@noindent
In error messages the start value and the increment of the data
displayed at the @i{x}-axis are (in contrast to the point numbers)
referred to as `real world coordinates'.

This function can only be used in the @code{PREPARATIONS} section of an
@code{EDL} script.


@anchor{init_2d()}
@findex init_2d()
@item init_2d()
The function initializes the display for two-dimensional data
representation.  The function may only be called once and accepts
up to nine arguments, all of them optional. The arguments are:
@enumerate
@item
Number of data sets to be displayed, maximum is currently 4. If not
given it defaults to 1.
@item
Number of points in @i{x}-direction, if missing or less than 1 it will
be treated as unknown and default to 16. If the specified value (or the
default value) turns out to be too small it is adjusted automatically in
the experiment so that all data fit into the display.
@item
Number of points in @i{y}-direction, if missing or less than 1 it will
be treated as unknown and default to 16. If the specified or the default
value turns out to be too small it is adjusted automatically in the
experiment so that all data fit into the display (at least as long as
the @code{FS} (Full Scale) button is switched on).
@item
Start value of the @i{x}-axis. If missing (or undefined, see also next
entry) point numbers are printed, starting with @code{1}.
@item
Increment for data along the @i{x}-axis (thus restricting the display to
equally spaced data). Setting it to zero implies that the start value
and the increment are undefined and point numbers are shown instead.
@item
Start value of the @i{y}-axis. The same rules as for the @i{x}-axis apply
for missing or undefined values.
@item
Increment for data along the @i{y}-axis. The same rules as for the
@i{x}-axis apply for missing values or when zero is specified.
@item
String variable with label to be shown at the @i{x}-axis.
@item                
String variable with label to be shown at the @i{y}axis.
@item
String variable with label to be shown at the @i{z}-axis.
@end enumerate
Formally, the function with its arguments can be written as
@example
init_2d( [ n_data_sets [ , n_x_points [ , n_y_points, 
         [ , x-start, x-increment, y-start, y-increment ] ,
         ]  ]  ] [ x-label [ , y-label [ , z-label ] ] ] )
@end example

This function can only be used in the @code{PREPARATIONS} section of an
@code{EDL} script.


@anchor{display_1d()}
@findex display_1d()
@item display_1d()
This function is used called to draw data in the window for 1D-data. It
takes the following arguments:
@enumerate
@item
The (@i{x}) point number (coordinate) where the data point (if only a
single number is given as the third argument) or the coordinate where
the first data point of an data array passed as the third argument is to
be shown.

Please note: in "sliding window" display mode this first argument won't
be used at all (but it must be given and must be larger than @code{0}),
new data will @strong{always} be appended to the right side of the
display. I.e.@: in "sliding window" display mode you have no direct
control about where the data will be displayed.
@item
The data point or a (one-dimensional) array of data (to be displayed
left to right).
@item
Number of the curve or data set the data are to be displayed belong
to. If missing it defaults to the first curve, 1. If there is more
than one data set given in the @code{@ref{display()}} command the
curve number must be specified.
@end enumerate
These arguments can be repeated as many times as there are data to be
displayed simultaneously (but in this case all of the arguments must be
specified!).

Formally, the function with its arguments can be written as
@example
display( n_x_point, data [ , n_curve [ , ... ] ] )
@end example

When the display mode (@ref{display_mode()}) is set to @code{SLIDING
DISPLAY} the @i{x}-coordinate has no function at all (but must be given
and must be larger than @code{0}), new data points are always appended
to the right of the already drawn data points.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{display_2d()}
@findex display_2d()
@item display_2d()
This function is used called to draw data in the window for 2D-data.
experiments. It takes the following arguments:
@enumerate
@item
The (@i{x}) point number (coordinate) where the data point (if only a
single number is given as the third argument) or the coordinate where
the first data point of an data array passed as the third argument is to
be shown.
@item
The @i{y}-point number (coordinate) of the data point or the coordinate
for the first data point of an data array (arrays are always drawn to
the right from the specified coordinate, i.e.@: in @i{x}-direction).
@item
The data point or a 1-dimensional or 2-dimensional array of data. If a
2-dimensional array is passed to the function, the first sub-array is
drawn at the coordinates passed to the function, while for each of the
following sub-arrays the @i{y}-point is incremented by 1. Not yet
defined sub-arrays are skipped (but the @i{y}-position is incremented),
at the row where this (undefined) sub-array would have appeared nothing
is drawn.
@item
Number of the curve or data set the data are to be displayed belong
to. If missing it defaults to the first curve, 1. If there is more
than one data set given in the @code{@ref{display()}} command the
curve number must be specified.
@end enumerate
These arguments can be repeated as many times as there are data to be
displayed simultaneously (but in this case all of the arguments must be
specified!).

Formally, the function with its arguments can be written as
@example
display( n_x_point, n_y_point, data [ , n_curve [ , ... ] ] )
@end example

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{display()}
@findex display()
@item display()
This function can be used instead of either @code{@ref{display_1d()}}
or @code{@ref{display_2d()}} if either @code{@ref{init_1d()}} or
@code{@ref{init_2d()}} (but not both) were called in the
@code{PREPARATIONS} section. It takes the following arguments:
@enumerate
@item
The (@i{x}) point number (coordinate) where the data point (if only a
single number is given as the third argument) or the coordinate where
the first data point of an data array passed as the third argument is to
be shown.
@item
Only for 2D-display: The @i{y}-point number (coordinate) of the data
point or the coordinate for the first data point of an data array
(arrays are always drawn to the right from the specified coordinate,
i.e.@: in @i{x}-direction).
@item
The data point or a (one-dimensional) array of data.
@item
Number of the curve or data set the data are to be displayed belong
to. If missing it defaults to the first curve, 1. If there is more
than one data set given in the @code{@ref{display()}} command the
curve number must be specified.
@end enumerate
These arguments can be repeated as many times as there are data to be
displayed simultaneously (but in this case all of the arguments must be
specified!).

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{display_mode()}
@findex display_mode()
@item display_mode()
Beside the normal display mode, where data get rescaled automatically to
fit onto the 1D display window (at least as long as the @code{FS} (Full
Scale) button is switched on), there's also a second display mode, where
a rescaling is done for the @i{y}-direction only. In this mode, when the
new data wouldn't fit into the display window anymore, the whole data set
is shifted to the left to make room for the new data, and some of the old
data vanish.

To switch between the normal display mode and the "sliding window"
display mode the function @code{@ref{display_mode()}} has to be used.
The function expects at least one argument, the mode to be used. You
have to specify the string @code{"NORMAL_DISPLAY"} (or @code{"NORMAL"}
or simply the number @code{0}) to switch to the normal display mode
(which is the default mode to be used) and the string
@code{"SLIDING_DISPLAY"} (or @code{"SLIDING"} or the number @code{1})
to switch to "sliding window" mode.

The second, optional argument is the number of points to display in
@i{x}-direction. If this argument isn't specified the previous number of
already displayed points will be used (but at least 32).

When the function gets called all previously displayed data will be
cleared from the screen as well as all markers possibly shown. The
scaling in @i{y}-directions remains unchanged.

This function can be used in both the @code{PREPARATIONS} as well as the
@code{EXPERIMENT} section of an @code{EDL} script.


@anchor{change_scale_1d()}
@findex change_scale_1d()
@item change_scale_1d()
This function allows to change the scale settings of the 1D-data
window (originally set in the call of @code{@ref{init_1d()}}) after an
experiment has been started. The function can be passed a maximum of
two arguments, the new start value of the @i{x}-axis and the new
@i{x}-increment.If one of these values should remain unchanged a
string (e.g.@: @code{"keep"}) instead of a value can be passed as the
argument.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{change_scale_2d()}
@findex change_scale_2d()
@item change_scale_2d()
This function allows to change the scale settings of the 2D-data
window (originally set in the call of @code{@ref{init_2d()}}) after an
experiment has been started. The function accepts up to four
arguments, the new start value of the @i{x}-axis, the new
@i{x}-increment, a new start value for the @i{y}-axis as well as the
@i{y}-increment. If one of these values should remain unchanged a
string (e.g.@: @code{"keep"}) instead of a value can be passed as the
argument.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{change_scale()}
@findex change_scale()
@item change_scale()
This function allows to change the scale settings (originally set in
the call of @code{@ref{init_1d()}} or @code{@ref{init_2d()}}) when
your using either a 1D-display or a 2D-display (but not both) after
the experiment has been started. With a one-dimensional display the
function can be passed a maximum of two arguments, the new start value
of the @i{x}-axis and the new @i{x}-increment. For two-dimensional
display the function also accepts a new start value for the @i{y}-axis
as well as the @i{y}-increment. If one of these values should remain
unchanged a string (e.g.@: @code{"keep"}) instead of a value can be
passed as the argument.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{vert_rescale_1d()}
@findex vert_rescale_1d()
@item vert_rescale_1d()
The function allows to resize the @i{y}-scaling of the display so that
all curves will again fit vertically into the display area (the horizontal
scaling is left unchanged). The function takes no arguments.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{vert_rescale_2d()}
@findex vert_rescale_2d()
@item vert_rescale_2d()
The function allows to resize the @i{z}-scaling of the display so that
currently displayed curve will use the full range of @i{z}-values again.
The function takes no arguments.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{vert_rescale()}
@findex vert_rescale()
@item vert_rescale()
The function allows to change the vertical scaling for 1D-display or
the @i{z}-scaling for 2D-display when only either 1D or 2D display is
activated. If both are active use the function
@code{@ref{vert_rescale_1d()}} to change the vertical scaling of the
1D display and @code{@ref{vert_rescale_2d()}} to change the
@i{z}-scaling of the 2D display.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.



@anchor{change_label_1d()}
@findex change_label_1d()
@item change_label_1d()
Using this function the labels at the axis of the 1D-display window can
be changed from within as @code{EDL} script. It accepts up to two
strings for the @i{x}- and @i{y}-axis labels. To leave a label unchanged
pass the function an empty string, i.e.@: @code{""}. If no label should
be drawn pass it a string that just contains one (or more) space
characters, i.e.@: @w{@code{" "}}.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{change_label_2d()}
@findex change_label_2d()
@item change_label_2d()
Using this function the labels at the axis of the 2D-display window
(and, if shown, of the cross section window) can be changed from within
as @code{EDL} script. It accepts up to three strings for the @i{x}-,
@i{y}-axis and @i{z}-axis label. To leave a label unchanged pass the
function an empty string, i.e.@: @code{""}. If no label should be drawn
pass it a string that just contains one (or more) space characters,
i.e.@: @w{@code{" "}}.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{change_label()}
@findex change_label()
@item change_label()
Using this function the labels at the axis of the display window (and,
if shown, of the cross section window) can be changed from within as
@code{EDL} script when only either the 1D- or the 2D-display window is
used (but not both). For 1D-display it accepts up to two strings for the
@i{x}- and @i{y}-axis labels, for 2D-display up to three, the third for
the @i{z}-axis label. To leave a label unchanged pass the function an
empty string, i.e.@: @code{""}. If no label should be drawn pass it a
string that just contains one (or more) space characters, i.e.@:
@w{@code{" "}}.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{rescale_1d()}
@findex rescale_1d()
@item rescale_1d()
In the function @code{@ref{init_1d()}} the number of points in
@i{x}-direction can be set. If, during the experiment more points are
displayed then set in the initialization, the scaling of the axis will
be changed automatically. Using the function @code{@ref{rescale()}}
one can change the number of points from within the @code{EDL} script.
The function accepts one argument, the new number of points in
@i{x}-direction. A negative number is silently ignored. For a value of
@code{0} the number of points is adjusted to the number of currently
displayed points. A value of @code{1} will be increased to the lowest
number of points that can be displayed, which is @code{2}. If the
number is smaller than the number of currently displayed points it is
automatically increased to this number.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{rescale_2d()}
@findex rescale_2d()
@item rescale_2d()
In the function @code{@ref{init_2d()}} the number of points in @i{x}-
and @i{y}- direction can be set. If, during the experiment more points
are displayed than had been set in the initialization, the scaling of
the axes will be changed automatically. Using the function
@code{@ref{rescale()}} one can change the number of points from within
the @code{EDL} script. The function accepts two arguments, the first
being the number of points to be displayed in @i{x}-direction and the
second the number of points in @i{y}-direction.

A negative number is silently ignored. For a value of @code{0} the
number of points is adjusted to the number of currently displayed points
in that direction. A value of @code{1} will be increased to the lowest
number of points that can be displayed, which is @code{2}. If the number
is smaller than the number of currently displayed points it is
automatically increased to this number.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{rescale()}
@findex rescale()
@item rescale()
This function can be called instead of @code{@ref{rescale_1d()}} or
@code{@ref{rescale_2d()}} when only either a 1D- or a 2D-display is
used (but not both at once). In the 1D-case the function accepts one
argument, the new number of points in @i{x}-direction. In the 2D-case
the function accepts two arguments, one for the number of points to be
displayed in @i{x}-direction and the second for the number of points
in @i{y}-direction.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{zoom_1d()}
@findex zoom_1d()
@item zoom_1d()
This function can be used to zoom into (or out of) the 1D display
window as well as shifting the contents of the window, just like you
can do using the mouse. It expects at least one and up to four
arguments. The first one is either the point number of the point to
show at the leftmost position in the window. The second is the number
of points to be shown within the 1D window. The third value is the
smallest @i{y}-value still to be shown in the 1D window. The fourth
and last optional argument is the span of @i{y}-values to show in the
1D window. The number of points to be shown in @i{x}-direction must be
larger than @code{1} and the @i{y}-span must be larger than @code{0}.
If an argument is not given or is given as an arbitrary string (e.g.@:
@code{"KEEP"}) the corresponding value remains unchanged.

The function returns the value @code{1} to indicate success or @code{0}
if it is impossible to set the zoom (since no scaling has been set for
the 1D window yet).

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{zoom_2d()}
@findex zoom_2d()
@item zoom_2d()
This function can be used to zoom into (or out of) the 2D display
window as well as shifting the contents of the window, just like you
can do using the mouse. It expects at least two and up to seven
arguments. The first one is the number of the curve to be zoomed. This
must be a number between @code{1} and the maximum curve number (as set
by the call of @code{@ref{init_2d()}}). The second and third argument
are the @i{x}-coordinate of the leftmost point to be displayed within
the 2D window and the number of points to be displayed in
@i{x}-direction. The fourth and fifth argument are the
@i{y}-coordinate of the point with the smallest @i{y}-value and the
number of points to be displayed. The sixth and seventh argument
determine the @i{z}-range to be displayed, the sixth argument being
the lowest-valued @i{z}-value and the last argument the @i{z}-span.
Both the number of points in @i{x}- and @i{y}-direction must be
numbers larger than @code{1} and the @i{z}-span larger than @code{0}.
If an argument is not given or is given as an arbitrary string (e.g.@:
@code{"KEEP"}) the corresponding value remains unchanged.

The function returns the value @code{1} to indicate success or @code{0}
if it is impossible to set the zoom (since no scaling has been set for
the 1D window yet).

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{zoom()}
@findex zoom()
@item zoom()
This function can be called instead of @code{@ref{zoom_1d()}} or
@code{@ref{zoom_2d()}} when only either a 1D- or a 2D-display is used
(but not both at once). In the 1D-case the function must be called
with at least two and up to four arguments, in the 2D case with at
least two and a maximum of seven arguments.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{clear_curve_1d()}
@findex clear_curve_1d()
@item clear_curve_1d()
Removes one or more curves from the 1d-display. As many curve numbers as
there are curves displayed can be passed to the function as
arguments. No arguments at all implies the first curve only. Invalid
arguments are discarded and an error message is printed.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{clear_curve_2d()}
@findex clear_curve_2d()
@item clear_curve_2d()
Removes one or more curves from the 2D-display. As many curve numbers as
there are 2D-curves displayed can be used. No arguments at all implies
the first curve only. Invalid arguments are discarded and an error message is
printed.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{clear_curve()}
@findex clear_curve()
@item clear_curve()
If there is only either a 1D- or 2D-display window this function can
be used instead of @code{@ref{clear_curve_1d()}} or
@code{@ref{clear_curve_2d()}}.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{draw_marker_1d()}
@findex draw_marker_1d()
@item draw_marker_1d()
This function can be used for 1D graphics and draws a vertical
dashed line on the display window. It expects at least one argument, an
integer number defining the @i{x}-position of the marker to be drawn. A
second, optional argument is the color of the marker, here one may
specify either an integer number or a string:
@multitable @columnfractions 0.15 .35 .35
@item Number @tab String @tab Color
@item @code{0} @tab @code{"WHITE"} @tab white
@item @code{1} @tab @code{"RED"} @tab red
@item @code{2} @tab @code{"GREEN"} @tab green
@item @code{3} @tab @code{"YELLOW"} @tab yellow
@item @code{4} @tab @code{"BLUE"} @tab blue
@item @code{5} @tab @code{"BLACK"} @tab black
@item @code{6} @tab @code{"DELETE"} @tab
@end multitable
@noindent
The last color, @code{"DELETE"}, is obviously not a color but can be used
to delete a marker at the specified position (if more than one marker
has been set for that position only the first, older one will be
deleted).

Please note: in "sliding window" display mode, the coordinate for the
marker is not used at all (but must be given and must be larger than
@code{0}), the marker will always be drawn at the newest point for the
first displayed curve (the curve numbered 1). Thus also can't delete a
single marker in this mode but only all of them using the function
@code{@ref{clear_marker_1d()}}.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{draw_marker_2d()}
@findex draw_marker_2d()
@item draw_marker_2d()
This function can be used for 2D graphics and draws a box in the display
window. It expects at least two arguments, integer numbers defining the
@i{x}- and @i{y}-position of the marker to be drawn. As a third argument
the curve number can be specified - if it is missing or as the value
@code{0} the marker is drawn over the currently displayed curve. The
fourth (optional) argument is the color of the marker, here one may
specify either an integer number or a string:
@multitable @columnfractions 0.15 .35 .35
@item Number @tab String @tab Color
@item @code{0} @tab @code{"WHITE"} @tab white
@item @code{1} @tab @code{"RED"} @tab red
@item @code{2} @tab @code{"GREEN"} @tab green
@item @code{3} @tab @code{"YELLOW"} @tab yellow
@item @code{4} @tab @code{"BLUE"} @tab blue
@item @code{5} @tab @code{"BLACK"} @tab black
@item @code{6} @tab @code{"DELETE"} @tab black
@end multitable
@noindent
The last color, @code{"DELETE"}, is invisible obviously not a color but
can be used to delete a marker at the specified position (if more than
one marker has been set for that position only the first, older one will
be deleted).

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{draw_marker()}
@findex draw_marker()
@item draw_marker()
This function can be called instead of @code{@ref{draw_marker_1d()}}
or @code{@ref{draw_marker_2d()}} when only either a 1D- or a
2D-display is used (but not both at once).

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{clear_marker_1d()}
@findex clear_marker_1d()
@item clear_marker_1d()
This function deletes all previously set 1D markers. It accepts no arguments.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{clear_marker_2d()}
@findex clear_marker_2d()
@item clear_marker_2d()
When invoked without any arguments at all this function deletes all
previously set 2D markers on all curves. Otherwise it expects a list
of curve numbers and deletes only all markers on these curves.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{clear_marker()}
@findex clear_marker()
@item clear_marker()
This function can be called instead of @code{@ref{clear_marker_1d()}}
or @code{@ref{clear_marker_2d()}} when only either a 1D- or a
2D-display is used (but not both at once).

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{curve_button_1d()}
@findex curve_button_1d()
@item curve_button_1d()
If invoked with a single argument, a number between @code{1} and the
maximum number of curves displayed in the 1D display window, it
returns @code{0} if the button for that curve (at the upper left hand
side of the 1D display window) is switched off (i.e.@: the curve is
exempt from rescaling operations) and @code{1} if its on. If called
with a second, boolean argument (i.e.@: either a string,@code{"ON"} or
@code{"OFF"}, or a number with @code{0} standing for off and a
non-zero number for on), the state of the button for the curve is
changed accordingly.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{curve_button_2d()}
@findex curve_button_2d()
@item curve_button_2d()
If invoked with no argument the number of the currently displaye 2D
curve (i.e.@: a number between @code{1} and the maximum number of
curves displayed in the 2D display window) is returned, or @code{0} if
no curve is displayed at the moment.

If invoked with a single argument, a number between @code{1} and the
maximum number of curves displayed in the 2D display window, it
returns @code{0} if the button for that curve (at the upper left hand
side of the 1D display window) is switched off (i.e.@: the curve is
not shown) and @code{1} if the curve is currently shown.

If called with a second, boolean argument (i.e.@: either a
string,@code{"ON"} or @code{"OFF"}, or a number with @code{0} standing
for off and a non-zero number for on), the state of the button for the
curve is changed accordingly.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{curve_button()}
@findex curve_button()
@item curve_button()
This function can be called instead of @code{@ref{curve_button_1d()}}
or @code{@ref{curve_button_2d()}} when only either a 1D- or a
2D-display is used (but not both at once).

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{fs_button_1d()}
@findex fs_button_1d()
@item fs_button_1d()
If invoked without an argument the function returns @code{1} if the
@code{FS} (Full Scale) button is switched on (automatic rescaling is
enabled) and @code{0} if it's switched off. If called with a boolean
argument (i.e.@: either a string,@code{"ON"} or @code{"OFF"}, or a
number with @code{0} standing for off and a non-zero number for on),
the state of the button is changed accordingly and automatic rescaling
enabled or disabled.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{fs_button_2d()}
@findex fs_button_2d()
@item fs_button_2d()
If invoked with a single argument, a number between @code{1} and the
maximum number of curves displayed in the 2D display window, it
returns @code{1} if the @code{FS} (Full Scale) button for that curve
is switched on (i.e.@: the curve will be rescaled automatically) and
@code{0} if the @code{FS} button for the curve is switched off.

If called with a second, boolean argument (i.e.@: either a
string,@code{"ON"} or @code{"OFF"}, or a number with @code{0} standing
for off and a non-zero number for on), the state of the @code{FS}
button for the curve designated by the first argument is changed
accordingly and automatic rescaling is enabled or disabled.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{fs_button()}
@findex fs_button()
@item fs_button()
This function can be called instead of @code{@ref{fs_button_1d()}} or
@code{@ref{fs_button_2d()}} when only either a 1D- or a 2D-display is
used (but not both at once).

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{print()}
@findex print()
@item print()
This function prints text into the output browser in the main form of
@code{fsc2}.  It needs a @i{format string}
@cindex format string
as its very first argument. The @i{format string} can contain any text
as well as a special character, @code{#},
@findex # @r{(in @code{@ref{print()}} function)}
that works as a placeholder for data to be printed in its place.
Here's a first simple example: You want to print the value of a
variable called @code{I}, that has been assigned a value of 3. Now,
@example
print( "The value of I is #.\n", I );
@end example
@noindent
will print, when the script is interpreted,
@example
The value of I is 3.
@end example
@noindent
But you can have not only one but as many placeholder characters in the
@i{format string} as you need. Of course, the number of placeholder
characters has to match the number of variables (or data) following the
@i{format string}. If the number of @code{#}'s and the number of
variables to be printed doesn't fit a warning is printed. If there are
too many @code{#}'s the superfluous ones are simply printed out, but if
there are not enough only as many variables as there are @code{#}'s are
printed, the remaining data are discarded.

You may use @code{@ref{print()}} to print integer or floating point
values (that includes the return values of functions) and variables
and strings (i.e.@: text enclosed in double quotes, @code{"}). Here's
a longer, somewhat contrived example:
@example
print( "The # of # is #\n", "sine", x, sin( x ) );
@end example
@noindent
This will print (assuming @code{x} equals @code{0.5}):
@example
The sine of 0.500000 is 0.479426
@end example

There are special sequences allowed in the @i{format string}. They all
start with an @i{escape character}, the backslash @code{\}. Here's a
list of all recognized special sequences:

@c The cindex must come before the start of the table,
@c otherwise the created HTML isn't valid

@cindex escape characters (in @code{@ref{print()}} function)

@table @samp
@item \n
Linefeed character: Ends a line, everything following it starts on a
new line. Thus several lines can be printed at once by one call of
@code{@ref{print()}}. @code{@ref{print()}} does not automatically add
a linefeed by itself.
@item \t
Embeds a tabulator character in the text, tab stops are set at every
eighth character position.
@item \\
Prints a backslash, @code{\}, thus switching off the special meaning of the
backslash as an escape character.
@item \"
Prints a quote -- use it to embed quotes into the @i{format
string}.
@item \#
Prints a @code{#}, thus switching off the special meaning of the
@code{#} character as a placeholder for variables to be printed.
@item \T
While normally nothing is printed during the test run of the
@code{EXPERIMENT} section of an @code{EDL} script, if the @i{format
string} starts with this escape sequence the @code{@ref{print()}}
function will produce output already in the test run (the @code{T} is
never printed).
@end table


@anchor{show_message()}
@findex show_message()
@item show_message()
The function allows to display a message in a new window. The user has
to click onto the "Ok" button in this window before the function
returns, i.e.@: the experiment is paused while the message is shown.

The function accepts a single argument, a string with the message to be
displayed. To display a multi-line message embed '@code{\n}' characters
in the string. Other escape sequences recognized by the function are:
'@code{\t}' for a tabulator character, '@code{\\}' or the backslash
character (a single backslash is always supposed to start an escape
sequence) and '@code{\"}' to embed double quotes in the message.

Avoid messages with more than 6 lines, they won't fit into the message
box.


@end table


@node File handling functions, Interaction functions, Output functions, Built-in Functions
@section File handling functions
@cindex file handling functions

All the following functions are for opening files and writing data to
these output files with different levels of user defined formating.
Please note that you don't have to explicitely open a file from the
@code{EDL} script as long as you only are going to use a single output
file -- @code{fsc2} will automatically ask for a file name the first
time you try to write out data in this case.

Please note: under certain circumstances it is also possible to write
data to @i{stdout} and @i{stderr}. To do so you must first either open
a regular file via a call of e.g.@: the function
@code{@ref{get_file()}} or by explicitely opening @i{stdout} or
@i{stderr} by a call of @code{@ref{open_file()}} with the number
@code{1} or @code{2} as the only argument (opening one of them this
way will also automatically allow you to writ eto the other). If this
has happened you then can use the numbers @code{1} and @code{2} as
file handles for @i{stdout} and @i{stderr}.


@noindent
@strong{List of all file handling functions}:
@table @samp
@item @ref{get_file()}
@item @ref{open_file()}
@item @ref{clone_file()}
@item @ref{reset_file()}
@item @ref{save()}
@item @ref{fsave()}
@item @ref{ffsave()}
@item @ref{save_program()}
@item @ref{save_output()}
@item @ref{save_comment()}
@end table


@noindent
@strong{Descriptions of file handling functions}:


@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{get_file()}
@findex get_file()

@table @samp

@item get_file()
Opens a new file and returns a unique identifier for the file that can
be stored in an integer variable and is to be used in calls to functions
of the @w{@code{save_xxx()}}-family. Usually a file selector gets shown
that lets the user choose a file. If opening the selected file fails the
user is asked to select a different file name. If the user cancels the
selection of a file (s)he is asked for confirmation since data may get
lost.

The function accepts up to five arguments, all of them optional. The
first one is usually the prompt string to be printed in the file
selector. If it is missing or is the empty string (use `@code{""}' to
create an empty string) it defaults to `@i{Please select a file
name:}'. The second argument is a pattern for the file name, per default
`@i{*.dat}'. You may use all the usual wildcard characters you're used
to from the shell. The third argument is the directory the search for
the file name should start in. As the fourth argument you may pass a
file name to the function as the default file that appears in the entry
for the selected file. Finally, the fifth and last argument can be a
default extension for the file. This extension will be appended
automatically to the name of the file the user selects unless the file
name already has this extension. This way one can enforce an extension
for the file name.

If @code{@ref{get_file()}} has never been called on the first call to
a function from the @code{save_xxx()}-family the user is asked to
select a file and this file is used exclusively in further
@code{save_xxx()}-calls. That means that calling
@code{@ref{get_file()}} after the default file has already been opened
is not allowed, call it either before the first save-operation or
never at all!

In batch mode (i.e.@: if @code{fsc2} got started with the '@code{-B}'
option) no file select box gets shown because the script is supposed to
be run without any user input. Instead the name of the @code{EDL} script
is used as a template for the output files name, with all path
information stripped off (so that the output file always goes into the
current directory) and an extension of "@code{.batch_output.#}"
appended, where the @code{#} stands for an integer number that is
chosen so that the file name is unique. Numbers start with @code{0}
and are incremented until a file name is found that does not exist
yet. The resulting file name is then used as the output file.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{open_file()}
@findex open_file()
@item open_file()
This function is similar to the previous one with the main difference
that one may specify an hard-coded file name in the script. The
function will use its first argument as a file name and try to open
this file. If the file already exists (or can't be opened) a warning
will be shown and, on user request will show up a file selector to
allow selecting a different file, just as the @code{@ref{get_file()}}.
Thus the arguments that the function accepts are identical to the ones
of @code{@ref{get_file()}} with the only exception that the first
argument is an additional argument with a string for the file name.

This function can also be used to explicitely open @i{stdout} and
@i{stderr}. To do so call the function with a single integer argument
of @code{1} or @code{2} (this is not necessary if another regular
file already has been opened since this automatically also opens
@i{stdout} and @i{stderr}).

If running in batch mode (i.e.@: if @code{fsc2} got started with the
'@code{-B}' option) and the file to be opened already exists a new file
name is created by appending the extension "@code{.batch_output.#}" to
the file name specified as the argument. The @code{#} stands for an
integer number that is chosen so that the file name is unique. Numbers
start with @code{0} and are incremented until a file name is found that
does not exist yet. The resulting file is used as the output file.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{clone_file()}
@findex clone_file()
@item clone_file()
Sometimes two output files are needed that should only differ in their
extension but not in the filename. In this case the function
@code{@ref{clone_file()}} can be useful. It expects exactly three
arguments. The first one is an identifier for an already existing file
as returned by the function @code{@ref{get_file()}}. If in the call of
@code{@ref{get_file()}} the user did @b{not} to choose a file, i.e.@:
pressed the @code{Cancel}-button, it is silently assumed that also the
new file to be created by @code{@ref{clone_file()}} is @b{not} to be
used. If either the numer @code{1} (for writing to @i{stdout}) or
@code{2} (for writing to @i{stderr}) was given as the argument a
warning is printed out and the output gets written to either
@i{stdout} or @i{stderr} as if the function wouldn't have been called.

The second and third arguments both have to be strings. The second
argument is the expected extension of the file that was selected via
the previous call of @code{@ref{get_file()}}. And the third argument
is the replacement for the extension of the previously selected file.
Both are to be specified without the starting dot. If the second
argument does not fit with the extension of the file the user had
chosen, the new extension from the third argument is simply appended
to the file name (instead of replacing the extension). If the
replacement extension (i.e.@: the third argument) is identical to the
extension of the already open file (i.e.@: the second argument) it is
also appended instead of being used for replacement.

A typical piece of code to open two files, the first with the extension
@code{dat} and the second with the same name but the extension
@code{list} would be:
@example
FILE1 = get_file( "", "*.dat", "", "", "dat" );
FILE2 = clone_file( FILE1, "dat", "list" );
@end example
@noindent
If the user chooses @code{experiment.dat} as the first file, a second
file with the name @code{experiment.list} will be opened automatically.

The function also takes care that no files will be overwritten
accidentally. If the second file already exists the user is asked to
select different file. The program enforces that the extension of the
new file is identical to the one passed to it as the third argument.

If running in batch mode (i.e.@: if @code{fsc2} got started with the
'@code{-B}' option) and the file to be opened already exists a new file
name is made up by appending the extension "@code{.batch_output.#}" to
the file name that got made up by the replacement procedure described
above. The @code{#} stands for an integer number that is chosen so that
the file name is unique. Numbers start with @code{0} and are incremented
until a file name is found that does not exist yet. The resulting file
is used as the output file.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{reset_file()}
@findex reset_file()
@item reset_file()
Under some circumstances it may be required to throw away everything
already written to file until that moment. That can be achieved by
calling this function. If there's only a single file that got opened
automatically (by callling a function that writes to a file withoyut
calling @code{@ref{open_file()}} before) then the function takes no
argument. If a file got opened by a call of @code{@ref{open_file()}}
or similar then the function must be called with a single argument,
the file handle for the file to be reset.


@anchor{save()}
@findex save()
@item save()
Writes one or more data or complete arrays to a file. Normally, each
value will be written onto a separate line. But often one would like
to have the elements of a 1-dimensional array (or 1-dimensional
subarrays of a higher-dimensional array) written all onto a single
line, separated by a space, a comma or something else the tools
one used for data post-processing expects. In this case the first
argument should be a string with this separator e.g.@: @code{", "}
if the elements of a line should be separated by a comma and a
space.

The second, also optional argument, is a file handle. This argument
must be given if somewhere before in the script the @code{fsc2}
function had been called and then must be its return value. If, on the
other hand, @code{@ref{get_file()}} had not been called before, the
argument should be left out and the user is asked to select a file now
and all further call of functions of the functions for saving data
wwill use this one file automatically.

All arguments (following the file identifier if there's one) are
data. The types of these data may be

@itemize @bullet
@item
Integer data
@item
Floating point data
@item
Strings (with interpretation of escape sequences, see
@code{@ref{fsave()}})
@item
One-dimensional arrays (or slices of more-dimensional arrays) of integer
or floating point type
@item
Complete more-dimensional arrays
@end itemize

If a separator is not specified the function saves data with each data
value being written with a new line character appended to it. In the
case of more-dimensional arrays an empty line is output between the
individual slices of the array. Here's an example: The array

@example
X[ 3, 2 ] = @{ @{ 1, 2 @}, @{ 3, 4 @}, @{ 5, 6 @} @}
save( X );
@end example
@noindent
will output
@example
1
2

3
4

5
6
@end example
while
@example
X[ 3, 2 ] = @{ @{ 1, 2 @}, @{ 3, 4 @}, @{ 5, 6 @} @}
save( ", ", X );
@end example
will result in
outputs
@example
1, 2
3, 4
5, 6
@end example

This function is rather suitable for storing large amount of datas,
all other functions that accept formating information are comparatively
slow since they have to analyze the format string for each call (and
don't allow to output arrays in a single call).

The function returns the total number of characters that have been
written to the file and it can only be used in the @code{EXPERIMENT}
section of an @code{EDL} script.


@anchor{fsave()}
@findex fsave()
@item fsave()
This function (the name stands for 'formated save') can be used to
write data to a file in a user formated way. The first argument must
be a file identifier if @code{@ref{get_file()}} had been called before
(or can be the numbers @code{1} and @code{2} to write to @i{stdout} or
@i{stder}). The next argument must be a @i{format string} with a
syntax remotely similar to the one for the @code{C} @code{printf(3)}
function. The format string can contain arbitrary text and conversion
specifiers, a @code{#} character for each data item from the remaining
argument list. In contrast to the @code{@ref{save()}} function this
function can not be used to print array slices or complete arrays, but
only simple data types. On the other hand, printing of complete arrays
can be done using loops, i.e.@: as in the following example:

@example
VARIABLES:

FILE_ID;
I; J;
X[ 3, 2 ] = @{ 1, 2, 3, 4, 5, 6 @};

EXPERIMENT:

FILE_ID = get_file( );

for I = 1 : 3 @{
    for J = 1 : 2 @{
        fsave( FILLE_ID, "X[ #, # ] = #\n", I, J, X[ I, J ] );
    @}
@}
@end example
@noindent
This will print:

@example
X[ 1, 1 ] = 1
X[ 1, 2 ] = 2
X[ 2, 1 ] = 3
X[ 2, 2 ] = 4
X[ 3, 1 ] = 5
X[ 3, 2 ] = 6
@end example

Within the format string and the argument strings escape sequences, all
starting with a backslash character @code{\}, can be used to print
otherwise unprintable characters. These are
@table @samp
@item \a
prints an alert (bell) character (@code{0x07})
@item \b
prints a backspace character (@code{0x08})
@item \f
prints a formfeed character (@code{0x0C})
@item \n
prints a newline character (@code{0x0A})
@item \r
prints a carriage return character (@code{0x0D})
@item \t
prints a horizontal tab character (@code{0x09})
@item \v
prints a vertical tab character (@code{0x0B})
@item \\
prints a backslash @code{\}
@item \?
prints a question mark @code{?}
@item \'
prints a single quote @code{'}
@item \"
prints a double quote @code{"}
@item \@i{ooo}
replaces the octal number @i{ooo} by the corresponding character (as
many octal digits are used as long as the resulting number is less
then 255)
@item \x@i{hh}
replaces the hexadecimal number @i{hh} by the corresponding character
(there must be one or two hexadecimal digits)

@item \#
prints a @code{#} (this is a special escape sequence to be used with
@code{@ref{fsave()}} only)
@end table

The function returns the total number of characters that have been written to
the file.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{ffsave()}
@findex ffsave()
@item ffsave()
This function can also be used to write data into a file using a
format string. In comparison to the @code{@ref{fsave()}} function it
gives you even more control over the format that is used by accepting
a format string that is nearly identical to the one of the @code{C}
@code{printf(3)} family of functions, missing only some elements that
wouldn't make sense here. As in the case of the @code{@ref{save()}}
and @code{@ref{fsave()}} function the first argument can be a file
identifier.

The format string may contain two types of objects: ordinary characters,
which are copied to the file, and conversion specifications, each of
which conversion and printing of the next successive argument. Each
conversion specifier begins with the character @code{%} and ends with
a conversion character. In between there may first a flag, which
modifies the specification:
@itemize
@item @code{-} which specifies left adjustment of the converted argument
      in its field,
@item @code{+} which specifies that a number will always printed with a
      sign,
@item @i{space}: if the first character is not a sign, a space will be
      prefixed,
@item @code{0}: for numeric conversions, specifies padding the field
      with leading zeros,
@item @code{#}, which specifies an alternate output form: for @code{e},
      @code{E}, @code{f}, @code{g} and @code{G}, the output will always
      have a decimal point, for @code{f} and @code{G}, trailing zeros
      will not be removed.
@end itemize

Following the flags the minimum field width as well as the precision can
be specified. If the (optional) flags are followed by a number it is
taken as the minimum field width. The converted argument will be printed
in a field at least this wide, and wider if necessary. If the converted
argument has fewer characters than the field width it will be padded on
the left (or on the right, if left adjustment has been requested) to
make up for the field with. The padding character normally is the space
character except and only @code{0} if the zero padding flag is present.

The next character can be a period, which separates the field width from
the precision, followed by another number, the precision, that specifies
the maximum number of characters to be printed from a string, or the
number of digits to be printed after the decimal point for @code{e},
@code{E}, or @code{f} conversion, or the number of significant digits
for @code{g} or @code{G} conversion, or the minimum number of digits to
be printed for an integer (leading @code{0}s will be added to make up
the necessary width).

Width or precision or both may be specified as @code{*}, in which case
the value is computed by converting the next arguments(s), which must be
an integer values.

In contrast to the @code{C} @code{printf(3)} format string no length
modifier can be used -- @code{fsc2} has no different short, long or
long long variable types.

The following table lists all conversion characters. If the character
found in the format string is not a valid conversion specifier the
function will abort and print an error message.
@table @samp
@item d, i
Integer value, if the argument is not an integer but a floating point
number its value is rounded to the next integer.
@item f
floating point value, if the argument is an integer it is converted to a
floating point value; decimal notation of the form @i{[-]mmm.ddd}, where
the number of @i{d}'s is specified by the precision. The default
precision is 6; a precision of @code{0} suppresses the decimal point
@item e, E
floating point value, if the argument is an integer it is converted to a
floating point value; decimal notation in either the form
@w{@i{[-]mmm.dddddd}@code{e}@i{[+-]xx}} or
@w{@i{[-]mmm.dddddd}@code{E}@i{[+-]xx}}, where the number of @i{d}'s is
specified by the precision. The default precision is 6, a precision of
@code{0} suppresses the decimal point.
@item g, G
floating point value, if the argument is an integer it is converted to a
floating point value; @code{%e} or @code{%E} is used if the exponent is
less than @code{-4} or greater than or equal to the precision, otherwise
@code{%f} is used. Trailing zeros and a trailing decimal point are not
printed.
@item %
no argument is converted, prints a @code{%}
@end table

The format string as well as argument strings may contain escape
sequences, starting with a backslash @code{\}, see
@code{@ref{fsave()}} for the complete list.


The function returns the total number of characters that have been written to
the file.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{save_program()}
@findex save_program()
@item save_program()
This functions writes the currently run @code{EDL} script into a file.
As usual, the first argument may be a file identifier -- the same
rules apply as for @code{@ref{save()}} and @code{@ref{fsave()}}. The
second argument can be a string that is prepended to each line of the
script, i.e.@: a comment character to make other programs like
@acronym{MATHLAB} or @acronym{octave} skip these lines.

If @code{#INCLUDE} statements are found in the @code{EDL} script also
the included files get saved into the output file, embedded into the
text of the script.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{save_output()}
@findex save_output()
@item save_output()
This function has the same arguments as @code{@ref{save_program()}}
but prints the content of the output window (i.e.@: the bottom browser
window in the main form) into the file.

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{save_comment()}
@findex save_comment()
@item save_comment()
This function is used to print comments into the file. When it is called a
small editor is shown and the user may enter comments. These will be then
written into the file.

The first argument may as usual be a file identifier (or may be
missing if @w{@code{@ref{get_file()}}} hasn't been called). The second
argument is again a string to be prepended to each line of the
comment. The third argument is a preset string that appears in the
comment editor when it is opened -- use "@code{\n}" to separate the
lines of a multi-line text. The last argument is the label string to
be shown on top of the editor -- it defaults to "Please enter a
comment:".

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.

@end table


@node Interaction functions, Mathematical functions, File handling functions, Built-in Functions
@section Interaction functions
@cindex interaction functions

The following functions are for creating, handling and deleting of
buttons, sliders and input and output fields. When such an object is
created for the first time a new window with the title "Toolbox" gets
created.  The objects (i.e.@: buttons, sliders and input and output
fields) displayed in this toolbox window allow the user to influence the
experiment when it is already running. The toolbox window will vanish
automatically when all objects have been deleted. The toolbox with its
objects can only be used during the experiment, i.e.@: the functions for
creating, handling and deleting of objects can only be used within the
@code{EXPERIMENT} section of the script.

There are two possible layouts for the toolbox, either all elements laid
out vertically (the default) or all side by side horizontally.  If that
many objects are created that the toolbox wouldn't fit onto the screen
anymore in vertical layout mode a new column is started automatically
while in horizontal mode a new row. When exactly this happens depends
(obviously) on the size of the screen, but also on details of the
lengths of labels or the font used for labels.

Please note that when the objects in the toolbox are used it usually
isn't possible anymore to check the complete experiment before it is run
because it is impossible to forsee which buttons, sliders or input
fields are going to be used at what moment in time (the only exception
is when only output fields are used). Therefore, these functions should
only be used where it is really necessary, e.g.@: when you're trying to
find the optimum parameters for an experiment but not in the final
experiment.

When the script is tested before the experiment is started it is
assumed that all buttons are not pressed and switched off (unless
their state has been set explicitly by the function
@code{@ref{button_state()}}, all sliders are assumed to be in the
middle position unless a different value has been set via the function
@code{@ref{slider_value()}} and all input and output fields are
initialized to @code{0} unless an initial value has been passed to the
functions @code{@ref{input_create()}} or @code{@ref{output_create()}}.

For all the objects to be created a label string to be drawn with the
object can be defined. Normally this will be a simple text, indicating
the meaning of the object. But in some cases it might be useful also to
be able to draw some symbols instead of text. This can be done by
starting the label string by the @code{'@@'} character. Immediately
after the @code{'@@'} one of the following texts can be used to draw a
symbol:
@table @samp
@item ->
Normal arrow pointing to the right.
@item <-
Normal arrow pointing to the left.
@item >
Triangular arrow pointing to the right.
@item <
Triangular arrow pointing to the left.
@item >>
Double triangle pointing to the right.
@item <<
Double triangle pointing to the left.
@item <->
Arrow pointing left and right.
@item ->|
Normal arrow pointing to the right and ending in a vertical bar.
@item >|
Triangular arrow pointing to the right and ending in a vertical bar.
@item |>
Triangular arrow pointing to the right and starting in a vertical bar.
@item -->
Thin arrow pointing to the right.
@item =
Three embossed lines.
@item arrow
Same as @code{-->}.
@item returnarrow
@code{<Return>} key symbol.
@item square
Square.
@item circle
Circle.
@item line
Horizontal line.
@item plus
Plus sign (rotate to get a cross).
@item UpLine
Embossed vertical line.
@item DnLine
Engraved vertical line.
@item UpArrow
Embossed triangular arrow pointing to the right.
@item DnArrow
Engraved triangular arrow pointing to the right.
@end table

It is also possible to rotate most of the symbols. When a symbol name is
preceeded by a digit between @code{1} and @code{9} (except @code{5}) the
symbol is rotated like on the numerical keypad, i.e.@: @code{6}
indicates no rotation, @code{9} a rotation by 45 degrees
anti-clockwise,8 a rotation by 90 degrees, etc. Hence the order is
@code{6,9,8,7,4,1,2,3} (just think of the keypad as consisting of arrow
keys). So to get an arrow pointing to the left top use a label string of
@code{"@@7->"}. To rotate the symbols in other directions not fitting
into this 45 degrees scheme put a @code{0} directly after the
@code{'@@'}, followed by exactly three digits that indicate the angle
(counter-clockwise). E.g.@: to get an arrow at an angle of 30 degrees
use the label string @code{"@@0030->"}.

The symbols are designed for labels with a square bounding box. But in
most cases the labels bounding box will not be square and the symbol is
scaled differently in @i{x}- and @i{y}-direction. If keeping the aspect
ration is desired, put a @code{'#'} character immediately after the
@code{'@@'}, e.g.@: @code{"@@#9->"}.

Two additional prefixes, @code{'+'} and @code{'-'}, followed by a single
digit, can be used to make small size adjustments. These prefixes must
either follow immediately after the @code{'@@'} or the @code{'#'}. The
@code{'+'} indicates an increase of the symbol size while @code{'-'}
will decrease the size. The digit following the prefix indicates the
increment or decrement in pixels. For example, to draw a circle that is 3
pixels smaller than the default size use the label string
@code{"@@-3circle"}.


@noindent
@strong{List of all interaction functions}:
@table @samp
@item @ref{layout()}
@item @ref{toolbox_changed()}
@item @ref{toolbox_wait()}
@item @ref{button_create()}
@item @ref{button_delete()}
@item @ref{button_state()}
@item @ref{button_changed()}
@item @ref{slider_create()}
@item @ref{slider_delete()}
@item @ref{slider_value()}
@item @ref{slider_changed()}
@item @ref{input_create()}
@item @ref{input_delete()}
@item @ref{input_value()}
@item @ref{input_changed()}
@item @ref{output_create()}
@item @ref{output_delete()}
@item @ref{output_value()}
@item @ref{menu_create()}
@item @ref{menu_add()}
@item @ref{menu_text()}
@item @ref{menu_delete()}
@item @ref{menu_choice()}
@item @ref{menu_changed()}
@item @ref{object_delete()}
@item @ref{object_change_label()}
@item @ref{object_enable()}
@item @ref{hide_toolbox()}
@end table


@noindent
@strong{Descriptions of interaction functions}:


All the following functions can only be used in the @code{EXPERIMENT}
section of an @code{EDL} script.

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{layout()}
@findex layout()

@table @samp
@item layout()
The functions tells the program how to layout the buttons and sliders in
the window, either vertically or horizontally. The function must be
called either with the strings @code{"VERT"}, @code{"VERTICAL"},
@code{"HORI"} or @code{"HORIZONTAL"} (the case of the letters doesn't
matter). The numbers @code{0} and @code{1} can be used alternatively for
vertical or horizontal layout.

Of course this function has to be called @b{before} a function to create
an object (button, slider or in- or output field) has been invoked.


@anchor{toolbox_changed()}
@findex toolbox_changed()
@item toolbox_changed()
This function lets you test if the state of one of the objects in the
toolbox has been changed by the user, i.e.@: if a button has been
pressed, a slider has been moved, an input field has been edited or the
selected entry of a menu has been changed. You can pass this function a
list of object IDs, in which case only the objects in the list are
checked. When no argument is passed to the function all objects (except
output fields) are checked. If the state of one or more objects has been
changed the function returns the ID of the first object (in the list or
of all objects in the toolbox) that has been changed. If none have been
changed @code{0} is returned.

Please note: the function will @strong{not} report changes due to
function calls that change the state of an object, e.g.@: when setting
a new slider position from within the @code{EDL} script. The function
also will report a change until the new state of the object has been
determined by an appropriate function call. I.e.@: it will keep
reporting e.g.@: a new slider value until you have called
@code{@ref{slider_value()}} for the object.


@anchor{toolbox_wait()}
@findex toolbox_wait()
@item toolbox_wait()
This function is very similar to the previous function,
@code{@ref{toolbox_changed()}}. The main difference is that it will
wait for a certain time and only returns when either this time has
expired or an objects state has changed. Thus it needs one additional
argument: the first argument must be the maximum time the function
will block if none of the objects were changed. This first argument
may be followed of a list of objects to check. The function also
returns the ID of the first changed object or @code{0} if the time
expired and no objects were changed during the time interval.

If you want to wait indefinitely you may pass the function a value of
@code{0} or a negative value. If you pass no arguments at all to the
function it will block until one of the objects in the toolbox has
been changed by the user.


@anchor{button_create()}
@findex button_create()
@item button_create()
The function creates a new button and returns a unique integer number
that has to be used in later calls to identify this button. There are
three types of buttons, normal buttons that can be just pressed to
create an event, push buttons that stay on or off, and finally radio
buttons, that are also some kind of push buttons but that belong to a
group of buttons of which only one button can be switched on at once,
i.e.@: if a radio button gets pressed all the other radio buttons
belonging to the same group (which has to be specified when the button
is created) become automatically unset.

Normal buttons are drawn as large rectangular boxes with the label in
the middle, push buttons are drawn as squares, standing on a corner,
that become yellow when pressed, and radio buttons as round buttons,
that become red when activated.

The first argument the function expects is the type of the button,
i.e.@: one of the strings @code{"NORMAL_BUTTON"}, @code{"PUSH_BUTTON"} or
@code{"RADIO_BUTTON"} (the case of the letters doesn't matter).

For a radio button it must be specified which group it belongs to. Each
group has a button functioning as the group leader which is always the
first button of the group. For all other members of this group the
identifier of the group leader button must be specified as the second
argument. I.e.@: to create a group of three radio buttons use
@example
B_ID_1 = button_create( "RADIO_BUTTON", "Label 1" );
B_ID_2 = button_create( "RADIO_BUTTON", B_ID_1, "Label 2" );
B_ID_3 = button_create( "RADIO_BUTTON", B_ID_1, "Label 3" );
@end example

For all buttons except radio buttons the second (optional) argument is
the string that is to appear as the label of the button. The final (also
optional) argument is another string that is the help text that will
appear when the mouse hoovers over the button for some time. Both label
and help text may contain two different escape sequences, namely
`@code{\n}', standing for a line break (to create a multi-line label or
help text) and `@code{\\}', standing for the backslash character to
allow a backslash in front of an `n'.

All buttons start in the deactivated state except the 'leader' of a
group of radio buttons.


@anchor{button_delete()}
@findex button_delete()
@item button_delete()
Using this function one or more buttons can be deleted. It expects one
or a list of button identifiers (separated by commas) as returned by
the function @code{@ref{button_create()}}.

If the group leader (i.e.@: the first button) of a group of radio
buttons is deleted, the next button of the group becomes the new group
leader automatically. Please also note that when deleting the radio
button that is currently active, none of the radio buttons will be
active. In this case it is your responsibility to switch on one of the
remaining radio buttons of the group (unless all the others are also
deleted immediately afterwards).


@anchor{button_state()}
@findex button_state()
@item button_state()
This function returns or sets the state of a button, depending on the
number of arguments passed to the function. The non-optional first
argument is the identifier of the button as it was returned by the
function @code{@ref{button_create()}}. If there are no more arguments
the state of the button is returned. There is a difference between the
values returned for normal buttons on the one side and push and radio
buttons on the other. For normal buttons a counter is maintained that
counts the number of times the button was pressed and its value is
returned and the counter is set back to zero at the same time. In
contrast, for push and radio buttons the state of the button, i.e.@:
either @code{0}, meaning off, or @code{1} for on is returned.

If for push and radio buttons there is a second argument the state of
the button will be be set. This argument must be either a string
(@code{"ON"} or @code{"OFF"}) or a number with @code{0} standing for off
and a non-zero number for on. If the radio button is currently active
and it is about to be switched off, an error message will be printed and
the button will remain active. To switch an active radio button off
activate another button from its group instead. The state of normal
buttons cannot be set.


@anchor{button_changed()}
@findex button_changed()
@item button_changed()
The function takes one argument, the ID of a button. It will return
@code{1} if the button has been activated and @code{0} if the state of
the button hasn't been changed. Please note that the function will
repeatedly report a change of the button state until you have
determined the new state of the button by calling
@code{@ref{button_state()}} for the button.

For radio buttons, the function will only report a change for a newly
activated button, but none for a button that automatically got switched
off, i.e.@: only for the button that has become active from a group of
radio buttons.


@anchor{slider_create()}
@findex slider_create()
@item slider_create()
Sliders are useful for setting values within a predefined range. There
are two types of sliders, normal sliders and value sliders. The
difference between these types is that for value sliders there is an
additional field showing the currently set value while for normal
sliders there isn't such a visual feedback. As already the function
@code{@ref{button_create()}} also this function returns a unique
integer number to be used to identify the slider.

The first argument the function expects is a string, either
@code{"NORMAL_SLIDER"}, @code{"VALUE_SLIDER"},
@code{"SLOW_NORMAL_SLIDER"} or @code{"SLOW_VALUE_SLIDER"} (the keywords
are case-insensitive). @code{NORMAL} sliders are just sliders without
any decoration while @code{VALUE} sliders have an extra field showing
the current value set via the slider. Normally, a slider reports a new
value whenever the slider has been moved. In contrast, @code{SLOW}
sliders only acquire a new value when also the mouse button (which has
to be kept pressed down while the slider is moved) has been released.

The second argument must be the minimum value the slider can be adjusted
to and the third argument is the maximum value. The minimum value must
always be smaller than the maximum value.

A fourth, optional parameter is the step size to be used, i.e.@: the
minimum increment the slider value can be changed. Of course, this value
has to be larger than zero and smaller than the difference between the
minimum and maximum value of the slider.

As in the case of buttons there are two more (optional) arguments, the
label to be shown below the slider and a help text. The same escape
sequences as for button labels and help texts.

All sliders start of set to the middle of their range. If a step size is
given for the slider the allowed value nearest to the middle value is
used as the sliders initial value.


@anchor{slider_delete()}
@findex slider_delete()
@item slider_delete()
The function deletes one or more sliders. It expects one or a list of
slider identifiers as returned by the function
@code{@ref{slider_create()}}.


@anchor{slider_value()}
@findex slider_value()
@item slider_value()
This function returns or sets the value of a slider. The first
argument must be a slider identifier as returned by the function
@code{@ref{slider_create()}}. If this is the only argument the value
the slider is currently set to is returned. If there's a second value
the slider is set to this value. Obviously, the value must be within
the range of the slider as defined by the minimum and maximum value
set in @code{@ref{slider_create()}}, otherwise an error message is
printed and the slider value is set to the next value still within the
allowed range. If a step size is set for the slider and the new value
does not fit with the step size the nearest allowed value is set.


@anchor{slider_changed()}
@findex slider_changed()
@item slider_changed()
The function takes one argument, the ID of a slider. It will return
@code{1} if the value of the slider has been changed by the user and
@code{0} if not. Please note that the function will repeatedly report
a change of the sliders value until you have determined the new value
by calling @code{@ref{slider_value()}} for the slider.


@anchor{input_create()}
@findex input_create()
@item input_create()
Using input fields numerical values can be entered. There are two
different types of input fields, one, that will only accept integer
values, while the other also allows input of floating point numbers.
The first argument of the function for creating an input field,
@code{@ref{input_create()}}, is the type of the input field. If the
first argument is @code{"INT_INPUT"} the input field will only accept
integer numbers, while with an argument of @code{"FLOAT_INPUT"} also
floating point numbers can be entered.

If the second argument is a number it is taken to be the initial value
in the input field. If there is either no second argument or the second
argument is not a number but a string, the input field will be
initialized to @code{0}.

As in the case of buttons and sliders there are two more (optional)
arguments, the label to be shown below the input field and a help
text. The same escape sequences as for button and slider labels and help
texts can be used for buttons and sliders.

The final, optional field for an input object of @code{"FLOAT_INPUT"}
type is a format string that is used when printing the value. The format
string is a simplified version of a C format string. It must start with
@code{%}, optionally followed by the minimum field width, a dot, the
precision and finally (non-optionally) either @code{f}, @code{e} or
@code{g} (or @code{F}, @code{E} or @code{G}). For more information
please read the manual page for @code{C}'s @code{printf(3)}.

Please note that the maximum amount of text shown in the input fields
consists of 32 characters (including white-space). If the text is longer
it gets truncated and longer texts can't be entered.


@anchor{input_delete()}
@findex input_delete()
@item input_delete()
The function deletes one or more input field. It expects one or a list
of input field identifiers as returned by the function
@code{@ref{input_create()}}.


@anchor{input_value()}
@findex input_value()
@item input_value()
This function returns or sets the value of an input field. The first
argument must be an input field identifier as returned by the function
@code{@ref{input_create()}}. If this is the only argument the value
the input field is set to is returned. If there's a second value the
input field is set to this value. Obviously, the value must be number,
an integer for @code{INT_INPUT} fields and a floating point number
(but integers will also be accepted) for @code{FLOAT_INPUT} objects.


@anchor{input_changed()}
@findex input_changed()
@item input_changed()
The function takes one argument, the ID of an input field. It returns
@code{1} if the value of the input field has been changed by the user
and @code{0} if not. Please note that the function will repeatedly
report a change of the input fields value until you have determined
the new value by calling @code{@ref{input_value()}}.


@anchor{output_create()}
@findex output_create()
@item output_create()
In contrast to input objects output objects can be used to display a
value but the user can't change the value. As in the case of input
objects there are two types of output fields, one, that will only
accept integer values while the other also allows output of floating
point numbers. The first argument of the function for creating an
output field, @code{@ref{output_create()}}, is the type of the output
field. If the first argument is @code{"INT_OUTPUT"} the output field
will only show integer numbers, while with an argument of
@code{"FLOAT_OUTPUT"} also floating point numbers can be displayed.
Beside the two output fields for numerical values there also exists a
field for string output. You create it by specifying
@code{"STRING_OUTPUT"} as the first argument.

If the second argument is a number it is taken to be the initial value
in the output field. In the case of output fields for integer or floating
point numbers if there is either no second argument or the second
argument is not a number but a string, the output field will be
initialized to @code{0}. For string output fields an initial value must
be given if there are more arguments to follow - it can be e.g.@: the
empty string. If a numerical value is given for a string output field the
number is converted to a string representing this number.

As in the case of buttons and sliders there are two more (optional)
arguments, the label to be shown below the input field and a help
text. The same escape sequences as for button and slider labels and help
texts can be used for buttons and sliders.

The final, optional field for an output object of @code{"FLOAT_OUTPUT"}
type is a format string that is used when printing the value. The format
string is a simplified version of a C format string. It must start with
@code{%}, optionally followed by the minimum field width, a dot, the
precision and finally (non-optionally) either @code{f}, @code{e} or
@code{g} (or @code{F}, @code{E} or @code{G}). For more information
please read the manual page for @code{C}'s @code{printf(3)}.

Please note that the maximum amount of text shown in any of the output
fields consists of 32 characters (including white-space). If the text
is longer it gets truncated.

@anchor{output_delete()}
@findex output_delete()
@item output_delete()
The function deletes one or more output field. It expects one or a
list of output field identifiers as returned by the function
@code{@ref{input_create()}}.


@anchor{output_value()}
@findex output_value()
@item output_value()
This function sets a new value for an output field or returns the
current value. The first argument must be an output field identifier
as returned by the function @code{@ref{output_create()}}. If this is
the only argument the value the output field is set to is returned. If
there's a second value the output field is set to this value.
Obviously, the value must be number for integer and floating point
output fields. If for a string output field a number is passed to the
function the number is automatically converted to a string
representing that number.


@anchor{menu_create()}
@findex menu_create()
@item menu_create()
This function creates a popup-menu button to allow the selection of one
of two or more alternatives. The first argument must be a label string,
followed by as many strings as necessary (but at least two) for the
items shown when the popup-menu button gets pressed. This widget does
not allow setting a help string.

As usual, the value returned is an integer ID for the popup-menu button
that has to be used in further commands dealing with the widget.


@anchor{menu_add()}
@findex menu_add()
@item menu_add()
This function allows to add one or more entries to an already existing
popup-menu, created by @code{@ref{menu_create()}}. The first argument
must be the ID of the menu and the following arguments must be
strings, one for each new entry to add.


@anchor{menu_text()}
@findex menu_text()
@item menu_text()
The function allows to either obtain or change the text of a menu
entry. If called with two arguments, first the menu ID and the the
number of the entry (between @code{1} and the total number of entries
in the menu) the text of that entry gets returned. If called with
another argument, a (non-empty) string the text of the corresponding
entry gets set to this string.


@anchor{menu_delete()}
@findex menu_delete()
@item menu_delete()
This function deletes one or more popup-menu buttons. It expects one
or more popup-menu button identifiers as returned by the function
@code{@ref{menu_create()}}.


@anchor{menu_choice()}
@findex menu_choice()
@item menu_choice()
This function either selects a new item from the list of items of the
popup-menu button or returns the number of the currently selected
item. The first argument must be a valid popup-menu button identifiers
as returned by the function @code{@ref{menu_create()}}. If there is no
second argument the currently selected item is returned, an integer
number between @code{1}, indicating that the first item is selected,
and the total number of items, indicating that the last item is
selected.

If called with a second argument this must be an integer number between
@code{1} and the total number of items of the popup-menu button. The
number indicates which of the items has to become marked as selected
(where, obviously, @code{1} will select the first item, @code{2} the
second etc.).


@anchor{menu_changed()}
@findex menu_changed()
@item menu_changed()
The function takes one argument, the ID of a menu. It will return
@code{1} if the the user has selected a new menu item and @code{0} if
not. Please note that the function will repeatedly report a change of
the selected menu item until you have determined the new item by
calling @code{@ref{menu_choice()}} for the menu object.


@anchor{object_delete()}
@findex object_delete()
@item object_delete()
The function deletes one or more objects from the toolbox. It expects
one or a comma separated list of object identifiers as returned by the
functions @code{@ref{button_create()}}, @code{@ref{slider_create()}},
@code{@ref{input_create()}}, @code{@ref{output_create()}} or
@code{@ref{menu_create()}}.


@anchor{object_change_label()}
@findex object_change_label()
@item object_change_label()
The function allows to change the label of an object. It takes two
arguments, the ID of the object that was returned when the object was
created and a string with the new label.


@anchor{object_enable()}
@findex object_enable()
@item object_enable()
The function allows to temporarily enable or disable the use of an
object. It takes two arguments, the ID of the object that was returned
when the object was created and either the string @code{"ON"} or the
value @code{1} to enable the object (which is the default state) or the
string @code{"OFF"} or the value @code{0} to disable the object.


@anchor{hide_toolbox()}
@findex hide_toolbox()
@item hide_toolbox()
This function can be used to hide and later redraw the toolbox. This
can, for example, be used to avoid multiple redraws when creating or
deleting several objects. The function can even be used before the
toolbox has been drawn for the first time. It expects exactly one
boolean argument, either @code{"ON"} (or @code{1}) to hide the toolbox
or @code{"OFF"} (or @code{0}) to redisplay it).



@end table



@node Mathematical functions, Auxiliary functions, Interaction functions, Built-in Functions
@section Mathematical functions
@cindex mathematical functions

The following mathematical function can be used in all section of an
@code{EDL} script that allow the use of functions.


@noindent
@strong{List of all mathematical functions}:
@table @samp
@item @ref{abs()}
@item @ref{acos()}
@item @ref{acosh()}
@item @ref{asin()}
@item @ref{asinh()}
@item @ref{atan()}
@item @ref{atanh()}
@item @ref{ceil()}
@item @ref{cos()}
@item @ref{cosh()}
@item @ref{float()}
@item @ref{floor()}
@item @ref{grandom()}
@item @ref{index_of_max()}
@item @ref{index_of_min()}
@item @ref{int()}
@item @ref{round()}
@item @ref{max_of()}
@item @ref{mean()}
@item @ref{mean_part_array()}
@item @ref{min_of()}
@item @ref{random()}
@item @ref{rms()}
@item @ref{set_seed()}
@item @ref{sin()}
@item @ref{sinh()}
@item @ref{sqrt()}
@item @ref{square()}
@item @ref{tan()}
@item @ref{tanh()}
@item @ref{add_to_average()}
@end table


@noindent
@strong{Descriptions of mathematical functions}:

@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{abs()}
@findex abs()

@table @samp

@item abs()
Returns the absolute value of an integer or floating point number (or
all the elements of an 1- or more-dimensional array) .


@anchor{acos()}
@findex acos()
@item acos()
Returns the inverse of the cosine function of the argument (simple
number or all elements of an 1- or more-dimensional array) as an angle
in radian. The argument must be in the interval @w{[-1, 1]}, the result
an element of the interval @w{[0, pi]}.


@anchor{acosh()}
@findex acosh()
@item acosh()
Returns the inverse of the hyperbolic cosine function of the argument
(simple number or all elements of an 1- or more-dimensional array ).


@anchor{asin()}
@findex asin()
@item asin()
Returns the inverse of the sine function of the argument (simple number
or all elements of an 1- or more-dimensional array) as an angle in
radian. The argument must be in the interval @w{[-1, 1]}, the result an
element of the interval @w{[-pi/2, pi/2]}.


@anchor{asinh()}
@findex asinh()
@item asinh()
Returns the inverse of the hyperbolic sine function of the argument
(simple number or all elements of an 1- or more-dimensional array).


@anchor{atan()}
@findex atan()
@item atan()
Returns the inverse of the tangent function of the argument (simple
number or all elements of an 1- or more-dimensional array) as an angle
in radian, the result an element of the interval @w{[-pi, pi]}.


@anchor{atanh()}
@findex atanh()
@item atanh()
Returns the inverse of the hyperbolic tangent function of the argument
(simple number or all elements of an 1- or more-dimensional array).


@anchor{ceil()}
@findex ceil()
@item ceil()
Converts a floating point number (or all the elements of an 1- or
more-dimensional array) to the smallest integer that is not less than
the argument, i.e.

@example
round( 8.6 ) = 9     round( -8.6 ) = -8
@end example


@anchor{cos()}
@findex cos()
@item cos()
Returns the cosine of the argument (simple number or all elements of an
1- or more-dimensional array), with the argument interpreted as the
angle in radian.


@anchor{cosh()}
@findex cosh()
@item cosh()
Returns the hyperbolic cosine of the argument (simple number or all elements
of an 1- or more-dimensional array).


@anchor{float()}
@findex float()
@item float()
Converts a number (or all the elements of an 1- or more-dimensional
array) to floating point type.


@anchor{floor()}
@findex floor()
@item floor()
Converts a floating point number (or all the elements of an 1- or
more-dimensional array) to the largest integer that is not larger than
the argument, i.e.

@example
floor( 8.6 ) = 8    floor( -8.6 ) = -9
@end example


@anchor{grandom()}
@findex grandom()
@item grandom()
If called without an argument the function returns one of a set of
pseudo-random number with Gaussian distribution, a mean of zero and a
variance of 1. If called with a non-zero, positive argument it returns
an array of Gaussian distributed random numbers where the argument
specifies the size of the array. These random numbers are probably
better suited for simulating noise than the ones returned by
@code{@ref{random()}}.


@anchor{index_of_max()}
@findex index_of_max()
@item index_of_max()
The function expects a 1-dimensional array as its only argument and
returns the index of the largest element in the array. If there's more
that one element having the maximum value in the array the index
designates the first of these elements.


@anchor{index_of_min()}
@findex index_of_min()
@item index_of_min()
The function expects a 1-dimensional array as its only argument and
returns the index of the smallest element in the array. If there's more
that one element having the minimum value in the array the index
designates the first of these elements.


@anchor{int()}
@findex int()
@item int()
Converts a number (or all the elements of an 1- or more-dimensional
array) to integer type by truncating all digits following the decimal
point.


@anchor{round()}
@findex round()
@item round()
Converts a floating point number (or all the elements of an 1- or
more-dimensional array) to the nearest integer, i.e.

@example
round( 8.5 ) = 9    round( 8.49 ) = 8    round( -1.75 ) = -2
@end example


@anchor{max_of()}
@findex max_of()
@item max_of()
Returns the largest value of all arguments. Arguments can be any number
of numbers or 1- or more-dimensional arrays. If all arguments are integer
numbers an integer number is returned, otherwise a floating point value.


@anchor{mean()}
@findex mean()
@item mean()
Expects an 1- or more-dimensional array as input and returns the mean
value of the array elements. Optionally, it accepts up to two more
integer arguments, the start index of the first element of the
(1-dimensional) array or the index of the first sub-matrix (for
more-dimensional array) to be included into the calculation and the
number of elements to be used. If the length parameter is missing all
elements up to the end of the 1D-array or all remaining sub-matrices of
the more-dimensional array are used, otherwise only the number of
elements or sub-arrays specified as the third argument are used.
.

@anchor{mean_part_array()}
@findex mean_part_array()
@item mean_part_array()
The function expects as its arguments an 1-dimensional arrays of integers
or floats and a positive integer, with the length of the array being an
integer multiple of this number. The array is now split into chunks of
this size and the chunks are averaged. The resulting 1-dimensional float
array is returned. This function is meant to speed up calculations in
cases where a repeated signal, that has been sampled several times and
is stored in a flat array, is to be averaged.

Calling the function with a chunk size of @code{1} is equivalent to
invoking the @code{@ref{mean()}} function while calling it with a
sub-partition size equal to the length of the array itself is
equivalent to calling the @code{@ref{float()}} function on the array.


@anchor{min_of()}
@findex min_of()
@item min_of()
Returns the smallest value of all arguments. Arguments can be any number
of numbers or 1- or more-dimensional arrays. If all arguments are integer
numbers an integer number is returned, otherwise a floating point value.


@anchor{random()}
@findex random()
@item random()
If called with no argument the function returns a single pseudo-random
number in the interval @w{[0, 1]}. If called with a non-zero, positive
argument it returns an array of random numbers where the argument
specifies the size of the array.


@anchor{rms()}
@findex rms()
@item rms()
Expects an one-dimensional array as input and returns the square root of
the sum of the squared array elements, divided by the number of
elements.  Optionally, it accepts up to two more integer arguments, the
index of the first element of the 1-dimensional array or the index of
the first sub-matrix (for more-dimensional arrays) to be included into
the calculation and the number of elements to be used. If the length
parameter is missing all elements up to the end of the array or all
remaining sub-arrays are used, otherwise only as many array elements or
sub-matrices as specified by the third argument are used..


@anchor{set_seed()}
@findex set_seed()
@item set_seed()
Sets a seed for the random number generator used in the functions
@code{@ref{random()}} and @code{@ref{grandom()}}. The argument has to
be a positive integer. Alternatively, when no argument is given, the
time in seconds since 00:00:00 UTC, January 1, 1970 is used as the
seed.


@anchor{sin()}
@findex sin()
@item sin()
Returns the sine of the argument (simple number or all elements of an 1-
or more-dimensional array), with the argument interpreted as the angle
in radian.


@anchor{sinh()}
@findex sinh()
@item sinh()
Returns the hyperbolic sine of the argument (simple number or all elements
of an 1- or more-dimensional array).


@anchor{sqrt()}
@findex sqrt()
@item sqrt()
Returns the square root of an integer or floating point number (or all
the elements of an 1- or more-dimensional array). The argument must be a
positive number.


@anchor{square()}
@findex square()
@item square()
Returns the square of an integer or floating point number (or all the
elements of an 1- or more-dimensional array).


@anchor{tan()}
@findex tan()
@item tan()
Returns the tangent of the argument (simple number or all elements of an
1- or more-dimensional array), with the argument interpreted as the
angle in radian.


@anchor{tanh()}
@findex tanh()
@item tanh()
Returns the hyperbolic tangent of the argument (simple number or all
elements of an 1- or more-dimensional array).


@anchor{add_to_average()}
@findex add_to_average()
@item add_to_average()
This is a utility functions to simplify (and speed up) the calculation
of averaged data. It takes three arguments, as the first an already
averaged (floating point) value or an array of such values, as the
second a new value to be added to the average or an array of such
data (obviously, both the first and the second argument must be either
both simple values or arrays, and if they are arrays, must have the
same lengths), and the third argument must be the an integer value
which is the new count of the number of data sets having contributed
to the average (i.e.@: if the average consists of already @code{N}
data sets and now a new one gets added then this value must be
@w{@code{N + 1}}).

With this function you can simply write
@example
avg = add_to_average( avg, data, N + 1 );
@end example
@noindent
instead of
@example
avg = ( N * avg + data ) / ( N + 1 );
@end example
@noindent
which is not only simpler to read but also a lot faster.


@end table



@node Auxiliary functions, , Mathematical functions, Built-in Functions
@section Auxiliary functions
@cindex auxiliary functions


@noindent
@strong{List of all auxiliary functions}:
@table @samp
@item @ref{end()}
@item @ref{abort()}
@item @ref{date()}
@item @ref{time()}
@item @ref{delta_time()}
@item @ref{wait()}
@item @ref{T_to_G()}
@item @ref{G_to_T()}
@item @ref{C_to_K()}
@item @ref{K_to_C()}
@item @ref{D_to_R()}
@item @ref{R_to_D()}
@item @ref{WL_to_WN()}
@item @ref{WN_to_WL()}
@item @ref{F_to_WN()}
@item @ref{WN_to_F()}
@item @ref{slice()}
@item @ref{int_slice()}
@item @ref{float_slice()}
@item @ref{dim()}
@item @ref{size()}
@item @ref{sort()}
@item @ref{reverse()}
@item @ref{sprint()}
@item @ref{mouse_position()}
@item @ref{lin_space()}
@item @ref{find_peak()}
@item @ref{spike_remove()}
@end table


@noindent
@strong{Descriptions of auxiliary functions}:


@c The anchor and the findex must come before the start of the table,
@c otherwise the created HTML isn't valid

@anchor{end()}
@findex end()

@table @samp
@item end()
The function simulates the user clicking onto the @code{Stop} button in
the display window. If there is an @code{ON_STOP} label flow of control
will be transfered to the code following the @code{ON_STOP} label,
otherwise the program will be stopped immediately. This function can be
used in the @code{EXPERIMENT} section only and not after the
@code{ON_STOP} label.


@anchor{abort()}
@findex abort()
@item abort()
The function will abort the currently running script immediately
without even running the code following the @code{ON_STOP} label, so it
is a kind of an emergency exit when nothing better will do. When called it
displays a message box on the screen to inform the user.

If called after the @code{ON_STOP} label it simply ends the experiment
without any notofication of the user, so it then can be used to get
out of the @code{ON_STOP} handling.

The function can only be used in the @code{EXPERIMENT} section.


@anchor{date()}
@findex date()
@item date()
When called without an argument the function returns a string with the
current date in a form like @w{"@code{Sun Jun 17, 2000}"}. Alternatively,
it may be called with a single argument, a string representing a format
string acceptable to the @code{strftime(3)} function .Please read the
manual page for this function (type "@w{@code{man 3 strftime}"} at the
command prompt to read it) to find out how such a format string must
look like. Allowed conversion specifiers are
"@code{"aAbBcCdDeFGghHIjklmMnPrRsStTuUVWxXyYzZ+%}", where "@code{cCxXyY}"
may be preceeded by '@code{E}' and "@code{deHImMSuUVwWy}" by '@code{O}'
to request use of an alternative format.


@anchor{time()}
@findex time()
@item time()
If called without an argument the function returns a string with the
current time in the form @w{@code{hh:mm:ss}}. If it's called with a
string containing of one or two characters the colons ('@code{:}') in
the returned string are replaced by the characters from the argument.
The new separator characters must be printable, i.e.@: they can't be
control characters.


@anchor{delta_time()}
@findex delta_time()
@item delta_time()
This function (that can only be used in the @code{EXPERIMENT} section of
the script) returns the time (in seconds) since the last call of the
functions as a floating point value. When called for the very first time
it returns the time since the start of the experiment (i.e.@: the time
the start of the @code{EXPERIMENT} section was processed). The time
returned by the function has micro-second resolution. During the test
run of the @code{EDL} script the function returns a very rough guess of
the time that will be required in the real run of the experiment.


@anchor{wait()}
@findex wait()
@item wait()
Waits for the specified time. Times are always to be given in seconds
or alternatively with a unit, e.g.@: @w{100 ms}. Unfortunately, the
time resolution of @code{@ref{wait()}} is in the @w{10 ms} range and
may even be less precise. If the argument is negative the function
will print an error message and return immediately. The maximum time
the function accepts is more than 2.1 billion seconds (or about 68
years).

This function can only be used in the @code{EXPERIMENT} section of an
@code{EDL} script.


@anchor{T_to_G()}
@findex T_to_G()
@item T_to_G()
Converts a number or all elements of an 1- or more-dimensional array,
assumed to have a unit of Tesla, to Gauss (by multiplying with
@code{1.0e4}).


@anchor{G_to_T()}
@findex G_to_T()
@item G_to_T()
Converts a number or all elements of an 1- or more-dimensional array,
assumed to have a unit of Gauss, to Tesla (by multiplying with
@code{1.0e-4}).


@anchor{C_to_K()}
@findex C_to_K()
@item C_to_K()
Converts a number or all elements of an 1- or more-dimensional array,
assumed to have a unit of degree Celsius, to Kelvin (by adding
@code{273.16}).


@anchor{K_to_C()}
@findex K_to_C()
@item K_to_C()
Converts a number or all elements of an 1- or more-dimensional array,
assumed to have a unit of Kelvin, to degree Celsius (by subtracting
@code{273.16}).


@anchor{D_to_R()}
@findex D_to_R()
@item D_to_R()
Converts a number or all elements of an 1- or more-dimensional array,
assumed to represent angles in degrees, to radians.


@anchor{R_to_D()}
@findex R_to_D()
@item R_to_D()
Converts a number or all elements of an 1- or more-dimensional array,
assumed to represent angles in radians, to degrees.


@anchor{WL_to_WN()}
@findex WL_to_WN()
@item WL_to_WN()
Converts a wave length (in @code{m}) or all elements of an 1- or
more-dimensional array of wave lengths to wavenumbers (in @code{cm^-1}).


@anchor{WN_to_WL()}
@findex WN_to_WL()
@item WN_to_WL()
Converts a wavenumber (in @code{cm^-1}) or all elements of an 1- or
more-dimensional array of wavenumbers to wave lengths (in @code{m}).


@anchor{F_to_WN()}
@findex F_to_WN()
@item F_to_WN()
Converts a frequency (in @code{Hz}) or all elements of an 1- or
more-dimensional array of frequencies to wavenumbers (in @code{cm^-1}).


@anchor{WN_to_F()}
@findex WN_to_F()
@item WN_to_F()
Converts a wavenumber (in @code{cm^-1}) or all elements of an 1- or
more-dimensional array of wavenumbers to frequencies (in @code{Hz}).


@anchor{slice()}
@findex slice()
@item slice()
The function returns a part (slice) of an one-dimensional array. It
expects at least two arguments, the array the values are to be taken
from and the number of the start element of the slice to be returned.
Usually, you also will pass it a third argument, the length of the slice
to be returned. If this argument is missing an array made up from all
elements from the start element to the end of the array is returned.

For an array defined as
@example
X[ 8 ] = @{ 1, 2, 3, 4, 5, 6, 7, 8 @}
@end example
@noindent
the call of @code{@ref{slice()}}
@example
slice( X, 3, 4 );
@end example
@noindent
will return an array with 4 elements containing the data
@example
3, 4, 5, 6
@end example

Please note: This function is not very useful anymore because the same
effect can be achieved by using ranges when indexing the
array (@pxref{Array ranges}).


@anchor{int_slice()}
@findex int_slice()
@item int_slice()
Creates an integer array of the size of the first and only argument
with every element set to @code{0} which then can be assigned to an
integer array of variable length. The size argument can also be
@code{0} to allow the removal f all elements of the array the result
is assigned to.


@anchor{float_slice()}
@findex float_slice()
@item float_slice()
Creates an float array of the size of the first and only argument with
every element set to @code{0.0} which then can be assigned to a float
array of variable length. The size argument can also be @code{0} to
allow the removal f all elements of the array the result is assigned
to.


@anchor{dim()}
@findex dim()
@item dim()
The function returns the dimension of the array passed to it as
argument. I.e.@: if applied to the array defined as
@example
X[ 4, 2, 5 ]
@end example
@noindent
it will return @code{3}.


@anchor{size()}
@findex size()
@item size()
The function normally takes one arguments, an array, and returns its
length. I.e.@: for an array defined as
@example
@code{X[ 4, 2, 5 ]}
@end example
@noindent
@code{size( X )} will return @code{4}, @code{size(X[4])} returns
@code{2} and @code{size(X[4,2])} returns @code{5}.

For variable sized arrays for which the length is still unknown the
function returns @code{0}.

If the argument is a simple numerical variable @code{1} is returned
and a warning is printed. If the argument is a string the length of the
string is returned.


@anchor{sort()}
@findex sort()
@item sort()
The function takes at least one argument, a one-dimensional array. If
no further argument is given it returns an array with the sorted (in
ascending order) values of the argument array. If there's a second
argument and this is @code{1} or @code{"DOWN"} or @code{"DOWNWARDS"}
then the array is sorted in descending order. (You may also specify
@code{0} or @code{"UP"} or @code{"UPWARDS"} as the second argument to
explicitely request sorting in ascending order.)


@anchor{reverse()}
@findex reverse()
@item reverse()
The function takes a single argument, normally a one- or more-dimensional
array. For a one-dimensional array it returns another array with the order of
the elements of the input array reversed. For a multi-dimensional array it
returns a multi-dimensional array of the same rank as the input array and the
order of all the elements of all one-dimensional arrays making up the
multi-dimensional array being reversed.

If the argument is a simple integer or floating point number the same
number gets returned. If the argument is a string the reversed string
is returned.


@anchor{sprint()}
@findex sprint()
@item sprint()
The function can be used to create strings with a text that only gets
determined while the experiment is running, e.g.@: to create label
strings on demand etc. The function expects at least one argument, a
format string, having exactly the same form as the format string
passed to the @code{@ref{print()}} function, i.e.@: with embedded
@code{#} characters as placeholders for the values of other variables
to be inserted into the string. For each unescaped @code{#} in the
string there must be an additional argument, a number, a variable or a
string. The function returns a variable that can be used in all places
where otherwise a string would be required. Here's a simple-minded
example on how to create a set of 10 buttons, where the label contains
the button number (note that the first @code{#} character is escaped
by a backslash, so it goes directly into the string to be created
without any conversions):
@example
FOR I = 1 : 10 @{
    B[ I ] = button_create( "NORMAL_BUTTON",
                            sprint( "Button \##", I ) );
@}
@end example


@anchor{mouse_position()}
@findex mouse_position()
@item mouse_position()
The function can be used to determine the mouse position in the display
windows currently having the focus. It expects either none or a single
argument, a integer value indicating which mouse buttons must be pressed
in order to return a set of values - @code{-1} (or any negative value)
means that values are to be returned independent of the state of the
mouse buttons, @code{0} means no mouse button may be pressed, @code{1}
means the left mouse button, @code{2} the middle button and @code{4} the
right button. Combinations can be specified by adding the values for the
respective mouse buttons. If no argument has been given the function for
historic reasons returns valid values when both the left and right mouse
button are pressed, i.e.@: it works as if the function was called with a
value of @code{3}. The function returns an array of 10 floating point
values.

The first element of the returned array can have the following values,
indicating the meaning of the following elements:
@table @samp
@item 0
The mouse pointer is not within the main display area of one of the
display windows, the requested mouse buttons aren't pressed, or no
curve is shown at the moment in the currently active window (possibly
because there's no scaling set for the curve). The remaining elements
(except the last) of the array have no meaning.

@item 1
The mouse pointer is in the display area of the 1D display window and
the requested mouse buttons are pressed. The second and third element
are the @i{x}- and @i{y}-coordinates of the position of the mouse
according to the current scaling for the first curve. If there is more
than one curve the following array elements are the coordinates of the
mouse position according to the scaling of each of the other curves as
far as they exist.

@item 2
The mouse pointer is in the display area of the 2D display window and
the requested mouse buttons are pressed. The second and third element
of the array are @i{x}- and @i{y}-coordinates of the mouse position
according to scaling of the currently displayed curve. The fourth
element is the @i{z}-value of the curve at this position. All of the
array elements (except the last one) are meaningless.

@item -2
The mouse pointer is in the display area of the 2D display window and
the requested mouse buttons are pressed. The second and third element
of the array are @i{x}- and @i{y}-coordinates of the mouse position
according to scaling of the correctly displayed curve. At the current
mouse position is no displayed point, a @i{z}-value thus cannot be
given. All other array elements (except the last one) are meaningless.

@item 3
The mouse pointer is in the display area of the display window showing a
cross section through a 2-dimensional data set and the requested mouse
buttons are pressed. The second and third element of the array are @i{x}-
and @i{y}-coordinates of the mouse position according to scaling of the
correctly displayed cross section curve. The fourth element is th
coordinate of the cut through the 2-dimensional curve. All other array
elements (except the last one) are meaningless.

@end table

The tenth and last element of the array can be used to figure out if one
of the modifier keys on the keyboard is currently pressed. Modifier keys
are the Shift keys, the Shift-Lock key, the Control keys and other keys
like the Alternate key. The value returned consists of values for:

@table @samp

@item @code{0}
No modifier key is pressed

@item @code{1}
Shift modifier key (typically one of the Shift keys) is pressed.

@item @code{2}
Shift-lock modifier (typically the Shift-lock key) is pressed.

@item @code{4}
Control modifier (typically one of the Control keys) is pressed.

@item @code{8}
Modifier-1 (typically the Alternate key) is pressed.

@item @code{16}
Modifier-2 key is pressed.

@item @code{32}
Modifier-3 key is pressed.

@item @code{64}
Modifier-4 key is pressed.

@item @code{128}
Modifier-5 key is pressed.

@end table

The value returned in last the array element is the sum of the above values
for the keys currently pressed. I.e.@: when someone holds down both the
Shift modifier key and the Control modifier key the returned value will
be 5. To find out if e.g.@: the Control modifier key is pressed you
could use:
@example
pos_arr = mouse_position( );
IF ( int( pos_arry[ 10 ] ) / 4 ) % 2 @{
    print( "The Control modifier key is pressed.\n" );
@}
@end example

Please note: since under X it is easy to remap keys the returned value
does not represent how a keys is labeled on the keyboard but the
function the user has assigned to it. If, for example, the user has
mapped the function "Shift" to the key labeled "Ctrl", pressing this
key will be reported as a press of the Shift modifier key. The
Modifier-2 to Modifier-5 functions often are not mapped to a key.


@anchor{lin_space()}
@findex lin_space()
@item lin_space()
The function returns an array of equally spaced (floating point)
numbers. It expects three arguments, the start value, then end value and
the number of points. It then returns an array with as many points as
specified by the third argument, starting with the value of the first
argument and ending with the value of the second and with the difference
between adjacent points being identical.


@anchor{find_peak()}
@findex find_peak()
@item find_peak()
This function can be used for trying to find a peak in a certain region of
a 1-dimensional array, the only function argument. The function returns
useful results only when the spectrum has a rather good signal-to-noise
ratio (at least about 250) and a more or less straight baseline (i.e.@:
does only changes linearly). It makes no assumptions about the form of
the peak and returns the index in the array where the area under the peak
is halve that of its total area, so it should work reasonable well with
asymmetric peaks.


@anchor{spike_remove()}
@findex spike_remove()
@item spike_remove()
The function tries to remove spikes from 1-dimensional arrays. Before going
on describing the arguments here's an explanation how it works. That's
necessary because a fit-it-all function for detecting and removing spikes
is impossible and when this function is used it must be done with all
restrictions in mind.

The function calculates numerically the first derivative of the 1-dimensional
arrays by computing the differences between neighboring points of the array.
It then goes on calculating the mean and the standard deviation of the
derivatives and picks the points where the derivative deviates by more than
a certain factor (to be specified as one of the arguments to the function)
of the standard deviation from the mean value. These "outliers" are further
investigated.

In the next step all points are discarded where no other "outlier" with the
opposite derivative is within its vicinity (another argument to be passed
to the function). Only the remaining points are taken to be spikes.

To summarize: a structure in the spectrum to be recognized as a spike
must satisfy two conditions. First, there must be an usually large
derivative and, at the same time, another unusually large derivative,
but with opposite sign, must exist in the near vicinity (and there's
some special treatment for spikes at the very fringes of the spectrum
in case it starts or ends with a spike). The algorithm fails often
rather miserably when e.g.@: a "positive" spike is directly followed
by a "negative" spike.

When a spike has been identified the points of the spike are replaced by the
a straight line starting from the point on the left to the point to the right
of the spike.

The arguments the function takes are the 1-dimensional-array and,
optionally, the factor by which the standard deviation is multiplied
to determine what should be taken to be "outliers" (which defaults to
@code{5.0}) and the maximum width a spike can have (in number of
points, defaulting to @code{3}). What to pick as the second and third
argument depends a lot on the circumstances. When the spikes don't
have a large amplitude (compared to the signal) or there are lots of
spikes a factor lower than the default value should be taken, otherwise
most of the spikes will make it through the filter. The maximum spike
width can only be determined from experience and must always be lower
than the width of any significant feature in the spectrum.

@strong{Please note}: Never, ever use this function on data you intend
to store as results of an experiment. It is only meant for situations
where one wants to display data during the experiment to get a first
impression of what's happening (e.g.@: to get rid of the spikes one
sometimes gets in spectra from a CCD camera when cosmic radiation hits
the detector). It is no replacement at all for a careful analysis of a
spectrum where one can use @i{a priori} knowledge to determine what
are spikes and what not (and even the eye is often a much better guide
than a stupid program)!

@end table
